diff -Naur a/arch/arm/boot/Makefile b/arch/arm/boot/Makefile
--- a/arch/arm/boot/Makefile	2022-05-27 17:20:13.781877650 +0800
+++ b/arch/arm/boot/Makefile	2022-05-31 11:56:47.693259679 +0800
@@ -16,6 +16,7 @@
 ifneq ($(MACHINE),)
 include $(MACHINE)/Makefile.boot
 endif
+include $(srctree)/arch/arm/boot/dts/Makefile
 
 # Note: the following conditions must always be true:
 #   ZRELADDR == virt_to_phys(PAGE_OFFSET + TEXT_OFFSET)
@@ -24,10 +25,12 @@
 ZRELADDR    := $(zreladdr-y)
 PARAMS_PHYS := $(params_phys-y)
 INITRD_PHYS := $(initrd_phys-y)
+DTB_OBJS ?= $(dtb-y)
+DTB_OBJS_FULL := $(addprefix $(obj)/dts/,$(DTB_OBJS))
 
 export ZRELADDR INITRD_PHYS PARAMS_PHYS
 
-targets := Image zImage xipImage bootpImage uImage
+targets := Image zImage xipImage bootpImage uImage zImage-dtb
 
 ifeq ($(CONFIG_XIP_KERNEL),y)
 
@@ -66,6 +69,10 @@
 $(obj)/zImage:	$(obj)/compressed/vmlinux FORCE
 	$(call if_changed,objcopy)
 
+$(obj)/zImage-dtb:	$(obj)/zImage $(DTB_OBJS_FULL) FORCE
+	@cat $(obj)/zImage $(DTB_OBJS_FULL) > $@
+	@$(kecho) '  Kernel: $@ is ready'
+
 endif
 
 ifneq ($(LOADADDR),)
@@ -86,7 +93,7 @@
 	false; \
 fi
 
-$(obj)/uImage:	$(obj)/zImage FORCE
+$(obj)/uImage:	$(obj)/zImage-dtb FORCE
 	@$(check_for_multiple_loadaddr)
 	$(call if_changed,uimage)
 
diff -Naur a/arch/arm64/boot/dts/amlogic/Makefile b/arch/arm64/boot/dts/amlogic/Makefile
--- a/arch/arm64/boot/dts/amlogic/Makefile	2022-05-27 17:20:14.013880643 +0800
+++ b/arch/arm64/boot/dts/amlogic/Makefile	2022-06-04 12:12:41.042068628 +0800
@@ -1,50 +1,2 @@
 # SPDX-License-Identifier: GPL-2.0
-dtb-$(CONFIG_ARCH_MESON) += meson-axg-s400.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12a-sei510.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12a-u200.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12a-x96-max.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-gtking.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-gtking-pro.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-a311d-khadas-vim3.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-s922x-khadas-vim3.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-odroid-n2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-odroid-n2-plus.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-ugoos-am6.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-kii-pro.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-nanopi-k2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-nexbox-a95x.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-odroidc2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-p200.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-p201.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-vega-s95-pro.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-vega-s95-meta.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-vega-s95-telos.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-wetek-hub.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-wetek-play2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s805x-libretech-ac.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-hwacom-amazetv.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-khadas-vim.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-libretech-cc.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-libretech-cc-v2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-nexbox-a95x.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-p212.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-p230.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-p231.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-phicomm-n1.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-sml5442tw.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s805x-p241.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905w-p281.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905w-tx3-mini.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-libretech-pc.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-khadas-vim2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-nexbox-a1.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-q200.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-q201.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-rbox-pro.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-s912-libretech-pc.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-vega-s96.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-wetek-core2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-sm1-sei610.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-sm1-khadas-vim3l.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-sm1-odroid-c4.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-a1-ad401.dtb
+dtb-$(CONFIG_ARCH_MESON) += meson-g12b-unionpi-tiger.dtb
\ No newline at end of file
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-g12b-a311d.dtsi b/arch/arm64/boot/dts/amlogic/meson-g12b-a311d.dtsi
--- a/arch/arm64/boot/dts/amlogic/meson-g12b-a311d.dtsi	2022-05-27 17:20:14.013880643 +0800
+++ b/arch/arm64/boot/dts/amlogic/meson-g12b-a311d.dtsi	2022-05-31 11:56:47.693259679 +0800
@@ -11,26 +11,6 @@
 		compatible = "operating-points-v2";
 		opp-shared;
 
-		opp-100000000 {
-			opp-hz = /bits/ 64 <100000000>;
-			opp-microvolt = <731000>;
-		};
-
-		opp-250000000 {
-			opp-hz = /bits/ 64 <250000000>;
-			opp-microvolt = <731000>;
-		};
-
-		opp-500000000 {
-			opp-hz = /bits/ 64 <500000000>;
-			opp-microvolt = <731000>;
-		};
-
-		opp-667000000 {
-			opp-hz = /bits/ 64 <667000000>;
-			opp-microvolt = <731000>;
-		};
-
 		opp-1000000000 {
 			opp-hz = /bits/ 64 <1000000000>;
 			opp-microvolt = <761000>;
@@ -65,31 +45,21 @@
 			opp-hz = /bits/ 64 <1800000000>;
 			opp-microvolt = <1001000>;
 		};
-	};
-
-	cpub_opp_table_1: opp-table-1 {
-		compatible = "operating-points-v2";
-		opp-shared;
 
-		opp-100000000 {
-			opp-hz = /bits/ 64 <100000000>;
-			opp-microvolt = <731000>;
+		opp-1908000000 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <1022000>;
 		};
 
-		opp-250000000 {
-			opp-hz = /bits/ 64 <250000000>;
-			opp-microvolt = <731000>;
-		};
-
-		opp-500000000 {
-			opp-hz = /bits/ 64 <500000000>;
-			opp-microvolt = <731000>;
+		opp-2016000000 {
+			opp-hz = /bits/ 64 <2016000000>;
+			opp-microvolt = <1022000>;
 		};
+	};
 
-		opp-667000000 {
-			opp-hz = /bits/ 64 <667000000>;
-			opp-microvolt = <731000>;
-		};
+	cpub_opp_table_1: opp-table-1 {
+		compatible = "operating-points-v2";
+		opp-shared;
 
 		opp-1000000000 {
 			opp-hz = /bits/ 64 <1000000000>;
@@ -126,24 +96,34 @@
 			opp-microvolt = <831000>;
 		};
 
-                opp-1908000000 {
-                        opp-hz = /bits/ 64 <1908000000>;
-                        opp-microvolt = <861000>;
-                };
-
-                opp-2016000000 {
-                        opp-hz = /bits/ 64 <2016000000>;
-                        opp-microvolt = <911000>;
-                };
-
-                opp-2108000000 {
-                        opp-hz = /bits/ 64 <2108000000>;
-                        opp-microvolt = <951000>;
-                };
-
-                opp-2208000000 {
-                        opp-hz = /bits/ 64 <2208000000>;
-                        opp-microvolt = <1011000>;
-                };
+		opp-1908000000 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <861000>;
+		};
+
+		opp-2016000000 {
+			opp-hz = /bits/ 64 <2016000000>;
+			opp-microvolt = <911000>;
+		};
+
+		opp-2108000000 {
+			opp-hz = /bits/ 64 <2108000000>;
+			opp-microvolt = <951000>;
+		};
+
+		opp-2208000000 {
+			opp-hz = /bits/ 64 <2208000000>;
+			opp-microvolt = <1011000>;
+		};
+
+		opp-2304000000 {
+			opp-hz = /bits/ 64 <2304000000>;
+			opp-microvolt = <1022000>;
+		};
+
+		opp-2400000000 {
+			opp-hz = /bits/ 64 <2400000000>;
+			opp-microvolt = <1022000>;
+		};
 	};
 };
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-g12b-unionpi-tiger.dts b/arch/arm64/boot/dts/amlogic/meson-g12b-unionpi-tiger.dts
--- a/arch/arm64/boot/dts/amlogic/meson-g12b-unionpi-tiger.dts	1970-01-01 08:00:00.000000000 +0800
+++ b/arch/arm64/boot/dts/amlogic/meson-g12b-unionpi-tiger.dts	2022-07-04 13:57:46.707580803 +0800
@@ -0,0 +1,489 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (c) 2019 Christian Hewitt <christianshewitt@gmail.com>
+ */
+
+/dts-v1/;
+
+#include "meson-g12b-a311d.dtsi"
+#include "meson-unionpi-tiger.dtsi"
+#include "meson-g12b-unionpi-tiger.dtsi"
+
+/ {
+	model = "UnionPi Tiger";
+	compatible = "unionpi,tiger", "amlogic,a311d", "amlogic,g12b";
+	amlogic-dt-id = "g12b_w400_b";
+
+	reserved-memory {
+		galcore_reserved:linux,galcore {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x1000000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+		
+		isp_cma_reserved:linux,isp_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x10000000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+
+		adapt_cma_reserved:linux,adapt_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x03000000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+		
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			/* ion_codec_mm max can alloc size 80M*/
+			size = <0x0 0x13400000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+		
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x0>;
+			alignment = <0x0 0x100000>;
+			//no-map;
+		};
+	};
+
+	cpu_version {
+		reg=<0x0 0xff800220 0x0 0x4>;
+	};
+	
+	canvas_legacy: canvas_legacy {
+		compatible = "amlogic, meson, canvas_legacy";
+		dev_name = "amlogic-canvas";
+		status = "okay";
+		amlogic,canvas = <&canvas>;
+	};
+	
+	media_clk {
+		compatible = "amlogic, media_clk";
+		status = "okay";
+		clocks = <&clkc CLKID_PARSER
+				&clkc CLKID_DEMUX
+				&clkc CLKID_AHB_ARB0
+				&clkc CLKID_DOS
+				&clkc CLKID_VDEC_MUX
+				&clkc CLKID_HCODEC_MUX
+				&clkc CLKID_HEVC_MUX
+				&clkc CLKID_HEVCF_MUX>;
+		clock-names = "parser_top",
+				"demux",
+				"ahbarb0",
+				"vdec",
+				"clk_vdec_mux",
+				"clk_hcodec_mux",
+				"clk_hevc_mux",
+				"clk_hevcb_mux";
+	};
+
+	codec_mm {
+		compatible = "amlogic, codec, mm";
+		memory-region = <&codec_mm_cma &codec_mm_reserved>;
+		dev_name = "codec_mm";
+		status = "okay";
+	};
+
+	codec_io: codec_io {
+		compatible = "amlogic, codec_io";
+		status = "okay";
+		#address-cells=<1>;
+		#size-cells=<1>;
+		ranges;
+		io_cbus_base{
+			reg = <0xffd00000 0x100000>;
+		};
+		io_dos_base{
+			reg = <0xff620000 0x10000>;
+		};
+		io_hiubus_base{
+			reg = <0xff63c000 0x2000>;
+		};
+		io_aobus_base{
+			reg = <0xff800000 0x10000>;
+		};
+		io_vcbus_base{
+			reg = <0xff900000 0x40000>;
+		};
+		io_dmc_base{
+			reg = <0xff638000 0x2000>;
+		};
+		io_efuse_base{
+			reg = <0xff630000 0x2000>;
+		};
+	};
+
+	vdec {
+		compatible = "amlogic, vdec";
+		dev_name = "vdec.0";
+		status = "okay";
+		interrupts = <0 3 1
+				0 23 1
+				0 32 1
+				0 43 1
+				0 44 1
+				0 45 1>;
+		interrupt-names = "vsync",
+				"demux",
+				"parser",
+				"mailbox_0",
+				"mailbox_1",
+				"mailbox_2";
+	};
+
+	amvenc_avc {
+		compatible = "amlogic, amvenc_avc";
+		dev_name = "amvenc_avc";
+		status = "okay";
+		interrupts = <0 45 1>;
+		interrupt-names = "mailbox_2";
+	};
+	
+	ge2d {
+		compatible = "amlogic, ge2d-g12a";
+		dev_name = "ge2d";
+		status = "okay";
+		interrupts = <GIC_SPI 146 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "ge2d";
+		clocks = <&clkc CLKID_VAPB>,
+			<&clkc CLKID_G2D>,
+			<&clkc CLKID_VAPB>;
+		clock-names = "clk_vapb_0",
+			"clk_ge2d",
+			"clk_ge2d_gate";
+		reg = <0x0 0xff940000 0x0 0x10000>;
+		amlogic,canvas = <&canvas>;
+	};
+
+	galcore {
+		compatible = "amlogic, galcore";
+		dev_name = "galcore";
+		status = "okay";
+		clocks = <&clkc CLKID_NNA_AXI_CLK>,
+				<&clkc CLKID_NNA_CORE_CLK>;
+		clock-names = "cts_vipnanoq_axi_clk_composite",
+						"cts_vipnanoq_core_clk_composite";
+		interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "galcore";
+		reg = <0x0 0xff100000 0x0 0x800>,
+				<0x0 0xff000000 0x0 0x400000>,
+				<0x0 0xff63c10c 0x0 0x4>,
+				<0x0 0xff63c110 0x0 0x4>,
+				<0x0 0xffd01088 0x0 0x4>,
+				<0X0 0xff63c1c8 0X0 0x4>;
+		reg-names = "NN_REG","NN_SRAM","NN_MEM0",
+					"NN_MEM1","NN_RESET","NN_CLK";
+		nn_power_version = <2>;
+		nn_efuse = <0xff63003c 0x20>;
+
+		memory-region = <&galcore_reserved>;
+	};
+
+	cpu_iomap {
+		compatible = "amlogic, iomap";
+		#address-cells=<2>;
+		#size-cells=<2>;
+		ranges;
+		io_cbus_base {
+			reg = <0x0 0xffd00000 0x0 0x26000>;
+		};
+		io_apb_base {
+			reg = <0x0 0xffe01000 0x0 0x7f000>;
+		};
+		io_aobus_base {
+			reg = <0x0 0xff800000 0x0 0xb000>;
+		};
+		io_vapb_base {
+			reg = <0x0 0xff900000 0x0 0x50000>;
+		};
+		io_hiu_base {
+			reg = <0x0 0xff63c000 0x0 0x2000>;
+		};
+	};
+
+	aml_pm {
+		compatible = "amlogic, pm";
+		status = "okay";
+		device_name = "aml_pm";
+		debug_reg = <0xff8000a8>;
+		exit_reg = <0xff80023c>;
+	};
+
+	aml_reboot{
+		compatible = "amlogic, reboot";
+		sys_reset = <0x84000009>;
+		sys_poweroff = <0x84000008>;
+	};
+
+	bluetooth{
+		compatible = "amlogic, bt-dev";
+		dev_name = "bluetooth";
+		status = "okay";
+		gpio_en = <&gpio GPIOX_16 GPIO_ACTIVE_HIGH>;
+		gpio_hostwake = <&gpio GPIOX_19 GPIO_ACTIVE_HIGH>;
+	};
+
+	wifi{
+		compatible = "amlogic, wifi-dev";
+		dev_name = "wifi";
+		status = "okay";
+		power_on_pin = <&gpio_ao GPIOAO_5 GPIO_ACTIVE_HIGH>;
+	};
+
+	partitions: partitions{
+		parts = <14>;
+		part-0 = <&logo>;
+		part-1 = <&updater>;
+		part-2 = <&misc>;
+		part-3 = <&dto>;
+		part-4 = <&cri_data>;
+		part-5 = <&param>;
+		part-6 = <&boot>;
+		part-7 = <&rsv>;
+		part-8 = <&tee>;
+		part-9 = <&vendor>;
+		part-10 = <&odm>;
+		part-11 = <&system>;
+		part-12 = <&cache>;
+		part-13 = <&data>;
+
+		logo:logo{
+			pname = "logo";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+
+		updater:updater{
+			pname = "updater";
+			size = <0x0 0x1800000>;
+			mask = <1>;
+		};
+
+		misc:misc{
+			pname = "misc";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+
+		dto:dto{
+			pname = "dto";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+
+		cri_data:cri_data{
+			pname = "cri_data";
+			size = <0x0 0x800000>;
+			mask = <2>;
+		};
+
+		rsv:rsv{
+			pname = "rsv";
+			size = <0x0 0x1000000>;
+			mask = <1>;
+		};
+
+		param:param{
+			pname = "param";
+			size = <0x0 0x1000000>;
+			mask = <2>;
+		};
+
+		boot:boot{
+			pname = "boot";
+			size = <0x0 0x1000000>;
+			mask = <1>;
+		};
+
+		tee:tee{
+			pname = "tee";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+
+		vendor:vendor{
+			pname = "vendor";
+			size = <0x0 0x20000000>;
+			mask = <1>;
+		};
+
+		odm:odm{
+			pname = "odm";
+			size = <0x0 0x10000000>;
+			mask = <1>;
+		};
+
+		system:system{
+			pname = "system";
+			size = <0x2 0x00000000>;
+			mask = <2>;
+		};
+
+		cache:cache{
+			pname = "cache";
+			size = <0x0 0x40000000>;
+			mask = <2>;
+		};
+
+		data:data{
+			pname = "data";
+			size = <0xffffffff 0xffffffff>;
+			mask = <4>;
+		};
+	};
+
+	unifykey{
+		compatible = "amlogic, unifykey";
+		status = "ok";
+		unifykey-num = <17>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+		unifykey-index-3 = <&keysn_3>;
+		unifykey-index-4 = <&keysn_4>;
+		unifykey-index-5 = <&keysn_5>;
+		unifykey-index-6 = <&keysn_6>;
+		unifykey-index-7 = <&keysn_7>;
+		unifykey-index-8 = <&keysn_8>;
+		unifykey-index-9 = <&keysn_9>;
+		unifykey-index-10= <&keysn_10>;
+		unifykey-index-11= <&keysn_11>;
+		unifykey-index-12= <&keysn_12>;
+		unifykey-index-13= <&keysn_13>;
+		unifykey-index-14= <&keysn_14>;
+		unifykey-index-15= <&keysn_15>;
+		unifykey-index-16= <&keysn_16>;
+
+		keysn_0: key_0{
+			key-name = "usid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_1:key_1{
+			key-name = "mac";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_2:key_2{
+			key-name = "hdcp";
+			key-device = "secure";
+			key-type = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_3:key_3{
+			key-name = "secure_boot_set";
+			key-device = "efuse";
+			key-permit = "write";
+		};
+		keysn_4:key_4{
+			key-name = "mac_bt";
+			key-device = "normal";
+			key-permit = "read","write","del";
+			key-type	= "mac";
+		};
+		keysn_5:key_5{
+			key-name = "mac_wifi";
+			key-device = "normal";
+			key-permit = "read","write","del";
+			key-type = "mac";
+		};
+		keysn_6:key_6{
+			key-name = "hdcp2_tx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_7:key_7{
+			key-name = "hdcp2_rx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_8:key_8{
+			key-name = "widevinekeybox";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_9:key_9{
+			key-name = "deviceid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_10:key_10{
+			key-name = "hdcp22_fw_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_11:key_11{
+			key-name = "PlayReadykeybox25";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_12:key_12{
+			key-name = "prpubkeybox";// PlayReady
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_13:key_13{
+			key-name = "prprivkeybox";// PlayReady
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_14:key_14{
+			key-name = "netflix_mgkid";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_15:key_15{
+				key-name = "eth_exphy_para";
+				key-device = "normal";
+				key-permit = "read","write","del";
+		};
+		keysn_16:key_16{
+			key-name = "um_factory_para";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+	};//End unifykey
+
+	sensor: sensor {
+			compatible = "soc, sensor";
+			status = "okay";
+			sensor-name = "imx219"; /*ov5647,imx290;os08a10;imx227;imx307;imx219*/
+			pinctrl-names="default";
+			clocks = <&clkc CLKID_24M>;
+			clock-names = "g12a_24m";
+	};
+
+	iq: iq {
+			compatible = "soc, iq";
+			status = "okay";
+			sensor-name = "imx219"; /*ov5647,imx290;os08a10;imx227;imx307;imx219*/
+	};
+};
+
+&isp {
+	status = "okay";
+	temper-line-offset = <0x1680>;
+	temper-buf-size = <12>;
+	temper-frame-num = <1>;
+	temper-frame-size = <0xBDD800>;
+	memory-region = <&isp_cma_reserved>;
+};
+
+&adapter {
+	status = "okay";
+	memory-region = <&adapt_cma_reserved>;
+};
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-g12b-unionpi-tiger.dtsi b/arch/arm64/boot/dts/amlogic/meson-g12b-unionpi-tiger.dtsi
--- a/arch/arm64/boot/dts/amlogic/meson-g12b-unionpi-tiger.dtsi	1970-01-01 08:00:00.000000000 +0800
+++ b/arch/arm64/boot/dts/amlogic/meson-g12b-unionpi-tiger.dtsi	2022-05-31 11:56:47.693259679 +0800
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (c) 2019 Christian Hewitt <christianshewitt@gmail.com>
+ */
+
+/ {
+	vddcpu_a: regulator-vddcpu-a {
+		compatible = "pwm-regulator";
+
+		regulator-name = "VDDCPU_A";
+		regulator-min-microvolt = <721000>;
+		regulator-max-microvolt = <1022000>;
+		regulator-ramp-delay = <10>;
+
+		vin-supply = <&dc_in>;
+
+		pwms = <&pwm_ab 0 1250 0>;
+		pwm-dutycycle-range = <100 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vddcpu_b: regulator-vddcpu-b {
+		compatible = "pwm-regulator";
+
+		regulator-name = "VDDCPU_B";
+		regulator-min-microvolt = <721000>;
+		regulator-max-microvolt = <1022000>;
+		regulator-ramp-delay = <10>;
+
+		vin-supply = <&dc_in>;
+
+		pwms = <&pwm_AO_cd 1 1250 0>;
+		pwm-dutycycle-range = <100 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&vddcpu_b>;
+	operating-points-v2 = <&cpu_opp_table_0>;
+	clocks = <&clkc CLKID_CPU_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcpu_b>;
+	operating-points-v2 = <&cpu_opp_table_0>;
+	clocks = <&clkc CLKID_CPU_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu100 {
+	cpu-supply = <&vddcpu_a>;
+	operating-points-v2 = <&cpub_opp_table_1>;
+	clocks = <&clkc CLKID_CPUB_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu101 {
+	cpu-supply = <&vddcpu_a>;
+	operating-points-v2 = <&cpub_opp_table_1>;
+	clocks = <&clkc CLKID_CPUB_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu102 {
+	cpu-supply = <&vddcpu_a>;
+	operating-points-v2 = <&cpub_opp_table_1>;
+	clocks = <&clkc CLKID_CPUB_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu103 {
+	cpu-supply = <&vddcpu_a>;
+	operating-points-v2 = <&cpub_opp_table_1>;
+	clocks = <&clkc CLKID_CPUB_CLK>;
+	clock-latency = <50000>;
+};
+
+&pwm_ab {
+	pinctrl-0 = <&pwm_a_e_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin0";
+	status = "okay";
+};
+
+&pwm_AO_cd {
+	pinctrl-0 = <&pwm_ao_c_6_pins>, <&pwm_ao_d_e_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin1";
+	status = "okay";
+};
+
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi b/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi
--- a/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi	2022-05-27 17:20:14.013880643 +0800
+++ b/arch/arm64/boot/dts/amlogic/meson-g12-common.dtsi	2022-06-18 13:48:23.734525427 +0800
@@ -17,6 +17,12 @@
 	#address-cells = <2>;
 	#size-cells = <2>;
 
+	aliases {
+		mmc0 = &sd_emmc_c; /* eMMC */
+		mmc1 = &sd_emmc_b; /* SD card */
+		mmc2 = &sd_emmc_a; /* SDIO */
+	};
+
 	chosen {
 		#address-cells = <2>;
 		#size-cells = <2>;
@@ -43,6 +49,10 @@
 		};
 	};
 
+	system-suspend {
+		compatible = "amlogic,meson-gx-pm";
+	};
+
 	efuse: efuse {
 		compatible = "amlogic,meson-gxbb-efuse";
 		clocks = <&clkc CLKID_EFUSE>;
@@ -55,10 +65,6 @@
 	gpu_opp_table: gpu-opp-table {
 		compatible = "operating-points-v2";
 
-		opp-124999998 {
-			opp-hz = /bits/ 64 <124999998>;
-			opp-microvolt = <800000>;
-		};
 		opp-249999996 {
 			opp-hz = /bits/ 64 <249999996>;
 			opp-microvolt = <800000>;
@@ -96,15 +102,19 @@
 		ranges;
 
 		/* 3 MiB reserved for ARM Trusted Firmware (BL31) */
-		secmon_reserved: secmon@5000000 {
-			reg = <0x0 0x05000000 0x0 0x300000>;
-			no-map;
+		secmon_reserved:linux,secmon {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x3400000>;
+			alignment = <0x0 0x400000>;
+			alloc-ranges = <0x0 0x05000000 0x0 0x3400000>;
+			clear-map;
 		};
 
 		linux,cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0x10000000>;
+			size = <0x0 0x38000000>;
 			alignment = <0x0 0x400000>;
 			linux,cma-default;
 		};
@@ -113,6 +123,16 @@
 	sm: secure-monitor {
 		compatible = "amlogic,meson-gxbb-sm";
 	};
+	
+	secmon {
+		compatible = "amlogic, secmon";
+		memory-region = <&secmon_reserved>;
+		in_base_func = <0x82000020>;
+		out_base_func = <0x82000021>;
+		inout_size_func = <0x8200002a>;
+		reserve_mem_size = <0x00300000>;
+		clear_range = <0x05100000 0x200000>;
+	};
 
 	soc {
 		compatible = "simple-bus";
@@ -224,6 +244,8 @@
 				      "timing-adjustment";
 			rx-fifo-depth = <4096>;
 			tx-fifo-depth = <2048>;
+			resets = <&reset RESET_ETHERNET>;
+			reset-names = "stmmaceth";
 			status = "disabled";
 
 			mdio0: mdio {
@@ -1681,12 +1703,31 @@
 								       <666666666>,
 								       <0>, /* Do Nothing */
 								       <0>, /* Do Nothing */
-								       <250000000>,
+								       <500000000>,
 								       <0>; /* Do Nothing */
 					};
+
+					mipi_analog_dphy: phy {
+						compatible = "amlogic,g12a-mipi-dphy-analog";
+						#phy-cells = <0>;
+						status = "disabled";
+					};
 				};
 			};
 
+			mipi_dphy: phy@44000 {
+				compatible = "amlogic,axg-mipi-dphy";
+				reg = <0x0 0x44000 0x0 0x2000>;
+				clocks = <&clkc CLKID_MIPI_DSI_PHY>;
+				clock-names = "pclk";
+				resets = <&reset RESET_MIPI_DSI_PHY>;
+				reset-names = "phy";
+				phys = <&mipi_analog_dphy>;
+				phy-names = "analog";
+				#phy-cells = <0>;
+				status = "disabled";
+			};
+
 			usb3_pcie_phy: phy@46000 {
 				compatible = "amlogic,g12a-usb3-pcie-phy";
 				reg = <0x0 0x46000 0x0 0x2000>;
@@ -1930,6 +1971,33 @@
 						};
 					};
 
+					uart_ao_b_1_pins: uart-ao-b-1 {
+						mux {
+							groups = "uart_ao_b_tx_2",
+								 "uart_ao_b_rx_3";
+							function = "uart_ao_b";
+							bias-disable;
+						};
+					};
+
+					uart_ao_b_2_pins: uart-ao-b-2 {
+						mux {
+							groups = "uart_ao_b_tx_8",
+								 "uart_ao_b_rx_9";
+							function = "uart_ao_b";
+							bias-disable;
+						};
+					};
+
+					uart_ao_b_cts_rts_pins: uart-ao-b-cts-rts {
+						mux {
+							groups = "uart_ao_b_cts",
+								 "uart_ao_b_rts";
+							function = "uart_ao_b";
+							bias-disable;
+						};
+					};
+
 					pwm_a_e_pins: pwm-a-e {
 						mux {
 							groups = "pwm_a_e";
@@ -2003,7 +2071,7 @@
 				};
 			};
 
-			vrtc: rtc@0a8 {
+			vrtc: rtc@a8 {
 				compatible = "amlogic,meson-vrtc";
 				reg = <0x0 0x000a8 0x0 0x4>;
 			};
@@ -2144,6 +2212,15 @@
 					remote-endpoint = <&hdmi_tx_in>;
 				};
 			};
+
+			/* DPI output port */
+			dpi_port: port@2 {
+				reg = <2>;
+
+				dpi_out: endpoint {
+					remote-endpoint = <&mipi_dsi_in>;
+				};
+			};
 		};
 
 		gic: interrupt-controller@ffc01000 {
@@ -2181,6 +2258,49 @@
 				amlogic,channel-interrupts = <64 65 66 67 68 69 70 71>;
 			};
 
+			mipi_dsi: mipi-dsi@7000 {
+				compatible = "amlogic,meson-g12a-dw-mipi-dsi";
+				reg = <0x0 0x7000 0x0 0x1000>;
+				resets = <&reset RESET_MIPI_DSI_HOST>;
+				reset-names = "top";
+				clocks = <&clkc CLKID_MIPI_DSI_HOST>,
+					 <&clkc CLKID_MIPI_DSI_PXCLK>;
+				clock-names = "pclk", "px_clk";
+				phys = <&mipi_dphy>;
+				phy-names = "dphy";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+
+				assigned-clocks = <&clkc CLKID_MIPI_DSI_PXCLK_SEL>;
+				assigned-clock-parents = <&clkc CLKID_GP0_PLL>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					/* VPU VENC Input */
+					mipi_dsi_venc_port: port@0 {
+						reg = <0>;
+
+						mipi_dsi_in: endpoint {
+							remote-endpoint = <&dpi_out>;
+						};
+					};
+
+					/* DSI Output */
+					mipi_dsi_panel_port: port@1 {
+						reg = <1>;
+					};
+				};
+			};
+
+			watchdog: wdt@f0d0 {
+				compatible = "amlogic,meson-gxbb-wdt";
+				reg = <0x0 0xf0d0 0x0 0x10>;
+				clocks = <&xtal>;
+			};
+
 			spicc0: spi@13000 {
 				compatible = "amlogic,meson-g12a-spicc";
 				reg = <0x0 0x13000 0x0 0x44>;
@@ -2305,6 +2425,7 @@
 				clocks = <&xtal>, <&clkc CLKID_UART0>, <&xtal>;
 				clock-names = "xtal", "pclk", "baud";
 				status = "disabled";
+				fifo-size = <128>;
 			};
 		};
 
@@ -2400,6 +2521,62 @@
 			operating-points-v2 = <&gpu_opp_table>;
 			#cooling-cells = <2>;
 		};
+
+        isp_sc: isp-sc@ff655400 {
+                compatible = "amlogic, isp-sc";
+                reg = <0x0 0xff655400 0x0 0x00001000>;
+                reg-names = "isp_sc";
+                interrupts = <0 17 IRQ_TYPE_EDGE_RISING>;
+                interrupt-names = "isp_sc";
+        };
+
+        isp: isp@ff140000 {
+                compatible = "arm, isp";
+                reg = <0x0 0xff140000 0x0 0x00040000>;
+                reg-names = "ISP";
+                isp-efuse = <0xff630038 0x4000>;
+                interrupts = <0 142 4>;
+                interrupt-names = "ISP";
+                temper-buf-size = <24>;
+                clocks = <&clkc CLKID_MIPI_ISP_CLK_COMP>,
+                        <&clkc CLKID_MIPI_CSI_PHY_CLK0_COMP>;
+                clock-names = "cts_mipi_isp_clk_composite",
+                        "cts_mipi_csi_phy_clk0_composite";
+                link-device = <&isp_sc>;
+        };
+		
+		adapter: isp-adapter@ff650000 {
+			compatible = "amlogic, isp-adapter";
+			reg = <0x0 0xff650000 0x0 0x00006000>;
+			reg-names = "adapter";
+			interrupts = <0 179 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "adapter-irq";
+			mem_alloc = <48>;
+		};
+
+		phycsi: phy-csi@ff650000 {
+			compatible = "amlogic, phy-csi";
+			reg = <0x0 0xff650000 0x0 0x00002000>,
+					<0x0 0xff652000 0x0 0x00002000>,
+					<0x0 0xff63c300 0x0 0x00000100>,
+					<0x0 0xff654000 0x0 0x00000100>,
+					<0x0 0xff654400 0x0 0x00000100>;
+			reg-names = "csi2_phy0", "csi2_phy1", "aphy_reg",
+					"csi0_host", "csi1_host";
+			interrupts = <0 41 IRQ_TYPE_EDGE_RISING>,
+					<0 42 IRQ_TYPE_EDGE_RISING>,
+					<0 72 IRQ_TYPE_EDGE_RISING>,
+					<0 74 IRQ_TYPE_EDGE_RISING>,
+					<0 87 IRQ_TYPE_EDGE_RISING>,
+					<0 88 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "phy0-irq",
+					"phy1-irq",
+					"csi-host0-intr2",
+					"csi-host0-intr1",
+					"csi-host1-intr2",
+					"csi-host1-intr1";
+			link-device = <&adapter>;
+		};
 	};
 
 	timer {
@@ -2422,4 +2599,10 @@
 		#clock-cells = <0>;
 	};
 
+	osc8M: osc8M {
+		compatible = "fixed-clock";
+		clock-output-names = "osc8M";
+		clock-frequency = <8000000>;
+		#clock-cells = <0>;
+	};
 };
diff -Naur a/arch/arm64/boot/dts/amlogic/meson-unionpi-tiger.dtsi b/arch/arm64/boot/dts/amlogic/meson-unionpi-tiger.dtsi
--- a/arch/arm64/boot/dts/amlogic/meson-unionpi-tiger.dtsi	1970-01-01 08:00:00.000000000 +0800
+++ b/arch/arm64/boot/dts/amlogic/meson-unionpi-tiger.dtsi	2022-06-04 12:16:05.318220487 +0800
@@ -0,0 +1,805 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (c) 2019 Christian Hewitt <christianshewitt@gmail.com>
+ */
+
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/meson-g12a-gpio.h>
+#include <dt-bindings/sound/meson-g12a-toacodec.h>
+#include <dt-bindings/sound/meson-g12a-tohdmitx.h>
+#include <dt-bindings/clock/g12a-clkc.h>
+#include <dt-bindings/reset/amlogic,meson-g12a-reset.h>
+#include <dt-bindings/clock/axg-audio-clkc.h>
+
+/ {
+	aliases {
+		serial0 = &uart_AO;
+		serial1 = &uart_AO_B;
+		serial2 = &uart_A;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c_AO;
+		ethernet0 = &ethmac;
+		rtc0 = &rtc;
+		rtc1 = &vrtc;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0xf0000000>;
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		power-button {
+			label = "power";
+			linux,code = <KEY_POWER>;
+			gpios = <&gpio GPIOC_7 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		/* USB-OTG Switch GPIO */
+		usb-switch {
+			label = "usb_switch";
+			gpios = <&gpio GPIOX_7 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+		};
+	};
+
+	emmc_pwrseq: emmc-pwrseq {
+		compatible = "mmc-pwrseq-emmc";
+		reset-gpios = <&gpio BOOT_12 GPIO_ACTIVE_LOW>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpio GPIOX_6 GPIO_ACTIVE_LOW>;
+	};
+
+	dc_in: regulator-dc_in {
+		compatible = "regulator-fixed";
+		regulator-name = "DC_IN";
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+		regulator-always-on;
+	};
+
+	vcc_5v: regulator-vcc_5v {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC_5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_in>;
+
+		/* SY8113B */
+		gpio = <&gpio GPIOH_8 GPIO_OPEN_DRAIN>;
+		enable-active-high;
+	};
+
+	vsys_3v3: regulator-vsys_3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VSYS_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dc_in>;
+		regulator-always-on;
+	};
+
+	usb_pwr_en: regulator-usb-pwr-en {
+		compatible = "regulator-fixed";
+		regulator-name = "USB_PWR_EN";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc_5v>;
+		enable-active-high;
+	};
+
+	usb1_pow: regulator-usb1-pow {
+		compatible = "regulator-fixed";
+		regulator-name = "USB1_POW";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc_5v>;
+		enable-active-high;
+	};
+
+	vddao_3v3: regulator-vddao-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDAO_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dc_in>;
+		regulator-always-on;
+	};
+
+	vddao_1v8: regulator-vddao_1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDAO_1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vddao_3v3>;
+		regulator-always-on;
+	};
+
+	usb_pwr: regulator-usb_pwr {
+		compatible = "regulator-fixed";
+		regulator-name = "USB_PWR";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc_5v>;
+		enable-active-high;
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+		status = "okay";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	spdif_dit: audio-codec-1 {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+		status = "okay";
+		sound-name-prefix = "DIT";
+	};
+
+	sound {
+		compatible = "amlogic,axg-sound-card";
+		model = "UNIONPI-TIGER";
+		audio-widgets = "Line", "Lineout",
+				"Line", "Linein";
+		audio-aux-devs = <&tdmout_b>, <&tdmout_c>, 
+				<&tdmin_a>, <&tdmin_b>, <&tdmin_c>, <&tdmin_lb>;
+		audio-routing = "TDMOUT_B IN 0", "FRDDR_A OUT 1",
+				"TDMOUT_B IN 1", "FRDDR_B OUT 1",
+				"TDMOUT_B IN 2", "FRDDR_C OUT 1",
+				"TDM_B Playback", "TDMOUT_B OUT",
+				"TDMOUT_C IN 0", "FRDDR_A OUT 2",
+				"TDMOUT_C IN 1", "FRDDR_B OUT 2",
+				"TDMOUT_C IN 2", "FRDDR_C OUT 2",
+				"TDM_C Playback", "TDMOUT_C OUT",
+				/* for audio capture */
+				"TDMIN_A IN 1", "TDM_B Capture",
+				"TDMIN_B IN 1", "TDM_B Capture",
+				"TDMIN_C IN 1", "TDM_B Capture",
+				"TDMIN_A IN 2", "TDM_C Capture",
+				"TDMIN_B IN 2", "TDM_C Capture",
+				"TDMIN_C IN 2", "TDM_C Capture",
+				"TDMIN_A IN 4", "TDM_B Loopback",
+				"TDMIN_B IN 4", "TDM_B Loopback",
+				"TDMIN_C IN 4", "TDM_B Loopback",
+				"TDMIN_A IN 5", "TDM_C Loopback",
+				"TDMIN_B IN 5", "TDM_C Loopback",
+				"TDMIN_C IN 5", "TDM_C Loopback",
+				"TDMIN_LB IN 1", "TDM_B Capture",
+				"TDMIN_LB IN 2", "TDM_C Capture",
+				"TDMIN_LB IN 4", "TDM_B Loopback",
+				"TDMIN_LB IN 5", "TDM_C Loopback",
+				/* tdmin -> toddr */
+				"TODDR_A IN 0", "TDMIN_A OUT",
+				"TODDR_B IN 0", "TDMIN_A OUT",
+				"TODDR_C IN 0", "TDMIN_A OUT",
+				"TODDR_A IN 1", "TDMIN_B OUT",
+				"TODDR_B IN 1", "TDMIN_B OUT",
+				"TODDR_C IN 1", "TDMIN_B OUT",
+				"TODDR_A IN 2", "TDMIN_C OUT",
+				"TODDR_B IN 2", "TDMIN_C OUT",
+				"TODDR_C IN 2", "TDMIN_C OUT",
+				"TODDR_A IN 6", "TDMIN_LB OUT",
+				"TODDR_B IN 6", "TDMIN_LB OUT",
+				"TODDR_C IN 6", "TDMIN_LB OUT",
+				"Linein MIC1", "Linein",
+				"TDM_B Capture", "Linein AIFTX";
+
+		assigned-clocks = <&clkc CLKID_MPLL2>,
+					<&clkc CLKID_MPLL0>,
+					<&clkc CLKID_MPLL1>;
+		assigned-clock-parents = <0>, <0>, <0>;
+		assigned-clock-rates = <294912000>,
+					 	<270950400>,
+					 	<393216000>;
+		status = "okay";
+
+		dai-link-0 {
+			sound-dai = <&frddr_a>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&frddr_b>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&frddr_c>;
+		};
+
+		dai-link-3 {
+			sound-dai = <&toddr_a>;
+		};
+
+		dai-link-4 {
+			sound-dai = <&toddr_b>;
+		};
+
+		dai-link-5 {
+			sound-dai = <&toddr_c>;
+		};
+
+		/* 8ch hdmi interface */
+		dai-link-6 {
+			sound-dai = <&tdmif_b>;
+			dai-format = "i2s";
+			dai-tdm-slot-tx-mask-0 = <1 1>;
+			dai-tdm-slot-rx-mask-1 = <1 1>;
+			dai-tdm-slot-tx-mask-2 = <1 1>;
+			dai-tdm-slot-tx-mask-3 = <1 1>;
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&tohdmitx TOHDMITX_I2S_IN_B>;
+			};
+			
+			codec-1 {
+				sound-dai = <&toacodec TOACODEC_IN_B>;
+			};
+			
+			/* audio capture */
+			codec-2 {
+				sound-dai = <&nau8540>;
+			};
+		};
+
+		/* i2s jack output interface */
+		dai-link-7 {
+			sound-dai = <&tdmif_c>;
+			dai-format = "i2s";
+			dai-tdm-slot-tx-mask-0 = <1 1>;
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&tohdmitx TOHDMITX_I2S_IN_C>;
+			};
+
+			codec-1 {
+				sound-dai = <&toacodec TOACODEC_IN_C>;
+			};
+		};
+		
+		/* hdmi glue */
+		dai-link-8 {
+			sound-dai = <&tohdmitx TOHDMITX_I2S_OUT>;
+
+			codec {
+				sound-dai = <&hdmi_tx>;
+			};
+		};
+
+		/* acodec glue */
+		dai-link-9 {
+			sound-dai = <&toacodec TOACODEC_OUT>;
+
+			codec {
+				sound-dai = <&acodec>;
+			};
+		};
+	};
+};
+
+&pdm {
+	status = "okay";
+};
+
+&acodec {
+	AVDD-supply = <&vddao_1v8>;
+	status = "okay";
+};
+
+&arb {
+	status = "okay";
+};
+
+&clkc_audio {
+	status = "okay";
+};
+
+&cec_AO {
+	pinctrl-0 = <&cec_ao_a_h_pins>;
+	pinctrl-names = "default";
+	status = "disabled";
+	hdmi-phandle = <&hdmi_tx>;
+};
+
+&cecb_AO {
+	pinctrl-0 = <&cec_ao_b_h_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+	hdmi-phandle = <&hdmi_tx>;
+};
+
+&ext_mdio {
+	external_phy: ethernet-phy@0 {
+		/* Realtek RTL8211F (0x001cc916) */
+		reg = <0>;
+		max-speed = <1000>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		reset-gpios = <&gpio GPIOZ_15 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
+
+		interrupt-parent = <&gpio_intc>;
+		/* MAC_INTR on GPIOZ_14 */
+		interrupts = <26 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&ethmac {
+				pinctrl-0 = <&eth_pins>, <&eth_rgmii_pins>;
+				pinctrl-names = "default";
+				status = "okay";
+				phy-mode = "rgmii";
+				phy-handle = <&external_phy>;
+				amlogic,tx-delay-ns = <2>;
+};
+
+&frddr_a {
+	status = "okay";
+};
+
+&frddr_b {
+	status = "okay";
+};
+
+&frddr_c {
+	status = "okay";
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmitx_hpd_pins>, <&hdmitx_ddc_pins>;
+	pinctrl-names = "default";
+	hdmi-supply = <&vcc_5v>;
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&mipi_dsi {
+	status = "okay";
+	
+	assigned-clocks = <&clkc CLKID_GP0_PLL>,
+			  <&clkc CLKID_MIPI_DSI_PXCLK_SEL>,
+			  <&clkc CLKID_MIPI_DSI_PXCLK>;
+	assigned-clock-parents = <0>,
+				 <&clkc CLKID_GP0_PLL>,
+				 <0>;
+	assigned-clock-rates = <720000000>,
+			       <0>,
+			       <720000000>;
+
+	panel@0 {
+		status = "okay";
+		compatible = "chipone,icn6211";
+		power-supply = <&vddao_3v3>;
+		/*compatible = "waveshare,tl070hdv03ct";
+		power-supply = <&vcc_5v>;*/
+		reg = <0>;
+
+		port {
+			dsi_in_panel: endpoint {
+				remote-endpoint = <&dsi_out_panel>;
+			};
+		};
+	};
+};
+
+&mipi_analog_dphy {
+	status = "okay";
+};
+
+&mipi_dphy {
+	status = "okay";
+};
+
+&mipi_dsi_panel_port {
+	dsi_out_panel: endpoint {
+		remote-endpoint = <&dsi_in_panel>;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_sck_x_pins>, <&i2c2_sda_x_pins>;
+	clock-frequency = <100000>; /* default 100k */
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0 = <&i2c3_sck_a_pins>, <&i2c3_sda_a_pins>;
+	clock-frequency = <100000>; /* default 100k */
+
+	i2cmux@71 {
+		compatible = "nxp,pca9546";
+		reg = <0x71>;
+		status = "okay";
+		pinctrl-names = "default";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/*i2c and gpio_extension*/
+		i2c3a: i2c3@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0>;
+				status = "okay";
+		};
+
+		i2c3b: i2c3@1 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <1>;
+				status = "okay";
+		};
+
+		i2c3c: i2c3@2 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <2>;
+
+				pca9575b: gpio@21 {
+						compatible = "nxp,pca9575";
+						reg = <0x21>;
+						gpio-controller;
+						#gpio-cells = <0x02>;
+						status = "okay";
+						gpio-line-names = "WAKEUP_OUT", "PWR_ON_N", "WAKEUP_IN", "W_DISABLE_N",
+												"PMU_RSTIN_N", "9342_RST", "SEN-SYNC1", "", "MUTE",
+												"WIFI_LED", "CM_GPIO_1", "", "AMP_PWRDN", "POWER_LED",
+												"GPIO_18", "GPIO_17";
+				};
+
+				pca9575a: gpio@23 {
+						compatible = "nxp,pca9575";
+						reg = <0x23>;
+						gpio-controller;
+						#gpio-cells = <0x02>;
+						status = "okay";
+						gpio-line-names = "GPIO_01", "GPIO_02", "GPIO_03", "GPIO_04",
+												"GPIO_05", "GPIO_06", "GPIO_07", "GPIO_08", "GPIO_09",
+												"GPIO_10", "GPIO_11", "GPIO_12", "GPIO_13", "GPIO_14",
+												"GPIO_15", "GPIO_16";
+				};
+
+				es7243: es7243@11 {
+					compatible = "everest,es7243";
+					#sound-dai-cells = <0>;
+					reg = <0x11>;
+					status = "okay";
+				};
+
+				nau8540: nau8540@1c {
+						compatible = "nuvoton,nau8540";
+						#sound-dai-cells = <0>;
+						reg = <0x1c>;
+						sound-name-prefix = "Linein";
+						status = "okay";
+				};
+
+				tlv320dac3101: tlv320dac3101@18 {
+						compatible = "ti,tlv320dac3101";
+						#sound-dai-cells = <0>;
+						reg = <0x18>;
+						slot_number = <3>;
+						differential_pair = <1>;
+						status = "okay";
+				};
+
+				ft5406: ft5406@38 {
+						compatible = "edt,edt-ft5406";
+						reg = <0x38>;
+						touchscreen-size-x = < 800 >;
+						touchscreen-size-y = < 480 >;
+						touchscreen-inverted-x = < 1 >;
+						touchscreen-inverted-y = < 1 >;
+						status = "okay";
+				};
+
+				icn6211: icn6211@45 {
+						compatible = "chipone,icn6211-i2c";
+						status = "okay";
+						reg = <0x45>;
+				};
+
+				sensor-i2c@6c {
+					compatible = "arm, i2c-sensor";
+					reg = <0x6c>;
+					reg-names = "i2c-sensor";
+					slave-addr = <0x6c>;
+					reg-type = <2>;
+					reg-data-type = <1>;
+					link-device = <&phycsi>;
+				};
+		};
+
+		/*icm-20948*/
+		i2c3d: i2c3@3 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <3>;
+				status = "okay";
+		};
+	};
+};
+
+&i2c_AO {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c_ao_sck_pins>, <&i2c_ao_sda_pins>;
+	clock-frequency = <400000>;
+
+	rtc: rtc@51 {
+		compatible = "nxp,pcf8563";
+		reg = <0x51>;
+		status = "okay";
+		wakeup-source;
+	};
+};
+
+&pwm_ab {
+	status = "okay";
+};
+
+&pwm_AO_ab {
+	status = "okay";
+	pinctrl-0 = <&pwm_ao_a_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin0";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddao_1v8>;
+};
+
+/* eMMC */
+&sd_emmc_c {
+	status = "okay";
+	compatible = "amlogic,meson-axg-mmc";
+	pinctrl-0 = <&emmc_ctrl_pins>, <&emmc_data_8b_pins>, <&emmc_ds_pins>;
+	pinctrl-1 = <&emmc_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <8>;
+	cap-mmc-highspeed;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	max-frequency = <200000000>;
+	disable-wp;
+
+	mmc-pwrseq = <&emmc_pwrseq>;
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&vddao_1v8>;
+};
+
+/* SD card */
+&sd_emmc_b {
+	status = "okay";
+	compatible = "amlogic,meson-axg-mmc";
+	pinctrl-0 = <&sdcard_c_pins>;
+	pinctrl-1 = <&sdcard_clk_gate_c_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <50000000>;
+	disable-wp;
+
+	cd-gpios = <&gpio GPIOC_6 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&vddao_3v3>;
+};
+
+/* SDIO */
+&sd_emmc_a {
+	status = "okay";
+	pinctrl-0 = <&sdio_pins>;
+	pinctrl-1 = <&sdio_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	sd-uhs-sdr104;
+	max-frequency = <167000000>;
+
+	non-removable;
+	disable-wp;
+
+	/* WiFi firmware requires power to be kept while in suspend */
+	keep-power-in-suspend;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&vddao_1v8>;
+};
+
+&tdmif_a {
+	status = "okay";
+};
+
+&tdmif_b {
+	pinctrl-0 = <&tdm_b_sclk_pins>, <&tdm_b_fs_pins>,
+				<&tdm_b_din0_pins>, <&tdm_b_din1_pins>, <&mclk0_a_pins>;
+	pinctrl-names = "default";
+	
+	assigned-clocks = <&clkc_audio AUD_CLKID_TDM_MCLK_PAD0>,
+						<&clkc_audio AUD_CLKID_TDM_SCLK_PAD1>,
+						<&clkc_audio AUD_CLKID_TDM_LRCLK_PAD1>;
+	assigned-clock-parents = <&clkc_audio AUD_CLKID_MST_B_MCLK>,
+						<&clkc_audio AUD_CLKID_MST_B_SCLK>,
+						<&clkc_audio AUD_CLKID_MST_B_LRCLK>;
+	assigned-clock-rates = <0>, <0>, <0>;
+
+	status = "okay";
+};
+
+&tdmif_c {
+	status = "okay";
+};
+
+&tdmin_a {
+	status = "okay";
+};
+
+&tdmin_b {
+	status = "okay";
+};
+
+&tdmin_lb {
+	status = "okay";
+};
+
+&tdmin_c {
+	status = "okay";
+};
+
+&tdmout_a {
+	status = "okay";
+};
+
+&tdmout_b {
+	status = "okay";
+};
+
+&tdmout_c {
+	status = "okay";
+};
+
+&toacodec {
+	status = "okay";
+};
+
+&tohdmitx {
+	status = "okay";
+};
+
+&toddr_a {
+	status = "okay";
+};
+
+&toddr_b {
+	status = "okay";
+};
+
+&toddr_c {
+	status = "okay";
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+	xtal_tick_en = <2>;
+};
+
+&uart_AO_B {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_b_2_pins>;
+	pinctrl-names = "default";
+};
+
+/* BT UART */
+&uart_A {
+	status = "okay";
+	pinctrl-0 = <&uart_a_pins>;
+	pinctrl-names = "default";
+};
+
+&dwc2 {
+	status = "okay";
+};
+
+&dwc3 {
+	status = "okay";
+};
+
+&usb2_phy0 {
+	status = "okay";
+	phy-supply = <&usb1_pow>;
+};
+
+&usb2_phy1 {
+	status = "okay";
+	phy-supply = <&usb1_pow>;
+};
+
+&usb3_pcie_phy {
+	status = "okay";
+	phy-supply = <&usb_pwr>;
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "host";
+	vbus-supply = <&usb_pwr_en>;
+};
+
+&spicc0 {
+	status = "okay";
+	pinctrl-names = "default","gpio_periphs";
+	pinctrl-0 = <&spicc0_x_pins>;
+	pinctrl-1 = <&spicc0_ss0_x_pins>;
+	num_chipselect = <1>;
+	cs-gpios = <&gpio GPIOX_10 GPIO_ACTIVE_LOW>;
+
+	spidev@0 {
+		status = "okay";
+		compatible = "rohm,dh2228fv";
+		reg = <0>;
+		spi-max-frequency = <10000000>;
+	};
+};
+
+&spicc1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spicc1_pins>;
+	num_chipselect = <1>;
+	cs-gpios = <&gpio GPIOH_6 GPIO_ACTIVE_LOW>;
+
+	spidev@0 {
+		status = "okay";
+		compatible = "microchip,mcp2515";
+		reg = <0>;
+		clocks = <&osc8M>;
+		spi-max-frequency = <5000000>;
+		interrupt-parent = <&gpio_intc>;
+		interrupts = <66 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
diff -Naur a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
--- a/arch/arm64/boot/dts/Makefile	2022-05-27 17:20:14.009880591 +0800
+++ b/arch/arm64/boot/dts/Makefile	2022-05-31 11:56:47.697259643 +0800
@@ -30,3 +30,5 @@
 subdir-y += toshiba
 subdir-y += xilinx
 subdir-y += zte
+dtbs: $(addprefix $(obj)/, $(DTB_LIST))
+clean-files := dts/*.dtb *.dtb
diff -Naur a/arch/arm64/boot/Makefile b/arch/arm64/boot/Makefile
--- a/arch/arm64/boot/Makefile	2022-05-27 17:20:14.009880591 +0800
+++ b/arch/arm64/boot/Makefile	2022-05-31 11:56:47.697259643 +0800
@@ -16,7 +16,20 @@
 
 OBJCOPYFLAGS_Image :=-O binary -R .note -R .note.gnu.build-id -R .comment -S
 
-targets := Image Image.bz2 Image.gz Image.lz4 Image.lzma Image.lzo
+targets := Image Image.bz2 Image.gz Image.lz4 Image.lzma Image.lzo Image.gz-dtb
+
+dtstree := $(srctree)/$(src)/dts
+
+dtb-$(CONFIG_OF_ALL_DTBS) := $(patsubst $(dtstree)/%.dts,%.dtb, $(foreach d,$(dts-dirs), $(wildcard $(dtstree)/$(d)/*.dts)))
+
+DTB_NAMES := $(subst $\",,$(CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE_NAMES))
+ifneq ($(DTB_NAMES),)
+DTB_LIST := $(addsuffix .dtb,$(DTB_NAMES))
+else
+DTB_LIST := $(dtb-y)
+endif
+
+DTB_OBJS := $(addprefix $(obj)/dts/,$(DTB_LIST))
 
 $(obj)/Image: vmlinux FORCE
 	$(call if_changed,objcopy)
@@ -24,6 +37,9 @@
 $(obj)/Image.bz2: $(obj)/Image FORCE
 	$(call if_changed,bzip2)
 
+$(obj)/Image-dtb: $(obj)/Image $(DTB_OBJS) FORCE
+	$(call if_changed,cat)
+
 $(obj)/Image.gz: $(obj)/Image FORCE
 	$(call if_changed,gzip)
 
@@ -36,10 +52,35 @@
 $(obj)/Image.lzo: $(obj)/Image FORCE
 	$(call if_changed,lzo)
 
-install:
+$(obj)/Image.gz-dtb: $(obj)/Image.gz $(DTB_OBJS) FORCE
+	$(call if_changed,cat)
+
+UIMAGE_LOADADDR=$(TEXT_OFFSET)
+UIMAGE_ENTRYADDR=$(TEXT_OFFSET)
+#UIMAGE_COMPRESSION = gzip
+check_for_multiple_loadaddr = \
+if [ $(words $(UIMAGE_LOADADDR)) -ne 1 ]; then \
+	echo 'multiple (or no) load addresses: $(UIMAGE_LOADADDR)'; \
+	echo 'This is incompatible with uImages'; \
+	echo 'Specify LOADADDR on the commandline to build an uImage'; \
+	false; \
+fi
+
+rm_uimage:
+	@rm -f $(obj)/uImage
+
+$(obj)/uImage: $(obj)/Image rm_uimage FORCE
+	@$(check_for_multiple_loadaddr)
+	@dd if=$< of=$<.dd ibs=4096 conv=sync && mv $<.dd $<
+	$(call if_changed,uimage)
+	$(if $(CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE),@$(kecho) '  CAT   $(DTB_OBJS) to $@')
+	$(if $(CONFIG_BUILD_ARM64_APPENDED_DTB_IMAGE),@cat $(DTB_OBJS) >>$@,)
+	@$(kecho) '  Image $@ is ready'
+
+install:$(obj)/uImage
 	$(CONFIG_SHELL) $(srctree)/$(src)/install.sh $(KERNELRELEASE) \
 	$(obj)/Image System.map "$(INSTALL_PATH)"
 
-zinstall:
+zinstall:$(obj)/uImage
 	$(CONFIG_SHELL) $(srctree)/$(src)/install.sh $(KERNELRELEASE) \
 	$(obj)/Image.gz System.map "$(INSTALL_PATH)"
diff -Naur a/arch/arm64/include/asm/kernel-pgtable.h b/arch/arm64/include/asm/kernel-pgtable.h
--- a/arch/arm64/include/asm/kernel-pgtable.h	2022-05-27 17:20:14.061881262 +0800
+++ b/arch/arm64/include/asm/kernel-pgtable.h	2022-05-31 11:56:47.705259573 +0800
@@ -86,7 +86,7 @@
 			+ EARLY_PGDS((vstart), (vend)) 	/* each PGDIR needs a next level page table */	\
 			+ EARLY_PUDS((vstart), (vend))	/* each PUD needs a next level page table */	\
 			+ EARLY_PMDS((vstart), (vend)))	/* each PMD needs a next level page table */
-#define INIT_DIR_SIZE (PAGE_SIZE * EARLY_PAGES(KIMAGE_VADDR, _end))
+#define INIT_DIR_SIZE (PAGE_SIZE * EARLY_PAGES(KIMAGE_VADDR + TEXT_OFFSET, _end))
 #define IDMAP_DIR_SIZE		(IDMAP_PGTABLE_LEVELS * PAGE_SIZE)
 
 /* Initial memory map size */
diff -Naur a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S
--- a/arch/arm64/kernel/head.S	2022-05-27 17:20:14.065881314 +0800
+++ b/arch/arm64/kernel/head.S	2022-05-31 11:56:47.705259573 +0800
@@ -36,10 +36,14 @@
 
 #include "efi-header.S"
 
-#define __PHYS_OFFSET	KERNEL_START
+#define __PHYS_OFFSET	(KERNEL_START - TEXT_OFFSET)
 
-#if (PAGE_OFFSET & 0x1fffff) != 0
+#if (TEXT_OFFSET & 0xfff) != 0
+#error TEXT_OFFSET must be at least 4KB aligned
+#elif (PAGE_OFFSET & 0x1fffff) != 0
 #error PAGE_OFFSET must be at least 2MB aligned
+#elif TEXT_OFFSET > 0x1fffff
+//#error TEXT_OFFSET must be less than 2MB
 #endif
 
 /*
@@ -73,7 +77,7 @@
 	b	primary_entry			// branch to kernel start, magic
 	.long	0				// reserved
 #endif
-	.quad	0				// Image load offset from start of RAM, little-endian
+	le64sym	_kernel_offset_le		// Image load offset from start of RAM, little-endian
 	le64sym	_kernel_size_le			// Effective size of kernel image, little-endian
 	le64sym	_kernel_flags_le		// Informative flags, little-endian
 	.quad	0				// reserved
@@ -379,7 +383,7 @@
 	 * Map the kernel image (starting with PHYS_OFFSET).
 	 */
 	adrp	x0, init_pg_dir
-	mov_q	x5, KIMAGE_VADDR		// compile time __va(_text)
+	mov_q	x5, KIMAGE_VADDR + TEXT_OFFSET	// compile time __va(_text)
 	add	x5, x5, x23			// add KASLR displacement
 	mov	x4, PTRS_PER_PGD
 	adrp	x6, _end			// runtime __pa(_end)
@@ -471,7 +475,7 @@
 
 	.pushsection ".rodata", "a"
 SYM_DATA_START(kimage_vaddr)
-	.quad		_text
+	.quad		_text - TEXT_OFFSET
 SYM_DATA_END(kimage_vaddr)
 EXPORT_SYMBOL(kimage_vaddr)
 	.popsection
diff -Naur a/arch/arm64/kernel/image.h b/arch/arm64/kernel/image.h
--- a/arch/arm64/kernel/image.h	2022-05-27 17:20:14.069881366 +0800
+++ b/arch/arm64/kernel/image.h	2022-05-31 11:56:47.705259573 +0800
@@ -62,6 +62,7 @@
  */
 #define HEAD_SYMBOLS						\
 	DEFINE_IMAGE_LE64(_kernel_size_le, _end - _text);	\
+	DEFINE_IMAGE_LE64(_kernel_offset_le, TEXT_OFFSET);	\
 	DEFINE_IMAGE_LE64(_kernel_flags_le, __HEAD_FLAGS);
 
 #endif /* __ARM64_KERNEL_IMAGE_H */
diff -Naur a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile
--- a/arch/arm64/kernel/Makefile	2022-05-27 17:20:14.065881314 +0800
+++ b/arch/arm64/kernel/Makefile	2022-05-31 11:56:47.705259573 +0800
@@ -3,6 +3,8 @@
 # Makefile for the linux kernel.
 #
 
+CPPFLAGS_vmlinux.lds	:= -DTEXT_OFFSET=$(TEXT_OFFSET)
+AFLAGS_head.o		:= -DTEXT_OFFSET=$(TEXT_OFFSET)
 CFLAGS_armv8_deprecated.o := -I$(src)
 
 CFLAGS_REMOVE_ftrace.o = $(CC_FLAGS_FTRACE)
diff -Naur a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S
--- a/arch/arm64/kernel/vmlinux.lds.S	2022-05-27 17:20:14.073881416 +0800
+++ b/arch/arm64/kernel/vmlinux.lds.S	2022-05-31 11:56:47.705259573 +0800
@@ -115,7 +115,7 @@
 		*(.dynsym .dynstr .hash .gnu.hash)
 	}
 
-	. = KIMAGE_VADDR;
+	. = KIMAGE_VADDR + TEXT_OFFSET;
 
 	.head.text : {
 		_text = .;
@@ -305,4 +305,4 @@
 /*
  * If padding is applied before .head.text, virt<->phys conversions will fail.
  */
-ASSERT(_text == KIMAGE_VADDR, "HEAD is misaligned")
+ASSERT(_text == (KIMAGE_VADDR  + TEXT_OFFSET), "HEAD is misaligned")
diff -Naur a/arch/arm64/Makefile b/arch/arm64/Makefile
--- a/arch/arm64/Makefile	2022-05-27 17:20:14.009880591 +0800
+++ b/arch/arm64/Makefile	2022-05-31 11:56:47.705259573 +0800
@@ -11,6 +11,9 @@
 # Copyright (C) 1995-2001 by Russell King
 
 LDFLAGS_vmlinux	:=--no-undefined -X
+CPPFLAGS_vmlinux.lds = -DTEXT_OFFSET=$(TEXT_OFFSET)
+
+OBJCOPYFLAGS	:=-O binary -R .note -R .note.gnu.build-id -R .comment -S
 
 ifeq ($(CONFIG_RELOCATABLE), y)
 # Pass --no-apply-dynamic-relocs to restore pre-binutils-2.27 behaviour
@@ -96,6 +99,11 @@
 asm-arch := armv8.4-a
 endif
 
+ifeq ($(CONFIG_AS_HAS_ARMV8_5), y)
+# make sure to pass the newest target architecture to -march.
+asm-arch := armv8.5-a
+endif
+
 ifdef asm-arch
 KBUILD_CFLAGS	+= -Wa,-march=$(asm-arch) \
 		   -DARM64_ASM_ARCH='"$(asm-arch)"'
@@ -134,6 +142,9 @@
 # Default value
 head-y		:= arch/arm64/kernel/head.o
 
+# The byte offset of the kernel image in RAM from the start of RAM.
+TEXT_OFFSET := 0x01080000
+
 ifeq ($(CONFIG_KASAN_SW_TAGS), y)
 KASAN_SHADOW_SCALE_SHIFT := 4
 else
@@ -144,13 +155,15 @@
 KBUILD_CPPFLAGS += -DKASAN_SHADOW_SCALE_SHIFT=$(KASAN_SHADOW_SCALE_SHIFT)
 KBUILD_AFLAGS += -DKASAN_SHADOW_SCALE_SHIFT=$(KASAN_SHADOW_SCALE_SHIFT)
 
+export TEXT_OFFSET
+
 core-y		+= arch/arm64/
 libs-y		:= arch/arm64/lib/ $(libs-y)
 libs-$(CONFIG_EFI_STUB) += $(objtree)/drivers/firmware/efi/libstub/lib.a
 
 # Default target when executing plain make
 boot		:= arch/arm64/boot
-KBUILD_IMAGE	:= $(boot)/Image.gz
+KBUILD_IMAGE	:= $(boot)/Image
 
 all:	Image.gz
 
diff -Naur a/arch/powerpc/platforms/85xx/mpc85xx_pm_ops.c b/arch/powerpc/platforms/85xx/mpc85xx_pm_ops.c
--- a/arch/powerpc/platforms/85xx/mpc85xx_pm_ops.c	2022-06-30 21:35:01.784330920 +0800
+++ b/arch/powerpc/platforms/85xx/mpc85xx_pm_ops.c	2022-05-27 17:20:14.357885080 +0800
@@ -94,8 +94,9 @@
 			pr_err("Could not map guts node address\n");
 			return -ENOMEM;
 		}
-		qoriq_pm_ops = &mpc85xx_pm_ops;
 	}
 
+	qoriq_pm_ops = &mpc85xx_pm_ops;
+
 	return 0;
 }
diff -Naur a/arch/x86/include/asm/page_64_types.h b/arch/x86/include/asm/page_64_types.h
--- a/arch/x86/include/asm/page_64_types.h	2022-06-30 21:35:01.784330920 +0800
+++ b/arch/x86/include/asm/page_64_types.h	2022-05-27 17:20:14.513887093 +0800
@@ -15,7 +15,7 @@
 #define THREAD_SIZE_ORDER	(2 + KASAN_STACK_ORDER)
 #define THREAD_SIZE  (PAGE_SIZE << THREAD_SIZE_ORDER)
 
-#define EXCEPTION_STACK_ORDER (1 + KASAN_STACK_ORDER)
+#define EXCEPTION_STACK_ORDER (0 + KASAN_STACK_ORDER)
 #define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
 
 #define IRQ_STACK_ORDER (2 + KASAN_STACK_ORDER)
diff -Naur a/arch/x86/kernel/cpu/bugs.c b/arch/x86/kernel/cpu/bugs.c
--- a/arch/x86/kernel/cpu/bugs.c	2022-07-04 18:32:52.121159105 +0800
+++ b/arch/x86/kernel/cpu/bugs.c	2022-05-27 17:20:14.525887248 +0800
@@ -1091,7 +1091,6 @@
 
 #define MDS_MSG_SMT "MDS CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/mds.html for more details.\n"
 #define TAA_MSG_SMT "TAA CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/tsx_async_abort.html for more details.\n"
-#define MMIO_MSG_SMT "MMIO Stale Data CPU bug present and SMT on, data leak possible. See https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/processor_mmio_stale_data.html for more details.\n"
 
 void cpu_bugs_smt_update(void)
 {
@@ -1136,16 +1135,6 @@
 		break;
 	}
 
-	switch (mmio_mitigation) {
-	case MMIO_MITIGATION_VERW:
-	case MMIO_MITIGATION_UCODE_NEEDED:
-		if (sched_smt_active())
-			pr_warn_once(MMIO_MSG_SMT);
-		break;
-	case MMIO_MITIGATION_OFF:
-		break;
-	}
-
 	mutex_unlock(&spec_ctrl_mutex);
 }
 
diff -Naur a/arch/x86/kvm/hyperv.c b/arch/x86/kvm/hyperv.c
--- a/arch/x86/kvm/hyperv.c	2022-07-04 18:32:52.121159105 +0800
+++ b/arch/x86/kvm/hyperv.c	2022-05-27 17:20:14.541887454 +0800
@@ -207,7 +207,7 @@
 	struct kvm_vcpu *vcpu = synic_to_vcpu(synic);
 	int ret;
 
-	if (!synic->active && (!host || data))
+	if (!synic->active && !host)
 		return 1;
 
 	trace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);
@@ -253,9 +253,6 @@
 	case HV_X64_MSR_EOM: {
 		int i;
 
-		if (!synic->active)
-			break;
-
 		for (i = 0; i < ARRAY_SIZE(synic->sint); i++)
 			kvm_hv_notify_acked_sint(vcpu, i);
 		break;
@@ -639,7 +636,7 @@
 	struct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);
 	struct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);
 
-	if (!synic->active && (!host || config))
+	if (!synic->active && !host)
 		return 1;
 
 	trace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,
@@ -663,7 +660,7 @@
 	struct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);
 	struct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);
 
-	if (!synic->active && (!host || count))
+	if (!synic->active && !host)
 		return 1;
 
 	trace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,
diff -Naur a/drivers/clk/meson/clk-mux.c b/drivers/clk/meson/clk-mux.c
--- a/drivers/clk/meson/clk-mux.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/clk/meson/clk-mux.c	2022-05-31 11:56:47.725259396 +0800
@@ -0,0 +1,214 @@
+/*
+ * drivers/amlogic/clk/clk-mux.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "clk-mux.h"
+
+
+#define to_clk_mux(_hw) container_of(_hw, struct clk_mux, hw)
+
+static inline u32 clk_mux_readl(struct clk_mux *mux)
+{
+	if (mux->flags & CLK_MUX_BIG_ENDIAN)
+		return ioread32be(mux->reg);
+
+	return readl(mux->reg);
+}
+
+static inline void clk_mux_writel(struct clk_mux *mux, u32 val)
+{
+	if (mux->flags & CLK_MUX_BIG_ENDIAN)
+		iowrite32be(val, mux->reg);
+	else
+		writel(val, mux->reg);
+}
+
+
+static u8 meson_clk_mux_get_parent(struct clk_hw *hw)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	int num_parents = clk_hw_get_num_parents(hw);
+	u32 val;
+
+	/*
+	 * FIXME need a mux-specific flag to determine if val is bitwise or
+	 * numeric. e.g. sys_clkin_ck's clksel field is 3 bits wide, but ranges
+	 * from 0x1 to 0x7 (index starts at one)
+	 * OTOH, pmd_trace_clk_mux_ck uses a separate bit for each clock, so
+	 * val = 0x4 really means "bit 2, index starts at bit 0"
+	 */
+	val = clk_mux_readl(mux) >> mux->shift;
+	val &= mux->mask;
+
+	if (mux->table) {
+		int i;
+
+		for (i = 0; i < num_parents; i++)
+			if (mux->table[i] == val)
+				return i;
+		return -EINVAL;
+	}
+
+	if (val && (mux->flags & CLK_MUX_INDEX_BIT))
+		val = ffs(val) - 1;
+
+	if (val && (mux->flags & CLK_MUX_INDEX_ONE))
+		val--;
+
+	if (val >= num_parents)
+		return -EINVAL;
+
+	return val;
+}
+
+static int meson_clk_mux_set_parent(struct clk_hw *hw, u8 index)
+{
+	struct clk_mux *mux = to_clk_mux(hw);
+	u32 val;
+	unsigned long flags = 0;
+
+	if (mux->table) {
+		index = mux->table[index];
+	} else {
+		if (mux->flags & CLK_MUX_INDEX_BIT)
+			index = (1 << ffs(index));
+
+		if (mux->flags & CLK_MUX_INDEX_ONE)
+			index++;
+	}
+
+	if (mux->lock)
+		spin_lock_irqsave(mux->lock, flags);
+	else
+		__acquire(mux->lock);
+
+	if (mux->flags & CLK_MUX_HIWORD_MASK) {
+		val = mux->mask << (mux->shift + 16);
+	} else {
+		val = clk_mux_readl(mux);
+		val &= ~(mux->mask << mux->shift);
+	}
+
+	val |= index << mux->shift;
+	clk_mux_writel(mux, val);
+
+	if (mux->lock)
+		spin_unlock_irqrestore(mux->lock, flags);
+	else
+		__release(mux->lock);
+
+	return 0;
+}
+
+static unsigned long meson_clk_mux_recalc_rate(struct clk_hw *hw,
+					       unsigned long parent_rate)
+{
+	struct clk_hw *parent_hw;
+	u32 index = 0;
+	unsigned long new_parent_rate;
+
+	index = meson_clk_mux_get_parent(hw);
+
+	parent_hw = clk_hw_get_parent_by_index(hw, index);
+	new_parent_rate = clk_hw_get_rate(parent_hw);
+	if (new_parent_rate != parent_rate)
+		clk_set_parent(hw->clk, parent_hw->clk);
+
+	return new_parent_rate;
+}
+
+int meson_clk_mux_determine_rate(struct clk_hw *hw,
+			     struct clk_rate_request *req)
+{
+	struct clk_hw *parent, *best_parent = NULL;
+	int i, num_parents, ret;
+	unsigned long best = 0;
+	struct clk_rate_request parent_req = *req;
+	struct clk_mux *mux = to_clk_mux(hw);
+
+	num_parents = clk_hw_get_num_parents(hw);
+
+	if ((num_parents == 2) && (mux->flags == CLK_PARENT_ALTERNATE)) {
+		i = meson_clk_mux_get_parent(hw);
+		i = (i + 1) % 2;
+
+		best_parent = clk_hw_get_parent_by_index(hw, i);
+		best = clk_hw_get_rate(best_parent);
+		if (best != parent_req.rate) {
+			ret = clk_set_rate(best_parent->clk, parent_req.rate);
+			if (ret)
+				pr_err("Fail! Can not set to %lu, cur rate: %lu\n",
+				   parent_req.rate, best);
+			else {
+				best = clk_hw_get_rate(best_parent);
+				pr_debug("success set parent %s rate to %lu\n",
+					clk_hw_get_name(best_parent), best);
+				if (!(clk_hw_get_flags(hw) &
+						CLK_SET_RATE_UNGATE)) {
+					clk_prepare(best_parent->clk);
+					clk_enable(best_parent->clk);
+				}
+			}
+		}
+	} else {
+		for (i = 0; i < num_parents; i++) {
+			parent = clk_hw_get_parent_by_index(hw, i);
+			if (!parent)
+				continue;
+
+			if (mux->flags & CLK_SET_RATE_PARENT) {
+				parent_req = *req;
+				ret = __clk_determine_rate(parent, &parent_req);
+				if (ret)
+					continue;
+			} else {
+				parent_req.rate = clk_hw_get_rate(parent);
+			}
+		}
+	}
+
+	if (!best_parent)
+		return -EINVAL;
+
+	if (best_parent)
+		req->best_parent_hw = best_parent;
+
+	req->best_parent_rate = best;
+	req->rate = best;
+
+	return 0;
+}
+
+const struct clk_ops meson_clk_mux_ops = {
+	.get_parent = meson_clk_mux_get_parent,
+	.set_parent = meson_clk_mux_set_parent,
+	.determine_rate = meson_clk_mux_determine_rate,
+	.recalc_rate = meson_clk_mux_recalc_rate,
+};
+
+const struct clk_ops meson_clk_mux_ro_ops = {
+	.get_parent = meson_clk_mux_get_parent,
+};
diff -Naur a/drivers/clk/meson/clk-mux.h b/drivers/clk/meson/clk-mux.h
--- a/drivers/clk/meson/clk-mux.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/clk/meson/clk-mux.h	2022-05-31 11:56:47.725259396 +0800
@@ -0,0 +1,19 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019 BayLibre, SAS.
+ * Author: Jerome Brunet <jbrunet@baylibre.com>
+ */
+
+#ifndef __MESON_CLK_MUX_H
+#define __MESON_CLK_MUX_H
+
+#include <linux/clk-provider.h>
+#include <linux/regmap.h>
+#include "parm.h"
+
+#define CLK_PARENT_ALTERNATE BIT(5)
+
+extern const struct clk_ops meson_clk_mux_ops;
+
+
+#endif /* __MESON_CLK_MUX_H */
diff -Naur a/drivers/clk/meson/clk-pll.c b/drivers/clk/meson/clk-pll.c
--- a/drivers/clk/meson/clk-pll.c	2022-05-27 17:20:14.749890137 +0800
+++ b/drivers/clk/meson/clk-pll.c	2022-05-31 11:56:47.725259396 +0800
@@ -283,6 +283,8 @@
 		delay--;
 	} while (delay > 0);
 
+	pr_warn("%s: pll %s did not lock\n", __func__, clk_hw_get_name(hw));
+
 	return -ETIMEDOUT;
 }
 
@@ -339,6 +341,9 @@
 	/* Enable the pll */
 	meson_parm_write(clk->map, &pll->en, 1);
 
+	/* Reset delay */
+	udelay(pll->rst_delay_us);
+
 	/* Take the pll out reset */
 	meson_parm_write(clk->map, &pll->rst, 0);
 
diff -Naur a/drivers/clk/meson/clk-pll.h b/drivers/clk/meson/clk-pll.h
--- a/drivers/clk/meson/clk-pll.h	2022-05-27 17:20:14.749890137 +0800
+++ b/drivers/clk/meson/clk-pll.h	2022-05-31 11:56:47.725259396 +0800
@@ -41,6 +41,7 @@
 	const struct pll_params_table *table;
 	const struct pll_mult_range *range;
 	u8 flags;
+	u32 rst_delay_us;
 };
 
 extern const struct clk_ops meson_clk_pll_ro_ops;
diff -Naur a/drivers/clk/meson/g12a.c b/drivers/clk/meson/g12a.c
--- a/drivers/clk/meson/g12a.c	2022-05-27 17:20:14.749890137 +0800
+++ b/drivers/clk/meson/g12a.c	2022-05-31 11:56:47.725259396 +0800
@@ -15,6 +15,7 @@
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/of_address.h>
 
 #include "clk-mpll.h"
 #include "clk-pll.h"
@@ -23,8 +24,9 @@
 #include "vid-pll-div.h"
 #include "meson-eeclk.h"
 #include "g12a.h"
+#include "g12a-vcodec-clk.h"
 
-static DEFINE_SPINLOCK(meson_clk_lock);
+/*static*/ DEFINE_SPINLOCK(meson_clk_lock);
 
 static struct clk_regmap g12a_fixed_pll_dco = {
 	.data = &(struct meson_clk_pll_data){
@@ -1602,20 +1604,21 @@
 };
 
 static const struct pll_mult_range g12a_gp0_pll_mult_range = {
-	.min = 125,
-	.max = 255,
+	.min = 132, /* Force M to 132 */
+	.max = 132,
 };
 
 /*
  * Internal gp0 pll emulation configuration parameters
  */
 static const struct reg_sequence g12a_gp0_init_regs[] = {
+	{ .reg = HHI_GP0_PLL_CNTL0,	.def = 0x08000000 },
 	{ .reg = HHI_GP0_PLL_CNTL1,	.def = 0x00000000 },
 	{ .reg = HHI_GP0_PLL_CNTL2,	.def = 0x00000000 },
-	{ .reg = HHI_GP0_PLL_CNTL3,	.def = 0x48681c00 },
-	{ .reg = HHI_GP0_PLL_CNTL4,	.def = 0x33771290 },
+	{ .reg = HHI_GP0_PLL_CNTL3,	.def = 0x6a285c00},
+	{ .reg = HHI_GP0_PLL_CNTL4,	.def = 0x65771290},
 	{ .reg = HHI_GP0_PLL_CNTL5,	.def = 0x39272000 },
-	{ .reg = HHI_GP0_PLL_CNTL6,	.def = 0x56540000 },
+	{ .reg = HHI_GP0_PLL_CNTL6,	.def = 0x56540000, .delay_us = 10 },
 };
 
 static struct clk_regmap g12a_gp0_pll_dco = {
@@ -1653,6 +1656,7 @@
 		.range = &g12a_gp0_pll_mult_range,
 		.init_regs = g12a_gp0_init_regs,
 		.init_count = ARRAY_SIZE(g12a_gp0_init_regs),
+		.rst_delay_us = 100,
 	},
 	.hw.init = &(struct clk_init_data){
 		.name = "gp0_pll_dco",
@@ -3657,6 +3661,86 @@
 	},
 };
 
+/* MIPI DSI Host Clocks */
+
+static const struct clk_hw *g12a_mipi_dsi_pxclk_parent_hws[] = {
+	&g12a_vid_pll.hw,
+	&g12a_gp0_pll.hw,
+	&g12a_hifi_pll.hw,
+	&g12a_mpll1.hw,
+	&g12a_fclk_div2.hw,
+	&g12a_fclk_div2p5.hw,
+	&g12a_fclk_div3.hw,
+	&g12a_fclk_div7.hw,
+};
+
+static struct clk_regmap g12a_mipi_dsi_pxclk_sel = {
+	.data = &(struct clk_regmap_mux_data){
+		.offset = HHI_MIPIDSI_PHY_CLK_CNTL,
+		.mask = 0x7,
+		.shift = 12,
+		.flags = CLK_MUX_ROUND_CLOSEST,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mipi_dsi_pxclk_sel",
+		.ops = &clk_regmap_mux_ops,
+		.parent_hws = g12a_mipi_dsi_pxclk_parent_hws,
+		.num_parents = ARRAY_SIZE(g12a_mipi_dsi_pxclk_parent_hws),
+		.flags = CLK_SET_RATE_NO_REPARENT,
+	},
+};
+
+static struct clk_regmap g12a_mipi_dsi_pxclk_div = {
+	.data = &(struct clk_regmap_div_data){
+		.offset = HHI_MIPIDSI_PHY_CLK_CNTL,
+		.shift = 0,
+		.width = 7,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "mipi_dsi_pxclk_div",
+		.ops = &clk_regmap_divider_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&g12a_mipi_dsi_pxclk_sel.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+static struct clk_regmap g12a_mipi_dsi_pxclk = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = HHI_MIPIDSI_PHY_CLK_CNTL,
+		.bit_idx = 8,
+	},
+	.hw.init = &(struct clk_init_data) {
+		.name = "mipi_dsi_pxclk",
+		.ops = &clk_regmap_gate_ops,
+		.parent_hws = (const struct clk_hw *[]) {
+			&g12a_mipi_dsi_pxclk_div.hw
+		},
+		.num_parents = 1,
+		.flags = CLK_SET_RATE_PARENT,
+	},
+};
+
+/* GPIO 24M */
+static struct clk_regmap g12a_24m = {
+	.data = &(struct clk_regmap_gate_data){
+		.offset = HHI_XTAL_DIVN_CNTL,
+		.bit_idx = 6,
+	},
+	.hw.init = &(struct clk_init_data){
+		.name = "g12a_24m",
+		.ops = &clk_regmap_gate_ops,
+		.parent_names = (const char *[]){ "xtal" },
+		.parent_data = &(const struct clk_parent_data) {
+			.fw_name = "xtal",
+		},
+		.num_parents = 1,
+		.flags = (CLK_SET_RATE_PARENT | CLK_IS_CRITICAL),
+	},
+};
+
 /* HDMI Clocks */
 
 static const struct clk_parent_data g12a_hdmi_parent_data[] = {
@@ -4099,6 +4183,96 @@
 	},
 };
 
+static const char * const media_parent_names[] = { "xtal",
+	"gp0_pll", "hifi_pll", "fclk_div2p5", "fclk_div3", "fclk_div4",
+	"fclk_div5",  "fclk_div7"};
+
+static const char * const media_parent_names_mipi[] = { "xtal",
+	"gp0_pll", "mpll1", "mpll2", "fclk_div3", "fclk_div4",
+	"fclk_div5",  "fclk_div7"};
+	
+static struct clk_mux cts_mipi_isp_clk_mux = {
+	.reg = (void *)HHI_MIPI_ISP_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 9,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "cts_mipi_isp_clk_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = media_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider cts_mipi_isp_clk_div = {
+	.reg = (void *)HHI_MIPI_ISP_CLK_CNTL,
+	.shift = 0,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "cts_mipi_isp_clk_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "cts_mipi_isp_clk_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate cts_mipi_isp_clk_gate = {
+	.reg = (void *)HHI_MIPI_ISP_CLK_CNTL,
+	.bit_idx = 8,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "cts_mipi_isp_clk_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "cts_mipi_isp_clk_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux cts_mipi_csi_phy_clk0_mux = {
+	.reg = (void *)HHI_MIPI_CSI_PHY_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 9,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "cts_mipi_csi_phy_clk0_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = media_parent_names_mipi,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider cts_mipi_csi_phy_clk0_div = {
+	.reg = (void *)HHI_MIPI_CSI_PHY_CLK_CNTL,
+	.shift = 0,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "cts_mipi_csi_phy_clk0_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "cts_mipi_csi_phy_clk0_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate cts_mipi_csi_phy_clk0_gate = {
+	.reg = (void *)HHI_MIPI_CSI_PHY_CLK_CNTL,
+	.bit_idx = 8,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "cts_mipi_csi_phy_clk0_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "cts_mipi_csi_phy_clk0_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
 #define MESON_GATE(_name, _reg, _bit) \
 	MESON_PCLK(_name, _reg, _bit, &g12a_clk81.hw)
 
@@ -4402,6 +4576,9 @@
 		[CLKID_SPICC1_SCLK_SEL]		= &g12a_spicc1_sclk_sel.hw,
 		[CLKID_SPICC1_SCLK_DIV]		= &g12a_spicc1_sclk_div.hw,
 		[CLKID_SPICC1_SCLK]		= &g12a_spicc1_sclk.hw,
+		[CLKID_MIPI_DSI_PXCLK_SEL]	= &g12a_mipi_dsi_pxclk_sel.hw,
+		[CLKID_MIPI_DSI_PXCLK_DIV]	= &g12a_mipi_dsi_pxclk_div.hw,
+		[CLKID_MIPI_DSI_PXCLK]		= &g12a_mipi_dsi_pxclk.hw,
 		[NR_CLKS]			= NULL,
 	},
 	.num = NR_CLKS,
@@ -4657,6 +4834,10 @@
 		[CLKID_SPICC1_SCLK_SEL]		= &g12a_spicc1_sclk_sel.hw,
 		[CLKID_SPICC1_SCLK_DIV]		= &g12a_spicc1_sclk_div.hw,
 		[CLKID_SPICC1_SCLK]		= &g12a_spicc1_sclk.hw,
+		[CLKID_MIPI_DSI_PXCLK_SEL]	= &g12a_mipi_dsi_pxclk_sel.hw,
+		[CLKID_MIPI_DSI_PXCLK_DIV]	= &g12a_mipi_dsi_pxclk_div.hw,
+		[CLKID_MIPI_DSI_PXCLK]		= &g12a_mipi_dsi_pxclk.hw,
+		[CLKID_24M]			= &g12a_24m.hw,
 		[NR_CLKS]			= NULL,
 	},
 	.num = NR_CLKS,
@@ -4903,6 +5084,9 @@
 		[CLKID_NNA_CORE_CLK_SEL]	= &sm1_nna_core_clk_sel.hw,
 		[CLKID_NNA_CORE_CLK_DIV]	= &sm1_nna_core_clk_div.hw,
 		[CLKID_NNA_CORE_CLK]		= &sm1_nna_core_clk.hw,
+		[CLKID_MIPI_DSI_PXCLK_SEL]	= &g12a_mipi_dsi_pxclk_sel.hw,
+		[CLKID_MIPI_DSI_PXCLK_DIV]	= &g12a_mipi_dsi_pxclk_div.hw,
+		[CLKID_MIPI_DSI_PXCLK]		= &g12a_mipi_dsi_pxclk.hw,
 		[NR_CLKS]			= NULL,
 	},
 	.num = NR_CLKS,
@@ -5150,6 +5334,10 @@
 	&sm1_nna_core_clk_sel,
 	&sm1_nna_core_clk_div,
 	&sm1_nna_core_clk,
+	&g12a_mipi_dsi_pxclk_sel,
+	&g12a_mipi_dsi_pxclk_div,
+	&g12a_mipi_dsi_pxclk,
+	&g12a_24m,
 };
 
 static const struct reg_sequence g12a_init_regs[] = {
@@ -5196,7 +5384,58 @@
 	struct clk *notifier_clk;
 	struct clk_hw *xtal;
 	int ret;
+	
+	void __iomem *clk_base;
+
+	clk_base = of_iomap(of_get_parent(pdev->dev.of_node), 0);
+	if (!clk_base) {
+		pr_err("%s: Unable to map clk base\n", __func__);
+		return -1;
+	}
+
+	cts_mipi_isp_clk_mux.reg = clk_base
+		+ (unsigned long)(cts_mipi_isp_clk_mux.reg);
+	cts_mipi_isp_clk_gate.reg = clk_base
+		+ (unsigned long)(cts_mipi_isp_clk_gate.reg);
+	cts_mipi_isp_clk_div.reg = clk_base
+		+ (unsigned long)(cts_mipi_isp_clk_div.reg);
+
+	cts_mipi_csi_phy_clk0_mux.reg = clk_base
+		+ (unsigned long)(cts_mipi_csi_phy_clk0_mux.reg);
+	cts_mipi_csi_phy_clk0_div.reg = clk_base
+		+ (unsigned long)(cts_mipi_csi_phy_clk0_div.reg);
+	cts_mipi_csi_phy_clk0_gate.reg = clk_base
+		+ (unsigned long)(cts_mipi_csi_phy_clk0_gate.reg);
+		
+	// register composite clks
+	hws[CLKID_MIPI_ISP_CLK_COMP] = clk_hw_register_composite(NULL,
+		"cts_mipi_isp_clk_composite",
+		media_parent_names, 8,
+		&cts_mipi_isp_clk_mux.hw,
+		&clk_mux_ops,
+		&cts_mipi_isp_clk_div.hw,
+		&clk_divider_ops,
+		&cts_mipi_isp_clk_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(hws[CLKID_MIPI_ISP_CLK_COMP]))
+		panic("%s: %d register cts_mipi_isp_clk_composite error\n",
+			__func__, __LINE__);
+
+	hws[CLKID_MIPI_CSI_PHY_CLK0_COMP] = clk_hw_register_composite(NULL,
+		"cts_mipi_csi_phy_clk0_composite",
+		media_parent_names_mipi, 8,
+		&cts_mipi_csi_phy_clk0_mux.hw,
+		&clk_mux_ops,
+		&cts_mipi_csi_phy_clk0_div.hw,
+		&clk_divider_ops,
+		&cts_mipi_csi_phy_clk0_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(hws[CLKID_MIPI_CSI_PHY_CLK0_COMP]))
+		panic("%s: %d register cts_mipi_csi_phy_clk0_composite error\n",
+			__func__, __LINE__);
 
+	meson_g12a_vcodec_init(hws, clk_base);
+	
 	ret = meson_g12a_dvfs_setup_common(pdev, hws);
 	if (ret)
 		return ret;
diff -Naur a/drivers/clk/meson/g12a.h b/drivers/clk/meson/g12a.h
--- a/drivers/clk/meson/g12a.h	2022-05-27 17:20:14.749890137 +0800
+++ b/drivers/clk/meson/g12a.h	2022-05-31 11:56:47.725259396 +0800
@@ -44,6 +44,7 @@
 #define HHI_PCIE_PLL_CNTL4		0x0A8
 #define HHI_PCIE_PLL_CNTL5		0x0AC
 #define HHI_PCIE_PLL_STS		0x0B8
+#define HHI_XTAL_DIVN_CNTL		0x0BC /* 0x2f offset in data sheet */
 #define HHI_HIFI_PLL_CNTL0		0x0D8
 #define HHI_HIFI_PLL_CNTL1		0x0DC
 #define HHI_HIFI_PLL_CNTL2		0x0E0
@@ -70,6 +71,7 @@
 #define HHI_MALI_CLK_CNTL		0x1b0
 #define HHI_VPU_CLKC_CNTL		0x1b4
 #define HHI_VPU_CLK_CNTL		0x1bC
+#define HHI_MIPI_ISP_CLK_CNTL		0x1C0 /* 0x70 offset in data sheet */
 #define HHI_NNA_CLK_CNTL		0x1C8
 #define HHI_HDMI_CLK_CNTL		0x1CC
 #define HHI_VDEC_CLK_CNTL		0x1E0
@@ -117,6 +119,7 @@
 #define HHI_HDMI_PLL_CNTL4		0x330
 #define HHI_HDMI_PLL_CNTL5		0x334
 #define HHI_HDMI_PLL_CNTL6		0x338
+#define HHI_MIPI_CSI_PHY_CLK_CNTL	0x340 /* 0xd0 offset in data sheet */
 #define HHI_SPICC_CLK_CNTL		0x3dc
 #define HHI_SYS1_PLL_CNTL0		0x380
 #define HHI_SYS1_PLL_CNTL1		0x384
@@ -264,8 +267,9 @@
 #define CLKID_NNA_AXI_CLK_DIV			263
 #define CLKID_NNA_CORE_CLK_SEL			265
 #define CLKID_NNA_CORE_CLK_DIV			266
+#define CLKID_MIPI_DSI_PXCLK_DIV		268
 
-#define NR_CLKS					268
+#define NR_CLKS					286
 
 /* include the CLKIDs that have been made part of the DT binding */
 #include <dt-bindings/clock/g12a-clkc.h>
diff -Naur a/drivers/clk/meson/g12a-vcodec-clk.c b/drivers/clk/meson/g12a-vcodec-clk.c
--- a/drivers/clk/meson/g12a-vcodec-clk.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/clk/meson/g12a-vcodec-clk.c	2022-05-31 11:56:47.725259396 +0800
@@ -0,0 +1,624 @@
+/*
+ * drivers/amlogic/clk/g12a/g12a_clk_media.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+
+#include "g12a.h"
+#include "clk-mux.h"
+#include "g12a-vcodec-clk.h"
+
+
+extern spinlock_t meson_clk_lock;
+
+
+const char *g12a_dec_parent_names[] = { "fclk_div2p5", "fclk_div3",
+	"fclk_div4", "fclk_div5", "fclk_div7", "hifi_pll", "gp0_pll", "xtal"};
+
+/* cts_vdec_clk */
+static struct clk_mux vdec_p0_mux = {
+	.reg = (void *)HHI_VDEC_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 9,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_p0_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = g12a_dec_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider vdec_p0_div = {
+	.reg = (void *)HHI_VDEC_CLK_CNTL,
+	.shift = 0,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_p0_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "vdec_p0_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate vdec_p0_gate = {
+	.reg = (void *)HHI_VDEC_CLK_CNTL,
+	.bit_idx = 8,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdec_p0_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "vdec_p0_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux vdec_p1_mux = {
+	.reg = (void *)HHI_VDEC3_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 9,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_p1_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = g12a_dec_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider vdec_p1_div = {
+	.reg = (void *)HHI_VDEC3_CLK_CNTL,
+	.shift = 0,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_p1_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "vdec_p1_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate vdec_p1_gate = {
+	.reg = (void *)HHI_VDEC3_CLK_CNTL,
+	.bit_idx = 8,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "vdec_p1_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "vdec_p1_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux vdec_mux = {
+	.reg = (void *)HHI_VDEC3_CLK_CNTL,
+	.mask = 0x1,
+	.shift = 15,
+	.lock = &meson_clk_lock,
+	.flags = CLK_PARENT_ALTERNATE,
+	.hw.init = &(struct clk_init_data){
+		.name = "vdec_mux",
+		.ops = &meson_clk_mux_ops,
+		.parent_names = (const char *[]){ "vdec_p0_composite",
+			"vdec_p1_composite"},
+		.num_parents = 2,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+/* cts_hcodec_clk */
+static struct clk_mux hcodec_p0_mux = {
+	.reg = (void *)HHI_VDEC_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 25,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hcodec_p0_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = g12a_dec_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider hcodec_p0_div = {
+	.reg = (void *)HHI_VDEC_CLK_CNTL,
+	.shift = 16,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hcodec_p0_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "hcodec_p0_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate hcodec_p0_gate = {
+	.reg = (void *)HHI_VDEC_CLK_CNTL,
+	.bit_idx = 24,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "hcodec_p0_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "hcodec_p0_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux hcodec_p1_mux = {
+	.reg = (void *)HHI_VDEC3_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 25,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hcodec_p1_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = g12a_dec_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider hcodec_p1_div = {
+	.reg = (void *)HHI_VDEC3_CLK_CNTL,
+	.shift = 16,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hcodec_p1_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "hcodec_p1_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate hcodec_p1_gate = {
+	.reg = (void *)HHI_VDEC3_CLK_CNTL,
+	.bit_idx = 24,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "hcodec_p1_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "hcodec_p1_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux hcodec_mux = {
+	.reg = (void *)HHI_VDEC3_CLK_CNTL,
+	.mask = 0x1,
+	.shift = 31,
+	.lock = &meson_clk_lock,
+	.flags = CLK_PARENT_ALTERNATE,
+	.hw.init = &(struct clk_init_data){
+		.name = "hcodec_mux",
+		.ops = &meson_clk_mux_ops,
+		.parent_names = (const char *[]){ "hcodec_p0_composite",
+			"hcodec_p1_composite"},
+		.num_parents = 2,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+/* cts_hevcb_clk */
+static struct clk_mux hevc_p0_mux = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 25,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevc_p0_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = g12a_dec_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider hevc_p0_div = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.shift = 16,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevc_p0_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "hevc_p0_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate hevc_p0_gate = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.bit_idx = 24,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevc_p0_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "hevc_p0_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux hevc_p1_mux = {
+	.reg = (void *)HHI_VDEC4_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 25,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevc_p1_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = g12a_dec_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider hevc_p1_div = {
+	.reg = (void *)HHI_VDEC4_CLK_CNTL,
+	.shift = 16,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevc_p1_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "hevc_p1_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate hevc_p1_gate = {
+	.reg = (void *)HHI_VDEC4_CLK_CNTL,
+	.bit_idx = 24,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevc_p1_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "hevc_p1_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux hevc_mux = {
+	.reg = (void *)HHI_VDEC4_CLK_CNTL,
+	.mask = 0x1,
+	.shift = 31,
+	.lock = &meson_clk_lock,
+	.flags = CLK_PARENT_ALTERNATE,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevc_mux",
+		.ops = &meson_clk_mux_ops,
+		.parent_names = (const char *[]){ "hevc_p0_composite",
+			"hevc_p1_composite"},
+		.num_parents = 2,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+/* cts_hevcf_clk */
+static struct clk_mux hevcf_p0_mux = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 9,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcf_p0_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = g12a_dec_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider hevcf_p0_div = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.shift = 0,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcf_p0_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "hevcf_p0_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate hevcf_p0_gate = {
+	.reg = (void *)HHI_VDEC2_CLK_CNTL,
+	.bit_idx = 8,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcf_p0_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "hevcf_p0_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux hevcf_p1_mux = {
+	.reg = (void *)HHI_VDEC4_CLK_CNTL,
+	.mask = 0x7,
+	.shift = 9,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcf_p1_mux",
+		.ops = &clk_mux_ops,
+		.parent_names = g12a_dec_parent_names,
+		.num_parents = 8,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_divider hevcf_p1_div = {
+	.reg = (void *)HHI_VDEC4_CLK_CNTL,
+	.shift = 0,
+	.width = 7,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcf_p1_div",
+		.ops = &clk_divider_ops,
+		.parent_names = (const char *[]){ "hevcf_p1_mux" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_gate hevcf_p1_gate = {
+	.reg = (void *)HHI_VDEC4_CLK_CNTL,
+	.bit_idx = 8,
+	.lock = &meson_clk_lock,
+	.hw.init = &(struct clk_init_data) {
+		.name = "hevcf_p1_gate",
+		.ops = &clk_gate_ops,
+		.parent_names = (const char *[]){ "hevcf_p1_div" },
+		.num_parents = 1,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+static struct clk_mux hevcf_mux = {
+	.reg = (void *)HHI_VDEC4_CLK_CNTL,
+	.mask = 0x1,
+	.shift = 15,
+	.lock = &meson_clk_lock,
+	.flags = CLK_PARENT_ALTERNATE,
+	.hw.init = &(struct clk_init_data){
+		.name = "hevcf_mux",
+		.ops = &meson_clk_mux_ops,
+		.parent_names = (const char *[]){ "hevcf_p0_composite",
+			"hevcf_p1_composite"},
+		.num_parents = 2,
+		.flags = CLK_GET_RATE_NOCACHE,
+	},
+};
+
+void meson_g12a_vcodec_init(struct clk_hw **clk_hws, void __iomem *clk_base)
+{
+	/* cts_vdec_clk */
+	vdec_p0_mux.reg = clk_base + (unsigned long)(vdec_p0_mux.reg);
+	vdec_p0_div.reg = clk_base + (unsigned long)(vdec_p0_div.reg);
+	vdec_p0_gate.reg = clk_base + (unsigned long)(vdec_p0_gate.reg);
+	vdec_p1_mux.reg = clk_base + (unsigned long)(vdec_p1_mux.reg);
+	vdec_p1_div.reg = clk_base + (unsigned long)(vdec_p1_div.reg);
+	vdec_p1_gate.reg = clk_base + (unsigned long)(vdec_p1_gate.reg);
+	vdec_mux.reg = clk_base + (unsigned long)(vdec_mux.reg);
+
+	/* cts_hcodec_clk */
+	hcodec_p0_mux.reg = clk_base + (unsigned long)(hcodec_p0_mux.reg);
+	hcodec_p0_div.reg = clk_base + (unsigned long)(hcodec_p0_div.reg);
+	hcodec_p0_gate.reg = clk_base + (unsigned long)(hcodec_p0_gate.reg);
+	hcodec_p1_mux.reg = clk_base + (unsigned long)(hcodec_p1_mux.reg);
+	hcodec_p1_div.reg = clk_base + (unsigned long)(hcodec_p1_div.reg);
+	hcodec_p1_gate.reg = clk_base + (unsigned long)(hcodec_p1_gate.reg);
+	hcodec_mux.reg = clk_base + (unsigned long)(hcodec_mux.reg);
+
+	/* cts_hevc_clk */
+	hevc_p0_mux.reg = clk_base + (unsigned long)(hevc_p0_mux.reg);
+	hevc_p0_div.reg = clk_base + (unsigned long)(hevc_p0_div.reg);
+	hevc_p0_gate.reg = clk_base + (unsigned long)(hevc_p0_gate.reg);
+	hevc_p1_mux.reg = clk_base + (unsigned long)(hevc_p1_mux.reg);
+	hevc_p1_div.reg = clk_base + (unsigned long)(hevc_p1_div.reg);
+	hevc_p1_gate.reg = clk_base + (unsigned long)(hevc_p1_gate.reg);
+	hevc_mux.reg = clk_base + (unsigned long)(hevc_mux.reg);
+
+	/* cts_hevcf_clk */
+	hevcf_p0_mux.reg = clk_base + (unsigned long)(hevcf_p0_mux.reg);
+	hevcf_p0_div.reg = clk_base + (unsigned long)(hevcf_p0_div.reg);
+	hevcf_p0_gate.reg = clk_base + (unsigned long)(hevcf_p0_gate.reg);
+	hevcf_p1_mux.reg = clk_base + (unsigned long)(hevcf_p1_mux.reg);
+	hevcf_p1_div.reg = clk_base + (unsigned long)(hevcf_p1_div.reg);
+	hevcf_p1_gate.reg = clk_base + (unsigned long)(hevcf_p1_gate.reg);
+	hevcf_mux.reg = clk_base + (unsigned long)(hevcf_mux.reg);
+
+	/* cts_vdec_clk */
+	clk_hws[CLKID_VDEC_P0_COMP] = clk_hw_register_composite(NULL,
+		"vdec_p0_composite",
+		g12a_dec_parent_names, 8,
+		&vdec_p0_mux.hw,
+		&clk_mux_ops,
+		&vdec_p0_div.hw,
+		&clk_divider_ops,
+		&vdec_p0_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(clk_hws[CLKID_VDEC_P0_COMP]))
+		panic("%s: %d clk_hw_register_composite vdec_p0_composite error\n",
+			__func__, __LINE__);
+
+	clk_hws[CLKID_VDEC_P1_COMP] = clk_hw_register_composite(NULL,
+		"vdec_p1_composite",
+		g12a_dec_parent_names, 8,
+		&vdec_p1_mux.hw,
+		&clk_mux_ops,
+		&vdec_p1_div.hw,
+		&clk_divider_ops,
+		&vdec_p1_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(clk_hws[CLKID_VDEC_P1_COMP]))
+		panic("%s: %d clk_hw_register_composite vdec_p1_composite error\n",
+			__func__, __LINE__);
+
+	if (clk_hw_register(NULL, &vdec_mux.hw)) {
+		panic("%s: %d clk_hw_register vdec_mux error\n",
+			__func__, __LINE__);
+	} else {
+		clk_hws[CLKID_VDEC_MUX] = &vdec_mux.hw;
+	}
+	
+	if (IS_ERR(clk_hws[CLKID_VDEC_MUX]))
+		panic("%s: %d clk_hw_register vdec_mux error\n",
+			__func__, __LINE__);
+
+	/* cts_hcodec_clk */
+	clk_hws[CLKID_HCODEC_P0_COMP] = clk_hw_register_composite(NULL,
+		"hcodec_p0_composite",
+		g12a_dec_parent_names, 8,
+		&hcodec_p0_mux.hw,
+		&clk_mux_ops,
+		&hcodec_p0_div.hw,
+		&clk_divider_ops,
+		&hcodec_p0_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(clk_hws[CLKID_HCODEC_P0_COMP]))
+		panic("%s: %d clk_hw_register_composite hcodec_p0_composite error\n",
+			__func__, __LINE__);
+
+	clk_hws[CLKID_HCODEC_P1_COMP] = clk_hw_register_composite(NULL,
+		"hcodec_p1_composite",
+		g12a_dec_parent_names, 8,
+		&hcodec_p1_mux.hw,
+		&clk_mux_ops,
+		&hcodec_p1_div.hw,
+		&clk_divider_ops,
+		&hcodec_p1_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(clk_hws[CLKID_HCODEC_P1_COMP]))
+		panic("%s: %d clk_hw_register_composite hcodec_p1_composite error\n",
+		__func__, __LINE__);
+
+	if (clk_hw_register(NULL, &hcodec_mux.hw)) {
+		panic("%s: %d clk_hw_register hcodec_mux error\n",
+			__func__, __LINE__);
+	} else {
+		clk_hws[CLKID_HCODEC_MUX] = &hcodec_mux.hw;
+	}
+	
+	if (IS_ERR(clk_hws[CLKID_HCODEC_MUX]))
+		panic("%s: %d clk_hw_register hcodec_mux error\n",
+			__func__, __LINE__);
+
+	/* cts_hevc_clk */
+	clk_hws[CLKID_HEVC_P0_COMP] = clk_hw_register_composite(NULL,
+		"hevc_p0_composite",
+		g12a_dec_parent_names, 8,
+		&hevc_p0_mux.hw,
+		&clk_mux_ops,
+		&hevc_p0_div.hw,
+		&clk_divider_ops,
+		&hevc_p0_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(clk_hws[CLKID_HEVC_P0_COMP]))
+		panic("%s: %d clk_hw_register_composite hevc_p0_composite error\n",
+			__func__, __LINE__);
+
+	clk_hws[CLKID_HEVC_P1_COMP] = clk_hw_register_composite(NULL,
+		"hevc_p1_composite",
+		g12a_dec_parent_names, 8,
+		&hevc_p1_mux.hw,
+		&clk_mux_ops,
+		&hevc_p1_div.hw,
+		&clk_divider_ops,
+		&hevc_p1_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(clk_hws[CLKID_HEVC_P1_COMP]))
+		panic("%s: %d clk_hw_register_composite hevc_p1_composite error\n",
+		__func__, __LINE__);
+
+	if (clk_hw_register(NULL, &hevc_mux.hw)) {
+		panic("%s: %d clk_hw_register hcodec_mux error\n",
+			__func__, __LINE__);
+	} else {
+		clk_hws[CLKID_HEVC_MUX] = &hevc_mux.hw;
+	}
+	
+	if (IS_ERR(clk_hws[CLKID_HEVC_MUX]))
+		panic("%s: %d clk_hw_register hevc_mux error\n",
+			__func__, __LINE__);
+
+	/* cts_hevcf_clk */
+	clk_hws[CLKID_HEVCF_P0_COMP] = clk_hw_register_composite(NULL,
+		"hevcf_p0_composite",
+		g12a_dec_parent_names, 8,
+		 &hevcf_p0_mux.hw,
+		&clk_mux_ops,
+		&hevcf_p0_div.hw,
+		&clk_divider_ops,
+		&hevcf_p0_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(clk_hws[CLKID_HEVCF_P0_COMP]))
+		panic("%s: %d clk_hw_register_composite hevcf_p0_composite error\n",
+			__func__, __LINE__);
+
+	clk_hws[CLKID_HEVCF_P1_COMP] = clk_hw_register_composite(NULL,
+		"hevcf_p1_composite",
+		g12a_dec_parent_names, 8,
+		&hevcf_p1_mux.hw,
+		&clk_mux_ops,
+		&hevcf_p1_div.hw,
+		&clk_divider_ops,
+		&hevcf_p1_gate.hw,
+		&clk_gate_ops, 0);
+	if (IS_ERR(clk_hws[CLKID_HEVCF_P1_COMP]))
+		panic("%s: %d clk_hw_register_composite hevcf_p1_composite error\n",
+		__func__, __LINE__);
+
+	if (clk_hw_register(NULL, &hevcf_mux.hw)) {
+		panic("%s: %d clk_hw_register hevcf_mux error\n",
+			__func__, __LINE__);
+	} else {
+		clk_hws[CLKID_HEVCF_MUX] = &hevcf_mux.hw;
+	}
+	
+	if (IS_ERR(clk_hws[CLKID_HEVCF_MUX]))
+		panic("%s: %d clk_hw_register hevcf_mux error\n",
+			__func__, __LINE__);
+
+	pr_info("%s: register meson media clk\n", __func__);
+}
+
diff -Naur a/drivers/clk/meson/g12a-vcodec-clk.h b/drivers/clk/meson/g12a-vcodec-clk.h
--- a/drivers/clk/meson/g12a-vcodec-clk.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/clk/meson/g12a-vcodec-clk.h	2022-05-31 11:56:47.725259396 +0800
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#ifndef __G12A_VCODEC_CLK_H
+#define __G12A_VCODEC_CLK_H
+
+extern void meson_g12a_vcodec_init(struct clk_hw **clks, void __iomem *clk_base);
+
+#endif /* __G12A_VCODEC_CLK_H */
diff -Naur a/drivers/clk/meson/Makefile b/drivers/clk/meson/Makefile
--- a/drivers/clk/meson/Makefile	2022-05-27 17:20:14.749890137 +0800
+++ b/drivers/clk/meson/Makefile	2022-05-31 11:56:47.725259396 +0800
@@ -7,7 +7,7 @@
 obj-$(CONFIG_COMMON_CLK_MESON_EE_CLKC) += meson-eeclk.o
 obj-$(CONFIG_COMMON_CLK_MESON_MPLL) += clk-mpll.o
 obj-$(CONFIG_COMMON_CLK_MESON_PHASE) += clk-phase.o
-obj-$(CONFIG_COMMON_CLK_MESON_PLL) += clk-pll.o
+obj-$(CONFIG_COMMON_CLK_MESON_PLL) += clk-pll.o clk-mux.o
 obj-$(CONFIG_COMMON_CLK_MESON_REGMAP) += clk-regmap.o
 obj-$(CONFIG_COMMON_CLK_MESON_SCLK_DIV) += sclk-div.o
 obj-$(CONFIG_COMMON_CLK_MESON_VID_PLL_DIV) += vid-pll-div.o
@@ -17,5 +17,5 @@
 obj-$(CONFIG_COMMON_CLK_AXG) += axg.o axg-aoclk.o
 obj-$(CONFIG_COMMON_CLK_AXG_AUDIO) += axg-audio.o
 obj-$(CONFIG_COMMON_CLK_GXBB) += gxbb.o gxbb-aoclk.o
-obj-$(CONFIG_COMMON_CLK_G12A) += g12a.o g12a-aoclk.o
+obj-$(CONFIG_COMMON_CLK_G12A) += g12a.o g12a-aoclk.o g12a-vcodec-clk.o
 obj-$(CONFIG_COMMON_CLK_MESON8B) += meson8b.o meson8-ddr.o
diff -Naur a/drivers/clk/meson/vid-pll-div.c b/drivers/clk/meson/vid-pll-div.c
--- a/drivers/clk/meson/vid-pll-div.c	2022-05-27 17:20:14.753890189 +0800
+++ b/drivers/clk/meson/vid-pll-div.c	2022-05-31 11:56:47.725259396 +0800
@@ -39,12 +39,14 @@
 	}
 
 static const struct vid_pll_div vid_pll_div_table[] = {
+	VID_PLL_DIV(0xffff, 0, 1, 1),	/* 1/1  => /1 */
 	VID_PLL_DIV(0x0aaa, 0, 2, 1),	/* 2/1  => /2 */
 	VID_PLL_DIV(0x5294, 2, 5, 2),	/* 5/2  => /2.5 */
 	VID_PLL_DIV(0x0db6, 0, 3, 1),	/* 3/1  => /3 */
 	VID_PLL_DIV(0x36cc, 1, 7, 2),	/* 7/2  => /3.5 */
 	VID_PLL_DIV(0x6666, 2, 15, 4),	/* 15/4 => /3.75 */
 	VID_PLL_DIV(0x0ccc, 0, 4, 1),	/* 4/1  => /4 */
+	VID_PLL_DIV(0x0ccc, 1, 467, 100), /* 467/100  => /4.67 */
 	VID_PLL_DIV(0x739c, 2, 5, 1),	/* 5/1  => /5 */
 	VID_PLL_DIV(0x0e38, 0, 6, 1),	/* 6/1  => /6 */
 	VID_PLL_DIV(0x0000, 3, 25, 4),	/* 25/4 => /6.25 */
diff -Naur a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c
--- a/drivers/edac/sb_edac.c	2022-06-29 08:47:07.171383478 +0800
+++ b/drivers/edac/sb_edac.c	2022-05-27 17:20:14.881891840 +0800
@@ -1052,7 +1052,7 @@
 	pci_read_config_dword(pvt->info.pci_vtd, HASWELL_TOHM_1, &reg);
 	rc = ((reg << 6) | rc) << 26;
 
-	return rc | 0x3ffffff;
+	return rc | 0x1ffffff;
 }
 
 static u64 knl_get_tolm(struct sbridge_pvt *pvt)
diff -Naur a/drivers/firmware/efi/libstub/arm64-stub.c b/drivers/firmware/efi/libstub/arm64-stub.c
--- a/drivers/firmware/efi/libstub/arm64-stub.c	2022-05-27 17:20:14.893891994 +0800
+++ b/drivers/firmware/efi/libstub/arm64-stub.c	2022-05-31 11:56:47.725259396 +0800
@@ -125,7 +125,7 @@
 
 	kernel_size = _edata - _text;
 	kernel_memsize = kernel_size + (_end - _edata);
-	*reserve_size = kernel_memsize;
+	*reserve_size = kernel_memsize + + TEXT_OFFSET % min_kimg_align;
 
 	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE) && phys_seed != 0) {
 		/*
@@ -141,7 +141,7 @@
 	if (status != EFI_SUCCESS) {
 		if (!check_image_region((u64)_text, kernel_memsize)) {
 			efi_err("FIRMWARE BUG: Image BSS overlaps adjacent EFI memory region\n");
-		} else if (IS_ALIGNED((u64)_text, min_kimg_align)) {
+		} else if (IS_ALIGNED((u64)_text - TEXT_OFFSET, min_kimg_align)) {
 			/*
 			 * Just execute from wherever we were loaded by the
 			 * UEFI PE/COFF loader if the alignment is suitable.
@@ -161,7 +161,7 @@
 		}
 	}
 
-	*image_addr = *reserve_addr;
+	*image_addr = *reserve_addr + TEXT_OFFSET % min_kimg_align;
 	memcpy((void *)*image_addr, _text, kernel_size);
 
 	return EFI_SUCCESS;
diff -Naur a/drivers/firmware/efi/libstub/Makefile b/drivers/firmware/efi/libstub/Makefile
--- a/drivers/firmware/efi/libstub/Makefile	2022-05-27 17:20:14.893891994 +0800
+++ b/drivers/firmware/efi/libstub/Makefile	2022-05-31 11:56:47.725259396 +0800
@@ -69,6 +69,7 @@
 lib-$(CONFIG_X86)		+= x86-stub.o
 lib-$(CONFIG_RISCV)		+= riscv-stub.o
 CFLAGS_arm32-stub.o		:= -DTEXT_OFFSET=$(TEXT_OFFSET)
+CFLAGS_arm64-stub.o		:= -DTEXT_OFFSET=$(TEXT_OFFSET)
 
 # Even when -mbranch-protection=none is set, Clang will generate a
 # .note.gnu.property for code-less object files (like lib/ctype.c),
diff -Naur a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c	2022-05-27 17:20:15.513899992 +0800
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-ahb-audio.c	2022-05-31 11:56:47.725259396 +0800
@@ -320,13 +320,17 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct snd_dw_hdmi *dw = substream->private_data;
 	void __iomem *base = dw->data.base;
+	u8 *eld;
 	int ret;
 
 	runtime->hw = dw_hdmi_hw;
 
-	ret = snd_pcm_hw_constraint_eld(runtime, dw->data.eld);
-	if (ret < 0)
-		return ret;
+	eld = dw->data.get_eld(dw->data.hdmi);
+	if (eld) {
+		ret = snd_pcm_hw_constraint_eld(runtime, eld);
+		if (ret < 0)
+			return ret;
+	}
 
 	ret = snd_pcm_limit_hw_rates(runtime);
 	if (ret < 0)
diff -Naur a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-audio.h b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-audio.h
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-audio.h	2022-05-27 17:20:15.513899992 +0800
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-audio.h	2022-05-31 11:56:47.725259396 +0800
@@ -9,15 +9,15 @@
 	void __iomem *base;
 	int irq;
 	struct dw_hdmi *hdmi;
-	u8 *eld;
+	u8 *(*get_eld)(struct dw_hdmi *hdmi);
 };
 
 struct dw_hdmi_i2s_audio_data {
 	struct dw_hdmi *hdmi;
-	u8 *eld;
 
 	void (*write)(struct dw_hdmi *hdmi, u8 val, int offset);
 	u8 (*read)(struct dw_hdmi *hdmi, int offset);
+	u8 *(*get_eld)(struct dw_hdmi *hdmi);
 };
 
 #endif
diff -Naur a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c	2022-05-27 17:20:15.513899992 +0800
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c	2022-05-31 11:56:47.729259361 +0800
@@ -143,6 +143,7 @@
 struct dw_hdmi {
 	struct drm_connector connector;
 	struct drm_bridge bridge;
+	struct drm_bridge *next_bridge;
 
 	unsigned int version;
 
@@ -754,6 +755,19 @@
 	else
 		hdmi->mc_clkdis |= HDMI_MC_CLKDIS_AUDCLK_DISABLE;
 	hdmi_writeb(hdmi, hdmi->mc_clkdis, HDMI_MC_CLKDIS);
+
+	 if (enable) {
+		hdmi_set_cts_n(hdmi, hdmi->audio_cts, 0);
+		hdmi_set_cts_n(hdmi, hdmi->audio_cts, hdmi->audio_n);
+	}
+}
+
+static u8 *hdmi_audio_get_eld(struct dw_hdmi *hdmi)
+{
+	if (!hdmi->curr_conn)
+		return NULL;
+
+	return hdmi->curr_conn->eld;
 }
 
 static void dw_hdmi_ahb_audio_enable(struct dw_hdmi *hdmi)
@@ -2395,21 +2409,6 @@
 	return ret;
 }
 
-static bool hdr_metadata_equal(const struct drm_connector_state *old_state,
-			       const struct drm_connector_state *new_state)
-{
-	struct drm_property_blob *old_blob = old_state->hdr_output_metadata;
-	struct drm_property_blob *new_blob = new_state->hdr_output_metadata;
-
-	if (!old_blob || !new_blob)
-		return old_blob == new_blob;
-
-	if (old_blob->length != new_blob->length)
-		return false;
-
-	return !memcmp(old_blob->data, new_blob->data, old_blob->length);
-}
-
 static int dw_hdmi_connector_atomic_check(struct drm_connector *connector,
 					  struct drm_atomic_state *state)
 {
@@ -2423,7 +2422,7 @@
 	if (!crtc)
 		return 0;
 
-	if (!hdr_metadata_equal(old_state, new_state)) {
+	if (!drm_connector_atomic_hdr_metadata_equal(old_state, new_state)) {
 		crtc_state = drm_atomic_get_crtc_state(state, crtc);
 		if (IS_ERR(crtc_state))
 			return PTR_ERR(crtc_state);
@@ -2492,8 +2491,7 @@
 	drm_connector_attach_max_bpc_property(connector, 8, 16);
 
 	if (hdmi->version >= 0x200a && hdmi->plat_data->use_drm_infoframe)
-		drm_object_attach_property(&connector->base,
-			connector->dev->mode_config.hdr_output_metadata_property, 0);
+		drm_connector_attach_hdr_output_metadata_property(connector);
 
 	drm_connector_attach_encoder(connector, hdmi->bridge.encoder);
 
@@ -2791,7 +2789,8 @@
 	struct dw_hdmi *hdmi = bridge->driver_private;
 
 	if (flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)
-		return 0;
+		return drm_bridge_attach(bridge->encoder, hdmi->next_bridge,
+					 bridge, flags);
 
 	return dw_hdmi_connector_create(hdmi);
 }
@@ -3176,6 +3175,52 @@
 /* -----------------------------------------------------------------------------
  * Probe/remove API, used from platforms based on the DRM bridge API.
  */
+
+static int dw_hdmi_parse_dt(struct dw_hdmi *hdmi)
+{
+	struct device_node *endpoint;
+	struct device_node *remote;
+
+	if (!hdmi->plat_data->output_port)
+		return 0;
+
+	endpoint = of_graph_get_endpoint_by_regs(hdmi->dev->of_node,
+						 hdmi->plat_data->output_port,
+						 -1);
+	if (!endpoint) {
+		/*
+		 * On platforms whose bindings don't make the output port
+		 * mandatory (such as Rockchip) the plat_data->output_port
+		 * field isn't set, so it's safe to make this a fatal error.
+		 */
+		dev_err(hdmi->dev, "Missing endpoint in port@%u\n",
+			hdmi->plat_data->output_port);
+		return -ENODEV;
+	}
+
+	remote = of_graph_get_remote_port_parent(endpoint);
+	of_node_put(endpoint);
+	if (!remote) {
+		dev_err(hdmi->dev, "Endpoint in port@%u unconnected\n",
+			hdmi->plat_data->output_port);
+		return -ENODEV;
+	}
+
+	if (!of_device_is_available(remote)) {
+		dev_err(hdmi->dev, "port@%u remote device is disabled\n",
+			hdmi->plat_data->output_port);
+		of_node_put(remote);
+		return -ENODEV;
+	}
+
+	hdmi->next_bridge = of_drm_find_bridge(remote);
+	of_node_put(remote);
+	if (!hdmi->next_bridge)
+		return -EPROBE_DEFER;
+
+	return 0;
+}
+
 struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
 			      const struct dw_hdmi_plat_data *plat_data)
 {
@@ -3212,6 +3257,10 @@
 	mutex_init(&hdmi->cec_notifier_mutex);
 	spin_lock_init(&hdmi->audio_lock);
 
+	ret = dw_hdmi_parse_dt(hdmi);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
 	ddc_node = of_parse_phandle(np, "ddc-i2c-bus", 0);
 	if (ddc_node) {
 		hdmi->ddc = of_get_i2c_adapter_by_node(ddc_node);
@@ -3377,6 +3426,7 @@
 	hdmi->bridge.funcs = &dw_hdmi_bridge_funcs;
 	hdmi->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID
 			 | DRM_BRIDGE_OP_HPD;
+	hdmi->bridge.interlace_allowed = true;
 #ifdef CONFIG_OF
 	hdmi->bridge.of_node = pdev->dev.of_node;
 #endif
@@ -3395,7 +3445,7 @@
 		audio.base = hdmi->regs;
 		audio.irq = irq;
 		audio.hdmi = hdmi;
-		audio.eld = hdmi->connector.eld;
+		audio.get_eld = hdmi_audio_get_eld;
 		hdmi->enable_audio = dw_hdmi_ahb_audio_enable;
 		hdmi->disable_audio = dw_hdmi_ahb_audio_disable;
 
@@ -3408,7 +3458,7 @@
 		struct dw_hdmi_i2s_audio_data audio;
 
 		audio.hdmi	= hdmi;
-		audio.eld	= hdmi->connector.eld;
+		audio.get_eld	= hdmi_audio_get_eld;
 		audio.write	= hdmi_writeb;
 		audio.read	= hdmi_readb;
 		hdmi->enable_audio = dw_hdmi_i2s_audio_enable;
@@ -3421,7 +3471,7 @@
 		hdmi->audio = platform_device_register_full(&pdevinfo);
 	}
 
-	if (config0 & HDMI_CONFIG0_CEC) {
+	if (!plat_data->disable_cec && (config0 & HDMI_CONFIG0_CEC)) {
 		cec.hdmi = hdmi;
 		cec.ops = &dw_hdmi_cec_ops;
 		cec.irq = irq;
@@ -3440,8 +3490,7 @@
 
 err_iahb:
 	clk_disable_unprepare(hdmi->iahb_clk);
-	if (hdmi->cec_clk)
-		clk_disable_unprepare(hdmi->cec_clk);
+	clk_disable_unprepare(hdmi->cec_clk);
 err_isfr:
 	clk_disable_unprepare(hdmi->isfr_clk);
 err_res:
@@ -3465,8 +3514,7 @@
 
 	clk_disable_unprepare(hdmi->iahb_clk);
 	clk_disable_unprepare(hdmi->isfr_clk);
-	if (hdmi->cec_clk)
-		clk_disable_unprepare(hdmi->cec_clk);
+	clk_disable_unprepare(hdmi->cec_clk);
 
 	if (hdmi->i2c)
 		i2c_del_adapter(&hdmi->i2c->adap);
diff -Naur a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-cec.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-cec.c
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-cec.c	2022-05-27 17:20:15.513899992 +0800
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-cec.c	2022-05-31 11:56:47.729259361 +0800
@@ -265,11 +265,9 @@
 	/* override the module pointer */
 	cec->adap->owner = THIS_MODULE;
 
-	ret = devm_add_action(&pdev->dev, dw_hdmi_cec_del, cec);
-	if (ret) {
-		cec_delete_adapter(cec->adap);
+	ret = devm_add_action_or_reset(&pdev->dev, dw_hdmi_cec_del, cec);
+	if (ret)
 		return ret;
-	}
 
 	ret = devm_request_threaded_irq(&pdev->dev, cec->irq,
 					dw_hdmi_cec_hardirq,
diff -Naur a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c	2022-05-27 17:20:15.513899992 +0800
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi-i2s-audio.c	2022-05-31 11:56:47.729259361 +0800
@@ -135,8 +135,15 @@
 			       size_t len)
 {
 	struct dw_hdmi_i2s_audio_data *audio = data;
+	u8 *eld;
+
+	eld = audio->get_eld(audio->hdmi);
+	if (eld)
+		memcpy(buf, eld, min_t(size_t, MAX_ELD_BYTES, len));
+	else
+		/* Pass en empty ELD if connector not available */
+		memset(buf, 0, len);
 
-	memcpy(buf, audio->eld, min_t(size_t, MAX_ELD_BYTES, len));
 	return 0;
 }
 
@@ -170,7 +177,7 @@
 	return dw_hdmi_set_plugged_cb(hdmi, fn, codec_dev);
 }
 
-static struct hdmi_codec_ops dw_hdmi_i2s_ops = {
+static const struct hdmi_codec_ops dw_hdmi_i2s_ops = {
 	.hw_params	= dw_hdmi_i2s_hw_params,
 	.audio_startup  = dw_hdmi_i2s_audio_startup,
 	.audio_shutdown	= dw_hdmi_i2s_audio_shutdown,
diff -Naur a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c
--- a/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c	2022-05-27 17:20:15.513899992 +0800
+++ b/drivers/gpu/drm/bridge/synopsys/dw-mipi-dsi.c	2022-05-31 11:56:47.729259361 +0800
@@ -246,6 +246,7 @@
 
 	struct clk *pclk;
 
+	bool device_found;
 	unsigned int lane_mbps; /* per lane */
 	u32 channel;
 	u32 lanes;
@@ -309,13 +310,37 @@
 	return readl(dsi->base + reg);
 }
 
+static int dw_mipi_dsi_panel_or_bridge(struct dw_mipi_dsi *dsi,
+				       struct device_node *node)
+{
+	struct drm_bridge *bridge;
+	struct drm_panel *panel;
+	int ret;
+
+	ret = drm_of_find_panel_or_bridge(node, 1, 0, &panel, &bridge);
+	if (ret)
+		return ret;
+
+	if (panel) {
+		bridge = drm_panel_bridge_add_typed(panel,
+						    DRM_MODE_CONNECTOR_DSI);
+		if (IS_ERR(bridge))
+			return PTR_ERR(bridge);
+	}
+
+	dsi->panel_bridge = bridge;
+
+	if (!dsi->panel_bridge)
+		return -EPROBE_DEFER;
+
+	return 0;
+}
+
 static int dw_mipi_dsi_host_attach(struct mipi_dsi_host *host,
 				   struct mipi_dsi_device *device)
 {
 	struct dw_mipi_dsi *dsi = host_to_dsi(host);
 	const struct dw_mipi_dsi_plat_data *pdata = dsi->plat_data;
-	struct drm_bridge *bridge;
-	struct drm_panel *panel;
 	int ret;
 
 	if (device->lanes > dsi->plat_data->max_data_lanes) {
@@ -329,22 +354,14 @@
 	dsi->format = device->format;
 	dsi->mode_flags = device->mode_flags;
 
-	ret = drm_of_find_panel_or_bridge(host->dev->of_node, 1, 0,
-					  &panel, &bridge);
-	if (ret)
-		return ret;
+	if (!dsi->device_found) {
+		ret = dw_mipi_dsi_panel_or_bridge(dsi, host->dev->of_node);
+		if (ret)
+			return ret;
 
-	if (panel) {
-		bridge = drm_panel_bridge_add_typed(panel,
-						    DRM_MODE_CONNECTOR_DSI);
-		if (IS_ERR(bridge))
-			return PTR_ERR(bridge);
+		dsi->device_found = true;
 	}
 
-	dsi->panel_bridge = bridge;
-
-	drm_bridge_add(&dsi->bridge);
-
 	if (pdata->host_ops && pdata->host_ops->attach) {
 		ret = pdata->host_ops->attach(pdata->priv_data, device);
 		if (ret < 0)
@@ -854,7 +871,8 @@
 	dsi_write(dsi, DSI_INT_MSK1, 0);
 }
 
-static void dw_mipi_dsi_bridge_post_disable(struct drm_bridge *bridge)
+static void dw_mipi_dsi_bridge_post_atomic_disable(struct drm_bridge *bridge,
+						   struct drm_bridge_state *old_bridge_state)
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 	const struct dw_mipi_dsi_phy_ops *phy_ops = dsi->plat_data->phy_ops;
@@ -961,7 +979,8 @@
 		dw_mipi_dsi_mode_set(dsi->slave, adjusted_mode);
 }
 
-static void dw_mipi_dsi_bridge_enable(struct drm_bridge *bridge)
+static void dw_mipi_dsi_bridge_atomic_enable(struct drm_bridge *bridge,
+					     struct drm_bridge_state *old_bridge_state)
 {
 	struct dw_mipi_dsi *dsi = bridge_to_dsi(bridge);
 
@@ -981,7 +1000,10 @@
 	enum drm_mode_status mode_status = MODE_OK;
 
 	if (pdata->mode_valid)
-		mode_status = pdata->mode_valid(pdata->priv_data, mode);
+		mode_status = pdata->mode_valid(pdata->priv_data, mode,
+						dsi->mode_flags,
+						dw_mipi_dsi_get_lanes(dsi),
+						dsi->format);
 
 	return mode_status;
 }
@@ -999,17 +1021,30 @@
 	/* Set the encoder type as caller does not know it */
 	bridge->encoder->encoder_type = DRM_MODE_ENCODER_DSI;
 
+	if (!dsi->device_found) {
+		int ret;
+
+		ret = dw_mipi_dsi_panel_or_bridge(dsi, dsi->dev->of_node);
+		if (ret)
+			return ret;
+
+		dsi->device_found = true;
+	}
+
 	/* Attach the panel-bridge to the dsi bridge */
 	return drm_bridge_attach(bridge->encoder, dsi->panel_bridge, bridge,
 				 flags);
 }
 
 static const struct drm_bridge_funcs dw_mipi_dsi_bridge_funcs = {
-	.mode_set     = dw_mipi_dsi_bridge_mode_set,
-	.enable	      = dw_mipi_dsi_bridge_enable,
-	.post_disable = dw_mipi_dsi_bridge_post_disable,
-	.mode_valid   = dw_mipi_dsi_bridge_mode_valid,
-	.attach	      = dw_mipi_dsi_bridge_attach,
+	.atomic_duplicate_state	= drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset		= drm_atomic_helper_bridge_reset,
+	.atomic_enable		= dw_mipi_dsi_bridge_atomic_enable,
+	.atomic_post_disable	= dw_mipi_dsi_bridge_post_atomic_disable,
+	.mode_set		= dw_mipi_dsi_bridge_mode_set,
+	.mode_valid		= dw_mipi_dsi_bridge_mode_valid,
+	.attach			= dw_mipi_dsi_bridge_attach,
 };
 
 #ifdef CONFIG_DEBUG_FS
@@ -1172,6 +1207,7 @@
 	ret = mipi_dsi_host_register(&dsi->dsi_host);
 	if (ret) {
 		dev_err(dev, "Failed to register MIPI host: %d\n", ret);
+		pm_runtime_disable(dev);
 		dw_mipi_dsi_debugfs_remove(dsi);
 		return ERR_PTR(ret);
 	}
@@ -1181,6 +1217,7 @@
 #ifdef CONFIG_OF
 	dsi->bridge.of_node = pdev->dev.of_node;
 #endif
+	drm_bridge_add(&dsi->bridge);
 
 	return dsi;
 }
@@ -1229,15 +1266,7 @@
  */
 int dw_mipi_dsi_bind(struct dw_mipi_dsi *dsi, struct drm_encoder *encoder)
 {
-	int ret;
-
-	ret = drm_bridge_attach(encoder, &dsi->bridge, NULL, 0);
-	if (ret) {
-		DRM_ERROR("Failed to initialize bridge with drm\n");
-		return ret;
-	}
-
-	return ret;
+	return drm_bridge_attach(encoder, &dsi->bridge, NULL, 0);
 }
 EXPORT_SYMBOL_GPL(dw_mipi_dsi_bind);
 
diff -Naur a/drivers/gpu/drm/drm_aperture.c b/drivers/gpu/drm/drm_aperture.c
--- a/drivers/gpu/drm/drm_aperture.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/drm_aperture.c	2022-05-31 11:56:47.729259361 +0800
@@ -0,0 +1,353 @@
+// SPDX-License-Identifier: MIT
+
+#include <linux/device.h>
+#include <linux/fb.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h> /* for firmware helpers */
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/vgaarb.h>
+
+#include <drm/drm_aperture.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_print.h>
+
+/**
+ * DOC: overview
+ *
+ * A graphics device might be supported by different drivers, but only one
+ * driver can be active at any given time. Many systems load a generic
+ * graphics drivers, such as EFI-GOP or VESA, early during the boot process.
+ * During later boot stages, they replace the generic driver with a dedicated,
+ * hardware-specific driver. To take over the device the dedicated driver
+ * first has to remove the generic driver. DRM aperture functions manage
+ * ownership of DRM framebuffer memory and hand-over between drivers.
+ *
+ * DRM drivers should call drm_aperture_remove_conflicting_framebuffers()
+ * at the top of their probe function. The function removes any generic
+ * driver that is currently associated with the given framebuffer memory.
+ * If the framebuffer is located at PCI BAR 0, the rsp code looks as in the
+ * example given below.
+ *
+ * .. code-block:: c
+ *
+ *	static const struct drm_driver example_driver = {
+ *		...
+ *	};
+ *
+ *	static int remove_conflicting_framebuffers(struct pci_dev *pdev)
+ *	{
+ *		bool primary = false;
+ *		resource_size_t base, size;
+ *		int ret;
+ *
+ *		base = pci_resource_start(pdev, 0);
+ *		size = pci_resource_len(pdev, 0);
+ *	#ifdef CONFIG_X86
+ *		primary = pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW;
+ *	#endif
+ *
+ *		return drm_aperture_remove_conflicting_framebuffers(base, size, primary,
+ *		                                                    &example_driver);
+ *	}
+ *
+ *	static int probe(struct pci_dev *pdev)
+ *	{
+ *		int ret;
+ *
+ *		// Remove any generic drivers...
+ *		ret = remove_conflicting_framebuffers(pdev);
+ *		if (ret)
+ *			return ret;
+ *
+ *		// ... and initialize the hardware.
+ *		...
+ *
+ *		drm_dev_register();
+ *
+ *		return 0;
+ *	}
+ *
+ * PCI device drivers should call
+ * drm_aperture_remove_conflicting_pci_framebuffers() and let it detect the
+ * framebuffer apertures automatically. Device drivers without knowledge of
+ * the framebuffer's location shall call drm_aperture_remove_framebuffers(),
+ * which removes all drivers for known framebuffer.
+ *
+ * Drivers that are susceptible to being removed by other drivers, such as
+ * generic EFI or VESA drivers, have to register themselves as owners of their
+ * given framebuffer memory. Ownership of the framebuffer memory is achieved
+ * by calling devm_aperture_acquire_from_firmware(). On success, the driver
+ * is the owner of the framebuffer range. The function fails if the
+ * framebuffer is already by another driver. See below for an example.
+ *
+ * .. code-block:: c
+ *
+ *	static int acquire_framebuffers(struct drm_device *dev, struct platform_device *pdev)
+ *	{
+ *		resource_size_t base, size;
+ *
+ *		mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+ *		if (!mem)
+ *			return -EINVAL;
+ *		base = mem->start;
+ *		size = resource_size(mem);
+ *
+ *		return devm_acquire_aperture_from_firmware(dev, base, size);
+ *	}
+ *
+ *	static int probe(struct platform_device *pdev)
+ *	{
+ *		struct drm_device *dev;
+ *		int ret;
+ *
+ *		// ... Initialize the device...
+ *		dev = devm_drm_dev_alloc();
+ *		...
+ *
+ *		// ... and acquire ownership of the framebuffer.
+ *		ret = acquire_framebuffers(dev, pdev);
+ *		if (ret)
+ *			return ret;
+ *
+ *		drm_dev_register(dev, 0);
+ *
+ *		return 0;
+ *	}
+ *
+ * The generic driver is now subject to forced removal by other drivers. This
+ * only works for platform drivers that support hot unplug.
+ * When a driver calls drm_aperture_remove_conflicting_framebuffers() et al
+ * for the registered framebuffer range, the aperture helpers call
+ * platform_device_unregister() and the generic driver unloads itself. It
+ * may not access the device's registers, framebuffer memory, ROM, etc
+ * afterwards.
+ */
+
+struct drm_aperture {
+	struct drm_device *dev;
+	resource_size_t base;
+	resource_size_t size;
+	struct list_head lh;
+	void (*detach)(struct drm_device *dev);
+};
+
+static LIST_HEAD(drm_apertures);
+static DEFINE_MUTEX(drm_apertures_lock);
+
+static bool overlap(resource_size_t base1, resource_size_t end1,
+		    resource_size_t base2, resource_size_t end2)
+{
+	return (base1 < end2) && (end1 > base2);
+}
+
+static void devm_aperture_acquire_release(void *data)
+{
+	struct drm_aperture *ap = data;
+	bool detached = !ap->dev;
+
+	if (detached)
+		return;
+
+	mutex_lock(&drm_apertures_lock);
+	list_del(&ap->lh);
+	mutex_unlock(&drm_apertures_lock);
+}
+
+static int devm_aperture_acquire(struct drm_device *dev,
+				 resource_size_t base, resource_size_t size,
+				 void (*detach)(struct drm_device *))
+{
+	size_t end = base + size;
+	struct list_head *pos;
+	struct drm_aperture *ap;
+
+	mutex_lock(&drm_apertures_lock);
+
+	list_for_each(pos, &drm_apertures) {
+		ap = container_of(pos, struct drm_aperture, lh);
+		if (overlap(base, end, ap->base, ap->base + ap->size)) {
+			mutex_unlock(&drm_apertures_lock);
+			return -EBUSY;
+		}
+	}
+
+	ap = devm_kzalloc(dev->dev, sizeof(*ap), GFP_KERNEL);
+	if (!ap) {
+		mutex_unlock(&drm_apertures_lock);
+		return -ENOMEM;
+	}
+
+	ap->dev = dev;
+	ap->base = base;
+	ap->size = size;
+	ap->detach = detach;
+	INIT_LIST_HEAD(&ap->lh);
+
+	list_add(&ap->lh, &drm_apertures);
+
+	mutex_unlock(&drm_apertures_lock);
+
+	return devm_add_action_or_reset(dev->dev, devm_aperture_acquire_release, ap);
+}
+
+static void drm_aperture_detach_firmware(struct drm_device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev->dev);
+
+	/*
+	 * Remove the device from the device hierarchy. This is the right thing
+	 * to do for firmware-based DRM drivers, such as EFI, VESA or VGA. After
+	 * the new driver takes over the hardware, the firmware device's state
+	 * will be lost.
+	 *
+	 * For non-platform devices, a new callback would be required.
+	 *
+	 * If the aperture helpers ever need to handle native drivers, this call
+	 * would only have to unplug the DRM device, so that the hardware device
+	 * stays around after detachment.
+	 */
+	platform_device_unregister(pdev);
+}
+
+/**
+ * devm_aperture_acquire_from_firmware - Acquires ownership of a firmware framebuffer
+ *                                       on behalf of a DRM driver.
+ * @dev:	the DRM device to own the framebuffer memory
+ * @base:	the framebuffer's byte offset in physical memory
+ * @size:	the framebuffer size in bytes
+ *
+ * Installs the given device as the new owner of the framebuffer. The function
+ * expects the framebuffer to be provided by a platform device that has been
+ * set up by firmware. Firmware can be any generic interface, such as EFI,
+ * VESA, VGA, etc. If the native hardware driver takes over ownership of the
+ * framebuffer range, the firmware state gets lost. Aperture helpers will then
+ * unregister the platform device automatically. Acquired apertures are
+ * released automatically if the underlying device goes away.
+ *
+ * The function fails if the framebuffer range, or parts of it, is currently
+ * owned by another driver. To evict current owners, callers should use
+ * drm_aperture_remove_conflicting_framebuffers() et al. before calling this
+ * function. The function also fails if the given device is not a platform
+ * device.
+ *
+ * Returns:
+ * 0 on success, or a negative errno value otherwise.
+ */
+int devm_aperture_acquire_from_firmware(struct drm_device *dev, resource_size_t base,
+					resource_size_t size)
+{
+	if (drm_WARN_ON(dev, !dev_is_platform(dev->dev)))
+		return -EINVAL;
+
+	return devm_aperture_acquire(dev, base, size, drm_aperture_detach_firmware);
+}
+EXPORT_SYMBOL(devm_aperture_acquire_from_firmware);
+
+static void drm_aperture_detach_drivers(resource_size_t base, resource_size_t size)
+{
+	resource_size_t end = base + size;
+	struct list_head *pos, *n;
+
+	mutex_lock(&drm_apertures_lock);
+
+	list_for_each_safe(pos, n, &drm_apertures) {
+		struct drm_aperture *ap =
+			container_of(pos, struct drm_aperture, lh);
+		struct drm_device *dev = ap->dev;
+
+		if (WARN_ON_ONCE(!dev))
+			continue;
+
+		if (!overlap(base, end, ap->base, ap->base + ap->size))
+			continue;
+
+		ap->dev = NULL; /* detach from device */
+		list_del(&ap->lh);
+
+		ap->detach(dev);
+	}
+
+	mutex_unlock(&drm_apertures_lock);
+}
+
+/**
+ * drm_aperture_remove_conflicting_framebuffers - remove existing framebuffers in the given range
+ * @base: the aperture's base address in physical memory
+ * @size: aperture size in bytes
+ * @primary: also kick vga16fb if present
+ * @req_driver: requesting DRM driver
+ *
+ * This function removes graphics device drivers which use memory range described by
+ * @base and @size.
+ *
+ * Returns:
+ * 0 on success, or a negative errno code otherwise
+ */
+int drm_aperture_remove_conflicting_framebuffers(resource_size_t base, resource_size_t size,
+						 bool primary, const struct drm_driver *req_driver)
+{
+#if IS_REACHABLE(CONFIG_FB)
+	struct apertures_struct *a;
+	int ret;
+
+	a = alloc_apertures(1);
+	if (!a)
+		return -ENOMEM;
+
+	a->ranges[0].base = base;
+	a->ranges[0].size = size;
+
+	ret = remove_conflicting_framebuffers(a, req_driver->name, primary);
+	kfree(a);
+
+	if (ret)
+		return ret;
+#endif
+
+	drm_aperture_detach_drivers(base, size);
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_aperture_remove_conflicting_framebuffers);
+
+/**
+ * drm_aperture_remove_conflicting_pci_framebuffers - remove existing framebuffers for PCI devices
+ * @pdev: PCI device
+ * @req_driver: requesting DRM driver
+ *
+ * This function removes graphics device drivers using memory range configured
+ * for any of @pdev's memory bars. The function assumes that PCI device with
+ * shadowed ROM drives a primary display and so kicks out vga16fb.
+ *
+ * Returns:
+ * 0 on success, or a negative errno code otherwise
+ */
+int drm_aperture_remove_conflicting_pci_framebuffers(struct pci_dev *pdev,
+						     const struct drm_driver *req_driver)
+{
+	resource_size_t base, size;
+	int bar, ret = 0;
+
+	for (bar = 0; bar < PCI_STD_NUM_BARS; ++bar) {
+		if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM))
+			continue;
+		base = pci_resource_start(pdev, bar);
+		size = pci_resource_len(pdev, bar);
+		drm_aperture_detach_drivers(base, size);
+	}
+
+	/*
+	 * WARNING: Apparently we must kick fbdev drivers before vgacon,
+	 * otherwise the vga fbdev driver falls over.
+	 */
+#if IS_REACHABLE(CONFIG_FB)
+	ret = remove_conflicting_pci_framebuffers(pdev, req_driver->name);
+#endif
+	if (ret == 0)
+		ret = vga_remove_vgacon(pdev);
+	return ret;
+}
+EXPORT_SYMBOL(drm_aperture_remove_conflicting_pci_framebuffers);
diff -Naur a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c
--- a/drivers/gpu/drm/drm_connector.c	2022-05-27 17:20:15.517900044 +0800
+++ b/drivers/gpu/drm/drm_connector.c	2022-05-31 11:56:47.729259361 +0800
@@ -2144,6 +2144,55 @@
 EXPORT_SYMBOL(drm_connector_attach_max_bpc_property);
 
 /**
+ * drm_connector_attach_hdr_output_metadata_property - attach "HDR_OUTPUT_METADA" property
+ * @connector: connector to attach the property on.
+ *
+ * This is used to allow the userspace to send HDR Metadata to the
+ * driver.
+ *
+ * Returns:
+ * Zero on success, negative errno on failure.
+ */
+int drm_connector_attach_hdr_output_metadata_property(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_property *prop = dev->mode_config.hdr_output_metadata_property;
+
+	drm_object_attach_property(&connector->base, prop, 0);
+
+	return 0;
+}
+EXPORT_SYMBOL(drm_connector_attach_hdr_output_metadata_property);
+
+/**
+ * drm_connector_atomic_hdr_metadata_equal - checks if the hdr metadata changed
+ * @old_state: old connector state to compare
+ * @new_state: new connector state to compare
+ *
+ * This is used by HDR-enabled drivers to test whether the HDR metadata
+ * have changed between two different connector state (and thus probably
+ * requires a full blown mode change).
+ *
+ * Returns:
+ * True if the metadata are equal, False otherwise
+ */
+bool drm_connector_atomic_hdr_metadata_equal(struct drm_connector_state *old_state,
+					     struct drm_connector_state *new_state)
+{
+	struct drm_property_blob *old_blob = old_state->hdr_output_metadata;
+	struct drm_property_blob *new_blob = new_state->hdr_output_metadata;
+
+	if (!old_blob || !new_blob)
+		return old_blob == new_blob;
+
+	if (old_blob->length != new_blob->length)
+		return false;
+
+	return !memcmp(old_blob->data, new_blob->data, old_blob->length);
+}
+EXPORT_SYMBOL(drm_connector_atomic_hdr_metadata_equal);
+
+/**
  * drm_connector_set_vrr_capable_property - sets the variable refresh rate
  * capable property for a connector
  * @connector: drm connector
diff -Naur a/drivers/gpu/drm/drm_ioctl.c b/drivers/gpu/drm/drm_ioctl.c
--- a/drivers/gpu/drm/drm_ioctl.c	2022-05-27 17:20:15.521900096 +0800
+++ b/drivers/gpu/drm/drm_ioctl.c	2022-05-31 11:56:47.729259361 +0800
@@ -678,9 +678,9 @@
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_RMFB, drm_mode_rmfb_ioctl, 0),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_PAGE_FLIP, drm_mode_page_flip_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DIRTYFB, drm_mode_dirtyfb_ioctl, DRM_MASTER),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_DUMB, drm_mode_create_dumb_ioctl, 0),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_MAP_DUMB, drm_mode_mmap_dumb_ioctl, 0),
-	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROY_DUMB, drm_mode_destroy_dumb_ioctl, 0),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CREATE_DUMB, drm_mode_create_dumb_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_MAP_DUMB, drm_mode_mmap_dumb_ioctl, DRM_RENDER_ALLOW),
+	DRM_IOCTL_DEF(DRM_IOCTL_MODE_DESTROY_DUMB, drm_mode_destroy_dumb_ioctl, DRM_RENDER_ALLOW),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_GETPROPERTIES, drm_mode_obj_get_properties_ioctl, 0),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_OBJ_SETPROPERTY, drm_mode_obj_set_property_ioctl, DRM_MASTER),
 	DRM_IOCTL_DEF(DRM_IOCTL_MODE_CURSOR2, drm_mode_cursor2_ioctl, DRM_MASTER),
diff -Naur a/drivers/gpu/drm/drm_vblank.c b/drivers/gpu/drm/drm_vblank.c
--- a/drivers/gpu/drm/drm_vblank.c	2022-05-27 17:20:15.525900147 +0800
+++ b/drivers/gpu/drm/drm_vblank.c	2022-05-31 11:56:47.729259361 +0800
@@ -1725,6 +1725,15 @@
 	reply->tval_usec = ts.tv_nsec / 1000;
 }
 
+static bool drm_wait_vblank_supported(struct drm_device *dev)
+{
+#if IS_ENABLED(CONFIG_DRM_LEGACY)
+	if (unlikely(drm_core_check_feature(dev, DRIVER_LEGACY)))
+		return dev->irq_enabled;
+#endif
+	return drm_dev_has_vblank(dev);
+}
+
 int drm_wait_vblank_ioctl(struct drm_device *dev, void *data,
 			  struct drm_file *file_priv)
 {
@@ -1736,7 +1745,7 @@
 	unsigned int pipe_index;
 	unsigned int flags, pipe, high_pipe;
 
-	if (!dev->irq_enabled)
+	if (!drm_wait_vblank_supported(dev))
 		return -EOPNOTSUPP;
 
 	if (vblwait->request.type & _DRM_VBLANK_SIGNAL)
@@ -2011,7 +2020,7 @@
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EOPNOTSUPP;
 
-	if (!dev->irq_enabled)
+	if (!drm_dev_has_vblank(dev))
 		return -EOPNOTSUPP;
 
 	crtc = drm_crtc_find(dev, file_priv, get_seq->crtc_id);
@@ -2070,7 +2079,7 @@
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EOPNOTSUPP;
 
-	if (!dev->irq_enabled)
+	if (!drm_dev_has_vblank(dev))
 		return -EOPNOTSUPP;
 
 	crtc = drm_crtc_find(dev, file_priv, queue_seq->crtc_id);
diff -Naur a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
--- a/drivers/gpu/drm/Makefile	2022-05-27 17:20:14.917892304 +0800
+++ b/drivers/gpu/drm/Makefile	2022-05-31 11:56:47.729259361 +0800
@@ -18,7 +18,7 @@
 		drm_dumb_buffers.o drm_mode_config.o drm_vblank.o \
 		drm_syncobj.o drm_lease.o drm_writeback.o drm_client.o \
 		drm_client_modeset.o drm_atomic_uapi.o drm_hdcp.o \
-		drm_managed.o drm_vblank_work.o
+		drm_managed.o drm_vblank_work.o drm_aperture.o
 
 drm-$(CONFIG_DRM_LEGACY) += drm_legacy_misc.o drm_bufs.o drm_context.o drm_dma.o drm_scatter.o drm_lock.o
 drm-$(CONFIG_DRM_LIB_RANDOM) += lib/drm_random.o
diff -Naur a/drivers/gpu/drm/meson/Kconfig b/drivers/gpu/drm/meson/Kconfig
--- a/drivers/gpu/drm/meson/Kconfig	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/Kconfig	2022-05-31 11:56:47.729259361 +0800
@@ -6,9 +6,11 @@
 	select DRM_KMS_HELPER
 	select DRM_KMS_CMA_HELPER
 	select DRM_GEM_CMA_HELPER
+	select DRM_DISPLAY_CONNECTOR
 	select VIDEOMODE_HELPERS
 	select REGMAP_MMIO
 	select MESON_CANVAS
+	select CEC_CORE if CEC_NOTIFIER
 
 config DRM_MESON_DW_HDMI
 	tristate "HDMI Synopsys Controller support for Amlogic Meson Display"
@@ -16,3 +18,10 @@
 	default y if DRM_MESON
 	select DRM_DW_HDMI
 	imply DRM_DW_HDMI_I2S_AUDIO
+
+config DRM_MESON_DW_MIPI_DSI
+	tristate "MIPI DSI Synopsys Controller support for Amlogic Meson Display"
+	depends on DRM_MESON
+	default y if DRM_MESON
+	select DRM_DW_MIPI_DSI
+	select GENERIC_PHY_MIPI_DPHY
diff -Naur a/drivers/gpu/drm/meson/Makefile b/drivers/gpu/drm/meson/Makefile
--- a/drivers/gpu/drm/meson/Makefile	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/Makefile	2022-05-31 11:56:47.729259361 +0800
@@ -1,7 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0-only
-meson-drm-y := meson_drv.o meson_plane.o meson_crtc.o meson_venc_cvbs.o
+meson-drm-y := meson_drv.o meson_plane.o meson_cursor.o meson_crtc.o meson_encoder_cvbs.o
 meson-drm-y += meson_viu.o meson_vpp.o meson_venc.o meson_vclk.o meson_overlay.o
 meson-drm-y += meson_rdma.o meson_osd_afbcd.o
+meson-drm-y += meson_encoder_hdmi.o meson_encoder_dsi.o
 
 obj-$(CONFIG_DRM_MESON) += meson-drm.o
 obj-$(CONFIG_DRM_MESON_DW_HDMI) += meson_dw_hdmi.o
+obj-$(CONFIG_DRM_MESON_DW_MIPI_DSI) += meson_dw_mipi_dsi.o
diff -Naur a/drivers/gpu/drm/meson/meson_crtc.c b/drivers/gpu/drm/meson/meson_crtc.c
--- a/drivers/gpu/drm/meson/meson_crtc.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_crtc.c	2022-05-31 11:56:47.729259361 +0800
@@ -36,6 +36,7 @@
 	struct drm_pending_vblank_event *event;
 	struct meson_drm *priv;
 	void (*enable_osd1)(struct meson_drm *priv);
+	void (*enable_osd2)(struct meson_drm *priv);
 	void (*enable_vd1)(struct meson_drm *priv);
 	void (*enable_osd1_afbc)(struct meson_drm *priv);
 	void (*disable_osd1_afbc)(struct meson_drm *priv);
@@ -82,7 +83,7 @@
 };
 
 static void meson_g12a_crtc_atomic_enable(struct drm_crtc *crtc,
-					  struct drm_crtc_state *old_state)
+					  struct drm_crtc_state *old_crtc_state)
 {
 	struct meson_crtc *meson_crtc = to_meson_crtc(crtc);
 	struct drm_crtc_state *crtc_state = crtc->state;
@@ -110,6 +111,20 @@
 	writel_relaxed(0 << 16 |
 			(crtc_state->mode.vdisplay - 1),
 			priv->io_base + _REG(VPP_OSD1_BLD_V_SCOPE));
+	writel_relaxed(0 << 16 |
+			(crtc_state->mode.hdisplay - 1),
+			priv->io_base + _REG(VPP_OSD2_BLD_H_SCOPE));
+	writel_relaxed(0 << 16 |
+			(crtc_state->mode.vdisplay - 1),
+			priv->io_base + _REG(VPP_OSD2_BLD_V_SCOPE));
+	writel_relaxed(crtc_state->mode.hdisplay |
+			crtc_state->mode.vdisplay << 16,
+		       priv->io_base +
+		       _REG(VIU_OSD_BLEND_BLEND0_SIZE));
+	writel_relaxed(crtc_state->mode.hdisplay |
+			crtc_state->mode.vdisplay << 16,
+		       priv->io_base +
+		       _REG(VIU_OSD_BLEND_BLEND1_SIZE));
 	writel_relaxed(crtc_state->mode.hdisplay << 16 |
 			crtc_state->mode.vdisplay,
 			priv->io_base + _REG(VPP_OUT_H_V_SIZE));
@@ -118,7 +133,7 @@
 }
 
 static void meson_crtc_atomic_enable(struct drm_crtc *crtc,
-				     struct drm_crtc_state *old_state)
+				     struct drm_crtc_state *old_crtc_state)
 {
 	struct meson_crtc *meson_crtc = to_meson_crtc(crtc);
 	struct drm_crtc_state *crtc_state = crtc->state;
@@ -146,7 +161,7 @@
 }
 
 static void meson_g12a_crtc_atomic_disable(struct drm_crtc *crtc,
-					   struct drm_crtc_state *old_state)
+					   struct drm_crtc_state *old_crtc_state)
 {
 	struct meson_crtc *meson_crtc = to_meson_crtc(crtc);
 	struct meson_drm *priv = meson_crtc->priv;
@@ -158,6 +173,9 @@
 	priv->viu.osd1_enabled = false;
 	priv->viu.osd1_commit = false;
 
+	priv->viu.osd2_enabled = false;
+	priv->viu.osd2_commit = false;
+
 	priv->viu.vd1_enabled = false;
 	priv->viu.vd1_commit = false;
 
@@ -171,7 +189,7 @@
 }
 
 static void meson_crtc_atomic_disable(struct drm_crtc *crtc,
-				      struct drm_crtc_state *old_state)
+				      struct drm_crtc_state *old_crtc_state)
 {
 	struct meson_crtc *meson_crtc = to_meson_crtc(crtc);
 	struct meson_drm *priv = meson_crtc->priv;
@@ -183,11 +201,14 @@
 	priv->viu.osd1_enabled = false;
 	priv->viu.osd1_commit = false;
 
+	priv->viu.osd2_enabled = false;
+	priv->viu.osd2_commit = false;
+
 	priv->viu.vd1_enabled = false;
 	priv->viu.vd1_commit = false;
 
 	/* Disable VPP Postblend */
-	writel_bits_relaxed(VPP_OSD1_POSTBLEND | VPP_VD1_POSTBLEND |
+	writel_bits_relaxed(VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND | VPP_VD1_POSTBLEND |
 			    VPP_VD1_PREBLEND | VPP_POSTBLEND_ENABLE, 0,
 			    priv->io_base + _REG(VPP_MISC));
 
@@ -201,7 +222,7 @@
 }
 
 static void meson_crtc_atomic_begin(struct drm_crtc *crtc,
-				    struct drm_crtc_state *state)
+				    struct drm_crtc_state *old_crtc_state)
 {
 	struct meson_crtc *meson_crtc = to_meson_crtc(crtc);
 	unsigned long flags;
@@ -223,6 +244,7 @@
 	struct meson_drm *priv = meson_crtc->priv;
 
 	priv->viu.osd1_commit = true;
+	priv->viu.osd2_commit = true;
 	priv->viu.vd1_commit = true;
 }
 
@@ -246,6 +268,12 @@
 			    priv->io_base + _REG(VPP_MISC));
 }
 
+static void meson_crtc_enable_osd2(struct meson_drm *priv)
+{
+	writel_bits_relaxed(VPP_OSD2_POSTBLEND, VPP_OSD2_POSTBLEND,
+			    priv->io_base + _REG(VPP_MISC));
+}
+
 static void meson_crtc_g12a_enable_osd1_afbc(struct meson_drm *priv)
 {
 	writel_relaxed(priv->viu.osd1_blk2_cfg4,
@@ -274,14 +302,20 @@
 	writel_relaxed(priv->viu.osd_blend_din0_scope_v,
 		       priv->io_base +
 		       _REG(VIU_OSD_BLEND_DIN0_SCOPE_V));
-	writel_relaxed(priv->viu.osb_blend0_size,
+	writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD1, OSD_BLEND_POSTBLD_SRC_OSD1,
+			    priv->io_base + _REG(OSD1_BLEND_SRC_CTRL));
+}
+
+static void meson_g12a_crtc_enable_osd2(struct meson_drm *priv)
+{
+	writel_relaxed(priv->viu.osd_blend_din3_scope_h,
 		       priv->io_base +
-		       _REG(VIU_OSD_BLEND_BLEND0_SIZE));
-	writel_relaxed(priv->viu.osb_blend1_size,
+		       _REG(VIU_OSD_BLEND_DIN1_SCOPE_H));
+	writel_relaxed(priv->viu.osd_blend_din3_scope_v,
 		       priv->io_base +
-		       _REG(VIU_OSD_BLEND_BLEND1_SIZE));
-	writel_bits_relaxed(3 << 8, 3 << 8,
-			    priv->io_base + _REG(OSD1_BLEND_SRC_CTRL));
+		       _REG(VIU_OSD_BLEND_DIN1_SCOPE_V));
+	writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD2, OSD_BLEND_POSTBLD_SRC_OSD2,
+			    priv->io_base + _REG(OSD2_BLEND_SRC_CTRL));
 }
 
 static void meson_crtc_enable_vd1(struct meson_drm *priv)
@@ -388,6 +422,43 @@
 		priv->viu.osd1_commit = false;
 	}
 
+	if (priv->viu.osd2_enabled && priv->viu.osd2_commit) {
+		writel_relaxed(priv->viu.osd2_ctrl_stat,
+				priv->io_base + _REG(VIU_OSD2_CTRL_STAT));
+		writel_relaxed(priv->viu.osd2_ctrl_stat2,
+				priv->io_base + _REG(VIU_OSD2_CTRL_STAT2));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[0],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[1],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W1));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[2],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W2));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[3],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W3));
+		writel_relaxed(priv->viu.osd2_blk0_cfg[4],
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W4));
+
+		/* vsync forced to update INTERLACE_SEL_ODD in interlace mode */
+		meson_crtc->vsync_forced = priv->viu.osd2_interlace;
+
+		meson_canvas_config(priv->canvas, priv->canvas_id_osd2,
+				priv->viu.osd2_addr,
+				priv->viu.osd2_stride,
+				priv->viu.osd2_height,
+				MESON_CANVAS_WRAP_NONE,
+				MESON_CANVAS_BLKMODE_LINEAR, 0);
+
+		/* Enable OSD2 */
+		if (meson_crtc->enable_osd2)
+			meson_crtc->enable_osd2(priv);
+
+		priv->viu.osd2_commit = false;
+	} else if (priv->viu.osd2_enabled && priv->viu.osd2_interlace) {
+		u32 reg = readl_relaxed(priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0)) & ~BIT(0);
+		writel_relaxed(reg | meson_venci_get_field(priv) ? 1 : 0,
+				priv->io_base + _REG(VIU_OSD2_BLK0_CFG_W0));
+	}
+
 	/* Update the VD1 registers */
 	if (priv->viu.vd1_enabled && priv->viu.vd1_commit) {
 
@@ -685,7 +756,7 @@
 	meson_crtc->priv = priv;
 	crtc = &meson_crtc->base;
 	ret = drm_crtc_init_with_planes(priv->drm, crtc,
-					priv->primary_plane, NULL,
+					priv->primary_plane, priv->cursor_plane,
 					&meson_crtc_funcs, "meson_crtc");
 	if (ret) {
 		dev_err(priv->drm->dev, "Failed to init CRTC\n");
@@ -694,6 +765,7 @@
 
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
 		meson_crtc->enable_osd1 = meson_g12a_crtc_enable_osd1;
+		meson_crtc->enable_osd2 = meson_g12a_crtc_enable_osd2;
 		meson_crtc->enable_vd1 = meson_g12a_crtc_enable_vd1;
 		meson_crtc->viu_offset = MESON_G12A_VIU_OFFSET;
 		meson_crtc->enable_osd1_afbc =
@@ -703,6 +775,7 @@
 		drm_crtc_helper_add(crtc, &meson_g12a_crtc_helper_funcs);
 	} else {
 		meson_crtc->enable_osd1 = meson_crtc_enable_osd1;
+		meson_crtc->enable_osd2 = meson_crtc_enable_osd2;
 		meson_crtc->enable_vd1 = meson_crtc_enable_vd1;
 		if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM)) {
 			meson_crtc->enable_osd1_afbc =
diff -Naur a/drivers/gpu/drm/meson/meson_cursor.c b/drivers/gpu/drm/meson/meson_cursor.c
--- a/drivers/gpu/drm/meson/meson_cursor.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_cursor.c	2022-05-31 11:56:47.729259361 +0800
@@ -0,0 +1,244 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#include <linux/bitfield.h>
+
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_device.h>
+#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem_cma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_plane_helper.h>
+
+#include "meson_cursor.h"
+#include "meson_registers.h"
+#include "meson_viu.h"
+
+struct meson_cursor {
+	struct drm_plane base;
+	struct meson_drm *priv;
+};
+#define to_meson_cursor(x) container_of(x, struct meson_cursor, base)
+
+static int meson_cursor_atomic_check(struct drm_plane *plane,
+				    struct drm_plane_state *state)
+{
+	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state->state,
+										 plane);
+	struct drm_crtc_state *crtc_state;
+
+	if (!new_plane_state->crtc)
+		return 0;
+
+	crtc_state = drm_atomic_get_crtc_state(state->state,
+					       new_plane_state->crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	return drm_atomic_helper_check_plane_state(new_plane_state,
+						   crtc_state,
+						   DRM_PLANE_HELPER_NO_SCALING,
+						   DRM_PLANE_HELPER_NO_SCALING,
+						   true, true);
+}
+
+/* Takes a fixed 16.16 number and converts it to integer. */
+static inline int64_t fixed16_to_int(int64_t value)
+{
+	return value >> 16;
+}
+
+static void meson_cursor_atomic_update(struct drm_plane *plane,
+				      struct drm_plane_state *state)
+{
+	struct meson_cursor *meson_cursor = to_meson_cursor(plane);
+	struct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state->state,
+									   plane);
+	struct drm_rect dest = drm_plane_state_dest(new_state);
+	struct meson_drm *priv = meson_cursor->priv;
+	struct drm_framebuffer *fb = new_state->fb;
+	struct drm_gem_cma_object *gem;
+	unsigned long flags;
+	int dst_w, dst_h;
+
+	/*
+	 * Update Coordinates
+	 * Update Formats
+	 * Update Buffer
+	 * Enable Plane
+	 */
+	spin_lock_irqsave(&priv->drm->event_lock, flags);
+
+	/* Enable OSD and BLK0, set max global alpha */
+	priv->viu.osd2_ctrl_stat = OSD_ENABLE |
+				   (0xFF << OSD_GLOBAL_ALPHA_SHIFT) |
+				   OSD_BLK0_ENABLE;
+
+	priv->viu.osd2_ctrl_stat2 = readl(priv->io_base +
+					  _REG(VIU_OSD2_CTRL_STAT2));
+
+	/* Set up BLK0 to point to the right canvas */
+	priv->viu.osd2_blk0_cfg[0] = priv->canvas_id_osd2 << OSD_CANVAS_SEL;
+	priv->viu.osd2_blk0_cfg[0] |= OSD_ENDIANNESS_LE;
+
+	/* On GXBB, Use the old non-HDR RGB2YUV converter */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB))
+		priv->viu.osd2_blk0_cfg[0] |= OSD_OUTPUT_COLOR_RGB;
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_ARGB8888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_32 |
+			OSD_COLOR_MATRIX_32_ARGB;
+		break;
+	case DRM_FORMAT_XBGR8888:
+	case DRM_FORMAT_ABGR8888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_32 |
+			OSD_COLOR_MATRIX_32_ABGR;
+		break;
+	case DRM_FORMAT_RGB888:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_24 |
+			OSD_COLOR_MATRIX_24_RGB;
+		break;
+	case DRM_FORMAT_RGB565:
+		priv->viu.osd2_blk0_cfg[0] |= OSD_BLK_MODE_16 |
+			OSD_COLOR_MATRIX_16_RGB565;
+		break;
+	}
+
+	switch (fb->format->format) {
+	case DRM_FORMAT_XRGB8888:
+	case DRM_FORMAT_XBGR8888:
+		/* For XRGB, replace the pixel's alpha by 0xFF */
+		priv->viu.osd2_ctrl_stat2 |= OSD_REPLACE_EN;
+		break;
+	case DRM_FORMAT_ARGB8888:
+	case DRM_FORMAT_ABGR8888:
+		/* For ARGB, use the pixel's alpha */
+		priv->viu.osd2_ctrl_stat2 &= ~OSD_REPLACE_EN;
+		break;
+	}
+
+	dst_w = new_state->crtc_w;
+	dst_h = new_state->crtc_h;
+
+	if (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)
+		priv->viu.osd2_interlace = true;
+	else
+		priv->viu.osd2_interlace = false;
+
+	/*
+	 * The format of these registers is (x2 << 16 | x1),
+	 * where x2 is exclusive.
+	 * e.g. +30x1920 would be (1919 << 16) | 30
+	 */
+	priv->viu.osd2_blk0_cfg[1] =
+				((fixed16_to_int(new_state->src.x2) - 1) << 16) |
+				fixed16_to_int(new_state->src.x1);
+	priv->viu.osd2_blk0_cfg[2] =
+				((fixed16_to_int(new_state->src.y2) - 1) << 16) |
+				fixed16_to_int(new_state->src.y1);
+	priv->viu.osd2_blk0_cfg[3] = ((dest.x2 - 1) << 16) | dest.x1;
+	priv->viu.osd2_blk0_cfg[4] = ((dest.y2 - 1) << 16) | dest.y1;
+
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+		priv->viu.osd_blend_din3_scope_h = ((dest.x2 - 1) << 16) | dest.x1;
+		priv->viu.osd_blend_din3_scope_v = ((dest.y2 - 1) << 16) | dest.y1;
+		priv->viu.osb_blend1_size = dst_h << 16 | dst_w;
+	}
+
+	/* Update Canvas with buffer address */
+	gem = drm_fb_cma_get_gem_obj(fb, 0);
+
+	priv->viu.osd2_addr = gem->paddr;
+	priv->viu.osd2_stride = fb->pitches[0];
+	priv->viu.osd2_height = fb->height;
+	priv->viu.osd2_width = fb->width;
+
+	/* TOFIX: Reset OSD2 before enabling it on GXL+ SoCs ? */
+
+	priv->viu.osd2_enabled = true;
+
+	spin_unlock_irqrestore(&priv->drm->event_lock, flags);
+}
+
+static void meson_cursor_atomic_disable(struct drm_plane *plane,
+				       struct drm_plane_state *state)
+{
+	struct meson_cursor *meson_cursor = to_meson_cursor(plane);
+	struct meson_drm *priv = meson_cursor->priv;
+
+	/* Disable OSD2 */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+		writel_bits_relaxed(OSD_BLEND_POSTBLD_SRC_OSD2, 0,
+				    priv->io_base + _REG(OSD2_BLEND_SRC_CTRL));
+	else
+		writel_bits_relaxed(VPP_OSD2_POSTBLEND, 0,
+				    priv->io_base + _REG(VPP_MISC));
+
+	priv->viu.osd2_enabled = false;
+}
+
+static const struct drm_plane_helper_funcs meson_cursor_helper_funcs = {
+	.atomic_check	= meson_cursor_atomic_check,
+	.atomic_disable	= meson_cursor_atomic_disable,
+	.atomic_update	= meson_cursor_atomic_update,
+};
+
+static const struct drm_plane_funcs meson_cursor_funcs = {
+	.update_plane		= drm_atomic_helper_update_plane,
+	.disable_plane		= drm_atomic_helper_disable_plane,
+	.destroy		= drm_plane_cleanup,
+	.reset			= drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state	= drm_atomic_helper_plane_destroy_state,
+};
+
+static const uint32_t supported_drm_formats[] = {
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+	DRM_FORMAT_XRGB8888,
+	DRM_FORMAT_XBGR8888,
+	DRM_FORMAT_RGB888,
+	DRM_FORMAT_RGB565,
+};
+
+static const uint64_t format_modifiers_default[] = {
+	DRM_FORMAT_MOD_LINEAR,
+	DRM_FORMAT_MOD_INVALID,
+};
+
+int meson_cursor_create(struct meson_drm *priv)
+{
+	struct meson_cursor *meson_cursor;
+	struct drm_plane *cursor;
+
+	meson_cursor = devm_kzalloc(priv->drm->dev, sizeof(*meson_cursor),
+				   GFP_KERNEL);
+	if (!meson_cursor)
+		return -ENOMEM;
+
+	meson_cursor->priv = priv;
+	cursor = &meson_cursor->base;
+
+	drm_universal_plane_init(priv->drm, cursor, 0xFF,
+				 &meson_cursor_funcs,
+				 supported_drm_formats,
+				 ARRAY_SIZE(supported_drm_formats),
+				 format_modifiers_default,
+				 DRM_PLANE_TYPE_CURSOR, "meson_cursor_plane");
+
+	drm_plane_helper_add(cursor, &meson_cursor_helper_funcs);
+
+	/* For now, OSD Cursor is always on top of the primary plane */
+	drm_plane_create_zpos_immutable_property(cursor, 2);
+
+	priv->cursor_plane = cursor;
+
+	return 0;
+}
diff -Naur a/drivers/gpu/drm/meson/meson_cursor.h b/drivers/gpu/drm/meson/meson_cursor.h
--- a/drivers/gpu/drm/meson/meson_cursor.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_cursor.h	2022-05-31 11:56:47.729259361 +0800
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#ifndef __MESON_CURSOR_H
+#define __MESON_CURSOR_H
+
+#include "meson_drv.h"
+
+int meson_cursor_create(struct meson_drm *priv);
+
+#endif /* __MESON_CURSOR_H */
diff -Naur a/drivers/gpu/drm/meson/meson_drv.c b/drivers/gpu/drm/meson/meson_drv.c
--- a/drivers/gpu/drm/meson/meson_drv.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_drv.c	2022-05-31 11:56:47.729259361 +0800
@@ -15,12 +15,12 @@
 #include <linux/platform_device.h>
 #include <linux/soc/amlogic/meson-canvas.h>
 
+#include <drm/drm_aperture.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_drv.h>
 #include <drm/drm_fb_helper.h>
 #include <drm/drm_gem_cma_helper.h>
 #include <drm/drm_gem_framebuffer_helper.h>
-#include <drm/drm_irq.h>
 #include <drm/drm_modeset_helper_vtables.h>
 #include <drm/drm_probe_helper.h>
 #include <drm/drm_vblank.h>
@@ -29,9 +29,12 @@
 #include "meson_drv.h"
 #include "meson_overlay.h"
 #include "meson_plane.h"
+#include "meson_cursor.h"
 #include "meson_osd_afbcd.h"
 #include "meson_registers.h"
-#include "meson_venc_cvbs.h"
+#include "meson_encoder_cvbs.h"
+#include "meson_encoder_hdmi.h"
+#include "meson_encoder_dsi.h"
 #include "meson_viu.h"
 #include "meson_vpp.h"
 #include "meson_rdma.h"
@@ -93,9 +96,6 @@
 static struct drm_driver meson_driver = {
 	.driver_features	= DRIVER_GEM | DRIVER_MODESET | DRIVER_ATOMIC,
 
-	/* IRQ */
-	.irq_handler		= meson_irq,
-
 	/* CMA Ops */
 	DRM_GEM_CMA_DRIVER_OPS_WITH_DUMB_CREATE(meson_dumb_create),
 
@@ -156,23 +156,6 @@
 	writel_relaxed(value, priv->io_base + _REG(VPU_WRARB_MODE_L2C1));
 }
 
-static void meson_remove_framebuffers(void)
-{
-	struct apertures_struct *ap;
-
-	ap = alloc_apertures(1);
-	if (!ap)
-		return;
-
-	/* The framebuffer can be located anywhere in RAM */
-	ap->ranges[0].base = 0;
-	ap->ranges[0].size = ~0;
-
-	drm_fb_helper_remove_conflicting_framebuffers(ap, "meson-drm-fb",
-						      false);
-	kfree(ap);
-}
-
 struct meson_drm_soc_attr {
 	struct meson_drm_soc_limits limits;
 	const struct soc_device_attribute *attrs;
@@ -226,8 +209,7 @@
 	priv->compat = match->compat;
 	priv->afbcd.ops = match->afbcd_ops;
 
-	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "vpu");
-	regs = devm_ioremap_resource(dev, res);
+	regs = devm_platform_ioremap_resource_byname(pdev, "vpu");
 	if (IS_ERR(regs)) {
 		ret = PTR_ERR(regs);
 		goto free_drm;
@@ -264,6 +246,9 @@
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_osd1);
 	if (ret)
 		goto free_drm;
+	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_osd2);
+	if (ret)
+		goto free_drm;
 	ret = meson_canvas_alloc(priv->canvas, &priv->canvas_id_vd1_0);
 	if (ret) {
 		meson_canvas_free(priv->canvas, priv->canvas_id_osd1);
@@ -297,8 +282,13 @@
 		}
 	}
 
-	/* Remove early framebuffers (ie. simplefb) */
-	meson_remove_framebuffers();
+	/*
+	 * Remove early framebuffers (ie. simplefb). The framebuffer can be
+	 * located anywhere in RAM
+	 */
+	ret = drm_aperture_remove_framebuffers(false, &meson_driver);
+	if (ret)
+		goto free_drm;
 
 	ret = drmm_mode_config_init(drm);
 	if (ret)
@@ -322,33 +312,47 @@
 
 	/* Encoder Initialization */
 
-	ret = meson_venc_cvbs_create(priv);
+	ret = meson_encoder_cvbs_init(priv);
 	if (ret)
-		goto free_drm;
+		goto exit_afbcd;
 
 	if (has_components) {
 		ret = component_bind_all(drm->dev, drm);
 		if (ret) {
 			dev_err(drm->dev, "Couldn't bind all components\n");
-			goto free_drm;
+			goto exit_afbcd;
 		}
 	}
 
+	ret = meson_encoder_hdmi_init(priv);
+	if (ret)
+		goto exit_afbcd;
+
+	ret = meson_cursor_create(priv);
+	if (ret)
+		goto exit_afbcd;
+
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+		ret = meson_encoder_dsi_init(priv);
+		if (ret)
+			goto free_drm;
+	}
+
 	ret = meson_plane_create(priv);
 	if (ret)
-		goto free_drm;
+		goto exit_afbcd;
 
 	ret = meson_overlay_create(priv);
 	if (ret)
-		goto free_drm;
+		goto exit_afbcd;
 
 	ret = meson_crtc_create(priv);
 	if (ret)
-		goto free_drm;
+		goto exit_afbcd;
 
-	ret = drm_irq_install(drm, priv->vsync_irq);
+	ret = request_irq(priv->vsync_irq, meson_irq, 0, drm->driver->name, drm);
 	if (ret)
-		goto free_drm;
+		goto exit_afbcd;
 
 	drm_mode_config_reset(drm);
 
@@ -365,7 +369,10 @@
 	return 0;
 
 uninstall_irq:
-	drm_irq_uninstall(drm);
+	free_irq(priv->vsync_irq, drm);
+exit_afbcd:
+	if (priv->afbcd.ops)
+		priv->afbcd.ops->exit(priv);
 free_drm:
 	drm_dev_put(drm);
 
@@ -393,13 +400,11 @@
 	drm_kms_helper_poll_fini(drm);
 	drm_atomic_helper_shutdown(drm);
 	component_unbind_all(dev, drm);
-	drm_irq_uninstall(drm);
+	free_irq(priv->vsync_irq, drm);
 	drm_dev_put(drm);
 
-	if (priv->afbcd.ops) {
-		priv->afbcd.ops->reset(priv);
-		meson_rdma_free(priv);
-	}
+	if (priv->afbcd.ops)
+		priv->afbcd.ops->exit(priv);
 }
 
 static const struct component_master_ops meson_drv_master_ops = {
@@ -442,46 +447,6 @@
 	return dev->of_node == data;
 }
 
-/* Possible connectors nodes to ignore */
-static const struct of_device_id connectors_match[] = {
-	{ .compatible = "composite-video-connector" },
-	{ .compatible = "svideo-connector" },
-	{ .compatible = "hdmi-connector" },
-	{ .compatible = "dvi-connector" },
-	{}
-};
-
-static int meson_probe_remote(struct platform_device *pdev,
-			      struct component_match **match,
-			      struct device_node *parent,
-			      struct device_node *remote)
-{
-	struct device_node *ep, *remote_node;
-	int count = 1;
-
-	/* If node is a connector, return and do not add to match table */
-	if (of_match_node(connectors_match, remote))
-		return 1;
-
-	component_match_add(&pdev->dev, match, compare_of, remote);
-
-	for_each_endpoint_of_node(remote, ep) {
-		remote_node = of_graph_get_remote_port_parent(ep);
-		if (!remote_node ||
-		    remote_node == parent || /* Ignore parent endpoint */
-		    !of_device_is_available(remote_node)) {
-			of_node_put(remote_node);
-			continue;
-		}
-
-		count += meson_probe_remote(pdev, match, remote, remote_node);
-
-		of_node_put(remote_node);
-	}
-
-	return count;
-}
-
 static void meson_drv_shutdown(struct platform_device *pdev)
 {
 	struct meson_drm *priv = dev_get_drvdata(&pdev->dev);
@@ -493,6 +458,13 @@
 	drm_atomic_helper_shutdown(priv->drm);
 }
 
+/* Possible connectors nodes to ignore */
+static const struct of_device_id connectors_match[] = {
+	{ .compatible = "composite-video-connector" },
+	{ .compatible = "svideo-connector" },
+	{}
+};
+
 static int meson_drv_probe(struct platform_device *pdev)
 {
 	struct component_match *match = NULL;
@@ -507,8 +479,21 @@
 			continue;
 		}
 
-		count += meson_probe_remote(pdev, &match, np, remote);
+		/* If an analog connector is detected, count it as an output */
+		if (of_match_node(connectors_match, remote)) {
+			++count;
+			of_node_put(remote);
+			continue;
+		}
+
+		dev_dbg(&pdev->dev, "parent %pOF remote match add %pOF parent %s\n",
+			np, remote, dev_name(&pdev->dev));
+
+		component_match_add(&pdev->dev, &match, compare_of, remote);
+
 		of_node_put(remote);
+
+		++count;
 	}
 
 	if (count && !match)
diff -Naur a/drivers/gpu/drm/meson/meson_drv.h b/drivers/gpu/drm/meson/meson_drv.h
--- a/drivers/gpu/drm/meson/meson_drv.h	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_drv.h	2022-05-31 11:56:47.729259361 +0800
@@ -43,12 +43,14 @@
 
 	struct meson_canvas *canvas;
 	u8 canvas_id_osd1;
+	u8 canvas_id_osd2;
 	u8 canvas_id_vd1_0;
 	u8 canvas_id_vd1_1;
 	u8 canvas_id_vd1_2;
 
 	struct drm_device *drm;
 	struct drm_crtc *crtc;
+	struct drm_plane *cursor_plane;
 	struct drm_plane *primary_plane;
 	struct drm_plane *overlay_plane;
 
@@ -82,6 +84,21 @@
 		uint32_t osd_blend_din0_scope_h;
 		uint32_t osd_blend_din0_scope_v;
 		uint32_t osb_blend0_size;
+
+		bool osd2_enabled;
+		bool osd2_interlace;
+		bool osd2_commit;
+		uint32_t osd2_ctrl_stat;
+		uint32_t osd2_ctrl_stat2;
+		uint32_t osd2_blk0_cfg[5];
+		uint32_t osd2_blk1_cfg4;
+		uint32_t osd2_blk2_cfg4;
+		uint32_t osd2_addr;
+		uint32_t osd2_stride;
+		uint32_t osd2_height;
+		uint32_t osd2_width;
+		uint32_t osd_blend_din3_scope_h;
+		uint32_t osd_blend_din3_scope_v;
 		uint32_t osb_blend1_size;
 
 		bool vd1_enabled;
diff -Naur a/drivers/gpu/drm/meson/meson_dw_hdmi.c b/drivers/gpu/drm/meson/meson_dw_hdmi.c
--- a/drivers/gpu/drm/meson/meson_dw_hdmi.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_dw_hdmi.c	2022-05-31 11:56:47.729259361 +0800
@@ -22,14 +22,11 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/drm_print.h>
 
-#include <linux/media-bus-format.h>
 #include <linux/videodev2.h>
 
 #include "meson_drv.h"
 #include "meson_dw_hdmi.h"
 #include "meson_registers.h"
-#include "meson_vclk.h"
-#include "meson_venc.h"
 
 #define DRIVER_NAME "meson-dw-hdmi"
 #define DRIVER_DESC "Amlogic Meson HDMI-TX DRM driver"
@@ -135,8 +132,6 @@
 };
 
 struct meson_dw_hdmi {
-	struct drm_encoder encoder;
-	struct drm_bridge bridge;
 	struct dw_hdmi_plat_data dw_plat_data;
 	struct meson_drm *priv;
 	struct device *dev;
@@ -148,12 +143,8 @@
 	struct regulator *hdmi_supply;
 	u32 irq_stat;
 	struct dw_hdmi *hdmi;
-	unsigned long output_bus_fmt;
+	struct drm_bridge *bridge;
 };
-#define encoder_to_meson_dw_hdmi(x) \
-	container_of(x, struct meson_dw_hdmi, encoder)
-#define bridge_to_meson_dw_hdmi(x) \
-	container_of(x, struct meson_dw_hdmi, bridge)
 
 static inline int dw_hdmi_is_compatible(struct meson_dw_hdmi *dw_hdmi,
 					const char *compat)
@@ -295,14 +286,14 @@
 
 /* Setup PHY bandwidth modes */
 static void meson_hdmi_phy_setup_mode(struct meson_dw_hdmi *dw_hdmi,
-				      const struct drm_display_mode *mode)
+				      const struct drm_display_mode *mode,
+				      bool mode_is_420)
 {
 	struct meson_drm *priv = dw_hdmi->priv;
 	unsigned int pixel_clock = mode->clock;
 
 	/* For 420, pixel clock is half unlike venc clock */
-	if (dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		pixel_clock /= 2;
+	if (mode_is_420) pixel_clock /= 2;
 
 	if (dw_hdmi_is_compatible(dw_hdmi, "amlogic,meson-gxl-dw-hdmi") ||
 	    dw_hdmi_is_compatible(dw_hdmi, "amlogic,meson-gxm-dw-hdmi")) {
@@ -374,68 +365,25 @@
 	mdelay(2);
 }
 
-static void dw_hdmi_set_vclk(struct meson_dw_hdmi *dw_hdmi,
-			     const struct drm_display_mode *mode)
-{
-	struct meson_drm *priv = dw_hdmi->priv;
-	int vic = drm_match_cea_mode(mode);
-	unsigned int phy_freq;
-	unsigned int vclk_freq;
-	unsigned int venc_freq;
-	unsigned int hdmi_freq;
-
-	vclk_freq = mode->clock;
-
-	/* For 420, pixel clock is half unlike venc clock */
-	if (dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		vclk_freq /= 2;
-
-	/* TMDS clock is pixel_clock * 10 */
-	phy_freq = vclk_freq * 10;
-
-	if (!vic) {
-		meson_vclk_setup(priv, MESON_VCLK_TARGET_DMT, phy_freq,
-				 vclk_freq, vclk_freq, vclk_freq, false);
-		return;
-	}
-
-	/* 480i/576i needs global pixel doubling */
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		vclk_freq *= 2;
-
-	venc_freq = vclk_freq;
-	hdmi_freq = vclk_freq;
-
-	/* VENC double pixels for 1080i, 720p and YUV420 modes */
-	if (meson_venc_hdmi_venc_repeat(vic) ||
-	    dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		venc_freq *= 2;
-
-	vclk_freq = max(venc_freq, hdmi_freq);
-
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		venc_freq /= 2;
-
-	DRM_DEBUG_DRIVER("vclk:%d phy=%d venc=%d hdmi=%d enci=%d\n",
-		phy_freq, vclk_freq, venc_freq, hdmi_freq,
-		priv->venc.hdmi_use_enci);
-
-	meson_vclk_setup(priv, MESON_VCLK_TARGET_HDMI, phy_freq, vclk_freq,
-			 venc_freq, hdmi_freq, priv->venc.hdmi_use_enci);
-}
-
 static int dw_hdmi_phy_init(struct dw_hdmi *hdmi, void *data,
 			    const struct drm_display_info *display,
 			    const struct drm_display_mode *mode)
 {
 	struct meson_dw_hdmi *dw_hdmi = (struct meson_dw_hdmi *)data;
+	bool is_hdmi2_sink = display->hdmi.scdc.supported;
 	struct meson_drm *priv = dw_hdmi->priv;
 	unsigned int wr_clk =
 		readl_relaxed(priv->io_base + _REG(VPU_HDMI_SETTING));
+	bool mode_is_420 = false;
 
 	DRM_DEBUG_DRIVER("\"%s\" div%d\n", mode->name,
 			 mode->clock > 340000 ? 40 : 10);
 
+	if (drm_mode_is_420_only(display, mode) ||
+	    (!is_hdmi2_sink &&
+	     drm_mode_is_420_also(display, mode)))
+		mode_is_420 = true;
+
 	/* Enable clocks */
 	regmap_update_bits(priv->hhi, HHI_HDMI_CLK_CNTL, 0xffff, 0x100);
 
@@ -457,8 +405,7 @@
 	dw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_BIST_CNTL, BIT(12));
 
 	/* TMDS pattern setup */
-	if (mode->clock > 340000 &&
-	    dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_YUV8_1X24) {
+	if (mode->clock > 340000 && !mode_is_420) {
 		dw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_01,
 				  0);
 		dw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_23,
@@ -476,7 +423,7 @@
 	dw_hdmi->data->top_write(dw_hdmi, HDMITX_TOP_TMDS_CLK_PTTN_CNTL, 0x2);
 
 	/* Setup PHY parameters */
-	meson_hdmi_phy_setup_mode(dw_hdmi, mode);
+	meson_hdmi_phy_setup_mode(dw_hdmi, mode, mode_is_420);
 
 	/* Setup PHY */
 	regmap_update_bits(priv->hhi, HHI_HDMI_PHY_CNTL1,
@@ -622,214 +569,15 @@
 		dw_hdmi_setup_rx_sense(dw_hdmi->hdmi, hpd_connected,
 				       hpd_connected);
 
-		drm_helper_hpd_irq_event(dw_hdmi->encoder.dev);
+		drm_helper_hpd_irq_event(dw_hdmi->bridge->dev);
+		drm_bridge_hpd_notify(dw_hdmi->bridge,
+				      hpd_connected ? connector_status_connected
+						    : connector_status_disconnected);
 	}
 
 	return IRQ_HANDLED;
 }
 
-static enum drm_mode_status
-dw_hdmi_mode_valid(struct dw_hdmi *hdmi, void *data,
-		   const struct drm_display_info *display_info,
-		   const struct drm_display_mode *mode)
-{
-	struct meson_dw_hdmi *dw_hdmi = data;
-	struct meson_drm *priv = dw_hdmi->priv;
-	bool is_hdmi2_sink = display_info->hdmi.scdc.supported;
-	unsigned int phy_freq;
-	unsigned int vclk_freq;
-	unsigned int venc_freq;
-	unsigned int hdmi_freq;
-	int vic = drm_match_cea_mode(mode);
-	enum drm_mode_status status;
-
-	DRM_DEBUG_DRIVER("Modeline " DRM_MODE_FMT "\n", DRM_MODE_ARG(mode));
-
-	/* If sink does not support 540MHz, reject the non-420 HDMI2 modes */
-	if (display_info->max_tmds_clock &&
-	    mode->clock > display_info->max_tmds_clock &&
-	    !drm_mode_is_420_only(display_info, mode) &&
-	    !drm_mode_is_420_also(display_info, mode))
-		return MODE_BAD;
-
-	/* Check against non-VIC supported modes */
-	if (!vic) {
-		status = meson_venc_hdmi_supported_mode(mode);
-		if (status != MODE_OK)
-			return status;
-
-		return meson_vclk_dmt_supported_freq(priv, mode->clock);
-	/* Check against supported VIC modes */
-	} else if (!meson_venc_hdmi_supported_vic(vic))
-		return MODE_BAD;
-
-	vclk_freq = mode->clock;
-
-	/* For 420, pixel clock is half unlike venc clock */
-	if (drm_mode_is_420_only(display_info, mode) ||
-	    (!is_hdmi2_sink &&
-	     drm_mode_is_420_also(display_info, mode)))
-		vclk_freq /= 2;
-
-	/* TMDS clock is pixel_clock * 10 */
-	phy_freq = vclk_freq * 10;
-
-	/* 480i/576i needs global pixel doubling */
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		vclk_freq *= 2;
-
-	venc_freq = vclk_freq;
-	hdmi_freq = vclk_freq;
-
-	/* VENC double pixels for 1080i, 720p and YUV420 modes */
-	if (meson_venc_hdmi_venc_repeat(vic) ||
-	    drm_mode_is_420_only(display_info, mode) ||
-	    (!is_hdmi2_sink &&
-	     drm_mode_is_420_also(display_info, mode)))
-		venc_freq *= 2;
-
-	vclk_freq = max(venc_freq, hdmi_freq);
-
-	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
-		venc_freq /= 2;
-
-	dev_dbg(dw_hdmi->dev, "%s: vclk:%d phy=%d venc=%d hdmi=%d\n",
-		__func__, phy_freq, vclk_freq, venc_freq, hdmi_freq);
-
-	return meson_vclk_vic_supported_freq(priv, phy_freq, vclk_freq);
-}
-
-/* Encoder */
-
-static const u32 meson_dw_hdmi_out_bus_fmts[] = {
-	MEDIA_BUS_FMT_YUV8_1X24,
-	MEDIA_BUS_FMT_UYYVYY8_0_5X24,
-};
-
-static void meson_venc_hdmi_encoder_destroy(struct drm_encoder *encoder)
-{
-	drm_encoder_cleanup(encoder);
-}
-
-static const struct drm_encoder_funcs meson_venc_hdmi_encoder_funcs = {
-	.destroy        = meson_venc_hdmi_encoder_destroy,
-};
-
-static u32 *
-meson_venc_hdmi_encoder_get_inp_bus_fmts(struct drm_bridge *bridge,
-					struct drm_bridge_state *bridge_state,
-					struct drm_crtc_state *crtc_state,
-					struct drm_connector_state *conn_state,
-					u32 output_fmt,
-					unsigned int *num_input_fmts)
-{
-	u32 *input_fmts = NULL;
-	int i;
-
-	*num_input_fmts = 0;
-
-	for (i = 0 ; i < ARRAY_SIZE(meson_dw_hdmi_out_bus_fmts) ; ++i) {
-		if (output_fmt == meson_dw_hdmi_out_bus_fmts[i]) {
-			*num_input_fmts = 1;
-			input_fmts = kcalloc(*num_input_fmts,
-					     sizeof(*input_fmts),
-					     GFP_KERNEL);
-			if (!input_fmts)
-				return NULL;
-
-			input_fmts[0] = output_fmt;
-
-			break;
-		}
-	}
-
-	return input_fmts;
-}
-
-static int meson_venc_hdmi_encoder_atomic_check(struct drm_bridge *bridge,
-					struct drm_bridge_state *bridge_state,
-					struct drm_crtc_state *crtc_state,
-					struct drm_connector_state *conn_state)
-{
-	struct meson_dw_hdmi *dw_hdmi = bridge_to_meson_dw_hdmi(bridge);
-
-	dw_hdmi->output_bus_fmt = bridge_state->output_bus_cfg.format;
-
-	DRM_DEBUG_DRIVER("output_bus_fmt %lx\n", dw_hdmi->output_bus_fmt);
-
-	return 0;
-}
-
-static void meson_venc_hdmi_encoder_disable(struct drm_bridge *bridge)
-{
-	struct meson_dw_hdmi *dw_hdmi = bridge_to_meson_dw_hdmi(bridge);
-	struct meson_drm *priv = dw_hdmi->priv;
-
-	DRM_DEBUG_DRIVER("\n");
-
-	writel_bits_relaxed(0x3, 0,
-			    priv->io_base + _REG(VPU_HDMI_SETTING));
-
-	writel_relaxed(0, priv->io_base + _REG(ENCI_VIDEO_EN));
-	writel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));
-}
-
-static void meson_venc_hdmi_encoder_enable(struct drm_bridge *bridge)
-{
-	struct meson_dw_hdmi *dw_hdmi = bridge_to_meson_dw_hdmi(bridge);
-	struct meson_drm *priv = dw_hdmi->priv;
-
-	DRM_DEBUG_DRIVER("%s\n", priv->venc.hdmi_use_enci ? "VENCI" : "VENCP");
-
-	if (priv->venc.hdmi_use_enci)
-		writel_relaxed(1, priv->io_base + _REG(ENCI_VIDEO_EN));
-	else
-		writel_relaxed(1, priv->io_base + _REG(ENCP_VIDEO_EN));
-}
-
-static void meson_venc_hdmi_encoder_mode_set(struct drm_bridge *bridge,
-				   const struct drm_display_mode *mode,
-				   const struct drm_display_mode *adjusted_mode)
-{
-	struct meson_dw_hdmi *dw_hdmi = bridge_to_meson_dw_hdmi(bridge);
-	struct meson_drm *priv = dw_hdmi->priv;
-	int vic = drm_match_cea_mode(mode);
-	unsigned int ycrcb_map = VPU_HDMI_OUTPUT_CBYCR;
-	bool yuv420_mode = false;
-
-	DRM_DEBUG_DRIVER("\"%s\" vic %d\n", mode->name, vic);
-
-	if (dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24) {
-		ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
-		yuv420_mode = true;
-	}
-
-	/* VENC + VENC-DVI Mode setup */
-	meson_venc_hdmi_mode_set(priv, vic, ycrcb_map, yuv420_mode, mode);
-
-	/* VCLK Set clock */
-	dw_hdmi_set_vclk(dw_hdmi, mode);
-
-	if (dw_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
-		/* Setup YUV420 to HDMI-TX, no 10bit diphering */
-		writel_relaxed(2 | (2 << 2),
-			       priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
-	else
-		/* Setup YUV444 to HDMI-TX, no 10bit diphering */
-		writel_relaxed(0, priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
-}
-
-static const struct drm_bridge_funcs meson_venc_hdmi_encoder_bridge_funcs = {
-	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
-	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
-	.atomic_get_input_bus_fmts = meson_venc_hdmi_encoder_get_inp_bus_fmts,
-	.atomic_reset = drm_atomic_helper_bridge_reset,
-	.atomic_check = meson_venc_hdmi_encoder_atomic_check,
-	.enable	= meson_venc_hdmi_encoder_enable,
-	.disable = meson_venc_hdmi_encoder_disable,
-	.mode_set = meson_venc_hdmi_encoder_mode_set,
-};
-
 /* DW HDMI Regmap */
 
 static int meson_dw_hdmi_reg_read(void *context, unsigned int reg,
@@ -876,28 +624,6 @@
 	.dwc_write = dw_hdmi_g12a_dwc_write,
 };
 
-static bool meson_hdmi_connector_is_available(struct device *dev)
-{
-	struct device_node *ep, *remote;
-
-	/* HDMI Connector is on the second port, first endpoint */
-	ep = of_graph_get_endpoint_by_regs(dev->of_node, 1, 0);
-	if (!ep)
-		return false;
-
-	/* If the endpoint node exists, consider it enabled */
-	remote = of_graph_get_remote_port(ep);
-	if (remote) {
-		of_node_put(ep);
-		return true;
-	}
-
-	of_node_put(ep);
-	of_node_put(remote);
-
-	return false;
-}
-
 static void meson_dw_hdmi_init(struct meson_dw_hdmi *meson_dw_hdmi)
 {
 	struct meson_drm *priv = meson_dw_hdmi->priv;
@@ -976,19 +702,11 @@
 	struct drm_device *drm = data;
 	struct meson_drm *priv = drm->dev_private;
 	struct dw_hdmi_plat_data *dw_plat_data;
-	struct drm_bridge *next_bridge;
-	struct drm_encoder *encoder;
-	struct resource *res;
 	int irq;
 	int ret;
 
 	DRM_DEBUG_DRIVER("\n");
 
-	if (!meson_hdmi_connector_is_available(dev)) {
-		dev_info(drm->dev, "HDMI Output connector not available\n");
-		return -ENODEV;
-	}
-
 	match = of_device_get_match_data(&pdev->dev);
 	if (!match) {
 		dev_err(&pdev->dev, "failed to get match data\n");
@@ -1004,7 +722,6 @@
 	meson_dw_hdmi->dev = dev;
 	meson_dw_hdmi->data = match;
 	dw_plat_data = &meson_dw_hdmi->dw_plat_data;
-	encoder = &meson_dw_hdmi->encoder;
 
 	meson_dw_hdmi->hdmi_supply = devm_regulator_get_optional(dev, "hdmi");
 	if (IS_ERR(meson_dw_hdmi->hdmi_supply)) {
@@ -1042,8 +759,7 @@
 		return PTR_ERR(meson_dw_hdmi->hdmitx_phy);
 	}
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	meson_dw_hdmi->hdmitx = devm_ioremap_resource(dev, res);
+	meson_dw_hdmi->hdmitx = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(meson_dw_hdmi->hdmitx))
 		return PTR_ERR(meson_dw_hdmi->hdmitx);
 
@@ -1076,33 +792,18 @@
 		return ret;
 	}
 
-	/* Encoder */
-
-	ret = drm_encoder_init(drm, encoder, &meson_venc_hdmi_encoder_funcs,
-			       DRM_MODE_ENCODER_TMDS, "meson_hdmi");
-	if (ret) {
-		dev_err(priv->dev, "Failed to init HDMI encoder\n");
-		return ret;
-	}
-
-	meson_dw_hdmi->bridge.funcs = &meson_venc_hdmi_encoder_bridge_funcs;
-	drm_bridge_attach(encoder, &meson_dw_hdmi->bridge, NULL, 0);
-
-	encoder->possible_crtcs = BIT(0);
-
 	meson_dw_hdmi_init(meson_dw_hdmi);
 
-	DRM_DEBUG_DRIVER("encoder initialized\n");
-
 	/* Bridge / Connector */
 
 	dw_plat_data->priv_data = meson_dw_hdmi;
-	dw_plat_data->mode_valid = dw_hdmi_mode_valid;
 	dw_plat_data->phy_ops = &meson_dw_hdmi_phy_ops;
 	dw_plat_data->phy_name = "meson_dw_hdmi_phy";
 	dw_plat_data->phy_data = meson_dw_hdmi;
 	dw_plat_data->input_bus_encoding = V4L2_YCBCR_ENC_709;
 	dw_plat_data->ycbcr_420_allowed = true;
+	dw_plat_data->disable_cec = true;
+	dw_plat_data->output_port = 1;
 
 	if (dw_hdmi_is_compatible(meson_dw_hdmi, "amlogic,meson-gxl-dw-hdmi") ||
 	    dw_hdmi_is_compatible(meson_dw_hdmi, "amlogic,meson-gxm-dw-hdmi") ||
@@ -1111,15 +812,11 @@
 
 	platform_set_drvdata(pdev, meson_dw_hdmi);
 
-	meson_dw_hdmi->hdmi = dw_hdmi_probe(pdev,
-					    &meson_dw_hdmi->dw_plat_data);
+	meson_dw_hdmi->hdmi = dw_hdmi_probe(pdev, &meson_dw_hdmi->dw_plat_data);
 	if (IS_ERR(meson_dw_hdmi->hdmi))
 		return PTR_ERR(meson_dw_hdmi->hdmi);
 
-	next_bridge = of_drm_find_bridge(pdev->dev.of_node);
-	if (next_bridge)
-		drm_bridge_attach(encoder, next_bridge,
-				  &meson_dw_hdmi->bridge, 0);
+	meson_dw_hdmi->bridge = of_drm_find_bridge(pdev->dev.of_node);
 
 	DRM_DEBUG_DRIVER("HDMI controller initialized\n");
 
diff -Naur a/drivers/gpu/drm/meson/meson_dw_mipi_dsi.c b/drivers/gpu/drm/meson/meson_dw_mipi_dsi.c
--- a/drivers/gpu/drm/meson/meson_dw_mipi_dsi.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_dw_mipi_dsi.c	2022-05-31 11:56:47.733259325 +0800
@@ -0,0 +1,364 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/reset.h>
+#include <linux/phy/phy.h>
+#include <linux/bitfield.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/bridge/dw_mipi_dsi.h>
+#include <drm/drm_mipi_dsi.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_device.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_print.h>
+
+#include "meson_drv.h"
+#include "meson_dw_mipi_dsi.h"
+#include "meson_registers.h"
+#include "meson_venc.h"
+
+#define DRIVER_NAME "meson-dw-mipi-dsi"
+#define DRIVER_DESC "Amlogic Meson MIPI-DSI DRM driver"
+
+struct meson_dw_mipi_dsi {
+	struct meson_drm *priv;
+	struct device *dev;
+	void __iomem *base;
+	struct phy *phy;
+	union phy_configure_opts phy_opts;
+	struct dw_mipi_dsi *dmd;
+	struct dw_mipi_dsi_plat_data pdata;
+	struct mipi_dsi_device *dsi_device;
+	const struct drm_display_mode *mode;
+	struct clk *px_clk;
+};
+
+#define encoder_to_meson_dw_mipi_dsi(x) \
+	container_of(x, struct meson_dw_mipi_dsi, encoder)
+
+static void meson_dw_mipi_dsi_hw_init(struct meson_dw_mipi_dsi *mipi_dsi)
+{
+	/* Software reset */
+	writel_bits_relaxed(MIPI_DSI_TOP_SW_RESET_DWC | MIPI_DSI_TOP_SW_RESET_INTR |
+			    MIPI_DSI_TOP_SW_RESET_DPI | MIPI_DSI_TOP_SW_RESET_TIMING,
+			    MIPI_DSI_TOP_SW_RESET_DWC | MIPI_DSI_TOP_SW_RESET_INTR |
+			    MIPI_DSI_TOP_SW_RESET_DPI | MIPI_DSI_TOP_SW_RESET_TIMING,
+			    mipi_dsi->base + MIPI_DSI_TOP_SW_RESET);
+	writel_bits_relaxed(MIPI_DSI_TOP_SW_RESET_DWC | MIPI_DSI_TOP_SW_RESET_INTR |
+			    MIPI_DSI_TOP_SW_RESET_DPI | MIPI_DSI_TOP_SW_RESET_TIMING,
+			    0, mipi_dsi->base + MIPI_DSI_TOP_SW_RESET);
+
+	/* Enable clocks */
+	writel_bits_relaxed(MIPI_DSI_TOP_CLK_SYSCLK_EN | MIPI_DSI_TOP_CLK_PIXCLK_EN,
+			    MIPI_DSI_TOP_CLK_SYSCLK_EN | MIPI_DSI_TOP_CLK_PIXCLK_EN,
+			    mipi_dsi->base + MIPI_DSI_TOP_CLK_CNTL);
+
+	/* Take memory out of power down */
+	writel_relaxed(0, mipi_dsi->base + MIPI_DSI_TOP_MEM_PD);
+}
+
+static int dw_mipi_dsi_phy_init(void *priv_data)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi = priv_data;
+	unsigned int dpi_data_format, venc_data_width;
+	int ret;
+
+	ret = clk_set_rate(mipi_dsi->px_clk, mipi_dsi->phy_opts.mipi_dphy.hs_clk_rate);
+	if (ret) {
+		pr_err("Failed to set DSI PLL rate %lu\n",
+		       mipi_dsi->phy_opts.mipi_dphy.hs_clk_rate);
+
+		return ret;
+	}
+
+	switch (mipi_dsi->dsi_device->format) {
+	case MIPI_DSI_FMT_RGB888:
+		dpi_data_format = DPI_COLOR_24BIT;
+		venc_data_width = VENC_IN_COLOR_24B;
+		break;
+	case MIPI_DSI_FMT_RGB666:
+		dpi_data_format = DPI_COLOR_18BIT_CFG_2;
+		venc_data_width = VENC_IN_COLOR_18B;
+		break;
+	case MIPI_DSI_FMT_RGB666_PACKED:
+	case MIPI_DSI_FMT_RGB565:
+		return -EINVAL;
+	};
+
+	/* Configure color format for DPI register */
+	writel_relaxed(FIELD_PREP(MIPI_DSI_TOP_DPI_COLOR_MODE, dpi_data_format) |
+		       FIELD_PREP(MIPI_DSI_TOP_IN_COLOR_MODE, venc_data_width) |
+		       FIELD_PREP(MIPI_DSI_TOP_COMP2_SEL, 2) |
+		       FIELD_PREP(MIPI_DSI_TOP_COMP1_SEL, 1) |
+		       FIELD_PREP(MIPI_DSI_TOP_COMP0_SEL, 0) |
+		       (mipi_dsi->mode->flags & DRM_MODE_FLAG_NHSYNC ?
+				0 : MIPI_DSI_TOP_HSYNC_INVERT) |
+		       (mipi_dsi->mode->flags & DRM_MODE_FLAG_NVSYNC ?
+				0 : MIPI_DSI_TOP_VSYNC_INVERT),
+			mipi_dsi->base + MIPI_DSI_TOP_CNTL);
+
+	return phy_configure(mipi_dsi->phy, &mipi_dsi->phy_opts);
+}
+
+static void dw_mipi_dsi_phy_power_on(void *priv_data)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi = priv_data;
+
+	if (phy_power_on(mipi_dsi->phy))
+		dev_warn(mipi_dsi->dev, "Failed to power on PHY\n");
+}
+
+static void dw_mipi_dsi_phy_power_off(void *priv_data)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi = priv_data;
+
+	if (phy_power_off(mipi_dsi->phy))
+		dev_warn(mipi_dsi->dev, "Failed to power off PHY\n");
+}
+
+static int
+dw_mipi_dsi_get_lane_mbps(void *priv_data, const struct drm_display_mode *mode,
+			  unsigned long mode_flags, u32 lanes, u32 format,
+			  unsigned int *lane_mbps)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi = priv_data;
+	int bpp;
+
+	mipi_dsi->mode = mode;
+
+	bpp = mipi_dsi_pixel_format_to_bpp(mipi_dsi->dsi_device->format);
+
+	phy_mipi_dphy_get_default_config(mode->clock * 1000,
+					 bpp, mipi_dsi->dsi_device->lanes,
+					 &mipi_dsi->phy_opts.mipi_dphy);
+
+	// UNIONMAN add: Round to 800MHz(needed by waveshare panel) (FIXME)
+	if (mipi_dsi->phy_opts.mipi_dphy.hs_clk_rate > 600*1000000) {
+		mipi_dsi->phy_opts.mipi_dphy.hs_clk_rate = max(800 * 1000000, 
+				mipi_dsi->phy_opts.mipi_dphy.hs_clk_rate); 
+	}
+	
+	*lane_mbps = mipi_dsi->phy_opts.mipi_dphy.hs_clk_rate / 1000000;
+
+	return 0;
+}
+
+static int
+dw_mipi_dsi_phy_get_timing(void *priv_data, unsigned int lane_mbps,
+			   struct dw_mipi_dsi_dphy_timing *timing)
+{
+	/* TOFIX handle other cases */
+
+	timing->clk_lp2hs = 37;
+	timing->clk_hs2lp = 135;
+	timing->data_lp2hs = 50;
+	timing->data_hs2lp = 3;
+
+	return 0;
+}
+
+static int
+dw_mipi_dsi_get_esc_clk_rate(void *priv_data, unsigned int *esc_clk_rate)
+{
+	*esc_clk_rate = 4; /* Mhz */
+
+	return 0;
+}
+
+static const struct dw_mipi_dsi_phy_ops meson_dw_mipi_dsi_phy_ops = {
+	.init = dw_mipi_dsi_phy_init,
+	.power_on = dw_mipi_dsi_phy_power_on,
+	.power_off = dw_mipi_dsi_phy_power_off,
+	.get_lane_mbps = dw_mipi_dsi_get_lane_mbps,
+	.get_timing = dw_mipi_dsi_phy_get_timing,
+	.get_esc_clk_rate = dw_mipi_dsi_get_esc_clk_rate,
+};
+
+static int meson_dw_mipi_dsi_bind(struct device *dev, struct device *master, void *data)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi = dev_get_drvdata(dev);
+	struct drm_device *drm = data;
+	struct meson_drm *priv = drm->dev_private;
+
+	/* Check before if we are supposed to have a sub-device... */
+	if (!mipi_dsi->dsi_device) {
+		dw_mipi_dsi_remove(mipi_dsi->dmd);
+		return -EPROBE_DEFER;
+	}
+
+	mipi_dsi->priv = priv;
+
+	meson_dw_mipi_dsi_hw_init(mipi_dsi);
+
+	return 0;
+}
+
+static const struct component_ops meson_dw_mipi_dsi_ops = {
+	.bind	= meson_dw_mipi_dsi_bind,
+};
+
+static int meson_dw_mipi_dsi_host_attach(void *priv_data,
+					 struct mipi_dsi_device *device)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi = priv_data;
+
+	mipi_dsi->dsi_device = device;
+
+	switch (device->format) {
+	case MIPI_DSI_FMT_RGB888:
+		break;
+	case MIPI_DSI_FMT_RGB666:
+		break;
+	case MIPI_DSI_FMT_RGB666_PACKED:
+	case MIPI_DSI_FMT_RGB565:
+		dev_err(mipi_dsi->dev, "invalid pixel format %d\n", device->format);
+		return -EINVAL;
+	};
+
+	return phy_init(mipi_dsi->phy);
+}
+
+static int meson_dw_mipi_dsi_host_detach(void *priv_data,
+					 struct mipi_dsi_device *device)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi = priv_data;
+
+	if (device == mipi_dsi->dsi_device)
+		mipi_dsi->dsi_device = NULL;
+	else
+		return -EINVAL;
+
+	return phy_exit(mipi_dsi->phy);
+}
+
+static const struct dw_mipi_dsi_host_ops meson_dw_mipi_dsi_host_ops = {
+	.attach = meson_dw_mipi_dsi_host_attach,
+	.detach = meson_dw_mipi_dsi_host_detach,
+};
+
+static int meson_dw_mipi_dsi_probe(struct platform_device *pdev)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi;
+	struct reset_control *top_rst;
+	struct resource *res;
+	int ret;
+
+	mipi_dsi = devm_kzalloc(&pdev->dev, sizeof(*mipi_dsi), GFP_KERNEL);
+	if (!mipi_dsi)
+		return -ENOMEM;
+
+	mipi_dsi->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mipi_dsi->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(mipi_dsi->base))
+		return PTR_ERR(mipi_dsi->base);
+
+	mipi_dsi->phy = devm_phy_get(&pdev->dev, "dphy");
+	if (IS_ERR(mipi_dsi->phy)) {
+		ret = PTR_ERR(mipi_dsi->phy);
+		dev_err(&pdev->dev, "failed to get mipi dphy: %d\n", ret);
+		return ret;
+	}
+
+	mipi_dsi->px_clk = devm_clk_get(&pdev->dev, "px_clk");
+	if (IS_ERR(mipi_dsi->px_clk)) {
+		dev_err(&pdev->dev, "Unable to get PLL clk\n");
+		return PTR_ERR(mipi_dsi->px_clk);
+	}
+
+	/*
+	 * We use a TOP reset signal because the APB reset signal
+	 * is handled by the TOP control registers.
+	 */
+	top_rst = devm_reset_control_get_exclusive(&pdev->dev, "top");
+	if (IS_ERR(top_rst)) {
+		ret = PTR_ERR(top_rst);
+
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Unable to get reset control: %d\n", ret);
+
+		return ret;
+	}
+
+	ret = clk_prepare_enable(mipi_dsi->px_clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Unable to prepare/enable PX clock\n");
+		return ret;
+	}
+
+	reset_control_assert(top_rst);
+	usleep_range(10, 20);
+	reset_control_deassert(top_rst);
+
+	/* MIPI DSI Controller */
+
+	mipi_dsi->pdata.base = mipi_dsi->base;
+	mipi_dsi->pdata.max_data_lanes = 4;
+	mipi_dsi->pdata.phy_ops = &meson_dw_mipi_dsi_phy_ops;
+	mipi_dsi->pdata.host_ops = &meson_dw_mipi_dsi_host_ops;
+	mipi_dsi->pdata.priv_data = mipi_dsi;
+	platform_set_drvdata(pdev, mipi_dsi);
+
+	mipi_dsi->dmd = dw_mipi_dsi_probe(pdev, &mipi_dsi->pdata);
+	if (IS_ERR(mipi_dsi->dmd)) {
+		ret = PTR_ERR(mipi_dsi->dmd);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev,
+				"Failed to probe dw_mipi_dsi: %d\n", ret);
+		goto err_clkdisable;
+	}
+
+	return component_add(mipi_dsi->dev, &meson_dw_mipi_dsi_ops);
+
+err_clkdisable:
+	clk_disable_unprepare(mipi_dsi->px_clk);
+
+	return ret;
+}
+
+static int meson_dw_mipi_dsi_remove(struct platform_device *pdev)
+{
+	struct meson_dw_mipi_dsi *mipi_dsi = dev_get_drvdata(&pdev->dev);
+
+	dw_mipi_dsi_remove(mipi_dsi->dmd);
+
+	component_del(mipi_dsi->dev, &meson_dw_mipi_dsi_ops);
+
+	clk_disable_unprepare(mipi_dsi->px_clk);
+
+	return 0;
+}
+
+static const struct of_device_id meson_dw_mipi_dsi_of_table[] = {
+	{ .compatible = "amlogic,meson-g12a-dw-mipi-dsi", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, meson_dw_mipi_dsi_of_table);
+
+static struct platform_driver meson_dw_mipi_dsi_platform_driver = {
+	.probe		= meson_dw_mipi_dsi_probe,
+	.remove		= meson_dw_mipi_dsi_remove,
+	.driver		= {
+		.name		= DRIVER_NAME,
+		.of_match_table	= meson_dw_mipi_dsi_of_table,
+	},
+};
+module_platform_driver(meson_dw_mipi_dsi_platform_driver);
+
+MODULE_AUTHOR("Neil Armstrong <narmstrong@baylibre.com>");
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/gpu/drm/meson/meson_dw_mipi_dsi.h b/drivers/gpu/drm/meson/meson_dw_mipi_dsi.h
--- a/drivers/gpu/drm/meson/meson_dw_mipi_dsi.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_dw_mipi_dsi.h	2022-05-31 11:56:47.733259325 +0800
@@ -0,0 +1,160 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2020 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __MESON_DW_MIPI_DSI_H
+#define __MESON_DW_MIPI_DSI_H
+
+/* Top-level registers */
+/* [31: 4]    Reserved.     Default 0.
+ *     [3] RW timing_rst_n: Default 1.
+ *		1=Assert SW reset of timing feature.   0=Release reset.
+ *     [2] RW dpi_rst_n: Default 1.
+ *		1=Assert SW reset on mipi_dsi_host_dpi block.   0=Release reset.
+ *     [1] RW intr_rst_n: Default 1.
+ *		1=Assert SW reset on mipi_dsi_host_intr block.  0=Release reset.
+ *     [0] RW dwc_rst_n:  Default 1.
+ *		1=Assert SW reset on IP core.   0=Release reset.
+ */
+#define MIPI_DSI_TOP_SW_RESET                      0x3c0
+
+#define MIPI_DSI_TOP_SW_RESET_DWC	BIT(0)
+#define MIPI_DSI_TOP_SW_RESET_INTR	BIT(1)
+#define MIPI_DSI_TOP_SW_RESET_DPI	BIT(2)
+#define MIPI_DSI_TOP_SW_RESET_TIMING	BIT(3)
+
+/* [31: 5] Reserved.   Default 0.
+ *     [4] RW manual_edpihalt: Default 0.
+ *		1=Manual suspend VencL; 0=do not suspend VencL.
+ *     [3] RW auto_edpihalt_en: Default 0.
+ *		1=Enable IP's edpihalt signal to suspend VencL;
+ *		0=IP's edpihalt signal does not affect VencL.
+ *     [2] RW clock_freerun: Apply to auto-clock gate only. Default 0.
+ *		0=Default, use auto-clock gating to save power;
+ *		1=use free-run clock, disable auto-clock gating, for debug mode.
+ *     [1] RW enable_pixclk: A manual clock gate option, due to DWC IP does not
+ *		have auto-clock gating. 1=Enable pixclk.      Default 0.
+ *     [0] RW enable_sysclk: A manual clock gate option, due to DWC IP does not
+ *		have auto-clock gating. 1=Enable sysclk.      Default 0.
+ */
+#define MIPI_DSI_TOP_CLK_CNTL                      0x3c4
+
+#define MIPI_DSI_TOP_CLK_SYSCLK_EN	BIT(0)
+#define MIPI_DSI_TOP_CLK_PIXCLK_EN	BIT(1)
+
+/* [31:24]    Reserved. Default 0.
+ * [23:20] RW dpi_color_mode: Define DPI pixel format. Default 0.
+ *		0=16-bit RGB565 config 1;
+ *		1=16-bit RGB565 config 2;
+ *		2=16-bit RGB565 config 3;
+ *		3=18-bit RGB666 config 1;
+ *		4=18-bit RGB666 config 2;
+ *		5=24-bit RGB888;
+ *		6=20-bit YCbCr 4:2:2;
+ *		7=24-bit YCbCr 4:2:2;
+ *		8=16-bit YCbCr 4:2:2;
+ *		9=30-bit RGB;
+ *		10=36-bit RGB;
+ *		11=12-bit YCbCr 4:2:0.
+ *    [19] Reserved. Default 0.
+ * [18:16] RW in_color_mode:  Define VENC data width. Default 0.
+ *		0=30-bit pixel;
+ *		1=24-bit pixel;
+ *		2=18-bit pixel, RGB666;
+ *		3=16-bit pixel, RGB565.
+ * [15:14] RW chroma_subsample: Define method of chroma subsampling. Default 0.
+ *		Applicable to YUV422 or YUV420 only.
+ *		0=Use even pixel's chroma;
+ *		1=Use odd pixel's chroma;
+ *		2=Use averaged value between even and odd pair.
+ * [13:12] RW comp2_sel:  Select which component to be Cr or B: Default 2.
+ *		0=comp0; 1=comp1; 2=comp2.
+ * [11:10] RW comp1_sel:  Select which component to be Cb or G: Default 1.
+ *		0=comp0; 1=comp1; 2=comp2.
+ *  [9: 8] RW comp0_sel:  Select which component to be Y  or R: Default 0.
+ *		0=comp0; 1=comp1; 2=comp2.
+ *     [7]    Reserved. Default 0.
+ *     [6] RW de_pol:  Default 0.
+ *		If DE input is active low, set to 1 to invert to active high.
+ *     [5] RW hsync_pol: Default 0.
+ *		If HS input is active low, set to 1 to invert to active high.
+ *     [4] RW vsync_pol: Default 0.
+ *		If VS input is active low, set to 1 to invert to active high.
+ *     [3] RW dpicolorm: Signal to IP.   Default 0.
+ *     [2] RW dpishutdn: Signal to IP.   Default 0.
+ *     [1]    Reserved.  Default 0.
+ *     [0]    Reserved.  Default 0.
+ */
+#define MIPI_DSI_TOP_CNTL                          0x3c8
+
+/* VENC data width */
+#define VENC_IN_COLOR_30B   0x0
+#define VENC_IN_COLOR_24B   0x1
+#define VENC_IN_COLOR_18B   0x2
+#define VENC_IN_COLOR_16B   0x3
+
+/* DPI pixel format */
+#define DPI_COLOR_16BIT_CFG_1		0
+#define DPI_COLOR_16BIT_CFG_2		1
+#define DPI_COLOR_16BIT_CFG_3		2
+#define DPI_COLOR_18BIT_CFG_1		3
+#define DPI_COLOR_18BIT_CFG_2		4
+#define DPI_COLOR_24BIT			5
+#define DPI_COLOR_20BIT_YCBCR_422	6
+#define DPI_COLOR_24BIT_YCBCR_422	7
+#define DPI_COLOR_16BIT_YCBCR_422	8
+#define DPI_COLOR_30BIT			9
+#define DPI_COLOR_36BIT			10
+#define DPI_COLOR_12BIT_YCBCR_420	11
+
+#define MIPI_DSI_TOP_DPI_COLOR_MODE	GENMASK(23, 20)
+#define MIPI_DSI_TOP_IN_COLOR_MODE	GENMASK(18, 16)
+#define MIPI_DSI_TOP_CHROMA_SUBSAMPLE	GENMASK(15, 14)
+#define MIPI_DSI_TOP_COMP2_SEL		GENMASK(13, 12)
+#define MIPI_DSI_TOP_COMP1_SEL		GENMASK(11, 10)
+#define MIPI_DSI_TOP_COMP0_SEL		GENMASK(9, 8)
+#define MIPI_DSI_TOP_DE_INVERT		BIT(6)
+#define MIPI_DSI_TOP_HSYNC_INVERT	BIT(5)
+#define MIPI_DSI_TOP_VSYNC_INVERT	BIT(4)
+#define MIPI_DSI_TOP_DPICOLORM		BIT(3)
+#define MIPI_DSI_TOP_DPISHUTDN		BIT(2)
+
+#define MIPI_DSI_TOP_SUSPEND_CNTL                  0x3cc
+#define MIPI_DSI_TOP_SUSPEND_LINE                  0x3d0
+#define MIPI_DSI_TOP_SUSPEND_PIX                   0x3d4
+#define MIPI_DSI_TOP_MEAS_CNTL                     0x3d8
+/* [0] R  stat_edpihalt:  edpihalt signal from IP.    Default 0. */
+#define MIPI_DSI_TOP_STAT                          0x3dc
+#define MIPI_DSI_TOP_MEAS_STAT_TE0                 0x3e0
+#define MIPI_DSI_TOP_MEAS_STAT_TE1                 0x3e4
+#define MIPI_DSI_TOP_MEAS_STAT_VS0                 0x3e8
+#define MIPI_DSI_TOP_MEAS_STAT_VS1                 0x3ec
+/* [31:16] RW intr_stat/clr. Default 0.
+ *		For each bit, read as this interrupt level status,
+ *		write 1 to clear.
+ * [31:22] Reserved
+ * [   21] stat/clr of eof interrupt
+ * [   21] vde_fall interrupt
+ * [   19] stat/clr of de_rise interrupt
+ * [   18] stat/clr of vs_fall interrupt
+ * [   17] stat/clr of vs_rise interrupt
+ * [   16] stat/clr of dwc_edpite interrupt
+ * [15: 0] RW intr_enable. Default 0.
+ *		For each bit, 1=enable this interrupt, 0=disable.
+ *	[15: 6] Reserved
+ *	[    5] eof interrupt
+ *	[    4] de_fall interrupt
+ *	[    3] de_rise interrupt
+ *	[    2] vs_fall interrupt
+ *	[    1] vs_rise interrupt
+ *	[    0] dwc_edpite interrupt
+ */
+#define MIPI_DSI_TOP_INTR_CNTL_STAT                0x3f0
+// 31: 2    Reserved.   Default 0.
+//  1: 0 RW mem_pd.     Default 3.
+#define MIPI_DSI_TOP_MEM_PD                        0x3f4
+
+#endif /* __MESON_DW_MIPI_DSI_H */
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_cvbs.c b/drivers/gpu/drm/meson/meson_encoder_cvbs.c
--- a/drivers/gpu/drm/meson/meson_encoder_cvbs.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_encoder_cvbs.c	2022-05-31 11:56:47.733259325 +0800
@@ -0,0 +1,284 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ * Copyright (C) 2014 Endless Mobile
+ *
+ * Written by:
+ *     Jasper St. Pierre <jstpierre@mecheye.net>
+ */
+
+#include <linux/export.h>
+#include <linux/of_graph.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_bridge_connector.h>
+#include <drm/drm_device.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+
+#include "meson_registers.h"
+#include "meson_vclk.h"
+#include "meson_encoder_cvbs.h"
+
+/* HHI VDAC Registers */
+#define HHI_VDAC_CNTL0		0x2F4 /* 0xbd offset in data sheet */
+#define HHI_VDAC_CNTL0_G12A	0x2EC /* 0xbd offset in data sheet */
+#define HHI_VDAC_CNTL1		0x2F8 /* 0xbe offset in data sheet */
+#define HHI_VDAC_CNTL1_G12A	0x2F0 /* 0xbe offset in data sheet */
+
+struct meson_encoder_cvbs {
+	struct drm_encoder	encoder;
+	struct drm_bridge	bridge;
+	struct drm_bridge	*next_bridge;
+	struct meson_drm	*priv;
+};
+
+#define bridge_to_meson_encoder_cvbs(x) \
+	container_of(x, struct meson_encoder_cvbs, bridge)
+
+/* Supported Modes */
+
+struct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT] = {
+	{ /* PAL */
+		.enci = &meson_cvbs_enci_pal,
+		.mode = {
+			DRM_MODE("720x576i", DRM_MODE_TYPE_DRIVER, 13500,
+				 720, 732, 795, 864, 0, 576, 580, 586, 625, 0,
+				 DRM_MODE_FLAG_INTERLACE),
+			.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,
+		},
+	},
+	{ /* NTSC */
+		.enci = &meson_cvbs_enci_ntsc,
+		.mode = {
+			DRM_MODE("720x480i", DRM_MODE_TYPE_DRIVER, 13500,
+				720, 739, 801, 858, 0, 480, 488, 494, 525, 0,
+				DRM_MODE_FLAG_INTERLACE),
+			.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,
+		},
+	},
+};
+
+static const struct meson_cvbs_mode *
+meson_cvbs_get_mode(const struct drm_display_mode *req_mode)
+{
+	int i;
+
+	for (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {
+		struct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];
+
+		if (drm_mode_match(req_mode, &meson_mode->mode,
+				   DRM_MODE_MATCH_TIMINGS |
+				   DRM_MODE_MATCH_CLOCK |
+				   DRM_MODE_MATCH_FLAGS |
+				   DRM_MODE_MATCH_3D_FLAGS))
+			return meson_mode;
+	}
+
+	return NULL;
+}
+
+static int meson_encoder_cvbs_attach(struct drm_bridge *bridge,
+				     enum drm_bridge_attach_flags flags)
+{
+	struct meson_encoder_cvbs *meson_encoder_cvbs =
+					bridge_to_meson_encoder_cvbs(bridge);
+
+	return drm_bridge_attach(bridge->encoder, meson_encoder_cvbs->next_bridge,
+				 &meson_encoder_cvbs->bridge, flags);
+}
+
+static int meson_encoder_cvbs_get_modes(struct drm_bridge *bridge,
+					struct drm_connector *connector)
+{
+	struct meson_encoder_cvbs *meson_encoder_cvbs =
+					bridge_to_meson_encoder_cvbs(bridge);
+	struct meson_drm *priv = meson_encoder_cvbs->priv;
+	struct drm_display_mode *mode;
+	int i;
+
+	for (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {
+		struct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];
+
+		mode = drm_mode_duplicate(priv->drm, &meson_mode->mode);
+		if (!mode) {
+			dev_err(priv->dev, "Failed to create a new display mode\n");
+			return 0;
+		}
+
+		drm_mode_probed_add(connector, mode);
+	}
+
+	return i;
+}
+
+static int meson_encoder_cvbs_mode_valid(struct drm_bridge *bridge,
+					const struct drm_display_info *display_info,
+					const struct drm_display_mode *mode)
+{
+	if (meson_cvbs_get_mode(mode))
+		return MODE_OK;
+
+	return MODE_BAD;
+}
+
+static int meson_encoder_cvbs_atomic_check(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state)
+{
+	if (meson_cvbs_get_mode(&crtc_state->mode))
+		return 0;
+
+	return -EINVAL;
+}
+
+static void meson_encoder_cvbs_atomic_enable(struct drm_bridge *bridge,
+					     struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_cvbs *encoder_cvbs = bridge_to_meson_encoder_cvbs(bridge);
+	struct drm_atomic_state *state = bridge_state->base.state;
+	struct meson_drm *priv = encoder_cvbs->priv;
+	const struct meson_cvbs_mode *meson_mode;
+	struct drm_connector_state *conn_state;
+	struct drm_crtc_state *crtc_state;
+	struct drm_connector *connector;
+
+	connector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);
+	if (WARN_ON(!connector))
+		return;
+
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (WARN_ON(!conn_state))
+		return;
+
+	crtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);
+	if (WARN_ON(!crtc_state))
+		return;
+
+	meson_mode = meson_cvbs_get_mode(&crtc_state->adjusted_mode);
+	if (WARN_ON(!meson_mode))
+		return;
+
+	meson_venci_cvbs_mode_set(priv, meson_mode->enci);
+
+	/* Setup 27MHz vclk2 for ENCI and VDAC */
+	meson_vclk_setup(priv, MESON_VCLK_TARGET_CVBS,
+			 MESON_VCLK_CVBS, MESON_VCLK_CVBS,
+			 MESON_VCLK_CVBS, MESON_VCLK_CVBS,
+			 true);
+
+	/* VDAC0 source is not from ATV */
+	writel_bits_relaxed(VENC_VDAC_SEL_ATV_DMD, 0,
+			    priv->io_base + _REG(VENC_VDAC_DACSEL0));
+
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {
+		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 1);
+		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);
+	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
+		 meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {
+		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0xf0001);
+		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);
+	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0x906001);
+		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
+	}
+}
+
+static void meson_encoder_cvbs_atomic_disable(struct drm_bridge *bridge,
+					      struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_cvbs *meson_encoder_cvbs =
+					bridge_to_meson_encoder_cvbs(bridge);
+	struct meson_drm *priv = meson_encoder_cvbs->priv;
+
+	/* Disable CVBS VDAC */
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);
+		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
+	} else {
+		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);
+		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);
+	}
+}
+
+static const struct drm_bridge_funcs meson_encoder_cvbs_bridge_funcs = {
+	.attach = meson_encoder_cvbs_attach,
+	.mode_valid = meson_encoder_cvbs_mode_valid,
+	.get_modes = meson_encoder_cvbs_get_modes,
+	.atomic_enable = meson_encoder_cvbs_atomic_enable,
+	.atomic_disable = meson_encoder_cvbs_atomic_disable,
+	.atomic_check = meson_encoder_cvbs_atomic_check,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+};
+
+int meson_encoder_cvbs_init(struct meson_drm *priv)
+{
+	struct drm_device *drm = priv->drm;
+	struct meson_encoder_cvbs *meson_encoder_cvbs;
+	struct drm_connector *connector;
+	struct device_node *remote;
+	int ret;
+
+	meson_encoder_cvbs = devm_kzalloc(priv->dev, sizeof(*meson_encoder_cvbs), GFP_KERNEL);
+	if (!meson_encoder_cvbs)
+		return -ENOMEM;
+
+	/* CVBS Connector Bridge */
+	remote = of_graph_get_remote_node(priv->dev->of_node, 0, 0);
+	if (!remote) {
+		dev_info(drm->dev, "CVBS Output connector not available\n");
+		return 0;
+	}
+
+	meson_encoder_cvbs->next_bridge = of_drm_find_bridge(remote);
+	if (!meson_encoder_cvbs->next_bridge) {
+		dev_err(priv->dev, "Failed to find CVBS Connector bridge\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* CVBS Encoder Bridge */
+	meson_encoder_cvbs->bridge.funcs = &meson_encoder_cvbs_bridge_funcs;
+	meson_encoder_cvbs->bridge.of_node = priv->dev->of_node;
+	meson_encoder_cvbs->bridge.type = DRM_MODE_CONNECTOR_Composite;
+	meson_encoder_cvbs->bridge.ops = DRM_BRIDGE_OP_MODES;
+	meson_encoder_cvbs->bridge.interlace_allowed = true;
+
+	drm_bridge_add(&meson_encoder_cvbs->bridge);
+
+	meson_encoder_cvbs->priv = priv;
+
+	/* Encoder */
+	ret = drm_simple_encoder_init(priv->drm, &meson_encoder_cvbs->encoder,
+				      DRM_MODE_ENCODER_TVDAC);
+	if (ret) {
+		dev_err(priv->dev, "Failed to init CVBS encoder: %d\n", ret);
+		return ret;
+	}
+
+	meson_encoder_cvbs->encoder.possible_crtcs = BIT(0);
+
+	/* Attach CVBS Encoder Bridge to Encoder */
+	ret = drm_bridge_attach(&meson_encoder_cvbs->encoder, &meson_encoder_cvbs->bridge, NULL,
+				DRM_BRIDGE_ATTACH_NO_CONNECTOR);
+	if (ret) {
+		dev_err(priv->dev, "Failed to attach bridge: %d\n", ret);
+		return ret;
+	}
+
+	/* Initialize & attach Bridge Connector */
+	connector = drm_bridge_connector_init(priv->drm, &meson_encoder_cvbs->encoder);
+	if (IS_ERR(connector)) {
+		dev_err(priv->dev, "Unable to create CVBS bridge connector\n");
+		return PTR_ERR(connector);
+	}
+	drm_connector_attach_encoder(connector, &meson_encoder_cvbs->encoder);
+
+	return 0;
+}
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_cvbs.h b/drivers/gpu/drm/meson/meson_encoder_cvbs.h
--- a/drivers/gpu/drm/meson/meson_encoder_cvbs.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_encoder_cvbs.h	2022-05-31 11:56:47.733259325 +0800
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2014 Endless Mobile
+ *
+ * Written by:
+ *     Jasper St. Pierre <jstpierre@mecheye.net>
+ */
+
+#ifndef __MESON_VENC_CVBS_H
+#define __MESON_VENC_CVBS_H
+
+#include "meson_drv.h"
+#include "meson_venc.h"
+
+struct meson_cvbs_mode {
+	struct meson_cvbs_enci_mode *enci;
+	struct drm_display_mode mode;
+};
+
+#define MESON_CVBS_MODES_COUNT	2
+
+/* Modes supported by the CVBS output */
+extern struct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT];
+
+int meson_encoder_cvbs_init(struct meson_drm *priv);
+
+#endif /* __MESON_VENC_CVBS_H */
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_dsi.c b/drivers/gpu/drm/meson/meson_encoder_dsi.c
--- a/drivers/gpu/drm/meson/meson_encoder_dsi.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_encoder_dsi.c	2022-05-31 11:56:47.733259325 +0800
@@ -0,0 +1,168 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_bridge_connector.h>
+#include <drm/drm_device.h>
+#include <drm/drm_probe_helper.h>
+
+#include "meson_drv.h"
+#include "meson_encoder_dsi.h"
+#include "meson_registers.h"
+#include "meson_venc.h"
+#include "meson_vclk.h"
+
+struct meson_encoder_dsi {
+	struct drm_encoder encoder;
+	struct drm_bridge bridge;
+	struct drm_bridge *next_bridge;
+	struct meson_drm *priv;
+};
+
+#define bridge_to_meson_encoder_dsi(x) \
+	container_of(x, struct meson_encoder_dsi, bridge)
+
+static int meson_encoder_dsi_attach(struct drm_bridge *bridge,
+				    enum drm_bridge_attach_flags flags)
+{
+	struct meson_encoder_dsi *encoder_dsi = bridge_to_meson_encoder_dsi(bridge);
+
+	return drm_bridge_attach(bridge->encoder, encoder_dsi->next_bridge,
+				 &encoder_dsi->bridge, flags);
+}
+
+static void meson_encoder_dsi_mode_set(struct drm_bridge *bridge,
+				       const struct drm_display_mode *mode,
+				       const struct drm_display_mode *adjusted_mode)
+{
+	struct meson_encoder_dsi *encoder_dsi = bridge_to_meson_encoder_dsi(bridge);
+	struct meson_drm *priv = encoder_dsi->priv;
+
+	meson_vclk_setup(priv, MESON_VCLK_TARGET_DSI, mode->clock, 0, 0, 0, false);
+
+	meson_venc_mipi_dsi_mode_set(priv, mode);
+	meson_encl_load_gamma(priv);
+
+	writel_relaxed(0, priv->io_base + _REG(ENCL_VIDEO_EN));
+
+	writel_bits_relaxed(ENCL_VIDEO_MODE_ADV_VFIFO_EN, ENCL_VIDEO_MODE_ADV_VFIFO_EN,
+			    priv->io_base + _REG(ENCL_VIDEO_MODE_ADV));
+	writel_relaxed(0, priv->io_base + _REG(ENCL_TST_EN));
+}
+
+static void meson_encoder_dsi_atomic_enable(struct drm_bridge *bridge,
+					    struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_dsi *encoder_dsi = bridge_to_meson_encoder_dsi(bridge);
+	struct meson_drm *priv = encoder_dsi->priv;
+
+	// UNIONMAN add:  fix green/black color distortion issue with DSI
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
+		writel_bits_relaxed(OSD1_HDR2_CTRL_REG_ONLY_MAT, 
+				OSD1_HDR2_CTRL_REG_ONLY_MAT,
+				priv->io_base + _REG(OSD1_HDR2_CTRL));
+		dev_info(priv->dev, "set OSD1_HDR2_CTRL to fix green/black color distortion.\n");
+	}
+
+	writel_bits_relaxed(BIT(0), 0, priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_EN_CTRL));
+
+	writel_relaxed(1, priv->io_base + _REG(ENCL_VIDEO_EN));
+}
+
+static void meson_encoder_dsi_atomic_disable(struct drm_bridge *bridge,
+					     struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_dsi *meson_encoder_dsi =
+					bridge_to_meson_encoder_dsi(bridge);
+	struct meson_drm *priv = meson_encoder_dsi->priv;
+
+	writel_relaxed(0, priv->io_base + _REG(ENCL_VIDEO_EN));
+
+	writel_bits_relaxed(BIT(0), BIT(0), priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_EN_CTRL));
+}
+
+static const struct drm_bridge_funcs meson_encoder_dsi_bridge_funcs = {
+	.attach	= meson_encoder_dsi_attach,
+	/*
+	 * TOFIX: remove when dw-mipi-dsi moves out of mode_set
+	 * We should get rid of mode_set, but until dw-mipi-dsi uses it
+	 * we need to setup the pixel clock before the following
+	 * bridge tries to setup the HW.
+	 */
+	.mode_set = meson_encoder_dsi_mode_set,
+	.atomic_enable = meson_encoder_dsi_atomic_enable,
+	.atomic_disable	= meson_encoder_dsi_atomic_disable,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+};
+
+int meson_encoder_dsi_init(struct meson_drm *priv)
+{
+	struct meson_encoder_dsi *meson_encoder_dsi;
+	struct device_node *remote;
+	int ret;
+
+	meson_encoder_dsi = devm_kzalloc(priv->dev, sizeof(*meson_encoder_dsi), GFP_KERNEL);
+	if (!meson_encoder_dsi)
+		return -ENOMEM;
+
+	/* DSI Transceiver Bridge */
+	remote = of_graph_get_remote_node(priv->dev->of_node, 2, 0);
+	if (!remote) {
+		dev_err(priv->dev, "DSI transceiver device is disabled");
+		return 0;
+	}
+
+	meson_encoder_dsi->next_bridge = of_drm_find_bridge(remote);
+	if (!meson_encoder_dsi->next_bridge) {
+		dev_dbg(priv->dev, "Failed to find DSI transceiver bridge: %d\n", ret);
+		return -EPROBE_DEFER;
+	}
+
+	/* DSI Encoder Bridge */
+	meson_encoder_dsi->bridge.funcs = &meson_encoder_dsi_bridge_funcs;
+	meson_encoder_dsi->bridge.of_node = priv->dev->of_node;
+	meson_encoder_dsi->bridge.type = DRM_MODE_CONNECTOR_DSI;
+
+	drm_bridge_add(&meson_encoder_dsi->bridge);
+
+	meson_encoder_dsi->priv = priv;
+
+	/* Encoder */
+	ret = drm_simple_encoder_init(priv->drm, &meson_encoder_dsi->encoder,
+				      DRM_MODE_ENCODER_DSI);
+	if (ret) {
+		dev_err(priv->dev, "Failed to init DSI encoder: %d\n", ret);
+		return ret;
+	}
+
+	meson_encoder_dsi->encoder.possible_crtcs = BIT(0);
+
+	/* Attach DSI Encoder Bridge to Encoder */
+	ret = drm_bridge_attach(&meson_encoder_dsi->encoder, &meson_encoder_dsi->bridge, NULL, 0);
+	if (ret) {
+		dev_err(priv->dev, "Failed to attach bridge: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * We should have now in place:
+	 * encoder->[dsi encoder bridge]->[dw-mipi-dsi bridge]->[panel bridge]->[panel]
+	 */
+
+	dev_dbg(priv->dev, "DSI encoder initialized\n");
+
+	return 0;
+}
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_dsi.h b/drivers/gpu/drm/meson/meson_encoder_dsi.h
--- a/drivers/gpu/drm/meson/meson_encoder_dsi.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_encoder_dsi.h	2022-05-31 11:56:47.733259325 +0800
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#ifndef __MESON_ENCODER_DSI_H
+#define __MESON_ENCODER_DSI_H
+
+int meson_encoder_dsi_init(struct meson_drm *priv);
+
+#endif /* __MESON_ENCODER_DSI_H */
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_hdmi.c b/drivers/gpu/drm/meson/meson_encoder_hdmi.c
--- a/drivers/gpu/drm/meson/meson_encoder_hdmi.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_encoder_hdmi.c	2022-05-31 11:56:47.733259325 +0800
@@ -0,0 +1,455 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_graph.h>
+#include <linux/regulator/consumer.h>
+#include <linux/reset.h>
+
+#include <media/cec-notifier.h>
+
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_bridge_connector.h>
+#include <drm/drm_device.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_simple_kms_helper.h>
+
+#include <linux/media-bus-format.h>
+#include <linux/videodev2.h>
+
+#include "meson_drv.h"
+#include "meson_registers.h"
+#include "meson_vclk.h"
+#include "meson_venc.h"
+#include "meson_encoder_hdmi.h"
+
+struct meson_encoder_hdmi {
+	struct drm_encoder encoder;
+	struct drm_bridge bridge;
+	struct drm_bridge *next_bridge;
+	struct drm_connector *connector;
+	struct meson_drm *priv;
+	unsigned long output_bus_fmt;
+	struct cec_notifier *cec_notifier;
+};
+
+#define bridge_to_meson_encoder_hdmi(x) \
+	container_of(x, struct meson_encoder_hdmi, bridge)
+
+static int meson_encoder_hdmi_attach(struct drm_bridge *bridge,
+				     enum drm_bridge_attach_flags flags)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+
+	return drm_bridge_attach(bridge->encoder, encoder_hdmi->next_bridge,
+				 &encoder_hdmi->bridge, flags);
+}
+
+static void meson_encoder_hdmi_detach(struct drm_bridge *bridge)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+
+	cec_notifier_conn_unregister(encoder_hdmi->cec_notifier);
+	encoder_hdmi->cec_notifier = NULL;
+}
+
+static void meson_encoder_hdmi_set_vclk(struct meson_encoder_hdmi *encoder_hdmi,
+					const struct drm_display_mode *mode)
+{
+	struct meson_drm *priv = encoder_hdmi->priv;
+	int vic = drm_match_cea_mode(mode);
+	unsigned int phy_freq;
+	unsigned int vclk_freq;
+	unsigned int venc_freq;
+	unsigned int hdmi_freq;
+
+	vclk_freq = mode->clock;
+
+	/* For 420, pixel clock is half unlike venc clock */
+	if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
+		vclk_freq /= 2;
+
+	/* TMDS clock is pixel_clock * 10 */
+	phy_freq = vclk_freq * 10;
+
+	if (!vic) {
+		meson_vclk_setup(priv, MESON_VCLK_TARGET_DMT, phy_freq,
+				 vclk_freq, vclk_freq, vclk_freq, false);
+		return;
+	}
+
+	/* 480i/576i needs global pixel doubling */
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		vclk_freq *= 2;
+
+	venc_freq = vclk_freq;
+	hdmi_freq = vclk_freq;
+
+	/* VENC double pixels for 1080i, 720p and YUV420 modes */
+	if (meson_venc_hdmi_venc_repeat(vic) ||
+	    encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
+		venc_freq *= 2;
+
+	vclk_freq = max(venc_freq, hdmi_freq);
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		venc_freq /= 2;
+
+	dev_dbg(priv->dev, "vclk:%d phy=%d venc=%d hdmi=%d enci=%d\n",
+		phy_freq, vclk_freq, venc_freq, hdmi_freq,
+		priv->venc.hdmi_use_enci);
+
+	meson_vclk_setup(priv, MESON_VCLK_TARGET_HDMI, phy_freq, vclk_freq,
+			 venc_freq, hdmi_freq, priv->venc.hdmi_use_enci);
+}
+
+static enum drm_mode_status meson_encoder_hdmi_mode_valid(struct drm_bridge *bridge,
+					const struct drm_display_info *display_info,
+					const struct drm_display_mode *mode)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct meson_drm *priv = encoder_hdmi->priv;
+	bool is_hdmi2_sink = display_info->hdmi.scdc.supported;
+	unsigned int phy_freq;
+	unsigned int vclk_freq;
+	unsigned int venc_freq;
+	unsigned int hdmi_freq;
+	int vic = drm_match_cea_mode(mode);
+	enum drm_mode_status status;
+
+	dev_dbg(priv->dev, "Modeline " DRM_MODE_FMT "\n", DRM_MODE_ARG(mode));
+
+	/* If sink does not support 540MHz, reject the non-420 HDMI2 modes */
+	if (display_info->max_tmds_clock &&
+	    mode->clock > display_info->max_tmds_clock &&
+	    !drm_mode_is_420_only(display_info, mode) &&
+	    !drm_mode_is_420_also(display_info, mode))
+		return MODE_BAD;
+
+	/* Check against non-VIC supported modes */
+	if (!vic) {
+		status = meson_venc_hdmi_supported_mode(mode);
+		if (status != MODE_OK)
+			return status;
+
+		return meson_vclk_dmt_supported_freq(priv, mode->clock);
+	/* Check against supported VIC modes */
+	} else if (!meson_venc_hdmi_supported_vic(vic))
+		return MODE_BAD;
+
+	vclk_freq = mode->clock;
+
+	/* For 420, pixel clock is half unlike venc clock */
+	if (drm_mode_is_420_only(display_info, mode) ||
+	    (!is_hdmi2_sink &&
+	     drm_mode_is_420_also(display_info, mode)))
+		vclk_freq /= 2;
+
+	/* TMDS clock is pixel_clock * 10 */
+	phy_freq = vclk_freq * 10;
+
+	/* 480i/576i needs global pixel doubling */
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		vclk_freq *= 2;
+
+	venc_freq = vclk_freq;
+	hdmi_freq = vclk_freq;
+
+	/* VENC double pixels for 1080i, 720p and YUV420 modes */
+	if (meson_venc_hdmi_venc_repeat(vic) ||
+	    drm_mode_is_420_only(display_info, mode) ||
+	    (!is_hdmi2_sink &&
+	     drm_mode_is_420_also(display_info, mode)))
+		venc_freq *= 2;
+
+	vclk_freq = max(venc_freq, hdmi_freq);
+
+	if (mode->flags & DRM_MODE_FLAG_DBLCLK)
+		venc_freq /= 2;
+
+	dev_dbg(priv->dev, "%s: vclk:%d phy=%d venc=%d hdmi=%d\n",
+		__func__, phy_freq, vclk_freq, venc_freq, hdmi_freq);
+
+	return meson_vclk_vic_supported_freq(priv, phy_freq, vclk_freq);
+}
+
+static void meson_encoder_hdmi_atomic_enable(struct drm_bridge *bridge,
+					     struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct drm_atomic_state *state = bridge_state->base.state;
+	unsigned int ycrcb_map = VPU_HDMI_OUTPUT_CBYCR;
+	struct meson_drm *priv = encoder_hdmi->priv;
+	struct drm_connector_state *conn_state;
+	const struct drm_display_mode *mode;
+	struct drm_crtc_state *crtc_state;
+	struct drm_connector *connector;
+	bool yuv420_mode = false;
+	int vic;
+
+	connector = drm_atomic_get_new_connector_for_encoder(state, bridge->encoder);
+	if (WARN_ON(!connector))
+		return;
+
+	conn_state = drm_atomic_get_new_connector_state(state, connector);
+	if (WARN_ON(!conn_state))
+		return;
+
+	crtc_state = drm_atomic_get_new_crtc_state(state, conn_state->crtc);
+	if (WARN_ON(!crtc_state))
+		return;
+
+	mode = &crtc_state->adjusted_mode;
+
+	vic = drm_match_cea_mode(mode);
+
+	dev_dbg(priv->dev, "\"%s\" vic %d\n", mode->name, vic);
+
+	if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24) {
+		ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
+		yuv420_mode = true;
+	} else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYVY8_1X16) {
+		ycrcb_map = VPU_HDMI_OUTPUT_CRYCB;
+	}
+
+	/* VENC + VENC-DVI Mode setup */
+	meson_venc_hdmi_mode_set(priv, vic, ycrcb_map, yuv420_mode, mode);
+
+	/* VCLK Set clock */
+	meson_encoder_hdmi_set_vclk(encoder_hdmi, mode);
+
+	if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYYVYY8_0_5X24)
+		/* Setup YUV420 to HDMI-TX, no 10bit diphering */
+		writel_relaxed(2 | (2 << 2),
+			       priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+	else if (encoder_hdmi->output_bus_fmt == MEDIA_BUS_FMT_UYVY8_1X16)
+		/* Setup YUV422 to HDMI-TX, no 10bit diphering */
+		writel_relaxed(1 | (2 << 2),
+				priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+	else
+		/* Setup YUV444 to HDMI-TX, no 10bit diphering */
+		writel_relaxed(0, priv->io_base + _REG(VPU_HDMI_FMT_CTRL));
+
+	dev_dbg(priv->dev, "%s\n", priv->venc.hdmi_use_enci ? "VENCI" : "VENCP");
+
+	if (priv->venc.hdmi_use_enci)
+		writel_relaxed(1, priv->io_base + _REG(ENCI_VIDEO_EN));
+	else
+		writel_relaxed(1, priv->io_base + _REG(ENCP_VIDEO_EN));
+}
+
+static void meson_encoder_hdmi_atomic_disable(struct drm_bridge *bridge,
+					     struct drm_bridge_state *bridge_state)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct meson_drm *priv = encoder_hdmi->priv;
+
+	writel_bits_relaxed(0x3, 0,
+			    priv->io_base + _REG(VPU_HDMI_SETTING));
+
+	writel_relaxed(0, priv->io_base + _REG(ENCI_VIDEO_EN));
+	writel_relaxed(0, priv->io_base + _REG(ENCP_VIDEO_EN));
+}
+
+static const u32 meson_encoder_hdmi_out_bus_fmts[] = {
+	MEDIA_BUS_FMT_YUV8_1X24,
+	MEDIA_BUS_FMT_UYVY8_1X16,
+	MEDIA_BUS_FMT_UYYVYY8_0_5X24,
+};
+
+static u32 *
+meson_encoder_hdmi_get_inp_bus_fmts(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state,
+					u32 output_fmt,
+					unsigned int *num_input_fmts)
+{
+	u32 *input_fmts = NULL;
+	int i;
+
+	*num_input_fmts = 0;
+
+	for (i = 0 ; i < ARRAY_SIZE(meson_encoder_hdmi_out_bus_fmts) ; ++i) {
+		if (output_fmt == meson_encoder_hdmi_out_bus_fmts[i]) {
+			*num_input_fmts = 1;
+			input_fmts = kcalloc(*num_input_fmts,
+					     sizeof(*input_fmts),
+					     GFP_KERNEL);
+			if (!input_fmts)
+				return NULL;
+
+			input_fmts[0] = output_fmt;
+
+			break;
+		}
+	}
+
+	return input_fmts;
+}
+
+static int meson_encoder_hdmi_atomic_check(struct drm_bridge *bridge,
+					struct drm_bridge_state *bridge_state,
+					struct drm_crtc_state *crtc_state,
+					struct drm_connector_state *conn_state)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct drm_connector_state *old_conn_state =
+		drm_atomic_get_old_connector_state(conn_state->state, conn_state->connector);
+	struct meson_drm *priv = encoder_hdmi->priv;
+
+	encoder_hdmi->output_bus_fmt = bridge_state->output_bus_cfg.format;
+
+	dev_dbg(priv->dev, "output_bus_fmt %lx\n", encoder_hdmi->output_bus_fmt);
+
+	if (!drm_connector_atomic_hdr_metadata_equal(old_conn_state, conn_state))
+		crtc_state->mode_changed = true;
+
+	return 0;
+}
+
+static void meson_encoder_hdmi_hpd_notify(struct drm_bridge *bridge,
+					  enum drm_connector_status status)
+{
+	struct meson_encoder_hdmi *encoder_hdmi = bridge_to_meson_encoder_hdmi(bridge);
+	struct edid *edid;
+
+	if (!encoder_hdmi->cec_notifier)
+		return;
+
+	if (status == connector_status_connected) {
+		edid = drm_bridge_get_edid(encoder_hdmi->next_bridge, encoder_hdmi->connector);
+		if (!edid)
+			return;
+
+		cec_notifier_set_phys_addr_from_edid(encoder_hdmi->cec_notifier, edid);
+	} else
+		cec_notifier_phys_addr_invalidate(encoder_hdmi->cec_notifier);
+}
+
+static const struct drm_bridge_funcs meson_encoder_hdmi_bridge_funcs = {
+	.attach = meson_encoder_hdmi_attach,
+	.detach = meson_encoder_hdmi_detach,
+	.mode_valid = meson_encoder_hdmi_mode_valid,
+	//.hpd_notify = meson_encoder_hdmi_hpd_notify, // UNIONMAN del
+	.atomic_enable = meson_encoder_hdmi_atomic_enable,
+	.atomic_disable = meson_encoder_hdmi_atomic_disable,
+	.atomic_get_input_bus_fmts = meson_encoder_hdmi_get_inp_bus_fmts,
+	.atomic_check = meson_encoder_hdmi_atomic_check,
+	.atomic_duplicate_state = drm_atomic_helper_bridge_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_bridge_destroy_state,
+	.atomic_reset = drm_atomic_helper_bridge_reset,
+};
+
+int meson_encoder_hdmi_init(struct meson_drm *priv)
+{
+	struct meson_encoder_hdmi *meson_encoder_hdmi;
+	struct platform_device *pdev;
+	struct device_node *remote;
+	int ret;
+
+	meson_encoder_hdmi = devm_kzalloc(priv->dev, sizeof(*meson_encoder_hdmi), GFP_KERNEL);
+	if (!meson_encoder_hdmi)
+		return -ENOMEM;
+
+	/* HDMI Transceiver Bridge */
+	remote = of_graph_get_remote_node(priv->dev->of_node, 1, 0);
+	if (!remote) {
+		dev_err(priv->dev, "HDMI transceiver device is disabled");
+		return 0;
+	}
+
+	meson_encoder_hdmi->next_bridge = of_drm_find_bridge(remote);
+	if (!meson_encoder_hdmi->next_bridge) {
+		dev_err(priv->dev, "Failed to find HDMI transceiver bridge\n");
+		return -EPROBE_DEFER;
+	}
+
+	/* HDMI Encoder Bridge */
+	meson_encoder_hdmi->bridge.funcs = &meson_encoder_hdmi_bridge_funcs;
+	meson_encoder_hdmi->bridge.of_node = priv->dev->of_node;
+	meson_encoder_hdmi->bridge.type = DRM_MODE_CONNECTOR_HDMIA;
+	meson_encoder_hdmi->bridge.interlace_allowed = true;
+
+	drm_bridge_add(&meson_encoder_hdmi->bridge);
+
+	meson_encoder_hdmi->priv = priv;
+
+	/* Encoder */
+	ret = drm_simple_encoder_init(priv->drm, &meson_encoder_hdmi->encoder,
+				      DRM_MODE_ENCODER_TMDS);
+	if (ret) {
+		dev_err(priv->dev, "Failed to init HDMI encoder: %d\n", ret);
+		return ret;
+	}
+
+	meson_encoder_hdmi->encoder.possible_crtcs = BIT(0);
+
+	/* Attach HDMI Encoder Bridge to Encoder */
+	ret = drm_bridge_attach(&meson_encoder_hdmi->encoder, &meson_encoder_hdmi->bridge, NULL,
+				0/*UNIONMAN modfiy: DRM_BRIDGE_ATTACH_NO_CONNECTOR*/);
+	if (ret) {
+		dev_err(priv->dev, "Failed to attach bridge: %d\n", ret);
+		return ret;
+	}
+
+#if 0 // UNIONMAN del: use connector created by dw_hdmi instead.
+	/* Initialize & attach Bridge Connector */
+	meson_encoder_hdmi->connector = drm_bridge_connector_init(priv->drm,
+							&meson_encoder_hdmi->encoder);
+	if (IS_ERR(meson_encoder_hdmi->connector)) {
+		dev_err(priv->dev, "Unable to create HDMI bridge connector\n");
+		return PTR_ERR(meson_encoder_hdmi->connector);
+	}
+	drm_connector_attach_encoder(meson_encoder_hdmi->connector,
+				     &meson_encoder_hdmi->encoder);
+
+	/*
+	 * We should have now in place:
+	 * encoder->[hdmi encoder bridge]->[dw-hdmi bridge]->[display connector bridge]->[display connector]
+	 */
+
+	/*
+	 * drm_connector_attach_max_bpc_property() requires the
+	 * connector to have a state.
+	 */
+	drm_atomic_helper_connector_reset(meson_encoder_hdmi->connector);
+
+	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
+	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A))
+		drm_connector_attach_hdr_output_metadata_property(meson_encoder_hdmi->connector);
+
+	drm_connector_attach_max_bpc_property(meson_encoder_hdmi->connector, 8, 8);
+
+	/* Handle this here until handled by drm_bridge_connector_init() */
+	meson_encoder_hdmi->connector->ycbcr_420_allowed = true;
+
+	pdev = of_find_device_by_node(remote);
+	if (pdev) {
+		struct cec_connector_info conn_info;
+		struct cec_notifier *notifier;
+
+		cec_fill_conn_info_from_drm(&conn_info, meson_encoder_hdmi->connector);
+
+		notifier = cec_notifier_conn_register(&pdev->dev, NULL, &conn_info);
+		if (!notifier)
+			return -ENOMEM;
+
+		meson_encoder_hdmi->cec_notifier = notifier;
+	}
+#endif
+	dev_dbg(priv->dev, "HDMI encoder initialized\n");
+
+	return 0;
+}
diff -Naur a/drivers/gpu/drm/meson/meson_encoder_hdmi.h b/drivers/gpu/drm/meson/meson_encoder_hdmi.h
--- a/drivers/gpu/drm/meson/meson_encoder_hdmi.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/meson/meson_encoder_hdmi.h	2022-05-31 11:56:47.733259325 +0800
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#ifndef __MESON_ENCODER_HDMI_H
+#define __MESON_ENCODER_HDMI_H
+
+int meson_encoder_hdmi_init(struct meson_drm *priv);
+
+#endif /* __MESON_ENCODER_HDMI_H */
diff -Naur a/drivers/gpu/drm/meson/meson_osd_afbcd.c b/drivers/gpu/drm/meson/meson_osd_afbcd.c
--- a/drivers/gpu/drm/meson/meson_osd_afbcd.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_osd_afbcd.c	2022-05-31 11:56:47.733259325 +0800
@@ -79,11 +79,6 @@
 	return meson_gxm_afbcd_pixel_fmt(modifier, format) >= 0;
 }
 
-static int meson_gxm_afbcd_init(struct meson_drm *priv)
-{
-	return 0;
-}
-
 static int meson_gxm_afbcd_reset(struct meson_drm *priv)
 {
 	writel_relaxed(VIU_SW_RESET_OSD1_AFBCD,
@@ -93,6 +88,16 @@
 	return 0;
 }
 
+static int meson_gxm_afbcd_init(struct meson_drm *priv)
+{
+	return 0;
+}
+
+static void meson_gxm_afbcd_exit(struct meson_drm *priv)
+{
+	meson_gxm_afbcd_reset(priv);
+}
+
 static int meson_gxm_afbcd_enable(struct meson_drm *priv)
 {
 	writel_relaxed(FIELD_PREP(OSD1_AFBCD_ID_FIFO_THRD, 0x40) |
@@ -172,6 +177,7 @@
 
 struct meson_afbcd_ops meson_afbcd_gxm_ops = {
 	.init = meson_gxm_afbcd_init,
+	.exit = meson_gxm_afbcd_exit,
 	.reset = meson_gxm_afbcd_reset,
 	.enable = meson_gxm_afbcd_enable,
 	.disable = meson_gxm_afbcd_disable,
@@ -269,6 +275,18 @@
 	return meson_g12a_afbcd_pixel_fmt(modifier, format) >= 0;
 }
 
+static int meson_g12a_afbcd_reset(struct meson_drm *priv)
+{
+	meson_rdma_reset(priv);
+
+	meson_rdma_writel_sync(priv, VIU_SW_RESET_G12A_AFBC_ARB |
+			       VIU_SW_RESET_G12A_OSD1_AFBCD,
+			       VIU_SW_RESET);
+	meson_rdma_writel_sync(priv, 0, VIU_SW_RESET);
+
+	return 0;
+}
+
 static int meson_g12a_afbcd_init(struct meson_drm *priv)
 {
 	int ret;
@@ -286,16 +304,10 @@
 	return 0;
 }
 
-static int meson_g12a_afbcd_reset(struct meson_drm *priv)
+static void meson_g12a_afbcd_exit(struct meson_drm *priv)
 {
-	meson_rdma_reset(priv);
-
-	meson_rdma_writel_sync(priv, VIU_SW_RESET_G12A_AFBC_ARB |
-			       VIU_SW_RESET_G12A_OSD1_AFBCD,
-			       VIU_SW_RESET);
-	meson_rdma_writel_sync(priv, 0, VIU_SW_RESET);
-
-	return 0;
+	meson_g12a_afbcd_reset(priv);
+	meson_rdma_free(priv);
 }
 
 static int meson_g12a_afbcd_enable(struct meson_drm *priv)
@@ -380,6 +392,7 @@
 
 struct meson_afbcd_ops meson_afbcd_g12a_ops = {
 	.init = meson_g12a_afbcd_init,
+	.exit = meson_g12a_afbcd_exit,
 	.reset = meson_g12a_afbcd_reset,
 	.enable = meson_g12a_afbcd_enable,
 	.disable = meson_g12a_afbcd_disable,
diff -Naur a/drivers/gpu/drm/meson/meson_osd_afbcd.h b/drivers/gpu/drm/meson/meson_osd_afbcd.h
--- a/drivers/gpu/drm/meson/meson_osd_afbcd.h	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_osd_afbcd.h	2022-05-31 11:56:47.733259325 +0800
@@ -14,6 +14,7 @@
 
 struct meson_afbcd_ops {
 	int (*init)(struct meson_drm *priv);
+	void (*exit)(struct meson_drm *priv);
 	int (*reset)(struct meson_drm *priv);
 	int (*enable)(struct meson_drm *priv);
 	int (*disable)(struct meson_drm *priv);
diff -Naur a/drivers/gpu/drm/meson/meson_overlay.c b/drivers/gpu/drm/meson/meson_overlay.c
--- a/drivers/gpu/drm/meson/meson_overlay.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_overlay.c	2022-05-31 11:56:47.733259325 +0800
@@ -10,10 +10,10 @@
 #include <drm/drm_atomic.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_device.h>
+#include <drm/drm_fb_cma_helper.h>
 #include <drm/drm_fourcc.h>
-#include <drm/drm_plane_helper.h>
 #include <drm/drm_gem_cma_helper.h>
-#include <drm/drm_fb_cma_helper.h>
+#include <drm/drm_plane_helper.h>
 #include <drm/drm_gem_framebuffer_helper.h>
 
 #include "meson_overlay.h"
@@ -167,16 +167,20 @@
 static int meson_overlay_atomic_check(struct drm_plane *plane,
 				      struct drm_plane_state *state)
 {
+	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state->state,
+										 plane);
 	struct drm_crtc_state *crtc_state;
 
-	if (!state->crtc)
+	if (!new_plane_state->crtc)
 		return 0;
 
-	crtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);
+	crtc_state = drm_atomic_get_crtc_state(state->state,
+					       new_plane_state->crtc);
 	if (IS_ERR(crtc_state))
 		return PTR_ERR(crtc_state);
 
-	return drm_atomic_helper_check_plane_state(state, crtc_state,
+	return drm_atomic_helper_check_plane_state(new_plane_state,
+						   crtc_state,
 						   FRAC_16_16(1, 5),
 						   FRAC_16_16(5, 1),
 						   true, true);
@@ -464,11 +468,12 @@
 }
 
 static void meson_overlay_atomic_update(struct drm_plane *plane,
-					struct drm_plane_state *old_state)
+					struct drm_plane_state *state)
 {
 	struct meson_overlay *meson_overlay = to_meson_overlay(plane);
-	struct drm_plane_state *state = plane->state;
-	struct drm_framebuffer *fb = state->fb;
+	struct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state->state,
+									   plane);
+	struct drm_framebuffer *fb = new_state->fb;
 	struct meson_drm *priv = meson_overlay->priv;
 	struct drm_gem_cma_object *gem;
 	unsigned long flags;
@@ -476,7 +481,7 @@
 
 	DRM_DEBUG_DRIVER("\n");
 
-	interlace_mode = state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE;
+	interlace_mode = new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE;
 
 	spin_lock_irqsave(&priv->drm->event_lock, flags);
 
@@ -717,7 +722,7 @@
 }
 
 static void meson_overlay_atomic_disable(struct drm_plane *plane,
-				       struct drm_plane_state *old_state)
+				       struct drm_plane_state *state)
 {
 	struct meson_overlay *meson_overlay = to_meson_overlay(plane);
 	struct meson_drm *priv = meson_overlay->priv;
diff -Naur a/drivers/gpu/drm/meson/meson_plane.c b/drivers/gpu/drm/meson/meson_plane.c
--- a/drivers/gpu/drm/meson/meson_plane.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_plane.c	2022-05-31 11:56:47.733259325 +0800
@@ -73,12 +73,15 @@
 static int meson_plane_atomic_check(struct drm_plane *plane,
 				    struct drm_plane_state *state)
 {
+	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state->state,
+										 plane);
 	struct drm_crtc_state *crtc_state;
 
-	if (!state->crtc)
+	if (!new_plane_state->crtc)
 		return 0;
 
-	crtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);
+	crtc_state = drm_atomic_get_crtc_state(state->state,
+					       new_plane_state->crtc);
 	if (IS_ERR(crtc_state))
 		return PTR_ERR(crtc_state);
 
@@ -87,7 +90,8 @@
 	 * - Upscaling up to 5x, vertical and horizontal
 	 * - Final coordinates must match crtc size
 	 */
-	return drm_atomic_helper_check_plane_state(state, crtc_state,
+	return drm_atomic_helper_check_plane_state(new_plane_state,
+						   crtc_state,
 						   FRAC_16_16(1, 5),
 						   DRM_PLANE_HELPER_NO_SCALING,
 						   false, true);
@@ -126,13 +130,14 @@
 }
 
 static void meson_plane_atomic_update(struct drm_plane *plane,
-				      struct drm_plane_state *old_state)
+				      struct drm_plane_state *state)
 {
 	struct meson_plane *meson_plane = to_meson_plane(plane);
-	struct drm_plane_state *state = plane->state;
-	struct drm_rect dest = drm_plane_state_dest(state);
+	struct drm_plane_state *new_state = drm_atomic_get_new_plane_state(state->state,
+									   plane);
+	struct drm_rect dest = drm_plane_state_dest(new_state);
 	struct meson_drm *priv = meson_plane->priv;
-	struct drm_framebuffer *fb = state->fb;
+	struct drm_framebuffer *fb = new_state->fb;
 	struct drm_gem_cma_object *gem;
 	unsigned long flags;
 	int vsc_ini_rcv_num, vsc_ini_rpt_p0_num;
@@ -245,7 +250,7 @@
 	hf_bank_len = 4;
 	vf_bank_len = 4;
 
-	if (state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE) {
+	if (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE) {
 		vsc_bot_rcv_num = 6;
 		vsc_bot_rpt_p0_num = 2;
 	}
@@ -255,10 +260,10 @@
 	hsc_ini_rpt_p0_num = (hf_bank_len / 2) - 1;
 	vsc_ini_rpt_p0_num = (vf_bank_len / 2) - 1;
 
-	src_w = fixed16_to_int(state->src_w);
-	src_h = fixed16_to_int(state->src_h);
-	dst_w = state->crtc_w;
-	dst_h = state->crtc_h;
+	src_w = fixed16_to_int(new_state->src_w);
+	src_h = fixed16_to_int(new_state->src_h);
+	dst_w = new_state->crtc_w;
+	dst_h = new_state->crtc_h;
 
 	/*
 	 * When the output is interlaced, the OSD must switch between
@@ -267,7 +272,7 @@
 	 * But the vertical scaler can provide such funtionnality if
 	 * is configured for 2:1 scaling with interlace options enabled.
 	 */
-	if (state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE) {
+	if (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE) {
 		dest.y1 /= 2;
 		dest.y2 /= 2;
 		dst_h /= 2;
@@ -276,7 +281,7 @@
 	hf_phase_step = ((src_w << 18) / dst_w) << 6;
 	vf_phase_step = (src_h << 20) / dst_h;
 
-	if (state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)
+	if (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)
 		bot_ini_phase = ((vf_phase_step / 2) >> 4);
 	else
 		bot_ini_phase = 0;
@@ -308,7 +313,7 @@
 					VSC_TOP_RPT_L0_NUM(vsc_ini_rpt_p0_num) |
 					VSC_VERTICAL_SCALER_EN;
 
-		if (state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)
+		if (new_state->crtc->mode.flags & DRM_MODE_FLAG_INTERLACE)
 			priv->viu.osd_sc_v_ctrl0 |=
 					VSC_BOT_INI_RCV_NUM(vsc_bot_rcv_num) |
 					VSC_BOT_RPT_L0_NUM(vsc_bot_rpt_p0_num) |
@@ -343,11 +348,11 @@
 	 * e.g. +30x1920 would be (1919 << 16) | 30
 	 */
 	priv->viu.osd1_blk0_cfg[1] =
-				((fixed16_to_int(state->src.x2) - 1) << 16) |
-				fixed16_to_int(state->src.x1);
+				((fixed16_to_int(new_state->src.x2) - 1) << 16) |
+				fixed16_to_int(new_state->src.x1);
 	priv->viu.osd1_blk0_cfg[2] =
-				((fixed16_to_int(state->src.y2) - 1) << 16) |
-				fixed16_to_int(state->src.y1);
+				((fixed16_to_int(new_state->src.y2) - 1) << 16) |
+				fixed16_to_int(new_state->src.y1);
 	priv->viu.osd1_blk0_cfg[3] = ((dest.x2 - 1) << 16) | dest.x1;
 	priv->viu.osd1_blk0_cfg[4] = ((dest.y2 - 1) << 16) | dest.y1;
 
@@ -355,7 +360,6 @@
 		priv->viu.osd_blend_din0_scope_h = ((dest.x2 - 1) << 16) | dest.x1;
 		priv->viu.osd_blend_din0_scope_v = ((dest.y2 - 1) << 16) | dest.y1;
 		priv->viu.osb_blend0_size = dst_h << 16 | dst_w;
-		priv->viu.osb_blend1_size = dst_h << 16 | dst_w;
 	}
 
 	/* Update Canvas with buffer address */
@@ -391,7 +395,7 @@
 }
 
 static void meson_plane_atomic_disable(struct drm_plane *plane,
-				       struct drm_plane_state *old_state)
+				       struct drm_plane_state *state)
 {
 	struct meson_plane *meson_plane = to_meson_plane(plane);
 	struct meson_drm *priv = meson_plane->priv;
diff -Naur a/drivers/gpu/drm/meson/meson_registers.h b/drivers/gpu/drm/meson/meson_registers.h
--- a/drivers/gpu/drm/meson/meson_registers.h	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_registers.h	2022-05-31 11:56:47.733259325 +0800
@@ -812,6 +812,7 @@
 #define VENC_STATA 0x1b6d
 #define VENC_INTCTRL 0x1b6e
 #define		VENC_INTCTRL_ENCI_LNRST_INT_EN  BIT(1)
+#define		VENC_INTCTRL_ENCP_LNRST_INT_EN  BIT(9)
 #define VENC_INTFLAG 0x1b6f
 #define VENC_VIDEO_TST_EN 0x1b70
 #define VENC_VIDEO_TST_MDSEL 0x1b71
@@ -1192,7 +1193,11 @@
 #define ENCL_VIDEO_PB_OFFST 0x1ca5
 #define ENCL_VIDEO_PR_OFFST 0x1ca6
 #define ENCL_VIDEO_MODE 0x1ca7
+#define		ENCL_PX_LN_CNT_SHADOW_EN	BIT(15)
 #define ENCL_VIDEO_MODE_ADV 0x1ca8
+#define		ENCL_VIDEO_MODE_ADV_VFIFO_EN	BIT(3)
+#define		ENCL_VIDEO_MODE_ADV_GAIN_HDTV	BIT(4)
+#define		ENCL_SEL_GAMMA_RGB_IN		BIT(10)
 #define ENCL_DBG_PX_RST 0x1ca9
 #define ENCL_DBG_LN_RST 0x1caa
 #define ENCL_DBG_PX_INT 0x1cab
@@ -1219,11 +1224,14 @@
 #define ENCL_VIDEO_VOFFST 0x1cc0
 #define ENCL_VIDEO_RGB_CTRL 0x1cc1
 #define ENCL_VIDEO_FILT_CTRL 0x1cc2
+#define		ENCL_VIDEO_FILT_CTRL_BYPASS_FILTER	BIT(12)
 #define ENCL_VIDEO_OFLD_VPEQ_OFST 0x1cc3
 #define ENCL_VIDEO_OFLD_VOAV_OFST 0x1cc4
 #define ENCL_VIDEO_MATRIX_CB 0x1cc5
 #define ENCL_VIDEO_MATRIX_CR 0x1cc6
 #define ENCL_VIDEO_RGBIN_CTRL 0x1cc7
+#define		ENCL_VIDEO_RGBIN_RGB	BIT(0)
+#define		ENCL_VIDEO_RGBIN_ZBLK	BIT(1)
 #define ENCL_MAX_LINE_SWITCH_POINT 0x1cc8
 #define ENCL_DACSEL_0 0x1cc9
 #define ENCL_DACSEL_1 0x1cca
@@ -1300,13 +1308,28 @@
 #define RDMA_STATUS2 0x1116
 #define RDMA_STATUS3 0x1117
 #define L_GAMMA_CNTL_PORT 0x1400
+#define		L_GAMMA_CNTL_PORT_VCOM_POL	BIT(7)	/* RW */
+#define		L_GAMMA_CNTL_PORT_RVS_OUT	BIT(6)	/* RW */
+#define		L_GAMMA_CNTL_PORT_ADR_RDY	BIT(5)	/* Read Only */
+#define		L_GAMMA_CNTL_PORT_WR_RDY	BIT(4)	/* Read Only */
+#define		L_GAMMA_CNTL_PORT_RD_RDY	BIT(3)	/* Read Only */
+#define		L_GAMMA_CNTL_PORT_TR		BIT(2)	/* RW */
+#define		L_GAMMA_CNTL_PORT_SET		BIT(1)	/* RW */
+#define		L_GAMMA_CNTL_PORT_EN		BIT(0)	/* RW */
 #define L_GAMMA_DATA_PORT 0x1401
 #define L_GAMMA_ADDR_PORT 0x1402
+#define		L_GAMMA_ADDR_PORT_RD		BIT(12)
+#define		L_GAMMA_ADDR_PORT_AUTO_INC	BIT(11)
+#define		L_GAMMA_ADDR_PORT_SEL_R		BIT(10)
+#define		L_GAMMA_ADDR_PORT_SEL_G		BIT(9)
+#define		L_GAMMA_ADDR_PORT_SEL_B		BIT(8)
+#define		L_GAMMA_ADDR_PORT_ADDR		GENMASK(7, 0)
 #define L_GAMMA_VCOM_HSWITCH_ADDR 0x1403
 #define L_RGB_BASE_ADDR 0x1405
 #define L_RGB_COEFF_ADDR 0x1406
 #define L_POL_CNTL_ADDR 0x1407
 #define L_DITH_CNTL_ADDR 0x1408
+#define		L_DITH_CNTL_DITH10_EN	BIT(10)
 #define L_GAMMA_PROBE_CTRL 0x1409
 #define L_GAMMA_PROBE_COLOR_L 0x140a
 #define L_GAMMA_PROBE_COLOR_H 0x140b
@@ -1363,6 +1386,8 @@
 #define L_LCD_PWM1_HI_ADDR 0x143f
 #define L_INV_CNT_ADDR 0x1440
 #define L_TCON_MISC_SEL_ADDR 0x1441
+#define		L_TCON_MISC_SEL_STV1	BIT(4)
+#define		L_TCON_MISC_SEL_STV2	BIT(5)
 #define L_DUAL_PORT_CNTL_ADDR 0x1442
 #define MLVDS_CLK_CTL1_HI 0x1443
 #define MLVDS_CLK_CTL1_LO 0x1444
diff -Naur a/drivers/gpu/drm/meson/meson_vclk.c b/drivers/gpu/drm/meson/meson_vclk.c
--- a/drivers/gpu/drm/meson/meson_vclk.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_vclk.c	2022-05-31 11:56:47.733259325 +0800
@@ -55,6 +55,8 @@
 #define VCLK2_DIV_MASK		0xff
 #define VCLK2_DIV_EN		BIT(16)
 #define VCLK2_DIV_RESET		BIT(17)
+#define CTS_ENCL_SEL_MASK	(0xf << 12)
+#define CTS_ENCL_SEL_SHIFT	12
 #define CTS_VDAC_SEL_MASK	(0xf << 28)
 #define CTS_VDAC_SEL_SHIFT	28
 #define HHI_VIID_CLK_CNTL	0x12c /* 0x4b offset in data sheet */
@@ -83,6 +85,7 @@
 #define VCLK_DIV12_EN		BIT(4)
 #define HHI_VID_CLK_CNTL2	0x194 /* 0x65 offset in data sheet */
 #define CTS_ENCI_EN		BIT(0)
+#define CTS_ENCL_EN		BIT(3)
 #define CTS_ENCP_EN		BIT(2)
 #define CTS_VDAC_EN		BIT(4)
 #define HDMI_TX_PIXEL_EN	BIT(5)
@@ -131,7 +134,7 @@
 	VID_PLL_DIV_15,
 };
 
-void meson_vid_pll_set(struct meson_drm *priv, unsigned int div)
+static void meson_vid_pll_set(struct meson_drm *priv, unsigned int div)
 {
 	unsigned int shift_val = 0;
 	unsigned int shift_sel = 0;
@@ -357,6 +360,8 @@
 	MESON_VCLK_HDMI_594000,
 /* 2970 /1 /1 /1 /5 /1  => /1 /2 */
 	MESON_VCLK_HDMI_594000_YUV420,
+/* 4830 /2 /1 /2 /5 /1  => /1 /1 */
+	MESON_VCLK_HDMI_241500,
 };
 
 struct meson_vclk_params {
@@ -467,6 +472,18 @@
 		.vid_pll_div = VID_PLL_DIV_5,
 		.vclk_div = 1,
 	},
+	[MESON_VCLK_HDMI_241500] = {
+		.pll_freq = 4830000,
+		.phy_freq = 2415000,
+		.venc_freq = 241500,
+		.vclk_freq = 241500,
+		.pixel_freq = 241500,
+		.pll_od1 = 2,
+		.pll_od2 = 1,
+		.pll_od3 = 2,
+		.vid_pll_div = VID_PLL_DIV_5,
+		.vclk_div = 1,
+	},
 	{ /* sentinel */ },
 };
 
@@ -487,9 +504,9 @@
 	return 0;
 }
 
-void meson_hdmi_pll_set_params(struct meson_drm *priv, unsigned int m,
-			       unsigned int frac, unsigned int od1,
-			       unsigned int od2, unsigned int od3)
+static void meson_hdmi_pll_set_params(struct meson_drm *priv, unsigned int m,
+				      unsigned int frac, unsigned int od1,
+				      unsigned int od2, unsigned int od3)
 {
 	unsigned int val;
 
@@ -873,6 +890,10 @@
 			m = 0xf7;
 			frac = vic_alternate_clock ? 0x8148 : 0x10000;
 			break;
+		case 4830000:
+			m = 0xc9;
+			frac = 0xd560;
+			break;
 		}
 
 		meson_hdmi_pll_set_params(priv, m, frac, od1, od2, od3);
@@ -1024,6 +1045,47 @@
 	regmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL, VCLK_EN, VCLK_EN);
 }
 
+static void meson_dsi_clock_config(struct meson_drm *priv, unsigned int freq)
+{
+	meson_hdmi_pll_generic_set(priv, freq * 10);
+
+	/* Setup vid_pll divider value /5 */
+	meson_vid_pll_set(priv, VID_PLL_DIV_5);
+
+	/* Disable VCLK2 */
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL, VCLK2_EN, 0);
+
+	/* Setup the VCLK2 divider value /2 */
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_DIV, VCLK2_DIV_MASK, 2 - 1);
+
+	/* select vid_pll for vclk2 */
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL,
+			   VCLK2_SEL_MASK, (0 << VCLK2_SEL_SHIFT));
+
+	/* enable vclk2 gate */
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL, VCLK2_EN, VCLK2_EN);
+
+	/* select vclk2_div1 for encl */
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_DIV,
+			   CTS_ENCL_SEL_MASK, (8 << CTS_ENCL_SEL_SHIFT));
+
+	/* release vclk2_div_reset and enable vclk2_div */
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_DIV, VCLK2_DIV_EN | VCLK2_DIV_RESET,
+			   VCLK2_DIV_EN);
+
+	/* enable vclk2_div1 gate */
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL, VCLK2_DIV1_EN, VCLK2_DIV1_EN);
+
+	/* reset vclk2 */
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL, VCLK2_SOFT_RESET, VCLK2_SOFT_RESET);
+	regmap_update_bits(priv->hhi, HHI_VIID_CLK_CNTL, VCLK2_SOFT_RESET, 0);
+
+	/* enable encl_clk */
+	regmap_update_bits(priv->hhi, HHI_VID_CLK_CNTL2, CTS_ENCL_EN, CTS_ENCL_EN);
+
+	usleep_range(10000, 11000);
+}
+
 void meson_vclk_setup(struct meson_drm *priv, unsigned int target,
 		      unsigned int phy_freq, unsigned int vclk_freq,
 		      unsigned int venc_freq, unsigned int dac_freq,
@@ -1050,6 +1112,9 @@
 		meson_vclk_set(priv, phy_freq, 0, 0, 0,
 			       VID_PLL_DIV_5, 2, 1, 1, false, false);
 		return;
+	} else if (target == MESON_VCLK_TARGET_DSI) {
+		meson_dsi_clock_config(priv, phy_freq);
+		return;
 	}
 
 	hdmi_tx_div = vclk_freq / dac_freq;
diff -Naur a/drivers/gpu/drm/meson/meson_vclk.h b/drivers/gpu/drm/meson/meson_vclk.h
--- a/drivers/gpu/drm/meson/meson_vclk.h	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_vclk.h	2022-05-31 11:56:47.733259325 +0800
@@ -17,6 +17,7 @@
 	MESON_VCLK_TARGET_CVBS = 0,
 	MESON_VCLK_TARGET_HDMI = 1,
 	MESON_VCLK_TARGET_DMT = 2,
+	MESON_VCLK_TARGET_DSI = 3,
 };
 
 /* 27MHz is the CVBS Pixel Clock */
diff -Naur a/drivers/gpu/drm/meson/meson_venc.c b/drivers/gpu/drm/meson/meson_venc.c
--- a/drivers/gpu/drm/meson/meson_venc.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_venc.c	2022-05-31 11:56:47.733259325 +0800
@@ -6,6 +6,7 @@
  */
 
 #include <linux/export.h>
+#include <linux/iopoll.h>
 
 #include <drm/drm_modes.h>
 
@@ -45,7 +46,7 @@
  * The ENCI is designed for PAl or NTSC encoding and can go through the VDAC
  * directly for CVBS encoding or through the ENCI_DVI encoder for HDMI.
  * The ENCP is designed for Progressive encoding but can also generate
- * 1080i interlaced pixels, and was initialy desined to encode pixels for
+ * 1080i interlaced pixels, and was initially designed to encode pixels for
  * VDAC to output RGB ou YUV analog outputs.
  * It's output is only used through the ENCP_DVI encoder for HDMI.
  * The ENCL LVDS encoder is not implemented.
@@ -866,10 +867,11 @@
 			    DRM_MODE_FLAG_PVSYNC | DRM_MODE_FLAG_NVSYNC))
 		return MODE_BAD;
 
-	if (mode->hdisplay < 640 || mode->hdisplay > 1920)
+	/* support higher resolution than 1920x1080 */
+	if (mode->hdisplay < 640 || mode->hdisplay > 2560)
 		return MODE_BAD_HVALUE;
 
-	if (mode->vdisplay < 480 || mode->vdisplay > 1200)
+	if (mode->vdisplay < 480 || mode->vdisplay > 1600)
 		return MODE_BAD_VVALUE;
 
 	return MODE_OK;
@@ -890,8 +892,8 @@
 }
 EXPORT_SYMBOL_GPL(meson_venc_hdmi_supported_vic);
 
-void meson_venc_hdmi_get_dmt_vmode(const struct drm_display_mode *mode,
-				   union meson_hdmi_venc_mode *dmt_mode)
+static void meson_venc_hdmi_get_dmt_vmode(const struct drm_display_mode *mode,
+					  union meson_hdmi_venc_mode *dmt_mode)
 {
 	memset(dmt_mode, 0, sizeof(*dmt_mode));
 
@@ -1557,6 +1559,205 @@
 }
 EXPORT_SYMBOL_GPL(meson_venc_hdmi_mode_set);
 
+static unsigned short meson_encl_gamma_table[256] = {
+	0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
+	64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124,
+	128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188,
+	192, 196, 200, 204, 208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252,
+	256, 260, 264, 268, 272, 276, 280, 284, 288, 292, 296, 300, 304, 308, 312, 316,
+	320, 324, 328, 332, 336, 340, 344, 348, 352, 356, 360, 364, 368, 372, 376, 380,
+	384, 388, 392, 396, 400, 404, 408, 412, 416, 420, 424, 428, 432, 436, 440, 444,
+	448, 452, 456, 460, 464, 468, 472, 476, 480, 484, 488, 492, 496, 500, 504, 508,
+	512, 516, 520, 524, 528, 532, 536, 540, 544, 548, 552, 556, 560, 564, 568, 572,
+	576, 580, 584, 588, 592, 596, 600, 604, 608, 612, 616, 620, 624, 628, 632, 636,
+	640, 644, 648, 652, 656, 660, 664, 668, 672, 676, 680, 684, 688, 692, 696, 700,
+	704, 708, 712, 716, 720, 724, 728, 732, 736, 740, 744, 748, 752, 756, 760, 764,
+	768, 772, 776, 780, 784, 788, 792, 796, 800, 804, 808, 812, 816, 820, 824, 828,
+	832, 836, 840, 844, 848, 852, 856, 860, 864, 868, 872, 876, 880, 884, 888, 892,
+	896, 900, 904, 908, 912, 916, 920, 924, 928, 932, 936, 940, 944, 948, 952, 956,
+	960, 964, 968, 972, 976, 980, 984, 988, 992, 996, 1000, 1004, 1008, 1012, 1016, 1020,
+};
+
+static void meson_encl_set_gamma_table(struct meson_drm *priv, u16 *data,
+				       u32 rgb_mask)
+{
+	int i, ret;
+	u32 reg;
+
+	writel_bits_relaxed(L_GAMMA_CNTL_PORT_EN, 0,
+			    priv->io_base + _REG(L_GAMMA_CNTL_PORT));
+
+	ret = readl_relaxed_poll_timeout(priv->io_base + _REG(L_GAMMA_CNTL_PORT),
+					 reg, reg & L_GAMMA_CNTL_PORT_ADR_RDY, 10, 10000);
+	if (ret)
+		pr_warn("%s: GAMMA ADR_RDY timeout\n", __func__);
+
+	writel_relaxed(L_GAMMA_ADDR_PORT_AUTO_INC | rgb_mask |
+		       FIELD_PREP(L_GAMMA_ADDR_PORT_ADDR, 0),
+		       priv->io_base + _REG(L_GAMMA_ADDR_PORT));
+
+	for (i = 0; i < 256; i++) {
+		ret = readl_relaxed_poll_timeout(priv->io_base + _REG(L_GAMMA_CNTL_PORT),
+						 reg, reg & L_GAMMA_CNTL_PORT_WR_RDY,
+						 10, 10000);
+		if (ret)
+			pr_warn_once("%s: GAMMA WR_RDY timeout\n", __func__);
+
+		writel_relaxed(data[i], priv->io_base + _REG(L_GAMMA_DATA_PORT));
+	}
+
+	ret = readl_relaxed_poll_timeout(priv->io_base + _REG(L_GAMMA_CNTL_PORT),
+					 reg, reg & L_GAMMA_CNTL_PORT_ADR_RDY, 10, 10000);
+	if (ret)
+		pr_warn("%s: GAMMA ADR_RDY timeout\n", __func__);
+
+	writel_relaxed(L_GAMMA_ADDR_PORT_AUTO_INC | rgb_mask |
+		       FIELD_PREP(L_GAMMA_ADDR_PORT_ADDR, 0x23),
+		       priv->io_base + _REG(L_GAMMA_ADDR_PORT));
+}
+
+void meson_encl_load_gamma(struct meson_drm *priv)
+{
+	meson_encl_set_gamma_table(priv, meson_encl_gamma_table, L_GAMMA_ADDR_PORT_SEL_R);
+	meson_encl_set_gamma_table(priv, meson_encl_gamma_table, L_GAMMA_ADDR_PORT_SEL_G);
+	meson_encl_set_gamma_table(priv, meson_encl_gamma_table, L_GAMMA_ADDR_PORT_SEL_B);
+
+	writel_bits_relaxed(L_GAMMA_CNTL_PORT_EN, L_GAMMA_CNTL_PORT_EN,
+			    priv->io_base + _REG(L_GAMMA_CNTL_PORT));
+}
+
+void meson_venc_mipi_dsi_mode_set(struct meson_drm *priv,
+				  const struct drm_display_mode *mode)
+{
+	unsigned int max_pxcnt;
+	unsigned int max_lncnt;
+	unsigned int havon_begin;
+	unsigned int havon_end;
+	unsigned int vavon_bline;
+	unsigned int vavon_eline;
+	unsigned int hso_begin;
+	unsigned int hso_end;
+	unsigned int vso_begin;
+	unsigned int vso_end;
+	unsigned int vso_bline;
+	unsigned int vso_eline;
+
+	max_pxcnt = mode->htotal - 1;
+	max_lncnt = mode->vtotal - 1;
+	havon_begin = mode->htotal - mode->hsync_start;
+	havon_end = havon_begin + mode->hdisplay - 1;
+	vavon_bline = mode->vtotal - mode->vsync_start;
+	vavon_eline = vavon_bline + mode->vdisplay - 1;
+	hso_begin = 0;
+	hso_end = mode->hsync_end - mode->hsync_start;
+	vso_begin = 0;
+	vso_end = 0;
+	vso_bline = 0;
+	vso_eline = mode->vsync_end - mode->vsync_start;
+
+	meson_vpp_setup_mux(priv, MESON_VIU_VPP_MUX_ENCL);
+
+	writel_relaxed(0, priv->io_base + _REG(ENCL_VIDEO_EN));
+
+	writel_relaxed(ENCL_PX_LN_CNT_SHADOW_EN, priv->io_base + _REG(ENCL_VIDEO_MODE));
+	writel_relaxed(ENCL_VIDEO_MODE_ADV_VFIFO_EN |
+		       ENCL_VIDEO_MODE_ADV_GAIN_HDTV |
+		       ENCL_SEL_GAMMA_RGB_IN, priv->io_base + _REG(ENCL_VIDEO_MODE_ADV));
+
+	writel_relaxed(ENCL_VIDEO_FILT_CTRL_BYPASS_FILTER,
+		       priv->io_base + _REG(ENCL_VIDEO_FILT_CTRL));
+	writel_relaxed(max_pxcnt, priv->io_base + _REG(ENCL_VIDEO_MAX_PXCNT));
+	writel_relaxed(max_lncnt, priv->io_base + _REG(ENCL_VIDEO_MAX_LNCNT));
+	writel_relaxed(havon_begin, priv->io_base + _REG(ENCL_VIDEO_HAVON_BEGIN));
+	writel_relaxed(havon_end, priv->io_base + _REG(ENCL_VIDEO_HAVON_END));
+	writel_relaxed(vavon_bline, priv->io_base + _REG(ENCL_VIDEO_VAVON_BLINE));
+	writel_relaxed(vavon_eline, priv->io_base + _REG(ENCL_VIDEO_VAVON_ELINE));
+
+	writel_relaxed(hso_begin, priv->io_base + _REG(ENCL_VIDEO_HSO_BEGIN));
+	writel_relaxed(hso_end, priv->io_base + _REG(ENCL_VIDEO_HSO_END));
+	writel_relaxed(vso_begin, priv->io_base + _REG(ENCL_VIDEO_VSO_BEGIN));
+	writel_relaxed(vso_end, priv->io_base + _REG(ENCL_VIDEO_VSO_END));
+	writel_relaxed(vso_bline, priv->io_base + _REG(ENCL_VIDEO_VSO_BLINE));
+	writel_relaxed(vso_eline, priv->io_base + _REG(ENCL_VIDEO_VSO_ELINE));
+	writel_relaxed(ENCL_VIDEO_RGBIN_RGB | ENCL_VIDEO_RGBIN_ZBLK,
+		       priv->io_base + _REG(ENCL_VIDEO_RGBIN_CTRL));
+
+	/* default black pattern */
+	writel_relaxed(0, priv->io_base + _REG(ENCL_TST_MDSEL));
+	writel_relaxed(0, priv->io_base + _REG(ENCL_TST_Y));
+	writel_relaxed(0, priv->io_base + _REG(ENCL_TST_CB));
+	writel_relaxed(0, priv->io_base + _REG(ENCL_TST_CR));
+	writel_relaxed(1, priv->io_base + _REG(ENCL_TST_EN));
+	writel_bits_relaxed(ENCL_VIDEO_MODE_ADV_VFIFO_EN, 0,
+			    priv->io_base + _REG(ENCL_VIDEO_MODE_ADV));
+
+	writel_relaxed(1, priv->io_base + _REG(ENCL_VIDEO_EN));
+
+	writel_relaxed(0, priv->io_base + _REG(L_RGB_BASE_ADDR));
+	writel_relaxed(0x400, priv->io_base + _REG(L_RGB_COEFF_ADDR)); /* Magic value */
+
+	writel_relaxed(L_DITH_CNTL_DITH10_EN, priv->io_base + _REG(L_DITH_CNTL_ADDR));
+
+	/* DE signal for TTL */
+	writel_relaxed(havon_begin, priv->io_base + _REG(L_OEH_HS_ADDR));
+	writel_relaxed(havon_end + 1, priv->io_base + _REG(L_OEH_HE_ADDR));
+	writel_relaxed(vavon_bline, priv->io_base + _REG(L_OEH_VS_ADDR));
+	writel_relaxed(vavon_eline, priv->io_base + _REG(L_OEH_VE_ADDR));
+
+	/* DE signal for TTL */
+	writel_relaxed(havon_begin, priv->io_base + _REG(L_OEV1_HS_ADDR));
+	writel_relaxed(havon_end + 1, priv->io_base + _REG(L_OEV1_HE_ADDR));
+	writel_relaxed(vavon_bline, priv->io_base + _REG(L_OEV1_VS_ADDR));
+	writel_relaxed(vavon_eline, priv->io_base + _REG(L_OEV1_VE_ADDR));
+
+	/* Hsync signal for TTL */
+	if (mode->flags & DRM_MODE_FLAG_PHSYNC) {
+		writel_relaxed(hso_end, priv->io_base + _REG(L_STH1_HS_ADDR));
+		writel_relaxed(hso_begin, priv->io_base + _REG(L_STH1_HE_ADDR));
+	} else {
+		writel_relaxed(hso_begin, priv->io_base + _REG(L_STH1_HS_ADDR));
+		writel_relaxed(hso_end, priv->io_base + _REG(L_STH1_HE_ADDR));
+	}
+	writel_relaxed(0, priv->io_base + _REG(L_STH1_VS_ADDR));
+	writel_relaxed(max_lncnt, priv->io_base + _REG(L_STH1_VE_ADDR));
+
+	/* Vsync signal for TTL */
+	writel_relaxed(vso_begin, priv->io_base + _REG(L_STV1_HS_ADDR));
+	writel_relaxed(vso_end, priv->io_base + _REG(L_STV1_HE_ADDR));
+	if (mode->flags & DRM_MODE_FLAG_PVSYNC) {
+		writel_relaxed(vso_eline, priv->io_base + _REG(L_STV1_VS_ADDR));
+		writel_relaxed(vso_bline, priv->io_base + _REG(L_STV1_VE_ADDR));
+	} else {
+		writel_relaxed(vso_bline, priv->io_base + _REG(L_STV1_VS_ADDR));
+		writel_relaxed(vso_eline, priv->io_base + _REG(L_STV1_VE_ADDR));
+	}
+
+	/* DE signal */
+	writel_relaxed(havon_begin, priv->io_base + _REG(L_DE_HS_ADDR));
+	writel_relaxed(havon_end + 1, priv->io_base + _REG(L_DE_HE_ADDR));
+	writel_relaxed(vavon_bline, priv->io_base + _REG(L_DE_VS_ADDR));
+	writel_relaxed(vavon_eline, priv->io_base + _REG(L_DE_VE_ADDR));
+
+	/* Hsync signal */
+	writel_relaxed(hso_begin, priv->io_base + _REG(L_HSYNC_HS_ADDR));
+	writel_relaxed(hso_end, priv->io_base + _REG(L_HSYNC_HE_ADDR));
+	writel_relaxed(0, priv->io_base + _REG(L_HSYNC_VS_ADDR));
+	writel_relaxed(max_lncnt, priv->io_base + _REG(L_HSYNC_VE_ADDR));
+
+	/* Vsync signal */
+	writel_relaxed(vso_begin, priv->io_base + _REG(L_VSYNC_HS_ADDR));
+	writel_relaxed(vso_end, priv->io_base + _REG(L_VSYNC_HE_ADDR));
+	writel_relaxed(vso_bline, priv->io_base + _REG(L_VSYNC_VS_ADDR));
+	writel_relaxed(vso_eline, priv->io_base + _REG(L_VSYNC_VE_ADDR));
+
+	writel_relaxed(0, priv->io_base + _REG(L_INV_CNT_ADDR));
+	writel_relaxed(L_TCON_MISC_SEL_STV1 | L_TCON_MISC_SEL_STV2,
+		       priv->io_base + _REG(L_TCON_MISC_SEL_ADDR));
+
+	priv->venc.current_mode = MESON_VENC_MODE_MIPI_DSI;
+}
+EXPORT_SYMBOL_GPL(meson_venc_mipi_dsi_mode_set);
+
 void meson_venci_cvbs_mode_set(struct meson_drm *priv,
 			       struct meson_cvbs_enci_mode *mode)
 {
@@ -1747,8 +1948,15 @@
 
 void meson_venc_enable_vsync(struct meson_drm *priv)
 {
-	writel_relaxed(VENC_INTCTRL_ENCI_LNRST_INT_EN,
-		       priv->io_base + _REG(VENC_INTCTRL));
+	switch (priv->venc.current_mode) {
+	case MESON_VENC_MODE_MIPI_DSI:
+		writel_relaxed(VENC_INTCTRL_ENCP_LNRST_INT_EN,
+			       priv->io_base + _REG(VENC_INTCTRL));
+		break;
+	default:
+		writel_relaxed(VENC_INTCTRL_ENCI_LNRST_INT_EN,
+			       priv->io_base + _REG(VENC_INTCTRL));
+	}
 	regmap_update_bits(priv->hhi, HHI_GCLK_MPEG2, BIT(25), BIT(25));
 }
 
diff -Naur a/drivers/gpu/drm/meson/meson_venc_cvbs.c b/drivers/gpu/drm/meson/meson_venc_cvbs.c
--- a/drivers/gpu/drm/meson/meson_venc_cvbs.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_venc_cvbs.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,293 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (C) 2016 BayLibre, SAS
- * Author: Neil Armstrong <narmstrong@baylibre.com>
- * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
- * Copyright (C) 2014 Endless Mobile
- *
- * Written by:
- *     Jasper St. Pierre <jstpierre@mecheye.net>
- */
-
-#include <linux/export.h>
-#include <linux/of_graph.h>
-
-#include <drm/drm_atomic_helper.h>
-#include <drm/drm_device.h>
-#include <drm/drm_edid.h>
-#include <drm/drm_probe_helper.h>
-#include <drm/drm_print.h>
-
-#include "meson_registers.h"
-#include "meson_vclk.h"
-#include "meson_venc_cvbs.h"
-
-/* HHI VDAC Registers */
-#define HHI_VDAC_CNTL0		0x2F4 /* 0xbd offset in data sheet */
-#define HHI_VDAC_CNTL0_G12A	0x2EC /* 0xbd offset in data sheet */
-#define HHI_VDAC_CNTL1		0x2F8 /* 0xbe offset in data sheet */
-#define HHI_VDAC_CNTL1_G12A	0x2F0 /* 0xbe offset in data sheet */
-
-struct meson_venc_cvbs {
-	struct drm_encoder	encoder;
-	struct drm_connector	connector;
-	struct meson_drm	*priv;
-};
-#define encoder_to_meson_venc_cvbs(x) \
-	container_of(x, struct meson_venc_cvbs, encoder)
-
-#define connector_to_meson_venc_cvbs(x) \
-	container_of(x, struct meson_venc_cvbs, connector)
-
-/* Supported Modes */
-
-struct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT] = {
-	{ /* PAL */
-		.enci = &meson_cvbs_enci_pal,
-		.mode = {
-			DRM_MODE("720x576i", DRM_MODE_TYPE_DRIVER, 13500,
-				 720, 732, 795, 864, 0, 576, 580, 586, 625, 0,
-				 DRM_MODE_FLAG_INTERLACE),
-			.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,
-		},
-	},
-	{ /* NTSC */
-		.enci = &meson_cvbs_enci_ntsc,
-		.mode = {
-			DRM_MODE("720x480i", DRM_MODE_TYPE_DRIVER, 13500,
-				720, 739, 801, 858, 0, 480, 488, 494, 525, 0,
-				DRM_MODE_FLAG_INTERLACE),
-			.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3,
-		},
-	},
-};
-
-static const struct meson_cvbs_mode *
-meson_cvbs_get_mode(const struct drm_display_mode *req_mode)
-{
-	int i;
-
-	for (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {
-		struct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];
-
-		if (drm_mode_match(req_mode, &meson_mode->mode,
-				   DRM_MODE_MATCH_TIMINGS |
-				   DRM_MODE_MATCH_CLOCK |
-				   DRM_MODE_MATCH_FLAGS |
-				   DRM_MODE_MATCH_3D_FLAGS))
-			return meson_mode;
-	}
-
-	return NULL;
-}
-
-/* Connector */
-
-static void meson_cvbs_connector_destroy(struct drm_connector *connector)
-{
-	drm_connector_cleanup(connector);
-}
-
-static enum drm_connector_status
-meson_cvbs_connector_detect(struct drm_connector *connector, bool force)
-{
-	/* FIXME: Add load-detect or jack-detect if possible */
-	return connector_status_connected;
-}
-
-static int meson_cvbs_connector_get_modes(struct drm_connector *connector)
-{
-	struct drm_device *dev = connector->dev;
-	struct drm_display_mode *mode;
-	int i;
-
-	for (i = 0; i < MESON_CVBS_MODES_COUNT; ++i) {
-		struct meson_cvbs_mode *meson_mode = &meson_cvbs_modes[i];
-
-		mode = drm_mode_duplicate(dev, &meson_mode->mode);
-		if (!mode) {
-			DRM_ERROR("Failed to create a new display mode\n");
-			return 0;
-		}
-
-		drm_mode_probed_add(connector, mode);
-	}
-
-	return i;
-}
-
-static int meson_cvbs_connector_mode_valid(struct drm_connector *connector,
-					   struct drm_display_mode *mode)
-{
-	/* Validate the modes added in get_modes */
-	return MODE_OK;
-}
-
-static const struct drm_connector_funcs meson_cvbs_connector_funcs = {
-	.detect			= meson_cvbs_connector_detect,
-	.fill_modes		= drm_helper_probe_single_connector_modes,
-	.destroy		= meson_cvbs_connector_destroy,
-	.reset			= drm_atomic_helper_connector_reset,
-	.atomic_duplicate_state	= drm_atomic_helper_connector_duplicate_state,
-	.atomic_destroy_state	= drm_atomic_helper_connector_destroy_state,
-};
-
-static const
-struct drm_connector_helper_funcs meson_cvbs_connector_helper_funcs = {
-	.get_modes	= meson_cvbs_connector_get_modes,
-	.mode_valid	= meson_cvbs_connector_mode_valid,
-};
-
-/* Encoder */
-
-static void meson_venc_cvbs_encoder_destroy(struct drm_encoder *encoder)
-{
-	drm_encoder_cleanup(encoder);
-}
-
-static const struct drm_encoder_funcs meson_venc_cvbs_encoder_funcs = {
-	.destroy        = meson_venc_cvbs_encoder_destroy,
-};
-
-static int meson_venc_cvbs_encoder_atomic_check(struct drm_encoder *encoder,
-					struct drm_crtc_state *crtc_state,
-					struct drm_connector_state *conn_state)
-{
-	if (meson_cvbs_get_mode(&crtc_state->mode))
-		return 0;
-
-	return -EINVAL;
-}
-
-static void meson_venc_cvbs_encoder_disable(struct drm_encoder *encoder)
-{
-	struct meson_venc_cvbs *meson_venc_cvbs =
-					encoder_to_meson_venc_cvbs(encoder);
-	struct meson_drm *priv = meson_venc_cvbs->priv;
-
-	/* Disable CVBS VDAC */
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
-	} else {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 8);
-	}
-}
-
-static void meson_venc_cvbs_encoder_enable(struct drm_encoder *encoder)
-{
-	struct meson_venc_cvbs *meson_venc_cvbs =
-					encoder_to_meson_venc_cvbs(encoder);
-	struct meson_drm *priv = meson_venc_cvbs->priv;
-
-	/* VDAC0 source is not from ATV */
-	writel_bits_relaxed(VENC_VDAC_SEL_ATV_DMD, 0,
-			    priv->io_base + _REG(VENC_VDAC_DACSEL0));
-
-	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXBB)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 1);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);
-	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXM) ||
-		 meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0, 0xf0001);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1, 0);
-	} else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		regmap_write(priv->hhi, HHI_VDAC_CNTL0_G12A, 0x906001);
-		regmap_write(priv->hhi, HHI_VDAC_CNTL1_G12A, 0);
-	}
-}
-
-static void meson_venc_cvbs_encoder_mode_set(struct drm_encoder *encoder,
-				   struct drm_display_mode *mode,
-				   struct drm_display_mode *adjusted_mode)
-{
-	const struct meson_cvbs_mode *meson_mode = meson_cvbs_get_mode(mode);
-	struct meson_venc_cvbs *meson_venc_cvbs =
-					encoder_to_meson_venc_cvbs(encoder);
-	struct meson_drm *priv = meson_venc_cvbs->priv;
-
-	if (meson_mode) {
-		meson_venci_cvbs_mode_set(priv, meson_mode->enci);
-
-		/* Setup 27MHz vclk2 for ENCI and VDAC */
-		meson_vclk_setup(priv, MESON_VCLK_TARGET_CVBS,
-				 MESON_VCLK_CVBS, MESON_VCLK_CVBS,
-				 MESON_VCLK_CVBS, MESON_VCLK_CVBS,
-				 true);
-	}
-}
-
-static const struct drm_encoder_helper_funcs
-				meson_venc_cvbs_encoder_helper_funcs = {
-	.atomic_check	= meson_venc_cvbs_encoder_atomic_check,
-	.disable	= meson_venc_cvbs_encoder_disable,
-	.enable		= meson_venc_cvbs_encoder_enable,
-	.mode_set	= meson_venc_cvbs_encoder_mode_set,
-};
-
-static bool meson_venc_cvbs_connector_is_available(struct meson_drm *priv)
-{
-	struct device_node *remote;
-
-	remote = of_graph_get_remote_node(priv->dev->of_node, 0, 0);
-	if (!remote)
-		return false;
-
-	of_node_put(remote);
-	return true;
-}
-
-int meson_venc_cvbs_create(struct meson_drm *priv)
-{
-	struct drm_device *drm = priv->drm;
-	struct meson_venc_cvbs *meson_venc_cvbs;
-	struct drm_connector *connector;
-	struct drm_encoder *encoder;
-	int ret;
-
-	if (!meson_venc_cvbs_connector_is_available(priv)) {
-		dev_info(drm->dev, "CVBS Output connector not available\n");
-		return 0;
-	}
-
-	meson_venc_cvbs = devm_kzalloc(priv->dev, sizeof(*meson_venc_cvbs),
-				       GFP_KERNEL);
-	if (!meson_venc_cvbs)
-		return -ENOMEM;
-
-	meson_venc_cvbs->priv = priv;
-	encoder = &meson_venc_cvbs->encoder;
-	connector = &meson_venc_cvbs->connector;
-
-	/* Connector */
-
-	drm_connector_helper_add(connector,
-				 &meson_cvbs_connector_helper_funcs);
-
-	ret = drm_connector_init(drm, connector, &meson_cvbs_connector_funcs,
-				 DRM_MODE_CONNECTOR_Composite);
-	if (ret) {
-		dev_err(priv->dev, "Failed to init CVBS connector\n");
-		return ret;
-	}
-
-	connector->interlace_allowed = 1;
-
-	/* Encoder */
-
-	drm_encoder_helper_add(encoder, &meson_venc_cvbs_encoder_helper_funcs);
-
-	ret = drm_encoder_init(drm, encoder, &meson_venc_cvbs_encoder_funcs,
-			       DRM_MODE_ENCODER_TVDAC, "meson_venc_cvbs");
-	if (ret) {
-		dev_err(priv->dev, "Failed to init CVBS encoder\n");
-		return ret;
-	}
-
-	encoder->possible_crtcs = BIT(0);
-
-	drm_connector_attach_encoder(connector, encoder);
-
-	return 0;
-}
diff -Naur a/drivers/gpu/drm/meson/meson_venc_cvbs.h b/drivers/gpu/drm/meson/meson_venc_cvbs.h
--- a/drivers/gpu/drm/meson/meson_venc_cvbs.h	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_venc_cvbs.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (C) 2016 BayLibre, SAS
- * Author: Neil Armstrong <narmstrong@baylibre.com>
- * Copyright (C) 2014 Endless Mobile
- *
- * Written by:
- *     Jasper St. Pierre <jstpierre@mecheye.net>
- */
-
-#ifndef __MESON_VENC_CVBS_H
-#define __MESON_VENC_CVBS_H
-
-#include "meson_drv.h"
-#include "meson_venc.h"
-
-struct meson_cvbs_mode {
-	struct meson_cvbs_enci_mode *enci;
-	struct drm_display_mode mode;
-};
-
-#define MESON_CVBS_MODES_COUNT	2
-
-/* Modes supported by the CVBS output */
-extern struct meson_cvbs_mode meson_cvbs_modes[MESON_CVBS_MODES_COUNT];
-
-int meson_venc_cvbs_create(struct meson_drm *priv);
-
-#endif /* __MESON_VENC_CVBS_H */
diff -Naur a/drivers/gpu/drm/meson/meson_venc.h b/drivers/gpu/drm/meson/meson_venc.h
--- a/drivers/gpu/drm/meson/meson_venc.h	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_venc.h	2022-05-31 11:56:47.733259325 +0800
@@ -21,6 +21,7 @@
 	MESON_VENC_MODE_CVBS_PAL,
 	MESON_VENC_MODE_CVBS_NTSC,
 	MESON_VENC_MODE_HDMI,
+	MESON_VENC_MODE_MIPI_DSI,
 };
 
 struct meson_cvbs_enci_mode {
@@ -47,6 +48,9 @@
 	unsigned int analog_sync_adj;
 };
 
+/* LCD Encoder gamma setup */
+void meson_encl_load_gamma(struct meson_drm *priv);
+
 /* HDMI Clock parameters */
 enum drm_mode_status
 meson_venc_hdmi_supported_mode(const struct drm_display_mode *mode);
@@ -63,6 +67,8 @@
 			      unsigned int ycrcb_map,
 			      bool yuv420_mode,
 			      const struct drm_display_mode *mode);
+void meson_venc_mipi_dsi_mode_set(struct meson_drm *priv,
+				  const struct drm_display_mode *mode);
 unsigned int meson_venci_get_field(struct meson_drm *priv);
 
 void meson_venc_enable_vsync(struct meson_drm *priv);
diff -Naur a/drivers/gpu/drm/meson/meson_viu.c b/drivers/gpu/drm/meson/meson_viu.c
--- a/drivers/gpu/drm/meson/meson_viu.c	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_viu.c	2022-05-31 11:56:47.733259325 +0800
@@ -78,32 +78,52 @@
 	EOTF_COEFF_RIGHTSHIFT /* right shift */
 };
 
-static void meson_viu_set_g12a_osd1_matrix(struct meson_drm *priv,
-					   int *m, bool csc_on)
+static void meson_viu_set_g12a_osd_matrix(struct meson_drm *priv,
+					  int *m, bool csc_on)
 {
 	/* VPP WRAP OSD1 matrix */
 	writel(((m[0] & 0xfff) << 16) | (m[1] & 0xfff),
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_PRE_OFFSET0_1));
+	writel(((m[0] & 0xfff) << 16) | (m[1] & 0xfff),
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_PRE_OFFSET0_1));
 	writel(m[2] & 0xfff,
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_PRE_OFFSET2));
+	writel(m[2] & 0xfff,
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_PRE_OFFSET2));
 	writel(((m[3] & 0x1fff) << 16) | (m[4] & 0x1fff),
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_COEF00_01));
+	writel(((m[3] & 0x1fff) << 16) | (m[4] & 0x1fff),
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_COEF00_01));
 	writel(((m[5] & 0x1fff) << 16) | (m[6] & 0x1fff),
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_COEF02_10));
+	writel(((m[5] & 0x1fff) << 16) | (m[6] & 0x1fff),
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_COEF02_10));
 	writel(((m[7] & 0x1fff) << 16) | (m[8] & 0x1fff),
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_COEF11_12));
+	writel(((m[7] & 0x1fff) << 16) | (m[8] & 0x1fff),
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_COEF11_12));
 	writel(((m[9] & 0x1fff) << 16) | (m[10] & 0x1fff),
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_COEF20_21));
+	writel(((m[9] & 0x1fff) << 16) | (m[10] & 0x1fff),
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_COEF20_21));
 	writel((m[11] & 0x1fff) << 16,
 		priv->io_base +	_REG(VPP_WRAP_OSD1_MATRIX_COEF22));
+	writel((m[11] & 0x1fff) << 16,
+		priv->io_base +	_REG(VPP_WRAP_OSD2_MATRIX_COEF22));
 
 	writel(((m[18] & 0xfff) << 16) | (m[19] & 0xfff),
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_OFFSET0_1));
+	writel(((m[18] & 0xfff) << 16) | (m[19] & 0xfff),
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_OFFSET0_1));
 	writel(m[20] & 0xfff,
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_OFFSET2));
+	writel(m[20] & 0xfff,
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_OFFSET2));
 
 	writel_bits_relaxed(BIT(0), csc_on ? BIT(0) : 0,
 		priv->io_base + _REG(VPP_WRAP_OSD1_MATRIX_EN_CTRL));
+	writel_bits_relaxed(BIT(0), csc_on ? BIT(0) : 0,
+		priv->io_base + _REG(VPP_WRAP_OSD2_MATRIX_EN_CTRL));
 }
 
 static void meson_viu_set_osd_matrix(struct meson_drm *priv,
@@ -114,21 +134,36 @@
 		/* osd matrix, VIU_MATRIX_0 */
 		writel(((m[0] & 0xfff) << 16) | (m[1] & 0xfff),
 			priv->io_base + _REG(VIU_OSD1_MATRIX_PRE_OFFSET0_1));
+		writel(((m[0] & 0xfff) << 16) | (m[1] & 0xfff),
+			priv->io_base + _REG(VIU_OSD2_MATRIX_PRE_OFFSET0_1));
 		writel(m[2] & 0xfff,
 			priv->io_base + _REG(VIU_OSD1_MATRIX_PRE_OFFSET2));
+		writel(m[2] & 0xfff,
+			priv->io_base + _REG(VIU_OSD2_MATRIX_PRE_OFFSET2));
 		writel(((m[3] & 0x1fff) << 16) | (m[4] & 0x1fff),
 			priv->io_base + _REG(VIU_OSD1_MATRIX_COEF00_01));
+		writel(((m[3] & 0x1fff) << 16) | (m[4] & 0x1fff),
+			priv->io_base + _REG(VIU_OSD2_MATRIX_COEF00_01));
 		writel(((m[5] & 0x1fff) << 16) | (m[6] & 0x1fff),
 			priv->io_base + _REG(VIU_OSD1_MATRIX_COEF02_10));
+		writel(((m[5] & 0x1fff) << 16) | (m[6] & 0x1fff),
+			priv->io_base + _REG(VIU_OSD2_MATRIX_COEF02_10));
 		writel(((m[7] & 0x1fff) << 16) | (m[8] & 0x1fff),
 			priv->io_base + _REG(VIU_OSD1_MATRIX_COEF11_12));
+		writel(((m[7] & 0x1fff) << 16) | (m[8] & 0x1fff),
+			priv->io_base + _REG(VIU_OSD2_MATRIX_COEF11_12));
 		writel(((m[9] & 0x1fff) << 16) | (m[10] & 0x1fff),
 			priv->io_base + _REG(VIU_OSD1_MATRIX_COEF20_21));
+		writel(((m[9] & 0x1fff) << 16) | (m[10] & 0x1fff),
+			priv->io_base + _REG(VIU_OSD2_MATRIX_COEF20_21));
 
 		if (m[21]) {
 			writel(((m[11] & 0x1fff) << 16) | (m[12] & 0x1fff),
 				priv->io_base +
 					_REG(VIU_OSD1_MATRIX_COEF22_30));
+			writel(((m[11] & 0x1fff) << 16),
+				priv->io_base +
+					_REG(VIU_OSD2_MATRIX_COEF22));
 			writel(((m[13] & 0x1fff) << 16) | (m[14] & 0x1fff),
 				priv->io_base +
 					_REG(VIU_OSD1_MATRIX_COEF31_32));
@@ -137,14 +172,21 @@
 					_REG(VIU_OSD1_MATRIX_COEF40_41));
 			writel(m[17] & 0x1fff, priv->io_base +
 				_REG(VIU_OSD1_MATRIX_COLMOD_COEF42));
-		} else
+		} else {
 			writel((m[11] & 0x1fff) << 16, priv->io_base +
 				_REG(VIU_OSD1_MATRIX_COEF22_30));
+			writel((m[11] & 0x1fff) << 16, priv->io_base +
+				_REG(VIU_OSD2_MATRIX_COEF22));
+		}
 
 		writel(((m[18] & 0xfff) << 16) | (m[19] & 0xfff),
 			priv->io_base + _REG(VIU_OSD1_MATRIX_OFFSET0_1));
+		writel(((m[18] & 0xfff) << 16) | (m[19] & 0xfff),
+			priv->io_base + _REG(VIU_OSD2_MATRIX_OFFSET0_1));
 		writel(m[20] & 0xfff,
 			priv->io_base + _REG(VIU_OSD1_MATRIX_OFFSET2));
+		writel(m[20] & 0xfff,
+			priv->io_base + _REG(VIU_OSD2_MATRIX_OFFSET2));
 
 		writel_bits_relaxed(3 << 30, m[21] << 30,
 			priv->io_base + _REG(VIU_OSD1_MATRIX_COLMOD_COEF42));
@@ -154,8 +196,12 @@
 		/* 23 reserved for clipping control */
 		writel_bits_relaxed(BIT(0), csc_on ? BIT(0) : 0,
 			priv->io_base + _REG(VIU_OSD1_MATRIX_CTRL));
+		writel_bits_relaxed(BIT(0), csc_on ? BIT(0) : 0,
+			priv->io_base + _REG(VIU_OSD2_MATRIX_CTRL));
 		writel_bits_relaxed(BIT(1), 0,
 			priv->io_base + _REG(VIU_OSD1_MATRIX_CTRL));
+		writel_bits_relaxed(BIT(1), 0,
+			priv->io_base + _REG(VIU_OSD2_MATRIX_CTRL));
 	} else if (m_select == VIU_MATRIX_OSD_EOTF) {
 		int i;
 
@@ -426,7 +472,7 @@
 	    meson_vpu_is_compatible(priv, VPU_COMPATIBLE_GXL))
 		meson_viu_load_matrix(priv);
 	else if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		meson_viu_set_g12a_osd1_matrix(priv, RGB709_to_YUV709l_coeff,
+		meson_viu_set_g12a_osd_matrix(priv, RGB709_to_YUV709l_coeff,
 					       true);
 		/* fix green/pink color distortion from vendor u-boot */
 		writel_bits_relaxed(OSD1_HDR2_CTRL_REG_ONLY_MAT |
@@ -469,14 +515,13 @@
 			priv->io_base + _REG(VD2_IF0_LUMA_FIFO_SIZE));
 
 	if (meson_vpu_is_compatible(priv, VPU_COMPATIBLE_G12A)) {
-		writel_relaxed(VIU_OSD_BLEND_REORDER(0, 1) |
-			       VIU_OSD_BLEND_REORDER(1, 0) |
-			       VIU_OSD_BLEND_REORDER(2, 0) |
-			       VIU_OSD_BLEND_REORDER(3, 0) |
-			       VIU_OSD_BLEND_DIN_EN(1) |
-			       VIU_OSD_BLEND1_DIN3_BYPASS_TO_DOUT1 |
-			       VIU_OSD_BLEND1_DOUT_BYPASS_TO_BLEND2 |
-			       VIU_OSD_BLEND_DIN0_BYPASS_TO_DOUT0 |
+		/* setup bypass to have OSD1->DOUT0 + OSD2->DOUT1 */
+		writel_relaxed(VIU_OSD_BLEND_REORDER(0, 1) |	/* OSD1 to DIN0 */
+			       VIU_OSD_BLEND_REORDER(1, 4) |
+			       VIU_OSD_BLEND_REORDER(2, 4) |
+			       VIU_OSD_BLEND_REORDER(3, 2) |	/* OSD2 to DIN3 */
+			       VIU_OSD_BLEND_DIN_EN(9) |	/* Enable DIN0 & DIN3 */
+			       VIU_OSD_BLEND_DIN0_BYPASS_TO_DOUT0 |	/* DIN0 to DOUT0 */
 			       VIU_OSD_BLEND_BLEN2_PREMULT_EN(1) |
 			       VIU_OSD_BLEND_HOLD_LINES(4),
 			       priv->io_base + _REG(VIU_OSD_BLEND_CTRL));
diff -Naur a/drivers/gpu/drm/meson/meson_vpp.h b/drivers/gpu/drm/meson/meson_vpp.h
--- a/drivers/gpu/drm/meson/meson_vpp.h	2022-05-27 17:20:15.601901127 +0800
+++ b/drivers/gpu/drm/meson/meson_vpp.h	2022-05-31 11:56:47.733259325 +0800
@@ -12,6 +12,8 @@
 struct drm_rect;
 struct meson_drm;
 
+/* Mux VIU/VPP to ENCL */
+#define MESON_VIU_VPP_MUX_ENCL	0x0
 /* Mux VIU/VPP to ENCI */
 #define MESON_VIU_VPP_MUX_ENCI	0x5
 /* Mux VIU/VPP to ENCP */
diff -Naur a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
--- a/drivers/gpu/drm/panel/Kconfig	2022-05-27 17:20:15.689902262 +0800
+++ b/drivers/gpu/drm/panel/Kconfig	2022-05-31 11:56:47.733259325 +0800
@@ -69,6 +69,15 @@
 	  that it can be automatically turned off when the panel goes into a
 	  low power state.
 
+config DRM_PANEL_CHIPONE_ICN6211
+	tristate "Chipone ICN6211 panel driver"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	help
+	  Say Y here if you want to enable support for the Chipone
+	  ICN6211 controller for 800x480 LCD panels with MIPI-DSI-RGB
+	  system interfaces, with 2 lane.
+
 config DRM_PANEL_ELIDA_KD35T133
 	tristate "Elida KD35T133 panel driver"
 	depends on OF
@@ -500,4 +509,13 @@
 	  Say Y here if you want to enable support for the Xinpeng
 	  XPP055C272 controller for 720x1280 LCD panels with MIPI/RGB/SPI
 	  system interfaces.
+
+config DRM_PANEL_WAVESHARE_TL070HDV03CT
+        tristate "Waveshare TL070HDV03CT 800x480 video mode panel"
+        depends on OF
+        depends on DRM_MIPI_DSI
+        depends on BACKLIGHT_CLASS_DEVICE
+        help
+          Say Y here if you want to enable support for Waveshare TL070HDV03CT
+          (800x480) Chipone ICN6211-based DSI panel
 endmenu
diff -Naur a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
--- a/drivers/gpu/drm/panel/Makefile	2022-05-27 17:20:15.689902262 +0800
+++ b/drivers/gpu/drm/panel/Makefile	2022-05-31 11:56:47.733259325 +0800
@@ -3,6 +3,7 @@
 obj-$(CONFIG_DRM_PANEL_ASUS_Z00T_TM5P5_NT35596) += panel-asus-z00t-tm5p5-n35596.o
 obj-$(CONFIG_DRM_PANEL_BOE_HIMAX8279D) += panel-boe-himax8279d.o
 obj-$(CONFIG_DRM_PANEL_BOE_TV101WUM_NL6) += panel-boe-tv101wum-nl6.o
+obj-$(CONFIG_DRM_PANEL_CHIPONE_ICN6211) += panel-chipone-icn6211.o
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
 obj-$(CONFIG_DRM_PANEL_ELIDA_KD35T133) += panel-elida-kd35t133.o
@@ -53,3 +54,4 @@
 obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-$(CONFIG_DRM_PANEL_WAVESHARE_TL070HDV03CT) += panel-waveshare-tl070hdv03ct.o
diff -Naur a/drivers/gpu/drm/panel/panel-chipone-icn6211.c b/drivers/gpu/drm/panel/panel-chipone-icn6211.c
--- a/drivers/gpu/drm/panel/panel-chipone-icn6211.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/panel/panel-chipone-icn6211.c	2022-05-31 11:56:47.737259290 +0800
@@ -0,0 +1,639 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for panels based on chipone icn6211 controller, compatible LCD module:
+ *
+ * - Waveshare 4.3" MIPI-DSI panel
+ *   https://www.waveshare.net/wiki/4.3inch_DSI_LCD#myresources
+ *
+ * Copyright (C) Unionman Co.,Ltd. 2022
+ */
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/media-bus-format.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/display_timing.h>
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <linux/backlight.h>
+#include <linux/device/class.h>
+
+
+#define DRV_NAME "panel-chipone-icn6211"
+
+struct icn6211 {
+	struct device *dev;
+	struct drm_panel panel;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+	bool enabled;
+	const struct icn6211_panel_desc *desc;
+};
+
+struct icn6211_panel_desc {
+	const struct drm_display_mode *mode;
+	unsigned int lanes;
+	unsigned long mode_flags;
+	enum mipi_dsi_pixel_format format;
+	int (*init_sequence)(struct icn6211 *ctx);
+};
+
+/* I2C registers. */
+#define REG_ID				0x80
+#define REG_PORTA			0x81
+#define REG_PORTA_HF		BIT(2)
+#define REG_PORTA_VF		BIT(3)
+#define REG_PORTB			0x82
+#define REG_POWERON			0x85
+#define REG_PWM				0x86
+
+#define HACTIVE_LI			0x20
+#define VACTIVE_LI			0x21
+#define VACTIVE_HACTIVE_HI	0x22
+#define HFP_LI				0x23
+#define HSYNC_LI			0x24
+#define HBP_LI				0x25
+#define HFP_HSW_HBP_HI		0x26
+#define VFP					0x27
+#define VSYNC				0x28
+#define VBP					0x29
+
+/* DSI D-PHY Layer Registers */
+#define D0W_DPHYCONTTX		0x0004
+#define CLW_DPHYCONTRX		0x0020
+#define D0W_DPHYCONTRX		0x0024
+#define D1W_DPHYCONTRX		0x0028
+#define COM_DPHYCONTRX		0x0038
+#define CLW_CNTRL			0x0040
+#define D0W_CNTRL			0x0044
+#define D1W_CNTRL			0x0048
+#define DFTMODE_CNTRL		0x0054
+	
+	/* DSI PPI Layer Registers */
+#define PPI_STARTPPI		0x0104
+#define PPI_BUSYPPI			0x0108
+#define PPI_LINEINITCNT		0x0110
+#define PPI_LPTXTIMECNT		0x0114
+#define PPI_CLS_ATMR		0x0140
+#define PPI_D0S_ATMR		0x0144
+#define PPI_D1S_ATMR		0x0148
+#define PPI_D0S_CLRSIPOCOUNT	0x0164
+#define PPI_D1S_CLRSIPOCOUNT	0x0168
+#define CLS_PRE			0x0180
+#define D0S_PRE			0x0184
+#define D1S_PRE			0x0188
+#define CLS_PREP		0x01A0
+#define D0S_PREP		0x01A4
+#define D1S_PREP		0x01A8
+#define CLS_ZERO		0x01C0
+#define D0S_ZERO		0x01C4
+#define D1S_ZERO		0x01C8
+#define PPI_CLRFLG		0x01E0
+#define PPI_CLRSIPO		0x01E4
+#define HSTIMEOUT		0x01F0
+#define HSTIMEOUTENABLE		0x01F4
+	
+	/* DSI Protocol Layer Registers */
+#define DSI_STARTDSI		0x0204
+#define DSI_BUSYDSI			0x0208
+#define DSI_LANEENABLE		0x0210
+# define DSI_LANEENABLE_CLOCK   BIT(0)
+# define DSI_LANEENABLE_D0		BIT(1)
+# define DSI_LANEENABLE_D1		BIT(2)
+
+#define DSI_LANESTATUS0		0x0214
+#define DSI_LANESTATUS1		0x0218
+#define DSI_INTSTATUS		0x0220
+#define DSI_INTMASK			0x0224
+#define DSI_INTCLR			0x0228
+#define DSI_LPTXTO			0x0230
+#define DSI_MODE			0x0260
+#define DSI_PAYLOAD0		0x0268
+#define DSI_PAYLOAD1		0x026C
+#define DSI_SHORTPKTDAT		0x0270
+#define DSI_SHORTPKTREQ		0x0274
+#define DSI_BTASTA			0x0278
+#define DSI_BTACLR			0x027C
+	
+/* DSI General Registers */
+#define DSIERRCNT		0x0300
+#define DSISIGMOD		0x0304
+	
+/* DSI Application Layer Registers */
+#define APLCTRL			0x0400
+#define APLSTAT			0x0404
+#define APLERR			0x0408
+#define PWRMOD			0x040C
+#define RDPKTLN			0x0410
+#define PXLFMT			0x0414
+#define MEMWRCMD		0x0418
+
+/* LCDC/DPI Host Registers */
+#define LCDCTRL			0x0420
+#define HSR				0x0424
+#define HDISPR			0x0428
+#define VSR				0x042C
+#define VDISPR			0x0430
+#define VFUEN			0x0434
+	
+/* DBI-B Host Registers */
+#define DBIBCTRL		0x0440
+	
+/* SPI Master Registers */
+#define SPICMR			0x0450
+#define SPITCR			0x0454
+	
+/* System Controller Registers */
+#define SYSSTAT			0x0460
+#define SYSCTRL			0x0464
+#define SYSPLL1			0x0468
+#define SYSPLL2			0x046C
+#define SYSPLL3			0x0470
+#define SYSPMCTRL		0x047C
+
+#define BRIGHTNESS_DEVICE_NAME  "icn6211"
+#define BRIGHTNESS_CLASS_NAME   "brightness"
+
+#define ICN6211_DSI(dsi, seq...)				\
+	{							\
+		const u8 d[] = { seq };				\
+		mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+	}
+
+struct panel_icn6211_i2c {
+	int brightness;
+	struct i2c_client *i2c;
+};
+
+static struct panel_icn6211_i2c *icn6211_i2c = NULL;
+static bool panel_icn6211_enable = false;
+
+
+static int panel_icn6211_i2c_read(struct panel_icn6211_i2c *ts, u8 reg)
+{
+	return i2c_smbus_read_byte_data(ts->i2c, reg);
+}
+
+static void panel_icn6211_i2c_write(struct panel_icn6211_i2c *ts,
+					  u8 reg, u8 val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(ts->i2c, reg, val);
+	if (ret)
+		dev_err(&ts->i2c->dev, "I2C write failed: %d\n", ret);
+}
+
+static int panel_icn6211_dsi_write(struct mipi_dsi_device *dsi, u16 reg, u32 val)
+{
+	u8 msg[] = {
+		reg,
+		reg >> 8,
+		val,
+		val >> 8,
+		val >> 16,
+		val >> 24,
+	};
+
+	mipi_dsi_generic_write(dsi, msg, sizeof(msg));
+
+	return 0;
+}
+
+static inline struct icn6211 *panel_to_icn6211(struct drm_panel *panel)
+{
+	return container_of(panel, struct icn6211, panel);
+}
+
+static const struct drm_display_mode icn6211_mode = {
+	.clock = 28344600 / 1000,
+	.hdisplay = 800,
+	.hsync_start = 800 + 16,
+	.hsync_end = 800 + 16 + 1,
+	.htotal = 800 + 16 + 1 + 88,
+	.vdisplay = 480,
+	.vsync_start = 480 + 7,
+	.vsync_end = 480 + 7 + 3,
+	.vtotal = 480 + 7 + 3 + 32,
+	.width_mm	= 105,
+	.height_mm   = 67,
+};
+
+struct icn6211_panel_desc icn6211_panel_desc = {
+	.mode = &icn6211_mode,
+	.lanes = 1,
+	.mode_flags = (MIPI_DSI_MODE_VIDEO |
+			   MIPI_DSI_MODE_VIDEO_BURST |
+			   MIPI_DSI_MODE_LPM),
+	.format = MIPI_DSI_FMT_RGB888,
+};
+
+static int icn6211_enable(struct drm_panel *panel)
+{
+	struct icn6211 *ctx = panel_to_icn6211(panel);
+	struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+	int i;
+
+	if (!panel_icn6211_enable) {
+		return -1;
+	}
+
+	if (ctx->enabled) {
+		dev_info(ctx->dev, "panel enabled\n");
+		return 0;
+	}
+
+	dev_info(ctx->dev, "panel enable\n");
+
+	panel_icn6211_i2c_write(icn6211_i2c, REG_POWERON, 1);
+
+	/* Wait for nPWRDWN to go low to indicate poweron is done. */
+	for (i = 0; i < 100; i++) {
+		if (panel_icn6211_i2c_read(icn6211_i2c, REG_PORTB) & 1)
+			break;
+	}
+
+	panel_icn6211_dsi_write(dsi, DSI_LANEENABLE,
+				  DSI_LANEENABLE_CLOCK |
+				  DSI_LANEENABLE_D0);
+	panel_icn6211_dsi_write(dsi, PPI_D0S_CLRSIPOCOUNT, 0x05);
+	panel_icn6211_dsi_write(dsi, PPI_D1S_CLRSIPOCOUNT, 0x05);
+	panel_icn6211_dsi_write(dsi, PPI_D0S_ATMR, 0x00);
+	panel_icn6211_dsi_write(dsi, PPI_D1S_ATMR, 0x00);
+	panel_icn6211_dsi_write(dsi, PPI_LPTXTIMECNT, 0x03);
+
+	panel_icn6211_dsi_write(dsi, SPICMR, 0x00);
+	panel_icn6211_dsi_write(dsi, LCDCTRL, 0x00100150);
+	panel_icn6211_dsi_write(dsi, SYSCTRL, 0x040f);
+	msleep(100);
+
+	panel_icn6211_dsi_write(dsi, PPI_STARTPPI, 0x01);
+	panel_icn6211_dsi_write(dsi, DSI_STARTDSI, 0x01);
+	msleep(100);
+
+	/* Turn on the backlight. */
+	panel_icn6211_i2c_write(icn6211_i2c, REG_PWM, 255);
+	icn6211_i2c->brightness = 255;
+
+	/* Default to the same orientation as the closed source
+	 * firmware used for the panel.
+	 */
+	panel_icn6211_i2c_write(icn6211_i2c, REG_PORTA, BIT(2));
+
+	ctx->enabled = true;
+
+	return 0;
+}
+
+static int icn6211_disable(struct drm_panel *panel)
+{
+	struct icn6211 *ctx = panel_to_icn6211(panel);
+
+	if (!panel_icn6211_enable) {
+		return -1;
+	}
+
+	dev_info(ctx->dev, "panel disable\n");
+
+	panel_icn6211_i2c_write(icn6211_i2c, REG_PWM, 0);
+	panel_icn6211_i2c_write(icn6211_i2c, REG_POWERON, 0);		
+
+	ctx->enabled = false;
+
+	return 0;
+}
+
+static int icn6211_unprepare(struct drm_panel *panel)
+{
+	if (!panel_icn6211_enable)
+		return 0;
+
+	struct icn6211 *ctx = panel_to_icn6211(panel);
+
+	if (!ctx->prepared)
+		return 0;
+
+	if (ctx->reset_gpio != NULL)
+		gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+
+	ctx->prepared = false;
+
+	return 0;
+}
+
+static int icn6211_prepare(struct drm_panel *panel)
+{
+    int ret;
+    struct icn6211 *ctx = panel_to_icn6211(panel);
+    struct mipi_dsi_device *dsi = to_mipi_dsi_device(ctx->dev);
+
+	if (!panel_icn6211_enable) {
+		return -1;
+	}
+
+    if (ctx->prepared)
+        return 0;
+
+	ret = mipi_dsi_turn_on_peripheral(dsi);
+	if (ret < 0) {
+		dev_err(panel->dev, "failed to turn on peripheral: %d\n", ret);
+		return ret;
+	}
+
+	ctx->prepared = true;
+
+    return 0;
+}
+
+static int icn6211_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	struct icn6211 *ctx = panel_to_icn6211(panel);
+	struct drm_display_mode *mode;
+	static const u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+
+	if (!panel_icn6211_enable) {
+		connector->status = connector_status_disconnected;
+		return 0;
+	}
+
+	mode = drm_mode_duplicate(connector->dev, ctx->desc->mode);
+	if (!mode) {
+		dev_err(ctx->dev, "Failed to add mode %ux%u@%u\n",
+			ctx->desc->mode->hdisplay, ctx->desc->mode->vdisplay,
+			drm_mode_vrefresh(ctx->desc->mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.bpc = 8;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	drm_display_info_set_bus_formats(&connector->display_info,
+					 &bus_format, 1);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs icn6211_drm_funcs = {
+	.disable   = icn6211_disable,
+	.unprepare = icn6211_unprepare,
+	.prepare   = icn6211_prepare,
+	.enable	   = icn6211_enable,
+	.get_modes = icn6211_get_modes,
+};
+
+static int icn6211_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct icn6211 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	ctx->dev = dev;
+	ctx->desc = of_device_get_match_data(dev);
+
+	dsi->mode_flags = ctx->desc->mode_flags;
+	dsi->format = ctx->desc->format;
+	dsi->lanes = ctx->desc->lanes;
+
+	drm_panel_init(&ctx->panel, dev, &icn6211_drm_funcs, DRM_MODE_CONNECTOR_DSI);
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "mipi_dsi_attach failed (%d). Is host ready?\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	dev_info(dev, "%ux%u@%u %ubpp dsi %ulanes\n",
+		 ctx->desc->mode->hdisplay, ctx->desc->mode->vdisplay,
+		 drm_mode_vrefresh(ctx->desc->mode),
+		 mipi_dsi_pixel_format_to_bpp(dsi->format), dsi->lanes);
+
+	return 0;
+}
+
+static void icn6211_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct icn6211 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = drm_panel_unprepare(&ctx->panel);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to unprepare panel: %d\n", ret);
+
+	ret = drm_panel_disable(&ctx->panel);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to disable panel: %d\n", ret);
+}
+
+static int icn6211_remove(struct mipi_dsi_device *dsi)
+{
+	struct icn6211 *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	icn6211_shutdown(dsi);
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id icn6211_of_match[] = {
+	{ .compatible = "chipone,icn6211", .data = &icn6211_panel_desc },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, icn6211_of_match);
+
+static struct mipi_dsi_driver icn6211_panel_driver = {
+	.probe	= icn6211_probe,
+	.remove = icn6211_remove,
+	.shutdown = icn6211_shutdown,
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = icn6211_of_match,
+	},
+};
+module_mipi_dsi_driver(icn6211_panel_driver);
+
+static ssize_t brightness_show(struct class *cla,
+					struct class_attribute *attr,
+					char *buf)
+{
+	int brightness = 0;
+
+	if (panel_icn6211_enable) {
+		brightness = icn6211_i2c->brightness;
+	}
+
+	if ((brightness >= 0) && (brightness <= 255)) {
+		brightness = (brightness * 100) / 255;
+	} else {
+		brightness = 100;
+	}
+
+	return snprintf(buf, 8, "%d\n", brightness);
+}
+
+static ssize_t brightness_store(struct class *cla,
+					 struct class_attribute *attr,
+					 const char *buf, size_t count)
+{
+	int brightness;
+
+	brightness = simple_strtoul(buf, NULL, 10);
+	if ((brightness >= 0) && (brightness <= 100)) {
+		brightness = (brightness * 255) / 100;
+	} else {
+		brightness = 255;
+	}
+
+	if (panel_icn6211_enable) {
+		if (brightness == 0) {
+			if (0 != icn6211_i2c->brightness) {
+				panel_icn6211_i2c_write(icn6211_i2c, REG_PWM, 0);
+				panel_icn6211_i2c_write(icn6211_i2c, REG_POWERON, 0);
+			}
+		} else {
+			if (0 == icn6211_i2c->brightness) {
+				panel_icn6211_i2c_write(icn6211_i2c, REG_POWERON, 1);
+				udelay(120);
+			}
+
+			panel_icn6211_i2c_write(icn6211_i2c, REG_PWM, brightness);
+			panel_icn6211_i2c_write(icn6211_i2c, REG_PORTA, BIT(2));
+		}
+
+		icn6211_i2c->brightness = brightness;
+	}
+
+	return count;
+}
+
+static CLASS_ATTR_RW(brightness);
+
+static struct attribute *icn6211_class_attrs[] = {
+	&class_attr_brightness.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(icn6211_class);
+
+static struct class icn6211_class = {
+	.name = BRIGHTNESS_CLASS_NAME,
+	.class_groups = icn6211_class_groups,
+};
+
+static int panel_icn6211_i2c_probe(struct i2c_client *i2c,
+				 const struct i2c_device_id *id)
+{
+	struct device *dev = &i2c->dev;
+	struct device *brightness_dev;
+	int ret;
+	int ver;
+
+	icn6211_i2c = devm_kzalloc(dev, sizeof(*icn6211_i2c), GFP_KERNEL);
+	if (!icn6211_i2c) {
+		dev_err(dev, "devm_kzalloc failed!\n");
+		return -ENOMEM;
+	}
+
+	i2c_set_clientdata(i2c, icn6211_i2c);
+
+	icn6211_i2c->i2c = i2c;
+	panel_icn6211_enable = false;
+
+	ver = panel_icn6211_i2c_read(icn6211_i2c, 0x80);
+	if (ver < 0) {
+		dev_err(dev, "I2C read failed: %d\n", ver);
+		return -ENODEV;
+	}
+
+	dev_info(dev, "icn6211 reg id 0x%x\n", ver);
+
+	switch (ver) {
+		case 0xde: /* ver 1 */
+		case 0xc3: /* ver 2 */
+			break;
+		default:
+			dev_err(dev, "Unknown firmware revision: 0x%02x\n", ver);
+			return -ENODEV;
+	}
+
+	/* Turn off at boot, so we can cleanly sequence powering on. */
+	panel_icn6211_enable = true;
+	panel_icn6211_i2c_write(icn6211_i2c, REG_POWERON, 0);
+
+	ret = class_register(&icn6211_class);
+	if (ret < 0) {
+		dev_warn(dev, "register icn6211 class fail! %d\n", ret);
+	}
+
+	brightness_dev = device_create(&icn6211_class, NULL, 0, NULL, BRIGHTNESS_DEVICE_NAME);
+	if (IS_ERR_OR_NULL(brightness_dev)) {
+		dev_err(dev, "create brightness device error\n");
+		class_unregister(&icn6211_class);
+	}
+
+	return 0;
+}
+
+static int panel_icn6211_i2c_remove(struct i2c_client *i2c)
+{
+	return 0;
+}
+
+static const struct of_device_id panel_icn6211_i2c_of_ids[] = {
+	{ .compatible = "chipone,icn6211-i2c" },
+	{ } /* sentinel */
+};
+MODULE_DEVICE_TABLE(of, panel_icn6211_i2c_of_ids);
+
+static struct i2c_driver panel_icn6211_i2c_driver = {
+	.driver = {
+		.name = "panel-icn6211-i2c",
+		.of_match_table = panel_icn6211_i2c_of_ids,
+	},
+	.probe = panel_icn6211_i2c_probe,
+	.remove = panel_icn6211_i2c_remove,
+};
+
+static int __init panel_icn6211_i2c_init(void)
+{
+	return i2c_add_driver(&panel_icn6211_i2c_driver);
+}
+module_init(panel_icn6211_i2c_init);
+
+static void __exit panel_icn6211_i2c_exit(void)
+{
+	i2c_del_driver(&panel_icn6211_i2c_driver);
+}
+module_exit(panel_icn6211_i2c_exit);
+
+MODULE_AUTHOR("AlgoIdeas <yu19881234@163.com>");
+MODULE_DESCRIPTION("DRM driver for chipone icn6211 based MIPI DSI panels");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/gpu/drm/panel/panel-waveshare-tl070hdv03ct.c b/drivers/gpu/drm/panel/panel-waveshare-tl070hdv03ct.c
--- a/drivers/gpu/drm/panel/panel-waveshare-tl070hdv03ct.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/gpu/drm/panel/panel-waveshare-tl070hdv03ct.c	2022-06-18 17:44:02.425470938 +0800
@@ -0,0 +1,402 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2022 Unionman Co., Ltd
+ * Author: Unionpi <unionman@unionman.com.cn>
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of_device.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_device.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_panel.h>
+
+/*
+ *Note: MIPI DSI high speed clock must be set to 800MHz
+ */
+
+#define LANES_NUM					(1)
+
+/*
+ * When power is turned off to this panel a minimum off time of 500ms has to be
+ * observed before powering back on as there's no external reset pin. Keep
+ * track of earliest wakeup time and delay subsequent prepare call accordingly
+ */
+#define MIN_POWEROFF_MS				(500)
+
+#define ICN_SET_HACTIVE_LI			0x20
+#define ICN_SET_VACTIVE_LI			0x21
+#define ICN_SET_VACTIVE_HACTIVE_HI	0x22
+#define ICN_SET_HFP_LI				0x23
+#define ICN_SET_HSYNC_LI			0x24
+#define ICN_SET_HBP_LI				0x25
+#define ICN_SET_HFP_HSW_HBP_HI		0x26
+#define ICN_SET_VFP					0x27
+#define ICN_SET_VSYNC				0x28
+#define ICN_SET_VBP					0x29
+#define ICN_SET_LANES				0x86
+
+struct ws_panel {
+	struct drm_panel base;
+	struct mipi_dsi_device *dsi;
+
+	struct regulator *supply;
+
+	bool prepared;
+	bool enabled;
+
+	ktime_t earliest_wake;
+
+	const struct drm_display_mode *mode;
+};
+
+#define ICN6211_DSI(dsi, seq...)				\
+{							\
+	const u8 d[] = { seq };				\
+	mipi_dsi_generic_write(dsi, d, ARRAY_SIZE(d));	\
+}
+
+#define ICN6211_DCS(dsi, cmd)				\
+{							\
+	mipi_dsi_dcs_write(dsi, cmd, NULL, 0);	\
+}
+
+static inline struct ws_panel *to_ws_panel(struct drm_panel *panel)
+{
+	return container_of(panel, struct ws_panel, base);
+}
+
+static int icn6211_init(struct drm_panel *panel)
+{
+	struct ws_panel *icn = to_ws_panel(panel);
+	struct mipi_dsi_device *dsi = icn->dsi;
+	const struct drm_display_mode *mode = icn->mode;
+
+#if 0 // Seemly no need
+	ICN6211_DCS(dsi, MIPI_DCS_EXIT_SLEEP_MODE);
+	msleep(120);
+	ICN6211_DCS(dsi, MIPI_DCS_SET_DISPLAY_ON);
+	msleep(120);
+#endif
+
+	ICN6211_DSI(dsi, 0x7a, 0xc1);   // Start Config
+
+	ICN6211_DSI(dsi, ICN_SET_HACTIVE_LI, mode->hdisplay & 0xff);
+
+	ICN6211_DSI(dsi, ICN_SET_VACTIVE_LI, mode->vdisplay & 0xff);
+
+	/**
+	 * lsb nibble: 2nd nibble of hdisplay
+	 * msb nibble: 2nd nibble of vdisplay
+	 */
+	ICN6211_DSI(dsi, ICN_SET_VACTIVE_HACTIVE_HI,
+			((mode->hdisplay >> 8) & 0xf) |
+			(((mode->vdisplay >> 8) & 0xf) << 4));
+
+	ICN6211_DSI(dsi, ICN_SET_HFP_LI, mode->hsync_start - mode->hdisplay);
+
+	ICN6211_DSI(dsi, ICN_SET_HSYNC_LI, mode->hsync_end - mode->hsync_start);
+
+	ICN6211_DSI(dsi, ICN_SET_HBP_LI, mode->htotal - mode->hsync_end);
+
+	ICN6211_DSI(dsi, ICN_SET_HFP_HSW_HBP_HI, 0x00);
+
+	ICN6211_DSI(dsi, ICN_SET_VFP, mode->vsync_start - mode->vdisplay);
+
+	ICN6211_DSI(dsi, ICN_SET_VSYNC, mode->vsync_end - mode->vsync_start);
+
+	ICN6211_DSI(dsi, ICN_SET_VBP, mode->vtotal - mode->vsync_end);
+
+	/* dsi specific sequence */
+	ICN6211_DSI(dsi, MIPI_DCS_SET_TEAR_OFF, 0x80);
+	//ICN6211_DSI(icn, MIPI_DCS_SET_ADDRESS_MODE, 0x28);
+	ICN6211_DSI(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0x10);
+
+	// if lanes == 4, needn't set lanes
+	if (dsi->lanes < 4 && dsi->lanes > 0) { 
+		ICN6211_DSI(dsi, ICN_SET_LANES, 0x28 + dsi->lanes - 1);
+	}
+
+	ICN6211_DSI(dsi, 0xb5, 0xa0);
+	ICN6211_DSI(dsi, 0x5c, 0xff);
+	ICN6211_DSI(dsi, MIPI_DCS_SET_COLUMN_ADDRESS, 0x01);
+	ICN6211_DSI(dsi, MIPI_DCS_GET_POWER_SAVE, 0x92);
+
+	// pixel_clk(30MHz) & mipi_clk(400MHz)
+	//ICN6211_DSI(icn, 0x6b, 0x71);
+	//ICN6211_DSI(icn, 0x69, 0x2b);
+	ICN6211_DSI(dsi, 0x6b, 0x73);
+	ICN6211_DSI(dsi, 0x69, 0x1d);
+
+	ICN6211_DSI(dsi, MIPI_DCS_ENTER_SLEEP_MODE, 0x40);
+
+	//ICN6211_DSI(icn, MIPI_DCS_EXIT_SLEEP_MODE, 0x98);
+	ICN6211_DSI(dsi, MIPI_DCS_EXIT_SLEEP_MODE, 0x88);
+
+	/* icn6211 specific sequence */
+	ICN6211_DSI(dsi, 0xb6, 0x20);
+	ICN6211_DSI(dsi, 0x51, 0x20);
+	ICN6211_DSI(dsi, 0x09, 0x10);
+
+	ICN6211_DSI(dsi, 0x7A, 0x3E); // End Config
+
+	usleep_range(10000, 11000);
+
+	return 0;
+}
+
+static int ws_panel_on(struct ws_panel *ws)
+{
+	return mipi_dsi_turn_on_peripheral(ws->dsi);
+}
+
+static int ws_panel_disable(struct drm_panel *panel)
+{
+	struct ws_panel *ws = to_ws_panel(panel);
+	int mipi_ret, bl_ret = 0;
+
+	if (!ws->enabled)
+		return 0;
+
+	mipi_ret = mipi_dsi_shutdown_peripheral(ws->dsi);
+
+	ws->enabled = false;
+
+	return mipi_ret ? mipi_ret : bl_ret;
+}
+
+static int ws_panel_unprepare(struct drm_panel *panel)
+{
+	struct ws_panel *ws = to_ws_panel(panel);
+
+	if (!ws->prepared)
+		return 0;
+
+	regulator_disable(ws->supply);
+	ws->earliest_wake = ktime_add_ms(ktime_get_real(), MIN_POWEROFF_MS);
+	ws->prepared = false;
+
+	return 0;
+}
+
+static int ws_panel_prepare(struct drm_panel *panel)
+{
+	struct ws_panel *ws = to_ws_panel(panel);
+	int ret;
+	s64 enablewait;
+
+	if (ws->prepared)
+		return 0;
+
+	if (!IS_ERR(ws->supply)) {
+		/*
+		 * If the user re-enabled the panel before the required off-time then
+		 * we need to wait the remaining period before re-enabling regulator
+		 */
+		enablewait = ktime_ms_delta(ws->earliest_wake, ktime_get_real());
+
+		/* Sanity check, this should never happen */
+		if (enablewait > MIN_POWEROFF_MS)
+			enablewait = MIN_POWEROFF_MS;
+
+		if (enablewait > 0)
+			msleep(enablewait);
+
+		ret = regulator_enable(ws->supply);
+		if (ret < 0)
+			return ret;
+
+		/*
+		 * A minimum delay of 250ms is required after power-up until commands
+		 * can be sent
+		 */
+		msleep(250);
+	}
+
+	ret = ws_panel_on(ws);
+	if (ret < 0) {
+		dev_err(panel->dev, "failed to set panel on: %d\n", ret);
+		goto poweroff;
+	}
+
+	icn6211_init(panel);
+
+	ws->prepared = true;
+
+	pr_info("panel prepare done.\n");
+
+	return 0;
+
+poweroff:
+	regulator_disable(ws->supply);
+
+	return ret;
+}
+
+static int ws_panel_enable(struct drm_panel *panel)
+{
+	struct ws_panel *ws = to_ws_panel(panel);
+
+	if (ws->enabled)
+		return 0;
+
+	ws->enabled = true;
+
+	return 0;
+}
+
+static const struct drm_display_mode default_mode = {
+	.clock = 28344600 / 1000,	// PCLK (kHz)
+	.hdisplay = 800,		// HACT
+	.hsync_start = 800 + 16,	// HACT + HFP
+	.hsync_end = 800 + 16 + 1,	// HACT + HFP + HSYNC
+	.htotal = 800 + 16 + 1 + 88,	// HACT + HFP + HSYNC + HBP
+	.vdisplay = 480,		// VACT
+	.vsync_start = 480 + 7,		// VACT + VFP
+	.vsync_end = 480 + 7 + 3,	// VACT + VFP + VSYNC
+	.vtotal = 480 + 7 + 3 + 32,	// VACT + VFP + VSYNC + VBP
+	.width_mm = 105,
+	.height_mm = 67
+};
+
+static int ws_panel_get_modes(struct drm_panel *panel,
+		struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &default_mode);
+	if (!mode) {
+		dev_err(panel->dev, "failed to add mode %ux%u@%u\n",
+				default_mode.hdisplay, default_mode.vdisplay,
+				drm_mode_vrefresh(&default_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs ws_panel_funcs = {
+	.disable = ws_panel_disable,
+	.unprepare = ws_panel_unprepare,
+	.prepare = ws_panel_prepare,
+	.enable = ws_panel_enable,
+	.get_modes = ws_panel_get_modes,
+};
+
+static const struct of_device_id ws_of_match[] = {
+	{ .compatible = "waveshare,tl070hdv03ct", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ws_of_match);
+
+static int ws_panel_add(struct ws_panel *ws)
+{
+	struct device *dev = &ws->dsi->dev;
+	int ret;
+
+	ws->mode = &default_mode;
+
+	ws->supply = devm_regulator_get(dev, "power");
+	if (IS_ERR(ws->supply)) {
+		// Just show a warning
+		pr_warn("no power supply found.");
+	}
+
+	drm_panel_init(&ws->base, &ws->dsi->dev,
+			&ws_panel_funcs, DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ws->base);
+	if (ret)
+		return ret;
+
+	drm_panel_add(&ws->base);
+
+	return 0;
+}
+
+static void ws_panel_del(struct ws_panel *ws)
+{
+	if (ws->base.dev)
+		drm_panel_remove(&ws->base);
+}
+
+static int ws_panel_probe(struct mipi_dsi_device *dsi)
+{
+	struct ws_panel *ws;
+	int ret;
+
+	dsi->lanes = LANES_NUM;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_BURST | MIPI_DSI_MODE_LPM 
+		| MIPI_DSI_MODE_VIDEO;
+
+	ws = devm_kzalloc(&dsi->dev, sizeof(*ws), GFP_KERNEL);
+	if (!ws)
+		return -ENOMEM;
+
+	mipi_dsi_set_drvdata(dsi, ws);
+
+	ws->dsi = dsi;
+
+	pr_info("init panel waveshare...\n");
+
+	ret = ws_panel_add(ws);
+	if (ret < 0)
+		return ret;
+
+	return mipi_dsi_attach(dsi);
+}
+
+static int ws_panel_remove(struct mipi_dsi_device *dsi)
+{
+	struct ws_panel *ws = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = drm_panel_disable(&ws->base);
+	if (ret < 0)
+		dev_err(&dsi->dev, "failed to disable panel: %d\n", ret);
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "failed to detach from DSI host: %d\n", ret);
+
+	ws_panel_del(ws);
+
+	return 0;
+}
+
+static void ws_panel_shutdown(struct mipi_dsi_device *dsi)
+{
+	struct ws_panel *ws = mipi_dsi_get_drvdata(dsi);
+
+	drm_panel_disable(&ws->base);
+}
+
+static struct mipi_dsi_driver ws_panel_driver = {
+	.driver = {
+		.name = "panel-waveshare-tl070hdv03ct",
+		.of_match_table = ws_of_match,
+	},
+	.probe = ws_panel_probe,
+	.remove = ws_panel_remove,
+	.shutdown = ws_panel_shutdown,
+};
+module_mipi_dsi_driver(ws_panel_driver);
+
+MODULE_AUTHOR("Unionpi <unionman@unionman.com.cn>");
+MODULE_DESCRIPTION("Waveshare TL070HDV03CT (800x480) Chipone ICN6211-based DSI panel driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/gpu/drm/panfrost/panfrost_devfreq.c b/drivers/gpu/drm/panfrost/panfrost_devfreq.c
--- a/drivers/gpu/drm/panfrost/panfrost_devfreq.c	2022-05-27 17:20:15.693902314 +0800
+++ b/drivers/gpu/drm/panfrost/panfrost_devfreq.c	2022-05-31 11:56:47.737259290 +0800
@@ -81,6 +81,7 @@
 }
 
 static struct devfreq_dev_profile panfrost_devfreq_profile = {
+	.timer = DEVFREQ_TIMER_DELAYED,
 	.polling_ms = 50, /* ~3 frames */
 	.target = panfrost_devfreq_target,
 	.get_dev_status = panfrost_devfreq_get_dev_status,
@@ -134,8 +135,16 @@
 	panfrost_devfreq_profile.initial_freq = cur_freq;
 	dev_pm_opp_put(opp);
 
+	/*
+	* Setup default thresholds for the simple_ondemand governor.
+	* The values are chosen based on experiments.
+	*/
+	pfdevfreq->gov_data.upthreshold = 45;
+	pfdevfreq->gov_data.downdifferential = 5;
+
 	devfreq = devm_devfreq_add_device(dev, &panfrost_devfreq_profile,
-					  DEVFREQ_GOV_SIMPLE_ONDEMAND, NULL);
+					  DEVFREQ_GOV_SIMPLE_ONDEMAND,
+					  &pfdevfreq->gov_data);
 	if (IS_ERR(devfreq)) {
 		DRM_DEV_ERROR(dev, "Couldn't initialize GPU devfreq\n");
 		ret = PTR_ERR(devfreq);
diff -Naur a/drivers/gpu/drm/panfrost/panfrost_devfreq.h b/drivers/gpu/drm/panfrost/panfrost_devfreq.h
--- a/drivers/gpu/drm/panfrost/panfrost_devfreq.h	2022-05-27 17:20:15.693902314 +0800
+++ b/drivers/gpu/drm/panfrost/panfrost_devfreq.h	2022-05-31 11:56:47.737259290 +0800
@@ -4,6 +4,7 @@
 #ifndef __PANFROST_DEVFREQ_H__
 #define __PANFROST_DEVFREQ_H__
 
+#include <linux/devfreq.h>
 #include <linux/spinlock.h>
 #include <linux/ktime.h>
 
@@ -17,6 +18,7 @@
 	struct devfreq *devfreq;
 	struct opp_table *regulators_opp_table;
 	struct thermal_cooling_device *cooling;
+	struct devfreq_simple_ondemand_data gov_data;
 	bool opp_of_table_added;
 
 	ktime_t busy_time;
diff -Naur a/drivers/gpu/drm/panfrost/panfrost_job.c b/drivers/gpu/drm/panfrost/panfrost_job.c
--- a/drivers/gpu/drm/panfrost/panfrost_job.c	2022-05-27 17:20:15.693902314 +0800
+++ b/drivers/gpu/drm/panfrost/panfrost_job.c	2022-05-31 11:56:47.737259290 +0800
@@ -157,7 +157,7 @@
 
 	panfrost_devfreq_record_busy(&pfdev->pfdevfreq);
 
-	ret = pm_runtime_get_sync(pfdev->dev);
+	ret = pm_runtime_resume_and_get(pfdev->dev);
 	if (ret < 0)
 		return;
 
diff -Naur a/drivers/gpu/drm/panfrost/panfrost_mmu.c b/drivers/gpu/drm/panfrost/panfrost_mmu.c
--- a/drivers/gpu/drm/panfrost/panfrost_mmu.c	2022-05-27 17:20:15.693902314 +0800
+++ b/drivers/gpu/drm/panfrost/panfrost_mmu.c	2022-05-31 11:56:47.737259290 +0800
@@ -632,22 +632,20 @@
 {
 	struct panfrost_device *pfdev = data;
 	u32 status = mmu_read(pfdev, MMU_INT_RAWSTAT);
-	int i, ret;
+	int ret;
 
-	for (i = 0; status; i++) {
-		u32 mask = BIT(i) | BIT(i + 16);
+	while (status) {
+		u32 as = ffs(status | (status >> 16)) - 1;
+		u32 mask = BIT(as) | BIT(as + 16);
 		u64 addr;
 		u32 fault_status;
 		u32 exception_type;
 		u32 access_type;
 		u32 source_id;
 
-		if (!(status & mask))
-			continue;
-
-		fault_status = mmu_read(pfdev, AS_FAULTSTATUS(i));
-		addr = mmu_read(pfdev, AS_FAULTADDRESS_LO(i));
-		addr |= (u64)mmu_read(pfdev, AS_FAULTADDRESS_HI(i)) << 32;
+		fault_status = mmu_read(pfdev, AS_FAULTSTATUS(as));
+		addr = mmu_read(pfdev, AS_FAULTADDRESS_LO(as));
+		addr |= (u64)mmu_read(pfdev, AS_FAULTADDRESS_HI(as)) << 32;
 
 		/* decode the fault status */
 		exception_type = fault_status & 0xFF;
@@ -658,8 +656,8 @@
 
 		/* Page fault only */
 		ret = -1;
-		if ((status & mask) == BIT(i) && (exception_type & 0xF8) == 0xC0)
-			ret = panfrost_mmu_map_fault_addr(pfdev, i, addr);
+		if ((status & mask) == BIT(as) && (exception_type & 0xF8) == 0xC0)
+			ret = panfrost_mmu_map_fault_addr(pfdev, as, addr);
 
 		if (ret)
 			/* terminal fault, print info about the fault */
@@ -671,7 +669,7 @@
 				"exception type 0x%X: %s\n"
 				"access type 0x%X: %s\n"
 				"source id 0x%X\n",
-				i, addr,
+				as, addr,
 				"TODO",
 				fault_status,
 				(fault_status & (1 << 10) ? "DECODER FAULT" : "SLAVE FAULT"),
@@ -680,6 +678,10 @@
 				source_id);
 
 		status &= ~mask;
+
+		/* If we received new MMU interrupts, process them before returning. */
+		if (!status)
+			status = mmu_read(pfdev, MMU_INT_RAWSTAT);
 	}
 
 	mmu_write(pfdev, MMU_INT_MASK, ~0);
diff -Naur a/drivers/iio/dac/ad5770r.c b/drivers/iio/dac/ad5770r.c
--- a/drivers/iio/dac/ad5770r.c	2022-06-30 21:35:01.796331169 +0800
+++ b/drivers/iio/dac/ad5770r.c	2022-05-27 17:20:15.869904585 +0800
@@ -522,7 +522,7 @@
 		return -EINVAL;
 
 	device_for_each_child_node(&st->spi->dev, child) {
-		ret = fwnode_property_read_u32(child, "reg", &num);
+		ret = fwnode_property_read_u32(child, "num", &num);
 		if (ret)
 			goto err_child_out;
 		if (num >= AD5770R_MAX_CHANNELS) {
diff -Naur a/drivers/irqchip/irq-meson-gpio.c b/drivers/irqchip/irq-meson-gpio.c
--- a/drivers/irqchip/irq-meson-gpio.c	2022-05-27 17:20:16.021906545 +0800
+++ b/drivers/irqchip/irq-meson-gpio.c	2022-05-31 11:56:47.737259290 +0800
@@ -15,6 +15,7 @@
 #include <linux/irqchip.h>
 #include <linux/of.h>
 #include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #define NUM_CHANNEL 8
 #define MAX_INPUT_MUX 256
@@ -136,6 +137,7 @@
 struct meson_gpio_irq_controller {
 	const struct meson_gpio_irq_params *params;
 	void __iomem *base;
+	struct irq_domain *domain;
 	u32 channel_irqs[NUM_CHANNEL];
 	DECLARE_BITMAP(channel_map, NUM_CHANNEL);
 	spinlock_t lock;
@@ -436,8 +438,8 @@
 	.translate	= meson_gpio_irq_domain_translate,
 };
 
-static int __init meson_gpio_irq_parse_dt(struct device_node *node,
-					  struct meson_gpio_irq_controller *ctl)
+static int meson_gpio_irq_parse_dt(struct device_node *node,
+				   struct meson_gpio_irq_controller *ctl)
 {
 	const struct of_device_id *match;
 	int ret;
@@ -463,63 +465,84 @@
 	return 0;
 }
 
-static int __init meson_gpio_irq_of_init(struct device_node *node,
-					 struct device_node *parent)
+static int meson_gpio_intc_probe(struct platform_device *pdev)
 {
-	struct irq_domain *domain, *parent_domain;
+	struct device_node *node = pdev->dev.of_node, *parent;
 	struct meson_gpio_irq_controller *ctl;
+	struct irq_domain *parent_domain;
+	struct resource *res;
 	int ret;
 
+	parent = of_irq_find_parent(node);
 	if (!parent) {
-		pr_err("missing parent interrupt node\n");
+		dev_err(&pdev->dev, "missing parent interrupt node\n");
 		return -ENODEV;
 	}
 
 	parent_domain = irq_find_host(parent);
 	if (!parent_domain) {
-		pr_err("unable to obtain parent domain\n");
+		dev_err(&pdev->dev, "unable to obtain parent domain\n");
 		return -ENXIO;
 	}
 
-	ctl = kzalloc(sizeof(*ctl), GFP_KERNEL);
+	ctl = devm_kzalloc(&pdev->dev, sizeof(*ctl), GFP_KERNEL);
 	if (!ctl)
 		return -ENOMEM;
 
 	spin_lock_init(&ctl->lock);
 
-	ctl->base = of_iomap(node, 0);
-	if (!ctl->base) {
-		ret = -ENOMEM;
-		goto free_ctl;
-	}
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	ctl->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(ctl->base))
+		return PTR_ERR(ctl->base);
 
 	ret = meson_gpio_irq_parse_dt(node, ctl);
 	if (ret)
-		goto free_channel_irqs;
+		return ret;
 
-	domain = irq_domain_create_hierarchy(parent_domain, 0,
-					     ctl->params->nr_hwirq,
-					     of_node_to_fwnode(node),
-					     &meson_gpio_irq_domain_ops,
-					     ctl);
-	if (!domain) {
-		pr_err("failed to add domain\n");
-		ret = -ENODEV;
-		goto free_channel_irqs;
+	ctl->domain = irq_domain_create_hierarchy(parent_domain, 0,
+						  ctl->params->nr_hwirq,
+						  of_node_to_fwnode(node),
+						  &meson_gpio_irq_domain_ops,
+						  ctl);
+	if (!ctl->domain) {
+		dev_err(&pdev->dev, "failed to add domain\n");
+		return -ENODEV;
 	}
 
-	pr_info("%d to %d gpio interrupt mux initialized\n",
-		ctl->params->nr_hwirq, NUM_CHANNEL);
+	platform_set_drvdata(pdev, ctl);
+
+	dev_info(&pdev->dev, "%d to %d gpio interrupt mux initialized\n",
+		 ctl->params->nr_hwirq, NUM_CHANNEL);
 
 	return 0;
+}
 
-free_channel_irqs:
-	iounmap(ctl->base);
-free_ctl:
-	kfree(ctl);
+static int meson_gpio_intc_remove(struct platform_device *pdev)
+{
+	struct meson_gpio_irq_controller *ctl = platform_get_drvdata(pdev);
 
-	return ret;
+	irq_domain_remove(ctl->domain);
+
+	return 0;
 }
 
-IRQCHIP_DECLARE(meson_gpio_intc, "amlogic,meson-gpio-intc",
-		meson_gpio_irq_of_init);
+static const struct of_device_id meson_gpio_intc_of_match[] = {
+	{ .compatible = "amlogic,meson-gpio-intc", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, meson_gpio_intc_of_match);
+
+static struct platform_driver meson_gpio_intc_driver = {
+	.probe  = meson_gpio_intc_probe,
+	.remove = meson_gpio_intc_remove,
+	.driver = {
+		.name = "meson-gpio-intc",
+		.of_match_table = meson_gpio_intc_of_match,
+	},
+};
+module_platform_driver(meson_gpio_intc_driver);
+
+MODULE_AUTHOR("Jerome Brunet <jbrunet@baylibre.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:meson-gpio-intc");
diff -Naur a/drivers/media/usb/dvb-usb/dibusb-common.c b/drivers/media/usb/dvb-usb/dibusb-common.c
--- a/drivers/media/usb/dvb-usb/dibusb-common.c	2022-06-30 21:35:01.804331335 +0800
+++ b/drivers/media/usb/dvb-usb/dibusb-common.c	2022-05-27 17:20:16.249909485 +0800
@@ -223,7 +223,7 @@
 	u8 *buf;
 	int rc;
 
-	buf = kzalloc(2, GFP_KERNEL);
+	buf = kmalloc(2, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
 
diff -Naur a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c
--- a/drivers/mmc/core/block.c	2022-05-27 17:20:16.361910930 +0800
+++ b/drivers/mmc/core/block.c	2022-05-31 11:56:47.737259290 +0800
@@ -44,7 +44,9 @@
 #include <linux/mmc/host.h>
 #include <linux/mmc/mmc.h>
 #include <linux/mmc/sd.h>
-
+#ifdef CONFIG_MMC_MESON_GX
+#include <linux/mmc/emmc_partitions.h>
+#endif
 #include <linux/uaccess.h>
 
 #include "queue.h"
@@ -2897,6 +2899,9 @@
 {
 	struct mmc_blk_data *md, *part_md;
 	char cap_str[10];
+#ifdef CONFIG_MMC_MESON_GX
+	int idx = 0;
+#endif
 
 	/*
 	 * Check that the card supports the command class(es) we need.
@@ -2931,9 +2936,17 @@
 	if (mmc_add_disk(md))
 		goto out;
 
+#ifdef CONFIG_MMC_MESON_GX
+	aml_emmc_partition_ops(card, md->disk);
+#endif
+
 	list_for_each_entry(part_md, &md->part, part) {
 		if (mmc_add_disk(part_md))
 			goto out;
+#ifdef CONFIG_MMC_MESON_GX
+		if (part_md->area_type == MMC_BLK_DATA_AREA_BOOT)
+			add_fake_boot_partition(part_md->disk, "bootloader%d", idx++);
+#endif
 	}
 
 	/* Add two debugfs entries */
diff -Naur a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
--- a/drivers/mmc/core/core.c	2022-05-27 17:20:16.361910930 +0800
+++ b/drivers/mmc/core/core.c	2022-05-31 11:56:47.737259290 +0800
@@ -215,6 +215,7 @@
 
 static void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)
 {
+#ifndef CONFIG_MMC_MESON_GX
 	int err;
 
 	/* Assumes host controller has been runtime resumed by mmc_claim_host */
@@ -224,7 +225,7 @@
 		mmc_request_done(host, mrq);
 		return;
 	}
-
+#endif
 	/*
 	 * For sdio rw commands we must wait for card busy otherwise some
 	 * sdio devices won't work properly.
@@ -1909,6 +1910,7 @@
 		return 1;
 	return 0;
 }
+EXPORT_SYMBOL(mmc_can_sanitize);
 
 int mmc_can_secure_erase_trim(struct mmc_card *card)
 {
diff -Naur a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
--- a/drivers/mmc/core/sd.c	2022-05-27 17:20:16.361910930 +0800
+++ b/drivers/mmc/core/sd.c	2022-05-31 11:56:47.737259290 +0800
@@ -1254,6 +1254,26 @@
 }
 
 /*
+ * Callback for shutdown
+ */
+static int mmc_sd_shutdown(struct mmc_host *host)
+{
+	mmc_claim_host(host);
+
+	if (mmc_card_suspended(host->card))
+		goto out;
+
+	mmc_power_off(host);
+	mmc_card_set_suspended(host->card);
+
+	pm_runtime_disable(&host->card->dev);
+	pm_runtime_set_suspended(&host->card->dev);
+
+out:
+	return 0;
+}
+
+/*
  * This function tries to determine if the same card is still present
  * and, if so, restore all state to it.
  */
@@ -1331,7 +1351,7 @@
 	.suspend = mmc_sd_suspend,
 	.resume = mmc_sd_resume,
 	.alive = mmc_sd_alive,
-	.shutdown = mmc_sd_suspend,
+	.shutdown = mmc_sd_shutdown,
 	.hw_reset = mmc_sd_hw_reset,
 };
 
diff -Naur a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
--- a/drivers/mmc/host/Kconfig	2022-06-29 08:47:07.175383518 +0800
+++ b/drivers/mmc/host/Kconfig	2022-05-27 17:20:16.365910981 +0800
@@ -503,7 +503,7 @@
 
 config MMC_WBSD
 	tristate "Winbond W83L51xD SD/MMC Card Interface support"
-	depends on ISA_DMA_API && !M68K
+	depends on ISA_DMA_API
 	help
 	  This selects the Winbond(R) W83L51xD Secure digital and
 	  Multimedia card Interface.
diff -Naur a/drivers/mmc/host/meson-gx-mmc.c b/drivers/mmc/host/meson-gx-mmc.c
--- a/drivers/mmc/host/meson-gx-mmc.c	2022-05-27 17:20:16.369911033 +0800
+++ b/drivers/mmc/host/meson-gx-mmc.c	2022-06-30 15:31:31.230991607 +0800
@@ -27,6 +27,7 @@
 #include <linux/interrupt.h>
 #include <linux/bitfield.h>
 #include <linux/pinctrl/consumer.h>
+#include "../../mmc/core/core.h"
 
 #define DRIVER_NAME "meson-gx-mmc"
 
@@ -38,6 +39,7 @@
 #define   CLK_RX_PHASE_MASK GENMASK(13, 12)
 #define   CLK_PHASE_0 0
 #define   CLK_PHASE_180 2
+#define   CLK_PHASE_270 3
 #define   CLK_V2_TX_DELAY_MASK GENMASK(19, 16)
 #define   CLK_V2_RX_DELAY_MASK GENMASK(23, 20)
 #define   CLK_V2_ALWAYS_ON BIT(24)
@@ -136,6 +138,7 @@
 	unsigned int rx_delay_mask;
 	unsigned int always_on;
 	unsigned int adjust;
+	unsigned int clk_core_phase;
 };
 
 struct sd_emmc_desc {
@@ -415,7 +418,7 @@
 	/* init SD_EMMC_CLOCK to sane defaults w/min clock rate */
 	clk_reg = CLK_ALWAYS_ON(host);
 	clk_reg |= CLK_DIV_MASK;
-	clk_reg |= FIELD_PREP(CLK_CORE_PHASE_MASK, CLK_PHASE_180);
+	clk_reg |= FIELD_PREP(CLK_CORE_PHASE_MASK, host->data->clk_core_phase);
 	clk_reg |= FIELD_PREP(CLK_TX_PHASE_MASK, CLK_PHASE_0);
 	clk_reg |= FIELD_PREP(CLK_RX_PHASE_MASK, CLK_PHASE_0);
 	writel(clk_reg, host->regs + SD_EMMC_CLOCK);
@@ -1120,6 +1123,43 @@
 	.start_signal_voltage_switch = meson_mmc_voltage_switch,
 };
 
+struct mmc_host *sdio_host;
+
+static void sdio_rescan(struct mmc_host *mmc)
+{
+	int ret;
+
+	mmc->rescan_entered = 0;
+
+	/*mmc->host_rescan_disable = false;*/
+	mmc_detect_change(mmc, 0);
+
+	/* start the delayed_work */
+	ret = flush_work(&(mmc->detect.work));
+	if (!ret)
+		pr_info("Error: sdio_rescan() already idle!\n");
+}
+
+void sdio_reinit(void)
+{
+	mmc_get_card(sdio_host->card, NULL);
+	if (sdio_host) {
+		if (sdio_host->card) {
+			pr_info("[%s] sdio hw_reset\n", __func__);
+			sdio_host->bus_ops->hw_reset(sdio_host);
+		}
+		else {
+			sdio_rescan(sdio_host);
+		}
+	} else {
+		pr_info("Error: sdio_host is NULL\n");
+	}
+	mmc_put_card(sdio_host->card, NULL);
+
+	pr_info("[%s] finish\n", __func__);
+}
+EXPORT_SYMBOL(sdio_reinit);
+
 static int meson_mmc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
@@ -1276,6 +1316,11 @@
 		goto err_bounce_buf;
 	}
 
+	/*sdio*/
+	if (mmc->pm_caps & MMC_PM_KEEP_POWER) {
+		sdio_host = mmc;
+	}
+
 	mmc->ops = &meson_mmc_ops;
 	mmc_add_host(mmc);
 
@@ -1325,6 +1370,7 @@
 	.rx_delay_mask	= CLK_V2_RX_DELAY_MASK,
 	.always_on	= CLK_V2_ALWAYS_ON,
 	.adjust		= SD_EMMC_ADJUST,
+	.clk_core_phase	= CLK_PHASE_180,
 };
 
 static const struct meson_mmc_data meson_axg_data = {
@@ -1332,6 +1378,7 @@
 	.rx_delay_mask	= CLK_V3_RX_DELAY_MASK,
 	.always_on	= CLK_V3_ALWAYS_ON,
 	.adjust		= SD_EMMC_V3_ADJUST,
+	.clk_core_phase	= CLK_PHASE_270,
 };
 
 static const struct of_device_id meson_mmc_of_match[] = {
diff -Naur a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c	2022-05-27 17:20:16.737915780 +0800
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c	2022-05-31 11:56:47.737259290 +0800
@@ -21,6 +21,39 @@
 
 #ifdef CONFIG_OF
 
+#if defined (CONFIG_DWMAC_MESON)
+static u8 DEFMAC[] = {0, 0, 0, 0, 0, 0};
+static unsigned int g_mac_addr_setup;
+static unsigned char chartonum(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'A' && c <= 'F')
+		return (c - 'A') + 10;
+	if (c >= 'a' && c <= 'f')
+		return (c - 'a') + 10;
+
+	return 0;
+}
+
+static int __init mac_addr_set(char *line)
+{
+	unsigned char mac[6];
+	int i = 0;
+
+	for (i = 0; i < 6 && line[0] != '\0' && line[1] != '\0'; i++) {
+		mac[i] = chartonum(line[0]) << 4 | chartonum(line[1]);
+		line += 3;
+	}
+	memcpy(DEFMAC, mac, 6);
+	pr_info("uboot setup mac-addr: %02x:%02x:%02x:%02x:%02x:%02x\n",
+	    DEFMAC[0], DEFMAC[1], DEFMAC[2], DEFMAC[3], DEFMAC[4], DEFMAC[5]);
+	g_mac_addr_setup++;
+	return 0;
+}
+__setup("mac=", mac_addr_set);
+#endif
+
 /**
  * dwmac1000_validate_mcast_bins - validates the number of Multicast filter bins
  * @dev: struct device of the platform device
@@ -406,7 +439,15 @@
 	if (!plat)
 		return ERR_PTR(-ENOMEM);
 
+#if defined (CONFIG_DWMAC_MESON)
+	if (g_mac_addr_setup)   /*so uboot mac= is first priority.*/
+		*mac = DEFMAC;
+	else
+		*mac = of_get_mac_address(np);
+#else
 	*mac = of_get_mac_address(np);
+#endif
+
 	if (IS_ERR(*mac)) {
 		if (PTR_ERR(*mac) == -EPROBE_DEFER)
 			return ERR_CAST(*mac);
diff -Naur a/drivers/phy/amlogic/Kconfig b/drivers/phy/amlogic/Kconfig
--- a/drivers/phy/amlogic/Kconfig	2022-05-27 17:20:17.085920267 +0800
+++ b/drivers/phy/amlogic/Kconfig	2022-05-31 11:56:48.077256291 +0800
@@ -49,6 +49,18 @@
 	  in Meson G12A SoCs.
 	  If unsure, say N.
 
+config PHY_MESON_G12A_MIPI_DPHY_ANALOG
+	tristate "Meson G12A MIPI Analog DPHY driver"
+	default ARCH_MESON
+	depends on OF && (ARCH_MESON || COMPILE_TEST)
+	select GENERIC_PHY
+	select REGMAP_MMIO
+	select GENERIC_PHY_MIPI_DPHY
+	help
+	  Enable this to support the Meson MIPI Analog DPHY found in Meson G12A
+	  SoCs.
+	  If unsure, say N.
+
 config PHY_MESON_AXG_PCIE
 	tristate "Meson AXG PCIE PHY driver"
 	default ARCH_MESON
@@ -66,7 +78,20 @@
 	depends on OF && (ARCH_MESON || COMPILE_TEST)
 	select GENERIC_PHY
 	select REGMAP_MMIO
+	select GENERIC_PHY_MIPI_DPHY
 	help
 	  Enable this to support the Meson MIPI + PCIE analog PHY
 	  found in Meson AXG SoCs.
 	  If unsure, say N.
+
+config PHY_MESON_AXG_MIPI_DPHY
+	tristate "Meson AXG MIPI DPHY driver"
+	default ARCH_MESON
+	depends on OF && (ARCH_MESON || COMPILE_TEST)
+	select GENERIC_PHY
+	select REGMAP_MMIO
+	select GENERIC_PHY_MIPI_DPHY
+	help
+	  Enable this to support the Meson MIPI DPHY found in Meson AXG
+	  SoCs.
+	  If unsure, say N.
diff -Naur a/drivers/phy/amlogic/Makefile b/drivers/phy/amlogic/Makefile
--- a/drivers/phy/amlogic/Makefile	2022-05-27 17:20:17.085920267 +0800
+++ b/drivers/phy/amlogic/Makefile	2022-05-31 11:56:48.077256291 +0800
@@ -3,5 +3,7 @@
 obj-$(CONFIG_PHY_MESON_GXL_USB2)		+= phy-meson-gxl-usb2.o
 obj-$(CONFIG_PHY_MESON_G12A_USB2)		+= phy-meson-g12a-usb2.o
 obj-$(CONFIG_PHY_MESON_G12A_USB3_PCIE)		+= phy-meson-g12a-usb3-pcie.o
+obj-$(CONFIG_PHY_MESON_G12A_MIPI_DPHY_ANALOG)	+= phy-meson-g12a-mipi-dphy-analog.o
 obj-$(CONFIG_PHY_MESON_AXG_PCIE)		+= phy-meson-axg-pcie.o
 obj-$(CONFIG_PHY_MESON_AXG_MIPI_PCIE_ANALOG)	+= phy-meson-axg-mipi-pcie-analog.o
+obj-$(CONFIG_PHY_MESON_AXG_MIPI_DPHY)		+= phy-meson-axg-mipi-dphy.o
diff -Naur a/drivers/phy/amlogic/phy-meson-axg-mipi-dphy.c b/drivers/phy/amlogic/phy-meson-axg-mipi-dphy.c
--- a/drivers/phy/amlogic/phy-meson-axg-mipi-dphy.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/phy/amlogic/phy-meson-axg-mipi-dphy.c	2022-05-31 11:56:48.077256291 +0800
@@ -0,0 +1,415 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Meson AXG MIPI DPHY driver
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved
+ * Copyright (C) 2020 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+
+/* [31] soft reset for the phy.
+ *		1: reset. 0: dessert the reset.
+ * [30] clock lane soft reset.
+ * [29] data byte lane 3 soft reset.
+ * [28] data byte lane 2 soft reset.
+ * [27] data byte lane 1 soft reset.
+ * [26] data byte lane 0 soft reset.
+ * [25] mipi dsi pll clock selection.
+ *		1:  clock from fixed 850Mhz clock source. 0: from VID2 PLL.
+ * [12] mipi HSbyteclk enable.
+ * [11] mipi divider clk selection.
+ *		1: select the mipi DDRCLKHS from clock divider.
+ *		0: from PLL clock.
+ * [10] mipi clock divider control.
+ *		1: /4. 0: /2.
+ * [9]  mipi divider output enable.
+ * [8]  mipi divider counter enable.
+ * [7]  PLL clock enable.
+ * [5]  LPDT data endian.
+ *		1 = transfer the high bit first. 0 : transfer the low bit first.
+ * [4]  HS data endian.
+ * [3]  force data byte lane in stop mode.
+ * [2]  force data byte lane 0 in receiver mode.
+ * [1]  write 1 to sync the txclkesc input. the internal logic have to
+ *	use txclkesc to decide Txvalid and Txready.
+ * [0]  enalbe the MIPI DPHY TxDDRClk.
+ */
+#define MIPI_DSI_PHY_CTRL				0x0
+
+/* [31] clk lane tx_hs_en control selection.
+ *		1: from register. 0: use clk lane state machine.
+ * [30] register bit for clock lane tx_hs_en.
+ * [29] clk lane tx_lp_en contrl selection.
+ *		1: from register. 0: from clk lane state machine.
+ * [28] register bit for clock lane tx_lp_en.
+ * [27] chan0 tx_hs_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [26] register bit for chan0 tx_hs_en.
+ * [25] chan0 tx_lp_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [24] register bit from chan0 tx_lp_en.
+ * [23] chan0 rx_lp_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [22] register bit from chan0 rx_lp_en.
+ * [21] chan0 contention detection enable control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [20] register bit from chan0 contention dectection enable.
+ * [19] chan1 tx_hs_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [18] register bit for chan1 tx_hs_en.
+ * [17] chan1 tx_lp_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [16] register bit from chan1 tx_lp_en.
+ * [15] chan2 tx_hs_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [14] register bit for chan2 tx_hs_en.
+ * [13] chan2 tx_lp_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [12] register bit from chan2 tx_lp_en.
+ * [11] chan3 tx_hs_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [10] register bit for chan3 tx_hs_en.
+ * [9]  chan3 tx_lp_en control selection.
+ *		1: from register. 0: from chan0 state machine.
+ * [8]  register bit from chan3 tx_lp_en.
+ * [4]  clk chan power down. this bit is also used as the power down
+ *	of the whole MIPI_DSI_PHY.
+ * [3]  chan3 power down.
+ * [2]  chan2 power down.
+ * [1]  chan1 power down.
+ * [0]  chan0 power down.
+ */
+#define MIPI_DSI_CHAN_CTRL				0x4
+
+/* [24]   rx turn watch dog triggered.
+ * [23]   rx esc watchdog  triggered.
+ * [22]   mbias ready.
+ * [21]   txclkesc  synced and ready.
+ * [20:17] clk lane state. {mbias_ready, tx_stop, tx_ulps, tx_hs_active}
+ * [16:13] chan3 state{0, tx_stop, tx_ulps, tx_hs_active}
+ * [12:9]  chan2 state.{0, tx_stop, tx_ulps, tx_hs_active}
+ * [8:5]   chan1 state. {0, tx_stop, tx_ulps, tx_hs_active}
+ * [4:0]   chan0 state. {TX_STOP, tx_ULPS, hs_active, direction, rxulpsesc}
+ */
+#define MIPI_DSI_CHAN_STS				0x8
+
+/* [31:24] TCLK_PREPARE.
+ * [23:16] TCLK_ZERO.
+ * [15:8]  TCLK_POST.
+ * [7:0]   TCLK_TRAIL.
+ */
+#define MIPI_DSI_CLK_TIM				0xc
+
+/* [31:24] THS_PREPARE.
+ * [23:16] THS_ZERO.
+ * [15:8]  THS_TRAIL.
+ * [7:0]   THS_EXIT.
+ */
+#define MIPI_DSI_HS_TIM					0x10
+
+/* [31:24] tTA_GET.
+ * [23:16] tTA_GO.
+ * [15:8]  tTA_SURE.
+ * [7:0]   tLPX.
+ */
+#define MIPI_DSI_LP_TIM					0x14
+
+/* wait time to  MIPI DIS analog ready. */
+#define MIPI_DSI_ANA_UP_TIM				0x18
+
+/* TINIT. */
+#define MIPI_DSI_INIT_TIM				0x1c
+
+/* TWAKEUP. */
+#define MIPI_DSI_WAKEUP_TIM				0x20
+
+/* when in RxULPS check state, after the the logic enable the analog,
+ *	how long we should wait to check the lP state .
+ */
+#define MIPI_DSI_LPOK_TIM				0x24
+
+/* Watchdog for RX low power state no finished. */
+#define MIPI_DSI_LP_WCHDOG				0x28
+
+/* tMBIAS,  after send power up signals to analog,
+ *	how long we should wait for analog powered up.
+ */
+#define MIPI_DSI_ANA_CTRL				0x2c
+
+/* [31:8]  reserved for future.
+ * [7:0]   tCLK_PRE.
+ */
+#define MIPI_DSI_CLK_TIM1				0x30
+
+/* watchdog for turn around waiting time. */
+#define MIPI_DSI_TURN_WCHDOG				0x34
+
+/* When in RxULPS state, how frequency we should to check
+ *	if the TX side out of ULPS state.
+ */
+#define MIPI_DSI_ULPS_CHECK				0x38
+#define MIPI_DSI_TEST_CTRL0				0x3c
+#define MIPI_DSI_TEST_CTRL1				0x40
+
+struct phy_meson_axg_mipi_dphy_priv {
+	struct device				*dev;
+	struct regmap				*regmap;
+	struct clk				*clk;
+	struct reset_control			*reset;
+	struct phy				*analog;
+	struct phy_configure_opts_mipi_dphy	config;
+};
+
+static const struct regmap_config phy_meson_axg_mipi_dphy_regmap_conf = {
+	.reg_bits = 8,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.max_register = MIPI_DSI_TEST_CTRL1,
+};
+
+static int phy_meson_axg_mipi_dphy_init(struct phy *phy)
+{
+	struct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);
+	int ret;
+
+	ret = phy_init(priv->analog);
+	if (ret)
+		return ret;
+
+	ret = reset_control_reset(priv->reset);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int phy_meson_axg_mipi_dphy_configure(struct phy *phy,
+					      union phy_configure_opts *opts)
+{
+	struct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);
+	int ret;
+
+	ret = phy_mipi_dphy_config_validate(&opts->mipi_dphy);
+	if (ret)
+		return ret;
+
+	ret = phy_configure(priv->analog, opts);
+	if (ret)
+		return ret;
+
+	memcpy(&priv->config, opts, sizeof(priv->config));
+
+	return 0;
+}
+
+static int phy_meson_axg_mipi_dphy_power_on(struct phy *phy)
+{
+	struct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);
+	int ret;
+	unsigned long temp;
+
+	ret = phy_power_on(priv->analog);
+	if (ret)
+		return ret;
+
+	/* enable phy clock */
+	regmap_write(priv->regmap, MIPI_DSI_PHY_CTRL,  0x1);
+	regmap_write(priv->regmap, MIPI_DSI_PHY_CTRL,
+		     BIT(0) | /* enable the DSI PLL clock . */
+		     BIT(7) | /* enable pll clock which connected to DDR clock path */
+		     BIT(8)); /* enable the clock divider counter */
+
+	/* enable the divider clock out */
+	regmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(9), BIT(9));
+
+	/* enable the byte clock generation. */
+	regmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(12), BIT(12));
+	regmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(31), BIT(31));
+	regmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(31), 0);
+
+	/* Calculate lanebyteclk period in ps */
+	temp = (1000000 * 100) / (priv->config.hs_clk_rate / 1000);
+	temp = temp * 8 * 10;
+
+	regmap_write(priv->regmap, MIPI_DSI_CLK_TIM,
+		     DIV_ROUND_UP(priv->config.clk_trail, temp) |
+		     (DIV_ROUND_UP(priv->config.clk_post +
+				   priv->config.hs_trail, temp) << 8) |
+		     (DIV_ROUND_UP(priv->config.clk_zero, temp) << 16) |
+		     (DIV_ROUND_UP(priv->config.clk_prepare, temp) << 24));
+	regmap_write(priv->regmap, MIPI_DSI_CLK_TIM1,
+		     DIV_ROUND_UP(priv->config.clk_pre, temp));
+
+	regmap_write(priv->regmap, MIPI_DSI_HS_TIM,
+		     DIV_ROUND_UP(priv->config.hs_exit, temp) |
+		     (DIV_ROUND_UP(priv->config.hs_trail, temp) << 8) |
+		     (DIV_ROUND_UP(priv->config.hs_zero, temp) << 16) |
+		     (DIV_ROUND_UP(priv->config.hs_prepare, temp) << 24));
+
+	regmap_write(priv->regmap, MIPI_DSI_LP_TIM,
+		     DIV_ROUND_UP(priv->config.lpx, temp) |
+		     (DIV_ROUND_UP(priv->config.ta_sure, temp) << 8) |
+		     (DIV_ROUND_UP(priv->config.ta_go, temp) << 16) |
+		     (DIV_ROUND_UP(priv->config.ta_get, temp) << 24));
+
+	regmap_write(priv->regmap, MIPI_DSI_ANA_UP_TIM, 0x0100);
+	regmap_write(priv->regmap, MIPI_DSI_INIT_TIM,
+		     DIV_ROUND_UP(priv->config.init * NSEC_PER_MSEC, temp));
+	regmap_write(priv->regmap, MIPI_DSI_WAKEUP_TIM,
+		     DIV_ROUND_UP(priv->config.wakeup * NSEC_PER_MSEC, temp));
+	regmap_write(priv->regmap, MIPI_DSI_LPOK_TIM, 0x7C);
+	regmap_write(priv->regmap, MIPI_DSI_ULPS_CHECK, 0x927C);
+	regmap_write(priv->regmap, MIPI_DSI_LP_WCHDOG, 0x1000);
+	regmap_write(priv->regmap, MIPI_DSI_TURN_WCHDOG, 0x1000);
+
+	/* Powerup the analog circuit */
+	switch (priv->config.lanes) {
+	case 1:
+		regmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0xe);
+		break;
+	case 2:
+		regmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0xc);
+		break;
+	case 3:
+		regmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0x8);
+		break;
+	case 4:
+	default:
+		regmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0);
+		break;
+	}
+
+	/* Trigger a sync active for esc_clk */
+	regmap_update_bits(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(1), BIT(1));
+
+	return 0;
+}
+
+static int phy_meson_axg_mipi_dphy_power_off(struct phy *phy)
+{
+	struct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);
+
+	regmap_write(priv->regmap, MIPI_DSI_CHAN_CTRL, 0xf);
+	regmap_write(priv->regmap, MIPI_DSI_PHY_CTRL, BIT(31));
+
+	phy_power_off(priv->analog);
+
+	return 0;
+}
+
+static int phy_meson_axg_mipi_dphy_exit(struct phy *phy)
+{
+	struct phy_meson_axg_mipi_dphy_priv *priv = phy_get_drvdata(phy);
+	int ret;
+
+	ret = phy_exit(priv->analog);
+	if (ret)
+		return ret;
+
+	return reset_control_reset(priv->reset);
+}
+
+static const struct phy_ops phy_meson_axg_mipi_dphy_ops = {
+	.configure	= phy_meson_axg_mipi_dphy_configure,
+	.init		= phy_meson_axg_mipi_dphy_init,
+	.exit		= phy_meson_axg_mipi_dphy_exit,
+	.power_on	= phy_meson_axg_mipi_dphy_power_on,
+	.power_off	= phy_meson_axg_mipi_dphy_power_off,
+	.owner		= THIS_MODULE,
+};
+
+static int phy_meson_axg_mipi_dphy_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct phy_provider *phy_provider;
+	struct resource *res;
+	struct phy_meson_axg_mipi_dphy_priv *priv;
+	struct phy *phy;
+	void __iomem *base;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->dev = dev;
+	platform_set_drvdata(pdev, priv);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	priv->regmap = devm_regmap_init_mmio(dev, base,
+					&phy_meson_axg_mipi_dphy_regmap_conf);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	priv->clk = devm_clk_get(dev, "pclk");
+	if (IS_ERR(priv->clk))
+		return PTR_ERR(priv->clk);
+
+	priv->reset = devm_reset_control_get(dev, "phy");
+	if (IS_ERR(priv->reset))
+		return PTR_ERR(priv->reset);
+
+	priv->analog = devm_phy_get(dev, "analog");
+	if (IS_ERR(priv->analog))
+		return PTR_ERR(priv->analog);
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
+
+	ret = reset_control_deassert(priv->reset);
+	if (ret)
+		return ret;
+
+	phy = devm_phy_create(dev, NULL, &phy_meson_axg_mipi_dphy_ops);
+	if (IS_ERR(phy)) {
+		ret = PTR_ERR(phy);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to create PHY\n");
+
+		return ret;
+	}
+
+	phy_set_drvdata(phy, priv);
+
+	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+
+    dev_info(dev, "create PHY : %d\n", PTR_ERR_OR_ZERO(phy_provider));
+
+	return PTR_ERR_OR_ZERO(phy_provider);
+}
+
+static const struct of_device_id phy_meson_axg_mipi_dphy_of_match[] = {
+	{ .compatible = "amlogic,axg-mipi-dphy", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, phy_meson_axg_mipi_dphy_of_match);
+
+static struct platform_driver phy_meson_axg_mipi_dphy_driver = {
+	.probe	= phy_meson_axg_mipi_dphy_probe,
+	.driver	= {
+		.name		= "phy-meson-axg-mipi-dphy",
+		.of_match_table	= phy_meson_axg_mipi_dphy_of_match,
+	},
+};
+module_platform_driver(phy_meson_axg_mipi_dphy_driver);
+
+MODULE_AUTHOR("Neil Armstrong <narmstrong@baylibre.com>");
+MODULE_DESCRIPTION("Meson AXG MIPI DPHY driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/phy/amlogic/phy-meson-g12a-mipi-dphy-analog.c b/drivers/phy/amlogic/phy-meson-g12a-mipi-dphy-analog.c
--- a/drivers/phy/amlogic/phy-meson-g12a-mipi-dphy-analog.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/phy/amlogic/phy-meson-g12a-mipi-dphy-analog.c	2022-05-31 11:56:48.077256291 +0800
@@ -0,0 +1,181 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Meson G12A MIPI DSI Analog PHY
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved
+ * Copyright (C) 2020 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ */
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/module.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/mfd/syscon.h>
+#include <linux/platform_device.h>
+#include <dt-bindings/phy/phy.h>
+
+#define HHI_MIPI_CNTL0 0x00
+#define		HHI_MIPI_CNTL0_DIF_REF_CTL1	GENMASK(31, 16)
+#define		HHI_MIPI_CNTL0_DIF_REF_CTL0	GENMASK(15, 0)
+
+#define HHI_MIPI_CNTL1 0x04
+#define		HHI_MIPI_CNTL1_BANDGAP		BIT(16)
+#define		HHI_MIPI_CNTL2_DIF_REF_CTL2	GENMASK(15, 0)
+
+#define HHI_MIPI_CNTL2 0x08
+#define		HHI_MIPI_CNTL2_DIF_TX_CTL1	GENMASK(31, 16)
+#define		HHI_MIPI_CNTL2_CH_EN		GENMASK(15, 11)
+#define		HHI_MIPI_CNTL2_DIF_TX_CTL0	GENMASK(10, 0)
+
+#define DSI_LANE_0				BIT(4)
+#define DSI_LANE_1				BIT(3)
+#define DSI_LANE_CLK				BIT(2)
+#define DSI_LANE_2				BIT(1)
+#define DSI_LANE_3				BIT(0)
+
+struct phy_g12a_mipi_dphy_analog_priv {
+	struct phy *phy;
+	struct regmap *regmap;
+	struct phy_configure_opts_mipi_dphy config;
+};
+
+static int phy_g12a_mipi_dphy_analog_configure(struct phy *phy,
+					       union phy_configure_opts *opts)
+{
+	struct phy_g12a_mipi_dphy_analog_priv *priv = phy_get_drvdata(phy);
+	int ret;
+
+	ret = phy_mipi_dphy_config_validate(&opts->mipi_dphy);
+	if (ret)
+		return ret;
+
+	memcpy(&priv->config, opts, sizeof(priv->config));
+
+	return 0;
+}
+
+static int phy_g12a_mipi_dphy_analog_power_on(struct phy *phy)
+{
+	struct phy_g12a_mipi_dphy_analog_priv *priv = phy_get_drvdata(phy);
+	unsigned int reg;
+
+	regmap_write(priv->regmap, HHI_MIPI_CNTL0,
+		     FIELD_PREP(HHI_MIPI_CNTL0_DIF_REF_CTL0, 0x8) |
+		     FIELD_PREP(HHI_MIPI_CNTL0_DIF_REF_CTL1, 0xa487));
+
+	regmap_write(priv->regmap, HHI_MIPI_CNTL1,
+		     FIELD_PREP(HHI_MIPI_CNTL2_DIF_REF_CTL2, 0x2e) |
+		     HHI_MIPI_CNTL1_BANDGAP);
+
+	regmap_write(priv->regmap, HHI_MIPI_CNTL2,
+		     FIELD_PREP(HHI_MIPI_CNTL2_DIF_TX_CTL0, /*UNIONMAN modify: 0x459*/0x45a) |
+		     FIELD_PREP(HHI_MIPI_CNTL2_DIF_TX_CTL1, 0x2680));
+
+	reg = DSI_LANE_CLK;
+	// UNIONMAN: Maybe there is a bug in SoC, we must enable all lanes
+	unsigned int lanes = 4;
+	switch (/*priv->config.lanes*/lanes) {
+	case 4:
+		reg |= DSI_LANE_3;
+		fallthrough;
+	case 3:
+		reg |= DSI_LANE_2;
+		fallthrough;
+	case 2:
+		reg |= DSI_LANE_1;
+		fallthrough;
+	case 1:
+		reg |= DSI_LANE_0;
+		break;
+	default:
+		reg = 0;
+	}
+
+	regmap_update_bits(priv->regmap, HHI_MIPI_CNTL2,
+			   HHI_MIPI_CNTL2_CH_EN,
+			   FIELD_PREP(HHI_MIPI_CNTL2_CH_EN, reg));
+
+	return 0;
+}
+
+static int phy_g12a_mipi_dphy_analog_power_off(struct phy *phy)
+{
+	struct phy_g12a_mipi_dphy_analog_priv *priv = phy_get_drvdata(phy);
+
+	regmap_write(priv->regmap, HHI_MIPI_CNTL0, 0);
+	regmap_write(priv->regmap, HHI_MIPI_CNTL1, 0);
+	regmap_write(priv->regmap, HHI_MIPI_CNTL2, 0);
+
+	return 0;
+}
+
+static const struct phy_ops phy_g12a_mipi_dphy_analog_ops = {
+	.configure = phy_g12a_mipi_dphy_analog_configure,
+	.power_on = phy_g12a_mipi_dphy_analog_power_on,
+	.power_off = phy_g12a_mipi_dphy_analog_power_off,
+	.owner = THIS_MODULE,
+};
+
+static int phy_g12a_mipi_dphy_analog_probe(struct platform_device *pdev)
+{
+	struct phy_provider *phy;
+	struct device *dev = &pdev->dev;
+	struct phy_g12a_mipi_dphy_analog_priv *priv;
+	struct device_node *np = dev->of_node;
+	struct regmap *map;
+	int ret;
+
+	priv = devm_kmalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	/* Get the hhi system controller node */
+	map = syscon_node_to_regmap(of_get_parent(dev->of_node));
+	if (IS_ERR(map)) {
+		dev_err(dev,
+			"failed to get HHI regmap\n");
+		return PTR_ERR(map);
+	}
+
+	priv->regmap = map;
+
+	priv->phy = devm_phy_create(dev, np, &phy_g12a_mipi_dphy_analog_ops);
+	if (IS_ERR(priv->phy)) {
+		ret = PTR_ERR(priv->phy);
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to create PHY\n");
+		return ret;
+	}
+
+	phy_set_drvdata(priv->phy, priv);
+	dev_set_drvdata(dev, priv);
+
+	phy = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
+
+    dev_info(dev, "create PHY : %d\n", PTR_ERR_OR_ZERO(phy));
+
+	return PTR_ERR_OR_ZERO(phy);
+}
+
+static const struct of_device_id phy_g12a_mipi_dphy_analog_of_match[] = {
+	{
+		.compatible = "amlogic,g12a-mipi-dphy-analog",
+	},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, phy_g12a_mipi_dphy_analog_of_match);
+
+static struct platform_driver phy_g12a_mipi_dphy_analog_driver = {
+	.probe = phy_g12a_mipi_dphy_analog_probe,
+	.driver = {
+		.name = "phy-meson-g12a-mipi-dphy-analog",
+		.of_match_table = phy_g12a_mipi_dphy_analog_of_match,
+	},
+};
+module_platform_driver(phy_g12a_mipi_dphy_analog_driver);
+
+MODULE_AUTHOR("Neil Armstrong <narmstrong@baylibre.com>");
+MODULE_DESCRIPTION("Meson G12A MIPI Analog D-PHY driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/drivers/pinctrl/meson/pinctrl-meson.c b/drivers/pinctrl/meson/pinctrl-meson.c
--- a/drivers/pinctrl/meson/pinctrl-meson.c	2022-05-27 17:20:17.113920629 +0800
+++ b/drivers/pinctrl/meson/pinctrl-meson.c	2022-06-29 09:32:26.735042911 +0800
@@ -56,6 +56,24 @@
 #include "../pinctrl-utils.h"
 #include "pinctrl-meson.h"
 
+static int meson_memory_duplicate(struct platform_device *pdev, void **addr,
+				  size_t n, size_t size)
+{
+	void *mem;
+
+	if (!(*addr))
+		return -EINVAL;
+
+	mem = devm_kzalloc(&pdev->dev, size * n, GFP_KERNEL);
+	if (!mem)
+		return -ENOMEM;
+
+	memcpy(mem, *addr, size * n);
+	*addr = mem;
+
+	return 0;
+};
+
 static const unsigned int meson_bit_strides[] = {
 	1, 1, 1, 1, 1, 2, 1
 };
@@ -152,6 +170,7 @@
 
 	return pc->data->num_funcs;
 }
+EXPORT_SYMBOL(meson_pmx_get_funcs_count);
 
 const char *meson_pmx_get_func_name(struct pinctrl_dev *pcdev,
 				    unsigned selector)
@@ -160,6 +179,7 @@
 
 	return pc->data->funcs[selector].name;
 }
+EXPORT_SYMBOL(meson_pmx_get_func_name);
 
 int meson_pmx_get_groups(struct pinctrl_dev *pcdev, unsigned selector,
 			 const char * const **groups,
@@ -172,6 +192,7 @@
 
 	return 0;
 }
+EXPORT_SYMBOL(meson_pmx_get_groups);
 
 static int meson_pinconf_set_gpio_bit(struct meson_pinctrl *pc,
 				      unsigned int pin,
@@ -248,11 +269,11 @@
 {
 	int ret;
 
-	ret = meson_pinconf_set_output(pc, pin, true);
+	ret = meson_pinconf_set_drive(pc, pin, high);
 	if (ret)
 		return ret;
 
-	return meson_pinconf_set_drive(pc, pin, high);
+	return meson_pinconf_set_output(pc, pin, true);
 }
 
 static int meson_pinconf_disable_bias(struct meson_pinctrl *pc,
@@ -355,6 +376,7 @@
 
 		switch (param) {
 		case PIN_CONFIG_DRIVE_STRENGTH_UA:
+		case PIN_CONFIG_INPUT_ENABLE:
 		case PIN_CONFIG_OUTPUT_ENABLE:
 		case PIN_CONFIG_OUTPUT:
 			arg = pinconf_to_config_argument(configs[i]);
@@ -383,6 +405,9 @@
 		case PIN_CONFIG_OUTPUT:
 			ret = meson_pinconf_set_output_drive(pc, pin, arg);
 			break;
+		case PIN_CONFIG_INPUT_ENABLE:
+			ret = meson_pinconf_set_output(pc, pin, !arg);
+			break;
 		default:
 			ret = -ENOTSUPP;
 		}
@@ -598,9 +623,42 @@
 	return !!(val & BIT(bit));
 }
 
+static int meson_gpio_to_irq(struct gpio_chip *chip, unsigned int gpio)
+{
+	struct meson_pinctrl *pc = gpiochip_get_data(chip);
+	struct meson_bank *bank;
+	struct irq_fwspec fwspec;
+	int hwirq;
+
+	if (meson_get_bank(pc, gpio, &bank))
+		return -EINVAL;
+
+	if (bank->irq_first < 0) {
+		dev_warn(pc->dev, "no support irq for pin[%d]\n", gpio);
+		return -EINVAL;
+	}
+
+	if (!pc->of_irq) {
+		dev_err(pc->dev, "invalid device node of gpio INTC\n");
+		return -EINVAL;
+	}
+
+	hwirq = gpio - bank->first + bank->irq_first;
+
+	fwspec.fwnode = of_node_to_fwnode(pc->of_irq);
+	fwspec.param_count = 2;
+	fwspec.param[0] = hwirq;
+	fwspec.param[1] = IRQ_TYPE_NONE;
+
+	return irq_create_fwspec_mapping(&fwspec);
+}
+
 static int meson_gpiolib_register(struct meson_pinctrl *pc)
 {
 	int ret;
+	const char **names;
+	const struct pinctrl_pin_desc *pins;
+	int i;
 
 	pc->chip.label = pc->data->name;
 	pc->chip.parent = pc->dev;
@@ -612,6 +670,13 @@
 	pc->chip.direction_output = meson_gpio_direction_output;
 	pc->chip.get = meson_gpio_get;
 	pc->chip.set = meson_gpio_set;
+	pc->chip.to_irq = meson_gpio_to_irq;
+	pc->chip.set_config = gpiochip_generic_config;
+	names = kcalloc(pc->desc.npins, sizeof(char *), GFP_KERNEL);
+	pins = pc->desc.pins;
+	for (i = 0; i < pc->desc.npins; i++)
+		names[pins[i].number] = pins[i].name;
+	pc->chip.names = (const char * const *)names;
 	pc->chip.base = -1;
 	pc->chip.ngpio = pc->data->num_pins;
 	pc->chip.can_sleep = false;
@@ -619,6 +684,16 @@
 	pc->chip.of_gpio_n_cells = 2;
 
 	ret = gpiochip_add_data(&pc->chip, pc);
+
+	/* pin->chip.names will be assigned to each gpio discriptor' name
+	 * member after gpiochip_add_data. To keep node name consistency when
+	 * use sysfs to export gpio, pc->chip.name need to be cleared also see
+	 * gpiod_export->device_create_with_groups.
+	 */
+	kfree(names);
+	names = NULL;
+	pc->chip.names = NULL;
+
 	if (ret) {
 		dev_err(pc->dev, "can't add gpio chip %s\n",
 			pc->data->name);
@@ -681,6 +756,13 @@
 	}
 
 	pc->of_node = gpio_np;
+	pc->of_irq = of_find_compatible_node(NULL,
+					     NULL,
+					     "amlogic,meson-gpio-intc-ext");
+	if (!pc->of_irq)
+		pc->of_irq = of_find_compatible_node(NULL,
+						     NULL,
+						     "amlogic,meson-gpio-intc");
 
 	pc->reg_mux = meson_map_resource(pc, gpio_np, "mux");
 	if (IS_ERR_OR_NULL(pc->reg_mux)) {
@@ -750,6 +832,16 @@
 	if (ret)
 		return ret;
 
+	ret = meson_memory_duplicate(pdev, (void **)&pc->data->groups, pc->data->num_groups,
+				     sizeof(struct meson_pmx_group));
+	if (ret)
+		return ret;
+
+	ret = meson_memory_duplicate(pdev, (void **)&pc->data->funcs, pc->data->num_funcs,
+				     sizeof(struct meson_pmx_func));
+	if (ret)
+		return ret;
+
 	pc->desc.name		= "pinctrl-meson";
 	pc->desc.owner		= THIS_MODULE;
 	pc->desc.pctlops	= &meson_pctrl_ops;
@@ -766,3 +858,4 @@
 
 	return meson_gpiolib_register(pc);
 }
+EXPORT_SYMBOL(meson_pinctrl_probe);
diff -Naur a/drivers/pinctrl/meson/pinctrl-meson.h b/drivers/pinctrl/meson/pinctrl-meson.h
--- a/drivers/pinctrl/meson/pinctrl-meson.h	2022-05-27 17:20:17.113920629 +0800
+++ b/drivers/pinctrl/meson/pinctrl-meson.h	2022-06-29 09:29:37.636093034 +0800
@@ -130,6 +130,7 @@
 	struct regmap *reg_gpio;
 	struct regmap *reg_ds;
 	struct gpio_chip chip;
+	struct device_node *of_irq;
 	struct device_node *of_node;
 };
 
diff -Naur a/drivers/soc/amlogic/meson-canvas.c b/drivers/soc/amlogic/meson-canvas.c
--- a/drivers/soc/amlogic/meson-canvas.c	2022-05-27 17:20:17.405924394 +0800
+++ b/drivers/soc/amlogic/meson-canvas.c	2022-05-31 11:56:48.077256291 +0800
@@ -148,6 +148,24 @@
 }
 EXPORT_SYMBOL_GPL(meson_canvas_alloc);
 
+int meson_canvas_alloc_spec(struct meson_canvas *canvas, u8 canvas_index)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&canvas->lock, flags);
+	if (!canvas->used[canvas_index]) {
+		canvas->used[canvas_index] = 1;
+		spin_unlock_irqrestore(&canvas->lock, flags);
+		return 0;
+	}
+	spin_unlock_irqrestore(&canvas->lock, flags);
+	
+	dev_err(canvas->dev, "Canvas (%u) is busy\n", canvas_index);
+	return -EBUSY;
+}
+EXPORT_SYMBOL_GPL(meson_canvas_alloc_spec);
+
+
 int meson_canvas_free(struct meson_canvas *canvas, u8 canvas_index)
 {
 	unsigned long flags;
diff -Naur a/drivers/staging/media/meson/vdec/codec_h264.c b/drivers/staging/media/meson/vdec/codec_h264.c
--- a/drivers/staging/media/meson/vdec/codec_h264.c	2022-05-27 17:20:17.521925890 +0800
+++ b/drivers/staging/media/meson/vdec/codec_h264.c	2022-05-31 11:56:48.081256256 +0800
@@ -353,7 +353,8 @@
 		frame_width, frame_height, crop_right, crop_bottom);
 
 	codec_h264_set_par(sess);
-	amvdec_src_change(sess, frame_width, frame_height, h264->max_refs + 5);
+	amvdec_src_change(sess, frame_width, frame_height,
+			  h264->max_refs + 5, 8);
 }
 
 /*
diff -Naur a/drivers/staging/media/meson/vdec/codec_hevc.c b/drivers/staging/media/meson/vdec/codec_hevc.c
--- a/drivers/staging/media/meson/vdec/codec_hevc.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/staging/media/meson/vdec/codec_hevc.c	2022-05-31 11:56:48.081256256 +0800
@@ -0,0 +1,1440 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2018 Maxime Jourdan <mjourdan@baylibre.com>
+ * Copyright (C) 2015 Amlogic, Inc. All rights reserved.
+ */
+
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-dma-contig.h>
+
+#include "codec_hevc.h"
+#include "dos_regs.h"
+#include "hevc_regs.h"
+#include "vdec_helpers.h"
+#include "codec_hevc_common.h"
+
+/* HEVC reg mapping */
+#define HEVC_DEC_STATUS_REG	HEVC_ASSIST_SCRATCH_0
+	#define HEVC_ACTION_DONE	0xff
+#define HEVC_RPM_BUFFER		HEVC_ASSIST_SCRATCH_1
+#define HEVC_SHORT_TERM_RPS	HEVC_ASSIST_SCRATCH_2
+#define HEVC_VPS_BUFFER		HEVC_ASSIST_SCRATCH_3
+#define HEVC_SPS_BUFFER		HEVC_ASSIST_SCRATCH_4
+#define HEVC_PPS_BUFFER		HEVC_ASSIST_SCRATCH_5
+#define HEVC_SAO_UP		HEVC_ASSIST_SCRATCH_6
+#define HEVC_STREAM_SWAP_BUFFER HEVC_ASSIST_SCRATCH_7
+#define H265_MMU_MAP_BUFFER	HEVC_ASSIST_SCRATCH_7
+#define HEVC_STREAM_SWAP_BUFFER2 HEVC_ASSIST_SCRATCH_8
+#define HEVC_sao_mem_unit	HEVC_ASSIST_SCRATCH_9
+#define HEVC_SAO_ABV		HEVC_ASSIST_SCRATCH_A
+#define HEVC_sao_vb_size	HEVC_ASSIST_SCRATCH_B
+#define HEVC_SAO_VB		HEVC_ASSIST_SCRATCH_C
+#define HEVC_SCALELUT		HEVC_ASSIST_SCRATCH_D
+#define HEVC_WAIT_FLAG		HEVC_ASSIST_SCRATCH_E
+#define RPM_CMD_REG		HEVC_ASSIST_SCRATCH_F
+#define LMEM_DUMP_ADR		HEVC_ASSIST_SCRATCH_F
+#define DEBUG_REG1		HEVC_ASSIST_SCRATCH_G
+#define HEVC_DECODE_MODE2	HEVC_ASSIST_SCRATCH_H
+#define NAL_SEARCH_CTL		HEVC_ASSIST_SCRATCH_I
+#define HEVC_DECODE_MODE	HEVC_ASSIST_SCRATCH_J
+	#define DECODE_MODE_SINGLE 0
+#define DECODE_STOP_POS		HEVC_ASSIST_SCRATCH_K
+#define HEVC_AUX_ADR		HEVC_ASSIST_SCRATCH_L
+#define HEVC_AUX_DATA_SIZE	HEVC_ASSIST_SCRATCH_M
+#define HEVC_DECODE_SIZE	HEVC_ASSIST_SCRATCH_N
+
+#define AMRISC_MAIN_REQ		 0x04
+
+/* HEVC Constants */
+#define MAX_REF_PIC_NUM		24
+#define MAX_REF_ACTIVE		16
+#define MAX_TILE_COL_NUM	10
+#define MAX_TILE_ROW_NUM	20
+#define MAX_SLICE_NUM		800
+#define INVALID_POC		0x80000000
+
+/* HEVC Workspace layout */
+#define MPRED_MV_BUF_SIZE 0x120000
+
+#define IPP_SIZE	0x4000
+#define SAO_ABV_SIZE	0x30000
+#define SAO_VB_SIZE	0x30000
+#define SH_TM_RPS_SIZE	0x800
+#define VPS_SIZE	0x800
+#define SPS_SIZE	0x800
+#define PPS_SIZE	0x2000
+#define SAO_UP_SIZE	0x2800
+#define SWAP_BUF_SIZE	0x800
+#define SWAP_BUF2_SIZE	0x800
+#define SCALELUT_SIZE	0x8000
+#define DBLK_PARA_SIZE	0x20000
+#define DBLK_DATA_SIZE	0x80000
+#define DBLK_DATA2_SIZE	0x80000
+#define MMU_VBH_SIZE	0x5000
+#define MPRED_ABV_SIZE	0x8000
+#define MPRED_MV_SIZE	(MPRED_MV_BUF_SIZE * MAX_REF_PIC_NUM)
+#define RPM_BUF_SIZE	0x100
+#define LMEM_SIZE	0xA00
+
+#define IPP_OFFSET       0x00
+#define SAO_ABV_OFFSET   (IPP_OFFSET + IPP_SIZE)
+#define SAO_VB_OFFSET    (SAO_ABV_OFFSET + SAO_ABV_SIZE)
+#define SH_TM_RPS_OFFSET (SAO_VB_OFFSET + SAO_VB_SIZE)
+#define VPS_OFFSET       (SH_TM_RPS_OFFSET + SH_TM_RPS_SIZE)
+#define SPS_OFFSET       (VPS_OFFSET + VPS_SIZE)
+#define PPS_OFFSET       (SPS_OFFSET + SPS_SIZE)
+#define SAO_UP_OFFSET    (PPS_OFFSET + PPS_SIZE)
+#define SWAP_BUF_OFFSET  (SAO_UP_OFFSET + SAO_UP_SIZE)
+#define SWAP_BUF2_OFFSET (SWAP_BUF_OFFSET + SWAP_BUF_SIZE)
+#define SCALELUT_OFFSET  (SWAP_BUF2_OFFSET + SWAP_BUF2_SIZE)
+#define DBLK_PARA_OFFSET (SCALELUT_OFFSET + SCALELUT_SIZE)
+#define DBLK_DATA_OFFSET (DBLK_PARA_OFFSET + DBLK_PARA_SIZE)
+#define DBLK_DATA2_OFFSET (DBLK_DATA_OFFSET + DBLK_DATA_SIZE)
+#define MMU_VBH_OFFSET   (DBLK_DATA2_OFFSET + DBLK_DATA2_SIZE)
+#define MPRED_ABV_OFFSET (MMU_VBH_OFFSET + MMU_VBH_SIZE)
+#define MPRED_MV_OFFSET  (MPRED_ABV_OFFSET + MPRED_ABV_SIZE)
+#define RPM_OFFSET       (MPRED_MV_OFFSET + MPRED_MV_SIZE)
+#define LMEM_OFFSET      (RPM_OFFSET + RPM_BUF_SIZE)
+
+/* ISR decode status */
+#define HEVC_DEC_IDLE                        0x0
+#define HEVC_NAL_UNIT_VPS                    0x1
+#define HEVC_NAL_UNIT_SPS                    0x2
+#define HEVC_NAL_UNIT_PPS                    0x3
+#define HEVC_NAL_UNIT_CODED_SLICE_SEGMENT    0x4
+#define HEVC_CODED_SLICE_SEGMENT_DAT         0x5
+#define HEVC_SLICE_DECODING                  0x6
+#define HEVC_NAL_UNIT_SEI                    0x7
+#define HEVC_SLICE_SEGMENT_DONE              0x8
+#define HEVC_NAL_SEARCH_DONE                 0x9
+#define HEVC_DECPIC_DATA_DONE                0xa
+#define HEVC_DECPIC_DATA_ERROR               0xb
+#define HEVC_SEI_DAT                         0xc
+#define HEVC_SEI_DAT_DONE                    0xd
+
+/* RPM misc_flag0 */
+#define PCM_LOOP_FILTER_DISABLED_FLAG_BIT		0
+#define PCM_ENABLE_FLAG_BIT				1
+#define LOOP_FILER_ACROSS_TILES_ENABLED_FLAG_BIT	2
+#define PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT	3
+#define DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT	4
+#define PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT		5
+#define DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT		6
+#define SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT	7
+#define SLICE_SAO_LUMA_FLAG_BIT				8
+#define SLICE_SAO_CHROMA_FLAG_BIT			9
+#define SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT 10
+
+/* Constants for HEVC_MPRED_CTRL1 */
+#define AMVP_MAX_NUM_CANDS_MEM	3
+#define AMVP_MAX_NUM_CANDS	2
+#define NUM_CHROMA_MODE		5
+#define DM_CHROMA_IDX		36
+
+/* Buffer sizes */
+#define SIZE_WORKSPACE ALIGN(LMEM_OFFSET + LMEM_SIZE, 64 * SZ_1K)
+#define SIZE_AUX (SZ_1K * 16)
+#define SIZE_FRAME_MMU (0x1200 * 4)
+#define RPM_SIZE 0x80
+#define RPS_USED_BIT 14
+
+/* Data received from the HW in this form, do not rearrange */
+union rpm_param {
+	struct {
+		u16 data[RPM_SIZE];
+	} l;
+	struct {
+		u16 CUR_RPS[MAX_REF_ACTIVE];
+		u16 num_ref_idx_l0_active;
+		u16 num_ref_idx_l1_active;
+		u16 slice_type;
+		u16 slice_temporal_mvp_enable_flag;
+		u16 dependent_slice_segment_flag;
+		u16 slice_segment_address;
+		u16 num_title_rows_minus1;
+		u16 pic_width_in_luma_samples;
+		u16 pic_height_in_luma_samples;
+		u16 log2_min_coding_block_size_minus3;
+		u16 log2_diff_max_min_coding_block_size;
+		u16 log2_max_pic_order_cnt_lsb_minus4;
+		u16 POClsb;
+		u16 collocated_from_l0_flag;
+		u16 collocated_ref_idx;
+		u16 log2_parallel_merge_level;
+		u16 five_minus_max_num_merge_cand;
+		u16 sps_num_reorder_pics_0;
+		u16 modification_flag;
+		u16 tiles_flags;
+		u16 num_tile_columns_minus1;
+		u16 num_tile_rows_minus1;
+		u16 tile_width[8];
+		u16 tile_height[8];
+		u16 misc_flag0;
+		u16 pps_beta_offset_div2;
+		u16 pps_tc_offset_div2;
+		u16 slice_beta_offset_div2;
+		u16 slice_tc_offset_div2;
+		u16 pps_cb_qp_offset;
+		u16 pps_cr_qp_offset;
+		u16 first_slice_segment_in_pic_flag;
+		u16 m_temporalId;
+		u16 m_nalUnitType;
+		u16 vui_num_units_in_tick_hi;
+		u16 vui_num_units_in_tick_lo;
+		u16 vui_time_scale_hi;
+		u16 vui_time_scale_lo;
+		u16 bit_depth;
+		u16 profile_etc;
+		u16 sei_frame_field_info;
+		u16 video_signal_type;
+		u16 modification_list[0x20];
+		u16 conformance_window_flag;
+		u16 conf_win_left_offset;
+		u16 conf_win_right_offset;
+		u16 conf_win_top_offset;
+		u16 conf_win_bottom_offset;
+		u16 chroma_format_idc;
+		u16 color_description;
+		u16 aspect_ratio_idc;
+		u16 sar_width;
+		u16 sar_height;
+	} p;
+};
+
+enum nal_unit_type {
+	NAL_UNIT_CODED_SLICE_BLA	= 16,
+	NAL_UNIT_CODED_SLICE_BLANT	= 17,
+	NAL_UNIT_CODED_SLICE_BLA_N_LP	= 18,
+	NAL_UNIT_CODED_SLICE_IDR	= 19,
+	NAL_UNIT_CODED_SLICE_IDR_N_LP	= 20,
+};
+
+enum slice_type {
+	B_SLICE = 0,
+	P_SLICE = 1,
+	I_SLICE = 2,
+};
+
+/* A frame being decoded */
+struct hevc_frame {
+	struct list_head list;
+	struct vb2_v4l2_buffer *vbuf;
+	u32 offset;
+	u32 poc;
+
+	int referenced;
+	u32 num_reorder_pic;
+
+	u32 cur_slice_idx;
+	u32 cur_slice_type;
+
+	/* 2 lists (L0/L1) ; 800 slices ; 16 refs */
+	u32 ref_poc_list[2][MAX_SLICE_NUM][MAX_REF_ACTIVE];
+	u32 ref_num[2];
+};
+
+struct codec_hevc {
+	struct mutex lock;
+
+	/* Common part of the HEVC decoder */
+	struct codec_hevc_common common;
+
+	/* Buffer for the HEVC Workspace */
+	void      *workspace_vaddr;
+	dma_addr_t workspace_paddr;
+
+	/* AUX buffer */
+	void      *aux_vaddr;
+	dma_addr_t aux_paddr;
+
+	/* Contains many information parsed from the bitstream */
+	union rpm_param rpm_param;
+
+	/* Information computed from the RPM */
+	u32 lcu_size; // Largest Coding Unit
+	u32 lcu_x_num;
+	u32 lcu_y_num;
+	u32 lcu_total;
+
+	/* Current Frame being handled */
+	struct hevc_frame *cur_frame;
+	u32 curr_poc;
+	/* Collocated Reference Picture */
+	struct hevc_frame *col_frame;
+	u32 col_poc;
+
+	/* All ref frames used by the HW at a given time */
+	struct list_head ref_frames_list;
+	u32 frames_num;
+
+	/* Coded resolution reported by the hardware */
+	u32 width, height;
+	/* Resolution minus the conformance window offsets */
+	u32 dst_width, dst_height;
+
+	u32 prev_tid0_poc;
+	u32 slice_segment_addr;
+	u32 slice_addr;
+	u32 ldc_flag;
+
+	/* Whether we detected the bitstream as 10-bit */
+	int is_10bit;
+};
+
+static u32 codec_hevc_num_pending_bufs(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc;
+	u32 ret;
+
+	hevc = sess->priv;
+	if (!hevc)
+		return 0;
+
+	mutex_lock(&hevc->lock);
+	ret = hevc->frames_num;
+	mutex_unlock(&hevc->lock);
+
+	return ret;
+}
+
+/* Update the L0 and L1 reference lists for a given frame */
+static void codec_hevc_update_frame_refs(struct amvdec_session *sess,
+					 struct hevc_frame *frame)
+{
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *params = &hevc->rpm_param;
+	int num_ref_idx_l0_active =
+		(params->p.num_ref_idx_l0_active > MAX_REF_ACTIVE) ?
+		MAX_REF_ACTIVE : params->p.num_ref_idx_l0_active;
+	int num_ref_idx_l1_active =
+		(params->p.num_ref_idx_l1_active > MAX_REF_ACTIVE) ?
+		MAX_REF_ACTIVE : params->p.num_ref_idx_l1_active;
+	int ref_picset0[MAX_REF_ACTIVE] = { 0 };
+	int ref_picset1[MAX_REF_ACTIVE] = { 0 };
+	u16 *mod_list = params->p.modification_list;
+	int num_neg = 0;
+	int num_pos = 0;
+	int total_num;
+	int i;
+
+	for (i = 0; i < MAX_REF_ACTIVE; i++) {
+		frame->ref_poc_list[0][frame->cur_slice_idx][i] = 0;
+		frame->ref_poc_list[1][frame->cur_slice_idx][i] = 0;
+	}
+
+	for (i = 0; i < MAX_REF_ACTIVE; i++) {
+		u16 cur_rps = params->p.CUR_RPS[i];
+		int delt = cur_rps & ((1 << (RPS_USED_BIT - 1)) - 1);
+
+		if (cur_rps & 0x8000)
+			break;
+
+		if (!((cur_rps >> RPS_USED_BIT) & 1))
+			continue;
+
+		if ((cur_rps >> (RPS_USED_BIT - 1)) & 1) {
+			ref_picset0[num_neg] =
+			       frame->poc - ((1 << (RPS_USED_BIT - 1)) - delt);
+			num_neg++;
+		} else {
+			ref_picset1[num_pos] = frame->poc + delt;
+			num_pos++;
+		}
+	}
+
+	total_num = num_neg + num_pos;
+
+	if (total_num <= 0)
+		goto end;
+
+	for (i = 0; i < num_ref_idx_l0_active; i++) {
+		int cidx;
+		if (params->p.modification_flag & 0x1)
+			cidx = mod_list[i];
+		else
+			cidx = i % total_num;
+
+		frame->ref_poc_list[0][frame->cur_slice_idx][i] =
+			cidx >= num_neg ? ref_picset1[cidx - num_neg] :
+			ref_picset0[cidx];
+	}
+
+	if (params->p.slice_type != B_SLICE)
+		goto end;
+
+	if (params->p.modification_flag & 0x2) {
+		for (i = 0; i < num_ref_idx_l1_active; i++) {
+			int cidx;
+			if (params->p.modification_flag & 0x1)
+				cidx = mod_list[num_ref_idx_l0_active + i];
+			else
+				cidx = mod_list[i];
+
+			frame->ref_poc_list[1][frame->cur_slice_idx][i] =
+				(cidx >= num_pos) ? ref_picset0[cidx - num_pos]
+				: ref_picset1[cidx];
+		}
+	} else {
+		for (i = 0; i < num_ref_idx_l1_active; i++) {
+			int cidx = i % total_num;
+			frame->ref_poc_list[1][frame->cur_slice_idx][i] =
+				cidx >= num_pos ? ref_picset0[cidx - num_pos] :
+				ref_picset1[cidx];
+		}
+	}
+
+end:
+	frame->ref_num[0] = num_ref_idx_l0_active;
+	frame->ref_num[1] = num_ref_idx_l1_active;
+
+	dev_dbg(sess->core->dev,
+		"Frame %u; slice %u; slice_type %u; num_l0 %u; num_l1 %u\n",
+		frame->poc, frame->cur_slice_idx, params->p.slice_type,
+		frame->ref_num[0], frame->ref_num[1]);
+}
+
+static void codec_hevc_update_ldc_flag(struct codec_hevc *hevc)
+{
+	struct hevc_frame *frame = hevc->cur_frame;
+	u32 slice_type = frame->cur_slice_type;
+	u32 slice_idx = frame->cur_slice_idx;
+	int i;
+
+	hevc->ldc_flag = 0;
+
+	if (slice_type == I_SLICE)
+		return;
+
+	hevc->ldc_flag = 1;
+	for (i = 0; (i < frame->ref_num[0]) && hevc->ldc_flag; i++) {
+		if (frame->ref_poc_list[0][slice_idx][i] > frame->poc) {
+			hevc->ldc_flag = 0;
+			break;
+		}
+	}
+
+	if (slice_type == P_SLICE)
+		return;
+
+	for (i = 0; (i < frame->ref_num[1]) && hevc->ldc_flag; i++) {
+		if (frame->ref_poc_list[1][slice_idx][i] > frame->poc) {
+			hevc->ldc_flag = 0;
+			break;
+		}
+	}
+}
+
+/* Tag "old" frames that are no longer referenced */
+static void codec_hevc_update_referenced(struct codec_hevc *hevc)
+{
+	union rpm_param *param = &hevc->rpm_param;
+	struct hevc_frame *frame;
+	int i;
+	u32 curr_poc = hevc->curr_poc;
+
+	list_for_each_entry(frame, &hevc->ref_frames_list, list) {
+		int is_referenced = 0;
+		u32 poc_tmp;
+
+		if (!frame->referenced)
+			continue;
+
+		for (i = 0; i < MAX_REF_ACTIVE; i++) {
+			int delt;
+			if (param->p.CUR_RPS[i] & 0x8000)
+				break;
+
+			delt = param->p.CUR_RPS[i] &
+			       ((1 << (RPS_USED_BIT - 1)) - 1);
+			if (param->p.CUR_RPS[i] & (1 << (RPS_USED_BIT - 1))) {
+				poc_tmp = curr_poc -
+					  ((1 << (RPS_USED_BIT - 1)) - delt);
+			} else
+				poc_tmp = curr_poc + delt;
+			if (poc_tmp == frame->poc) {
+				is_referenced = 1;
+				break;
+			}
+		}
+
+		frame->referenced = is_referenced;
+	}
+}
+
+static struct hevc_frame *
+codec_hevc_get_lowest_poc_frame(struct codec_hevc *hevc)
+{
+	struct hevc_frame *tmp, *ret = NULL;
+	u32 poc = INT_MAX;
+
+	list_for_each_entry(tmp, &hevc->ref_frames_list, list) {
+		if (tmp->poc < poc) {
+			ret = tmp;
+			poc = tmp->poc;
+		}
+	}
+
+	return ret;
+}
+
+/* Try to output as many frames as possible */
+static void codec_hevc_output_frames(struct amvdec_session *sess)
+{
+	struct hevc_frame *tmp;
+	struct codec_hevc *hevc = sess->priv;
+
+	while ((tmp = codec_hevc_get_lowest_poc_frame(hevc))) {
+		if (hevc->curr_poc &&
+		    (tmp->referenced ||
+		     tmp->num_reorder_pic >= hevc->frames_num))
+			break;
+
+		dev_dbg(sess->core->dev, "DONE frame poc %u; vbuf %u\n",
+			tmp->poc, tmp->vbuf->vb2_buf.index);
+		amvdec_dst_buf_done_offset(sess, tmp->vbuf, tmp->offset,
+					   V4L2_FIELD_NONE, false);
+		list_del(&tmp->list);
+		kfree(tmp);
+		hevc->frames_num--;
+	}
+}
+
+
+static int
+codec_hevc_setup_workspace(struct amvdec_session *sess,
+			   struct codec_hevc *hevc)
+{
+	struct amvdec_core *core = sess->core;
+	u32 revision = core->platform->revision;
+	dma_addr_t wkaddr;
+
+	/* Allocate some memory for the HEVC decoder's state */
+	hevc->workspace_vaddr = dma_alloc_coherent(core->dev, SIZE_WORKSPACE,
+						   &wkaddr, GFP_KERNEL);
+	if (!hevc->workspace_vaddr)
+		return -ENOMEM;
+
+	hevc->workspace_paddr = wkaddr;
+
+	amvdec_write_dos(core, HEVCD_IPP_LINEBUFF_BASE, wkaddr + IPP_OFFSET);
+	amvdec_write_dos(core, HEVC_RPM_BUFFER, wkaddr + RPM_OFFSET);
+	amvdec_write_dos(core, HEVC_SHORT_TERM_RPS, wkaddr + SH_TM_RPS_OFFSET);
+	amvdec_write_dos(core, HEVC_VPS_BUFFER, wkaddr + VPS_OFFSET);
+	amvdec_write_dos(core, HEVC_SPS_BUFFER, wkaddr + SPS_OFFSET);
+	amvdec_write_dos(core, HEVC_PPS_BUFFER, wkaddr + PPS_OFFSET);
+	amvdec_write_dos(core, HEVC_SAO_UP, wkaddr + SAO_UP_OFFSET);
+
+	if (codec_hevc_use_mmu(revision, sess->pixfmt_cap, hevc->is_10bit)) {
+		amvdec_write_dos(core, HEVC_SAO_MMU_VH0_ADDR,
+				 wkaddr + MMU_VBH_OFFSET);
+		amvdec_write_dos(core, HEVC_SAO_MMU_VH1_ADDR,
+				 wkaddr + MMU_VBH_OFFSET + (MMU_VBH_SIZE / 2));
+
+		if (revision >= VDEC_REVISION_G12A)
+			amvdec_write_dos(core, HEVC_ASSIST_MMU_MAP_ADDR,
+					 hevc->common.mmu_map_paddr);
+		else
+			amvdec_write_dos(core, H265_MMU_MAP_BUFFER,
+					 hevc->common.mmu_map_paddr);
+	} else if (revision < VDEC_REVISION_G12A) {
+		amvdec_write_dos(core, HEVC_STREAM_SWAP_BUFFER,
+				 wkaddr + SWAP_BUF_OFFSET);
+		amvdec_write_dos(core, HEVC_STREAM_SWAP_BUFFER2,
+				 wkaddr + SWAP_BUF2_OFFSET);
+	}
+
+	amvdec_write_dos(core, HEVC_SCALELUT, wkaddr + SCALELUT_OFFSET);
+	amvdec_write_dos(core, HEVC_DBLK_CFG4, wkaddr + DBLK_PARA_OFFSET);
+	amvdec_write_dos(core, HEVC_DBLK_CFG5, wkaddr + DBLK_DATA_OFFSET);
+	if (revision >= VDEC_REVISION_G12A)
+		amvdec_write_dos(core, HEVC_DBLK_CFGE,
+				 wkaddr + DBLK_DATA2_OFFSET);
+
+	amvdec_write_dos(core, LMEM_DUMP_ADR, wkaddr + LMEM_OFFSET);
+
+	return 0;
+}
+
+static int codec_hevc_start(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc;
+	u32 val;
+	int i;
+	int ret;
+
+	hevc = kzalloc(sizeof(*hevc), GFP_KERNEL);
+	if (!hevc)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&hevc->ref_frames_list);
+	hevc->curr_poc = INVALID_POC;
+
+	ret = codec_hevc_setup_workspace(sess, hevc);
+	if (ret)
+		goto free_hevc;
+
+	val = BIT(0); /* stream_fetch_enable */
+	if (core->platform->revision >= VDEC_REVISION_G12A)
+		val |= (0xf << 25); /* arwlen_axi_max */
+	amvdec_write_dos_bits(core, HEVC_STREAM_CONTROL, val);
+
+	val = amvdec_read_dos(core, HEVC_PARSER_INT_CONTROL) & 0x03ffffff;
+	val |= (3 << 29) | BIT(27) | BIT(24) | BIT(22) | BIT(7) | BIT(4) |
+	       BIT(0);
+	amvdec_write_dos(core, HEVC_PARSER_INT_CONTROL, val);
+	amvdec_write_dos_bits(core, HEVC_SHIFT_STATUS, BIT(1) | BIT(0));
+	amvdec_write_dos(core, HEVC_SHIFT_CONTROL,
+			 (3 << 6) | BIT(5) | BIT(2) | BIT(0));
+	amvdec_write_dos(core, HEVC_CABAC_CONTROL, 1);
+	amvdec_write_dos(core, HEVC_PARSER_CORE_CONTROL, 1);
+	amvdec_write_dos(core, HEVC_DEC_STATUS_REG, 0);
+
+	amvdec_write_dos(core, HEVC_IQIT_SCALELUT_WR_ADDR, 0);
+	for (i = 0; i < 1024; ++i)
+		amvdec_write_dos(core, HEVC_IQIT_SCALELUT_DATA, 0);
+
+	amvdec_write_dos(core, HEVC_DECODE_SIZE, 0);
+
+	amvdec_write_dos(core, HEVC_PARSER_CMD_WRITE, BIT(16));
+	for (i = 0; i < ARRAY_SIZE(vdec_hevc_parser_cmd); ++i)
+		amvdec_write_dos(core, HEVC_PARSER_CMD_WRITE,
+				 vdec_hevc_parser_cmd[i]);
+
+	amvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_0, PARSER_CMD_SKIP_CFG_0);
+	amvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_1, PARSER_CMD_SKIP_CFG_1);
+	amvdec_write_dos(core, HEVC_PARSER_CMD_SKIP_2, PARSER_CMD_SKIP_CFG_2);
+	amvdec_write_dos(core, HEVC_PARSER_IF_CONTROL,
+			 BIT(5) | BIT(2) | BIT(0));
+
+	amvdec_write_dos(core, HEVCD_IPP_TOP_CNTL, BIT(0));
+	amvdec_write_dos(core, HEVCD_IPP_TOP_CNTL, BIT(1));
+
+	amvdec_write_dos(core, HEVC_WAIT_FLAG, 1);
+
+	/* clear mailbox interrupt */
+	amvdec_write_dos(core, HEVC_ASSIST_MBOX1_CLR_REG, 1);
+	/* enable mailbox interrupt */
+	amvdec_write_dos(core, HEVC_ASSIST_MBOX1_MASK, 1);
+	/* disable PSCALE for hardware sharing */
+	amvdec_write_dos(core, HEVC_PSCALE_CTRL, 0);
+	/* Let the uCode do all the parsing */
+	amvdec_write_dos(core, NAL_SEARCH_CTL, 0xc);
+
+	amvdec_write_dos(core, DECODE_STOP_POS, 0);
+	amvdec_write_dos(core, HEVC_DECODE_MODE, DECODE_MODE_SINGLE);
+	amvdec_write_dos(core, HEVC_DECODE_MODE2, 0);
+
+	/* AUX buffers */
+	hevc->aux_vaddr = dma_alloc_coherent(core->dev, SIZE_AUX,
+					     &hevc->aux_paddr, GFP_KERNEL);
+	if (!hevc->aux_vaddr) {
+		dev_err(core->dev, "Failed to request HEVC AUX\n");
+		ret = -ENOMEM;
+		goto free_hevc;
+	}
+
+	amvdec_write_dos(core, HEVC_AUX_ADR, hevc->aux_paddr);
+	amvdec_write_dos(core, HEVC_AUX_DATA_SIZE,
+			 (((SIZE_AUX) >> 4) << 16) | 0);
+	mutex_init(&hevc->lock);
+	sess->priv = hevc;
+
+	return 0;
+
+free_hevc:
+	kfree(hevc);
+	return ret;
+}
+
+static void codec_hevc_flush_output(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct hevc_frame *tmp;
+
+	while (!list_empty(&hevc->ref_frames_list)) {
+		tmp = codec_hevc_get_lowest_poc_frame(hevc);
+		amvdec_dst_buf_done(sess, tmp->vbuf, V4L2_FIELD_NONE);
+		list_del(&tmp->list);
+		kfree(tmp);
+		hevc->frames_num--;
+	}
+}
+
+static int codec_hevc_stop(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct amvdec_core *core = sess->core;
+
+	mutex_lock(&hevc->lock);
+	codec_hevc_flush_output(sess);
+
+	if (hevc->workspace_vaddr)
+		dma_free_coherent(core->dev, SIZE_WORKSPACE,
+				  hevc->workspace_vaddr,
+				  hevc->workspace_paddr);
+
+	if (hevc->aux_vaddr)
+		dma_free_coherent(core->dev, SIZE_AUX,
+				  hevc->aux_vaddr, hevc->aux_paddr);
+
+	codec_hevc_free_fbc_buffers(sess, &hevc->common);
+	mutex_unlock(&hevc->lock);
+	mutex_destroy(&hevc->lock);
+
+	return 0;
+}
+
+static struct hevc_frame *
+codec_hevc_get_frame_by_poc(struct codec_hevc *hevc, u32 poc)
+{
+	struct hevc_frame *tmp;
+
+	list_for_each_entry(tmp, &hevc->ref_frames_list, list) {
+		if (tmp->poc == poc)
+			return tmp;
+	}
+
+	return NULL;
+}
+
+static struct hevc_frame *
+codec_hevc_prepare_new_frame(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct hevc_frame *new_frame = NULL;
+	struct codec_hevc *hevc = sess->priv;
+	struct vb2_v4l2_buffer *vbuf;
+	union rpm_param *params = &hevc->rpm_param;
+
+	new_frame = kzalloc(sizeof(*new_frame), GFP_KERNEL);
+	if (!new_frame)
+		return NULL;
+
+	vbuf = v4l2_m2m_dst_buf_remove(sess->m2m_ctx);
+	if (!vbuf) {
+		dev_err(sess->core->dev, "No dst buffer available\n");
+		return NULL;
+	}
+
+	new_frame->vbuf = vbuf;
+	new_frame->referenced = 1;
+	new_frame->poc = hevc->curr_poc;
+	new_frame->cur_slice_type = params->p.slice_type;
+	new_frame->num_reorder_pic = params->p.sps_num_reorder_pics_0;
+	new_frame->offset = amvdec_read_dos(core, HEVC_SHIFT_BYTE_COUNT);
+
+	list_add_tail(&new_frame->list, &hevc->ref_frames_list);
+	hevc->frames_num++;
+
+	return new_frame;
+}
+
+static void
+codec_hevc_set_sao(struct amvdec_session *sess, struct hevc_frame *frame)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	struct vb2_buffer *vb = &frame->vbuf->vb2_buf;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 pic_height_cu =
+		(hevc->height + hevc->lcu_size - 1) / hevc->lcu_size;
+	u32 sao_mem_unit = (hevc->lcu_size == 16 ? 9 :
+			   hevc->lcu_size == 32 ? 14 : 24) << 4;
+	u32 sao_vb_size = (sao_mem_unit + (2 << 4)) * pic_height_cu;
+	u32 misc_flag0 = param->p.misc_flag0;
+	dma_addr_t buf_y_paddr;
+	dma_addr_t buf_u_v_paddr;
+	u32 slice_deblocking_filter_disabled_flag;
+	u32 val, val_2;
+
+	val = (amvdec_read_dos(core, HEVC_SAO_CTRL0) & ~0xf) |
+	      ilog2(hevc->lcu_size);
+	amvdec_write_dos(core, HEVC_SAO_CTRL0, val);
+
+	amvdec_write_dos(core, HEVC_SAO_PIC_SIZE,
+			 hevc->width | (hevc->height << 16));
+	amvdec_write_dos(core, HEVC_SAO_PIC_SIZE_LCU,
+			 (hevc->lcu_x_num - 1) | (hevc->lcu_y_num - 1) << 16);
+
+	if (codec_hevc_use_downsample(sess->pixfmt_cap, hevc->is_10bit) ||
+	    codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,
+			       hevc->is_10bit))
+		buf_y_paddr =
+		     hevc->common.fbc_buffer_paddr[vb->index];
+	else
+		buf_y_paddr =
+		       vb2_dma_contig_plane_dma_addr(vb, 0);
+
+	if (codec_hevc_use_fbc(sess->pixfmt_cap, hevc->is_10bit)) {
+		val = amvdec_read_dos(core, HEVC_SAO_CTRL5) & ~0xff0000;
+		amvdec_write_dos(core, HEVC_SAO_CTRL5, val);
+		amvdec_write_dos(core, HEVC_CM_BODY_START_ADDR, buf_y_paddr);
+	}
+
+	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
+		buf_y_paddr =
+		       vb2_dma_contig_plane_dma_addr(vb, 0);
+		buf_u_v_paddr =
+		       vb2_dma_contig_plane_dma_addr(vb, 1);
+		amvdec_write_dos(core, HEVC_SAO_Y_START_ADDR, buf_y_paddr);
+		amvdec_write_dos(core, HEVC_SAO_C_START_ADDR, buf_u_v_paddr);
+		amvdec_write_dos(core, HEVC_SAO_Y_WPTR, buf_y_paddr);
+		amvdec_write_dos(core, HEVC_SAO_C_WPTR, buf_u_v_paddr);
+	}
+
+	if (codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,
+			       hevc->is_10bit)) {
+		dma_addr_t header_adr = vb2_dma_contig_plane_dma_addr(vb, 0);
+		if (codec_hevc_use_downsample(sess->pixfmt_cap, hevc->is_10bit))
+			header_adr = hevc->common.mmu_header_paddr[vb->index];
+		amvdec_write_dos(core, HEVC_CM_HEADER_START_ADDR, header_adr);
+		/* use HEVC_CM_HEADER_START_ADDR */
+		amvdec_write_dos_bits(core, HEVC_SAO_CTRL5, BIT(10));
+		amvdec_write_dos_bits(core, HEVC_SAO_CTRL9, BIT(0));
+	}
+
+	amvdec_write_dos(core, HEVC_SAO_Y_LENGTH,
+			 amvdec_get_output_size(sess));
+	amvdec_write_dos(core, HEVC_SAO_C_LENGTH,
+			 (amvdec_get_output_size(sess) / 2));
+
+	if (frame->cur_slice_idx == 0) {
+		if (core->platform->revision >= VDEC_REVISION_G12A) {
+			if (core->platform->revision >= VDEC_REVISION_SM1)
+				val = 0xfc << 8;
+			else
+				val = 0x54 << 8;
+
+			/* enable first, compressed write */
+			if (codec_hevc_use_fbc(sess->pixfmt_cap,
+					       hevc->is_10bit))
+				val |= BIT(8);
+
+			/* enable second, uncompressed write */
+			if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)
+				val |= BIT(9);
+
+			/* dblk pipeline mode=1 for performance */
+			if (hevc->width >= 1280)
+				val |= BIT(4);
+
+			amvdec_write_dos(core, HEVC_DBLK_CFGB, val);
+			amvdec_write_dos(core, HEVC_DBLK_STS1 + 16, BIT(28));
+		}
+
+		amvdec_write_dos(core, HEVC_DBLK_CFG2,
+				 hevc->width | (hevc->height << 16));
+
+		val = 0;
+		if ((misc_flag0 >> PCM_ENABLE_FLAG_BIT) & 0x1)
+			val |= ((misc_flag0 >>
+				 PCM_LOOP_FILTER_DISABLED_FLAG_BIT) & 0x1) << 3;
+
+		val |= (param->p.pps_cb_qp_offset & 0x1f) << 4;
+		val |= (param->p.pps_cr_qp_offset & 0x1f) << 9;
+		val |= (hevc->lcu_size == 64) ? 0 :
+		       ((hevc->lcu_size == 32) ? 1 : 2);
+		amvdec_write_dos(core, HEVC_DBLK_CFG1, val);
+	}
+
+	val = amvdec_read_dos(core, HEVC_SAO_CTRL1) & ~0x3ff3;
+	val |= 0xff0; /* Set endianness for 2-bytes swaps (nv12) */
+	if (core->platform->revision < VDEC_REVISION_G12A) {
+		if (!codec_hevc_use_fbc(sess->pixfmt_cap, hevc->is_10bit))
+			val |= BIT(0); /* disable cm compression */
+		/* TOFIX: Handle Amlogic Framebuffer compression */
+	}
+
+	amvdec_write_dos(core, HEVC_SAO_CTRL1, val);
+
+	if (!codec_hevc_use_fbc(sess->pixfmt_cap, hevc->is_10bit)) {
+		/* no downscale for NV12 */
+		val = amvdec_read_dos(core, HEVC_SAO_CTRL5) & ~0xff0000;
+		amvdec_write_dos(core, HEVC_SAO_CTRL5, val);
+	}
+
+	val = amvdec_read_dos(core, HEVCD_IPP_AXIIF_CONFIG) & ~0x30;
+	val |= 0xf;
+	amvdec_write_dos(core, HEVCD_IPP_AXIIF_CONFIG, val);
+
+	val = 0;
+	val_2 = amvdec_read_dos(core, HEVC_SAO_CTRL0);
+	val_2 &= (~0x300);
+
+	slice_deblocking_filter_disabled_flag = (misc_flag0 >>
+			SLICE_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) & 0x1;
+	if ((misc_flag0 & (1 << DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_BIT))
+		&& (misc_flag0 & (1 << DEBLOCKING_FILTER_OVERRIDE_FLAG_BIT))) {
+		val |= slice_deblocking_filter_disabled_flag << 2;
+
+		if (!slice_deblocking_filter_disabled_flag) {
+			val |= (param->p.slice_beta_offset_div2 & 0xf) << 3;
+			val |= (param->p.slice_tc_offset_div2 & 0xf) << 7;
+		}
+	} else {
+		val |=
+			((misc_flag0 >>
+			  PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) & 0x1) << 2;
+
+		if (((misc_flag0 >> PPS_DEBLOCKING_FILTER_DISABLED_FLAG_BIT) &
+			 0x1) == 0) {
+			val |= (param->p.pps_beta_offset_div2 & 0xf) << 3;
+			val |= (param->p.pps_tc_offset_div2 & 0xf) << 7;
+		}
+	}
+	if ((misc_flag0 & (1 << PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT))
+		&& ((misc_flag0 & (1 << SLICE_SAO_LUMA_FLAG_BIT))
+			|| (misc_flag0 & (1 << SLICE_SAO_CHROMA_FLAG_BIT))
+			|| (!slice_deblocking_filter_disabled_flag))) {
+		val |=
+			((misc_flag0 >>
+			  SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1)	<< 1;
+		val_2 |=
+			((misc_flag0 >>
+			  SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			& 0x1) << 9;
+	} else {
+		val |=
+			((misc_flag0 >>
+			  PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1) << 1;
+		val_2 |=
+			((misc_flag0 >>
+			  PPS_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_BIT)
+			 & 0x1) << 9;
+	}
+
+	amvdec_write_dos(core, HEVC_DBLK_CFG9, val);
+	amvdec_write_dos(core, HEVC_SAO_CTRL0, val_2);
+
+	amvdec_write_dos(core, HEVC_sao_mem_unit, sao_mem_unit);
+	amvdec_write_dos(core, HEVC_SAO_ABV,
+			 hevc->workspace_paddr + SAO_ABV_OFFSET);
+	amvdec_write_dos(core, HEVC_sao_vb_size, sao_vb_size);
+	amvdec_write_dos(core, HEVC_SAO_VB,
+			 hevc->workspace_paddr + SAO_VB_OFFSET);
+}
+
+static dma_addr_t codec_hevc_get_frame_mv_paddr(struct codec_hevc *hevc,
+						struct hevc_frame *frame)
+{
+	return hevc->workspace_paddr + MPRED_MV_OFFSET +
+		(frame->vbuf->vb2_buf.index * MPRED_MV_BUF_SIZE);
+}
+
+static void
+codec_hevc_set_mpred_ctrl(struct amvdec_core *core, struct codec_hevc *hevc)
+{
+	union rpm_param *param = &hevc->rpm_param;
+	u32 slice_type = param->p.slice_type;
+	u32 lcu_size_log2 = ilog2(hevc->lcu_size);
+	u32 val;
+
+	val = slice_type |
+	      MPRED_CTRL0_ABOVE_EN |
+	      MPRED_CTRL0_MV_WR_EN |
+	      MPRED_CTRL0_BUF_LINEAR |
+	      (lcu_size_log2 << 16) |
+	      (3 << 20) | /* cu_size_log2 */
+	      (param->p.log2_parallel_merge_level << 24);
+
+	if (slice_type != I_SLICE)
+		val |= MPRED_CTRL0_MV_RD_EN;
+
+	if (param->p.collocated_from_l0_flag)
+		val |= MPRED_CTRL0_COL_FROM_L0;
+
+	if (param->p.slice_temporal_mvp_enable_flag)
+		val |= MPRED_CTRL0_TMVP;
+
+	if (hevc->ldc_flag)
+		val |= MPRED_CTRL0_LDC;
+
+	if (param->p.dependent_slice_segment_flag)
+		val |= MPRED_CTRL0_NEW_SLI_SEG;
+
+	if (param->p.slice_segment_address == 0)
+		val |= MPRED_CTRL0_NEW_PIC |
+		       MPRED_CTRL0_NEW_TILE;
+
+	amvdec_write_dos(core, HEVC_MPRED_CTRL0, val);
+
+	val = (5 - param->p.five_minus_max_num_merge_cand) |
+	      (AMVP_MAX_NUM_CANDS << 4) |
+	      (AMVP_MAX_NUM_CANDS_MEM << 8) |
+	      (NUM_CHROMA_MODE << 12) |
+	      (DM_CHROMA_IDX << 16);
+	amvdec_write_dos(core, HEVC_MPRED_CTRL1, val);
+}
+
+static void codec_hevc_set_mpred_mv(struct amvdec_core *core,
+				    struct codec_hevc *hevc,
+				    struct hevc_frame *frame,
+				    struct hevc_frame *col_frame)
+{
+	union rpm_param *param = &hevc->rpm_param;
+	u32 lcu_size_log2 = ilog2(hevc->lcu_size);
+	u32 mv_mem_unit = lcu_size_log2 == 6 ? 0x200 :
+			  lcu_size_log2 == 5 ? 0x80 : 0x20;
+	dma_addr_t col_mv_rd_start_addr, col_mv_rd_ptr, col_mv_rd_end_addr;
+	dma_addr_t mpred_mv_wr_ptr;
+	u32 val;
+
+	val = amvdec_read_dos(core, HEVC_MPRED_CURR_LCU);
+
+	col_mv_rd_start_addr = codec_hevc_get_frame_mv_paddr(hevc, col_frame);
+	mpred_mv_wr_ptr = codec_hevc_get_frame_mv_paddr(hevc, frame) +
+			  (hevc->slice_addr * mv_mem_unit);
+	col_mv_rd_ptr = col_mv_rd_start_addr +
+			(hevc->slice_addr * mv_mem_unit);
+	col_mv_rd_end_addr = col_mv_rd_start_addr +
+			     (hevc->lcu_total * mv_mem_unit);
+
+	amvdec_write_dos(core, HEVC_MPRED_MV_WR_START_ADDR,
+			 codec_hevc_get_frame_mv_paddr(hevc, frame));
+	amvdec_write_dos(core, HEVC_MPRED_MV_RD_START_ADDR,
+			 col_mv_rd_start_addr);
+
+	if (param->p.slice_segment_address == 0) {
+		amvdec_write_dos(core, HEVC_MPRED_ABV_START_ADDR,
+				 hevc->workspace_paddr + MPRED_ABV_OFFSET);
+		amvdec_write_dos(core, HEVC_MPRED_MV_WPTR, mpred_mv_wr_ptr);
+		amvdec_write_dos(core, HEVC_MPRED_MV_RPTR,
+				 col_mv_rd_start_addr);
+	} else {
+		amvdec_write_dos(core, HEVC_MPRED_MV_RPTR, col_mv_rd_ptr);
+	}
+
+	amvdec_write_dos(core, HEVC_MPRED_MV_RD_END_ADDR, col_mv_rd_end_addr);
+}
+
+/* Update motion prediction with the current slice */
+static void codec_hevc_set_mpred(struct amvdec_session *sess,
+				 struct hevc_frame *frame,
+				 struct hevc_frame *col_frame)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	u32 *ref_num = frame->ref_num;
+	u32 *ref_poc_l0 = frame->ref_poc_list[0][frame->cur_slice_idx];
+	u32 *ref_poc_l1 = frame->ref_poc_list[1][frame->cur_slice_idx];
+	u32 val;
+	int i;
+
+	codec_hevc_set_mpred_ctrl(core, hevc);
+	codec_hevc_set_mpred_mv(core, hevc, frame, col_frame);
+
+	amvdec_write_dos(core, HEVC_MPRED_PIC_SIZE,
+			 hevc->width | (hevc->height << 16));
+
+	val = ((hevc->lcu_x_num - 1) | (hevc->lcu_y_num - 1) << 16);
+	amvdec_write_dos(core, HEVC_MPRED_PIC_SIZE_LCU, val);
+
+	amvdec_write_dos(core, HEVC_MPRED_REF_NUM,
+			 (ref_num[1] << 8) | ref_num[0]);
+	amvdec_write_dos(core, HEVC_MPRED_REF_EN_L0, (1 << ref_num[0]) - 1);
+	amvdec_write_dos(core, HEVC_MPRED_REF_EN_L1, (1 << ref_num[1]) - 1);
+
+	amvdec_write_dos(core, HEVC_MPRED_CUR_POC, hevc->curr_poc);
+	amvdec_write_dos(core, HEVC_MPRED_COL_POC, hevc->col_poc);
+
+	for (i = 0; i < MAX_REF_ACTIVE; ++i) {
+		amvdec_write_dos(core, HEVC_MPRED_L0_REF00_POC + i * 4,
+				 ref_poc_l0[i]);
+		amvdec_write_dos(core, HEVC_MPRED_L1_REF00_POC + i * 4,
+				 ref_poc_l1[i]);
+	}
+}
+
+/*  motion compensation reference cache controller */
+static void codec_hevc_set_mcrcc(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	u32 val, val_2;
+	int l0_cnt = 0;
+	int l1_cnt = 0x7fff;
+
+	if (!codec_hevc_use_fbc(sess->pixfmt_cap, hevc->is_10bit)) {
+		l0_cnt = hevc->cur_frame->ref_num[0];
+		l1_cnt = hevc->cur_frame->ref_num[1];
+	}
+
+	if (hevc->cur_frame->cur_slice_type == I_SLICE) {
+		amvdec_write_dos(core, HEVCD_MCRCC_CTL1, 0);
+		return;
+	}
+
+	if (hevc->cur_frame->cur_slice_type == P_SLICE) {
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+				 BIT(1));
+		val = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		val &= 0xffff;
+		val |= (val << 16);
+		amvdec_write_dos(core, HEVCD_MCRCC_CTL2, val);
+
+		if (l0_cnt == 1) {
+			amvdec_write_dos(core, HEVCD_MCRCC_CTL3, val);
+		} else {
+			val = amvdec_read_dos(core,
+					      HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+			val &= 0xffff;
+			val |= (val << 16);
+			amvdec_write_dos(core, HEVCD_MCRCC_CTL3, val);
+		}
+	} else { /* B_SLICE */
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 0);
+		val = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		val &= 0xffff;
+		val |= (val << 16);
+		amvdec_write_dos(core, HEVCD_MCRCC_CTL2, val);
+
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+				 BIT(12) | BIT(1));
+		val_2 = amvdec_read_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+		val_2 &= 0xffff;
+		val_2 |= (val_2 << 16);
+		if (val == val_2 && l1_cnt > 1) {
+			val_2 = amvdec_read_dos(core,
+						HEVCD_MPP_ANC_CANVAS_DATA_ADDR);
+			val_2 &= 0xffff;
+			val_2 |= (val_2 << 16);
+		}
+		amvdec_write_dos(core, HEVCD_MCRCC_CTL3, val);
+	}
+
+	/* enable mcrcc progressive-mode */
+	amvdec_write_dos(core, HEVCD_MCRCC_CTL1, 0xff0);
+}
+
+static void codec_hevc_set_ref_list(struct amvdec_session *sess,
+				u32 ref_num, u32 *ref_poc_list)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct hevc_frame *ref_frame;
+	struct amvdec_core *core = sess->core;
+	int i;
+	u32 buf_id_y;
+	u32 buf_id_uv;
+
+	for (i = 0; i < ref_num; i++) {
+		ref_frame = codec_hevc_get_frame_by_poc(hevc, ref_poc_list[i]);
+
+		if (!ref_frame) {
+			dev_warn(core->dev, "Couldn't find ref. frame %u\n",
+				ref_poc_list[i]);
+			continue;
+		}
+
+		if (codec_hevc_use_fbc(sess->pixfmt_cap, hevc->is_10bit)) {
+			buf_id_y = buf_id_uv = ref_frame->vbuf->vb2_buf.index;
+		} else {
+			buf_id_y = ref_frame->vbuf->vb2_buf.index * 2;
+			buf_id_uv = buf_id_y + 1;
+		}
+
+		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR,
+				 (buf_id_uv << 16) |
+				 (buf_id_uv << 8) |
+				 buf_id_y);
+	}
+}
+
+static void codec_hevc_set_mc(struct amvdec_session *sess,
+			      struct hevc_frame *frame)
+{
+	struct amvdec_core *core = sess->core;
+
+	if (frame->cur_slice_type == I_SLICE)
+		return;
+
+	amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR, 1);
+	codec_hevc_set_ref_list(sess, frame->ref_num[0],
+		frame->ref_poc_list[0][frame->cur_slice_idx]);
+
+	if (frame->cur_slice_type == P_SLICE)
+		return;
+
+	amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_ACCCONFIG_ADDR,
+			 BIT(12) | BIT(0));
+	codec_hevc_set_ref_list(sess, frame->ref_num[1],
+		frame->ref_poc_list[1][frame->cur_slice_idx]);
+}
+
+static void codec_hevc_update_col_frame(struct codec_hevc *hevc)
+{
+	struct hevc_frame *cur_frame = hevc->cur_frame;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 list_no = 0;
+	u32 col_ref = param->p.collocated_ref_idx;
+	u32 col_from_l0 = param->p.collocated_from_l0_flag;
+	u32 cur_slice_idx = cur_frame->cur_slice_idx;
+
+	if (cur_frame->cur_slice_type == B_SLICE)
+		list_no = 1 - col_from_l0;
+
+	if (col_ref >= cur_frame->ref_num[list_no])
+		hevc->col_poc = INVALID_POC;
+	else
+		hevc->col_poc = cur_frame->ref_poc_list[list_no]
+						       [cur_slice_idx]
+						       [col_ref];
+
+	if (cur_frame->cur_slice_type == I_SLICE)
+		goto end;
+
+	if (hevc->col_poc != INVALID_POC)
+		hevc->col_frame = codec_hevc_get_frame_by_poc(hevc,
+							      hevc->col_poc);
+	else
+		hevc->col_frame = hevc->cur_frame;
+
+end:
+	if (!hevc->col_frame)
+		hevc->col_frame = hevc->cur_frame;
+}
+
+static void codec_hevc_update_pocs(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 nal_unit_type = param->p.m_nalUnitType;
+	u32 temporal_id = param->p.m_temporalId & 0x7;
+	int max_poc_lsb =
+		1 << (param->p.log2_max_pic_order_cnt_lsb_minus4 + 4);
+	int prev_poc_lsb;
+	int prev_poc_msb;
+	int poc_msb;
+	int poc_lsb = param->p.POClsb;
+
+	if (nal_unit_type == NAL_UNIT_CODED_SLICE_IDR ||
+	    nal_unit_type == NAL_UNIT_CODED_SLICE_IDR_N_LP) {
+		hevc->curr_poc = 0;
+		if ((temporal_id - 1) == 0)
+			hevc->prev_tid0_poc = hevc->curr_poc;
+
+		return;
+	}
+
+	prev_poc_lsb = hevc->prev_tid0_poc % max_poc_lsb;
+	prev_poc_msb = hevc->prev_tid0_poc - prev_poc_lsb;
+
+	if ((poc_lsb < prev_poc_lsb) &&
+	    ((prev_poc_lsb - poc_lsb) >= (max_poc_lsb / 2)))
+		poc_msb = prev_poc_msb + max_poc_lsb;
+	else if ((poc_lsb > prev_poc_lsb) &&
+		 ((poc_lsb - prev_poc_lsb) > (max_poc_lsb / 2)))
+		poc_msb = prev_poc_msb - max_poc_lsb;
+	else
+		poc_msb = prev_poc_msb;
+
+	if (nal_unit_type == NAL_UNIT_CODED_SLICE_BLA   ||
+	    nal_unit_type == NAL_UNIT_CODED_SLICE_BLANT ||
+	    nal_unit_type == NAL_UNIT_CODED_SLICE_BLA_N_LP)
+		poc_msb = 0;
+
+	hevc->curr_poc = (poc_msb + poc_lsb);
+	if ((temporal_id - 1) == 0)
+		hevc->prev_tid0_poc = hevc->curr_poc;
+}
+
+static void codec_hevc_process_segment_header(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	union rpm_param *param = &hevc->rpm_param;
+
+	if (param->p.first_slice_segment_in_pic_flag == 0) {
+		hevc->slice_segment_addr = param->p.slice_segment_address;
+		if (!param->p.dependent_slice_segment_flag)
+			hevc->slice_addr = hevc->slice_segment_addr;
+	} else {
+		hevc->slice_segment_addr = 0;
+		hevc->slice_addr = 0;
+	}
+
+	codec_hevc_update_pocs(sess);
+}
+
+static int codec_hevc_process_segment(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	struct amvdec_core *core = sess->core;
+	union rpm_param *param = &hevc->rpm_param;
+	u32 slice_segment_address = param->p.slice_segment_address;
+
+	/* First slice: new frame */
+	if (slice_segment_address == 0) {
+		codec_hevc_update_referenced(hevc);
+		codec_hevc_output_frames(sess);
+
+		hevc->cur_frame = codec_hevc_prepare_new_frame(sess);
+		if (!hevc->cur_frame)
+			return -1;
+	} else {
+		hevc->cur_frame->cur_slice_idx++;
+	}
+
+	codec_hevc_update_frame_refs(sess, hevc->cur_frame);
+	codec_hevc_update_col_frame(hevc);
+	codec_hevc_update_ldc_flag(hevc);
+	if (codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,
+			       hevc->is_10bit))
+		codec_hevc_fill_mmu_map(sess, &hevc->common,
+					&hevc->cur_frame->vbuf->vb2_buf,
+					hevc->is_10bit);
+	codec_hevc_set_mc(sess, hevc->cur_frame);
+	codec_hevc_set_mcrcc(sess);
+	codec_hevc_set_mpred(sess, hevc->cur_frame, hevc->col_frame);
+	codec_hevc_set_sao(sess, hevc->cur_frame);
+
+	amvdec_write_dos_bits(core, HEVC_WAIT_FLAG, BIT(1));
+	amvdec_write_dos(core, HEVC_DEC_STATUS_REG,
+			 HEVC_CODED_SLICE_SEGMENT_DAT);
+
+	/* Interrupt the firmware's processor */
+	amvdec_write_dos(core, HEVC_MCPU_INTR_REQ, AMRISC_MAIN_REQ);
+
+	return 0;
+}
+
+static int codec_hevc_process_rpm(struct codec_hevc *hevc)
+{
+	union rpm_param *param = &hevc->rpm_param;
+	int src_changed = 0;
+	u32 dst_width, dst_height;
+	u32 lcu_size;
+	u32 is_10bit = 0;
+
+	if (param->p.slice_segment_address	||
+	    !param->p.pic_width_in_luma_samples	||
+	    !param->p.pic_height_in_luma_samples)
+		return 0;
+
+	if (param->p.bit_depth)
+		is_10bit = 1;
+
+	hevc->width = param->p.pic_width_in_luma_samples;
+	hevc->height = param->p.pic_height_in_luma_samples;
+	dst_width = hevc->width;
+	dst_height = hevc->height;
+
+	lcu_size = 1 << (param->p.log2_min_coding_block_size_minus3 +
+		   3 + param->p.log2_diff_max_min_coding_block_size);
+
+	hevc->lcu_x_num = (hevc->width + lcu_size - 1) / lcu_size;
+	hevc->lcu_y_num = (hevc->height + lcu_size - 1) / lcu_size;
+	hevc->lcu_total = hevc->lcu_x_num * hevc->lcu_y_num;
+
+	if (param->p.conformance_window_flag) {
+		u32 sub_width = 1, sub_height = 1;
+
+		switch (param->p.chroma_format_idc) {
+		case 1:
+			sub_height = 2; /* fallthrough */
+		case 2:
+			sub_width = 2;
+			break;
+		}
+
+		dst_width -= sub_width *
+			     (param->p.conf_win_left_offset +
+			      param->p.conf_win_right_offset);
+		dst_height -= sub_height *
+			      (param->p.conf_win_top_offset +
+			       param->p.conf_win_bottom_offset);
+	}
+
+	if (dst_width != hevc->dst_width ||
+	    dst_height != hevc->dst_height ||
+	    lcu_size != hevc->lcu_size ||
+	    is_10bit != hevc->is_10bit)
+		src_changed = 1;
+
+	hevc->dst_width = dst_width;
+	hevc->dst_height = dst_height;
+	hevc->lcu_size = lcu_size;
+	hevc->is_10bit = is_10bit;
+
+	return src_changed;
+}
+
+/*
+ * The RPM section within the workspace contains
+ * many information regarding the parsed bitstream
+ */
+static void codec_hevc_fetch_rpm(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+	u16 *rpm_vaddr = hevc->workspace_vaddr + RPM_OFFSET;
+	int i, j;
+
+	for (i = 0; i < RPM_SIZE; i += 4)
+		for (j = 0; j < 4; j++)
+			hevc->rpm_param.l.data[i + j] = rpm_vaddr[i + 3 - j];
+}
+
+static void codec_hevc_resume(struct amvdec_session *sess)
+{
+	struct codec_hevc *hevc = sess->priv;
+
+	if (codec_hevc_setup_buffers(sess, &hevc->common, hevc->is_10bit)) {
+		amvdec_abort(sess);
+		return;
+	}
+
+	codec_hevc_setup_decode_head(sess, hevc->is_10bit);
+	codec_hevc_process_segment_header(sess);
+	if (codec_hevc_process_segment(sess))
+		amvdec_abort(sess);
+}
+
+static irqreturn_t codec_hevc_threaded_isr(struct amvdec_session *sess)
+{
+	struct amvdec_core *core = sess->core;
+	struct codec_hevc *hevc = sess->priv;
+	u32 dec_status = amvdec_read_dos(core, HEVC_DEC_STATUS_REG);
+
+	if (!hevc)
+		return IRQ_HANDLED;
+
+	mutex_lock(&hevc->lock);
+	if (dec_status != HEVC_SLICE_SEGMENT_DONE) {
+		dev_err(core->dev_dec, "Unrecognized dec_status: %08X\n",
+			dec_status);
+		amvdec_abort(sess);
+		goto unlock;
+	}
+
+	sess->keyframe_found = 1;
+	codec_hevc_fetch_rpm(sess);
+	if (codec_hevc_process_rpm(hevc)) {
+		amvdec_src_change(sess, hevc->dst_width, hevc->dst_height, 16,
+				  hevc->is_10bit ? 10 : 8);
+		goto unlock;
+	}
+
+	codec_hevc_process_segment_header(sess);
+	if (codec_hevc_process_segment(sess))
+		amvdec_abort(sess);
+
+unlock:
+	mutex_unlock(&hevc->lock);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t codec_hevc_isr(struct amvdec_session *sess)
+{
+	return IRQ_WAKE_THREAD;
+}
+
+struct amvdec_codec_ops codec_hevc_ops = {
+	.start = codec_hevc_start,
+	.stop = codec_hevc_stop,
+	.isr = codec_hevc_isr,
+	.threaded_isr = codec_hevc_threaded_isr,
+	.num_pending_bufs = codec_hevc_num_pending_bufs,
+	.drain = codec_hevc_flush_output,
+	.resume = codec_hevc_resume,
+};
diff -Naur a/drivers/staging/media/meson/vdec/codec_hevc_common.c b/drivers/staging/media/meson/vdec/codec_hevc_common.c
--- a/drivers/staging/media/meson/vdec/codec_hevc_common.c	2022-05-27 17:20:17.521925890 +0800
+++ b/drivers/staging/media/meson/vdec/codec_hevc_common.c	2022-05-31 11:56:48.081256256 +0800
@@ -30,8 +30,11 @@
 void codec_hevc_setup_decode_head(struct amvdec_session *sess, int is_10bit)
 {
 	struct amvdec_core *core = sess->core;
-	u32 body_size = amvdec_am21c_body_size(sess->width, sess->height);
-	u32 head_size = amvdec_am21c_head_size(sess->width, sess->height);
+	u32 use_mmu = codec_hevc_use_mmu(core->platform->revision,
+					 sess->pixfmt_cap, is_10bit);
+	u32 body_size = amvdec_amfbc_body_size(sess->width, sess->height,
+					       is_10bit, use_mmu);
+	u32 head_size = amvdec_amfbc_head_size(sess->width, sess->height);
 
 	if (!codec_hevc_use_fbc(sess->pixfmt_cap, is_10bit)) {
 		/* Enable 2-plane reference read mode */
@@ -39,9 +42,17 @@
 		return;
 	}
 
+	/* enable mem saving mode for 8-bit */
+	if (!is_10bit)
+		amvdec_write_dos_bits(core, HEVC_SAO_CTRL5, BIT(9));
+	else
+		amvdec_clear_dos_bits(core, HEVC_SAO_CTRL5, BIT(9));
+
 	if (codec_hevc_use_mmu(core->platform->revision,
 			       sess->pixfmt_cap, is_10bit))
 		amvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL1, BIT(4));
+	else if (!is_10bit)
+		amvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL1, BIT(3));
 	else
 		amvdec_write_dos(core, HEVCD_MPP_DECOMP_CTL1, 0);
 
@@ -73,7 +84,7 @@
 
 		idx = vb->index;
 
-		if (codec_hevc_use_downsample(sess->pixfmt_cap, is_10bit))
+		if (codec_hevc_use_fbc(sess->pixfmt_cap, is_10bit))
 			buf_y_paddr = comm->fbc_buffer_paddr[idx];
 		else
 			buf_y_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);
@@ -114,8 +125,8 @@
 {
 	struct amvdec_core *core = sess->core;
 	struct v4l2_m2m_buffer *buf;
-	u32 revision = core->platform->revision;
 	u32 pixfmt_cap = sess->pixfmt_cap;
+	const u32 revision = core->platform->revision;
 	int i;
 
 	amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_CONF_ADDR,
@@ -127,12 +138,14 @@
 		dma_addr_t buf_uv_paddr = 0;
 		u32 idx = vb->index;
 
-		if (codec_hevc_use_mmu(revision, pixfmt_cap, is_10bit))
-			buf_y_paddr = comm->mmu_header_paddr[idx];
-		else if (codec_hevc_use_downsample(pixfmt_cap, is_10bit))
-			buf_y_paddr = comm->fbc_buffer_paddr[idx];
-		else
+		if (codec_hevc_use_downsample(pixfmt_cap, is_10bit)) {
+			if (codec_hevc_use_mmu(revision, pixfmt_cap, is_10bit))
+				buf_y_paddr = comm->mmu_header_paddr[idx];
+			else
+				buf_y_paddr = comm->fbc_buffer_paddr[idx];
+		} else {
 			buf_y_paddr = vb2_dma_contig_plane_dma_addr(vb, 0);
+		}
 
 		amvdec_write_dos(core, HEVCD_MPP_ANC2AXI_TBL_DATA,
 				 buf_y_paddr >> 5);
@@ -150,60 +163,64 @@
 		amvdec_write_dos(core, HEVCD_MPP_ANC_CANVAS_DATA_ADDR, 0);
 }
 
-void codec_hevc_free_fbc_buffers(struct amvdec_session *sess,
+void codec_hevc_free_mmu_headers(struct amvdec_session *sess,
 				 struct codec_hevc_common *comm)
 {
 	struct device *dev = sess->core->dev;
-	u32 am21_size = amvdec_am21c_size(sess->width, sess->height);
 	int i;
 
 	for (i = 0; i < MAX_REF_PIC_NUM; ++i) {
-		if (comm->fbc_buffer_vaddr[i]) {
-			dma_free_coherent(dev, am21_size,
-					  comm->fbc_buffer_vaddr[i],
-					  comm->fbc_buffer_paddr[i]);
-			comm->fbc_buffer_vaddr[i] = NULL;
+		if (comm->mmu_header_vaddr[i]) {
+			dma_free_coherent(dev, MMU_COMPRESS_HEADER_SIZE,
+					  comm->mmu_header_vaddr[i],
+					  comm->mmu_header_paddr[i]);
+			comm->mmu_header_vaddr[i] = NULL;
 		}
 	}
 }
-EXPORT_SYMBOL_GPL(codec_hevc_free_fbc_buffers);
+EXPORT_SYMBOL_GPL(codec_hevc_free_mmu_headers);
 
-static int codec_hevc_alloc_fbc_buffers(struct amvdec_session *sess,
+static int codec_hevc_alloc_mmu_headers(struct amvdec_session *sess,
 					struct codec_hevc_common *comm)
 {
 	struct device *dev = sess->core->dev;
 	struct v4l2_m2m_buffer *buf;
-	u32 am21_size = amvdec_am21c_size(sess->width, sess->height);
 
 	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
 		u32 idx = buf->vb.vb2_buf.index;
 		dma_addr_t paddr;
-		void *vaddr = dma_alloc_coherent(dev, am21_size, &paddr,
-						 GFP_KERNEL);
+		void *vaddr = dma_alloc_coherent(dev, MMU_COMPRESS_HEADER_SIZE,
+						 &paddr, GFP_KERNEL);
 		if (!vaddr) {
-			codec_hevc_free_fbc_buffers(sess, comm);
+			codec_hevc_free_mmu_headers(sess, comm);
 			return -ENOMEM;
 		}
 
-		comm->fbc_buffer_vaddr[idx] = vaddr;
-		comm->fbc_buffer_paddr[idx] = paddr;
+		comm->mmu_header_vaddr[idx] = vaddr;
+		comm->mmu_header_paddr[idx] = paddr;
 	}
 
 	return 0;
 }
 
-void codec_hevc_free_mmu_headers(struct amvdec_session *sess,
+void codec_hevc_free_fbc_buffers(struct amvdec_session *sess,
 				 struct codec_hevc_common *comm)
 {
 	struct device *dev = sess->core->dev;
+	u32 use_mmu = codec_hevc_use_mmu(sess->core->platform->revision,
+					 sess->pixfmt_cap,
+					 sess->bitdepth == 10 ? 1 : 0);
+	u32 am21_size = amvdec_amfbc_size(sess->width, sess->height,
+					  sess->bitdepth == 10 ? 1 : 0,
+					  use_mmu);
 	int i;
 
 	for (i = 0; i < MAX_REF_PIC_NUM; ++i) {
-		if (comm->mmu_header_vaddr[i]) {
-			dma_free_coherent(dev, MMU_COMPRESS_HEADER_SIZE,
-					  comm->mmu_header_vaddr[i],
-					  comm->mmu_header_paddr[i]);
-			comm->mmu_header_vaddr[i] = NULL;
+		if (comm->fbc_buffer_vaddr[i]) {
+			dma_free_coherent(dev, am21_size,
+					  comm->fbc_buffer_vaddr[i],
+					  comm->fbc_buffer_paddr[i]);
+			comm->fbc_buffer_vaddr[i] = NULL;
 		}
 	}
 
@@ -213,33 +230,47 @@
 				  comm->mmu_map_paddr);
 		comm->mmu_map_vaddr = NULL;
 	}
+
+	codec_hevc_free_mmu_headers(sess, comm);
 }
-EXPORT_SYMBOL_GPL(codec_hevc_free_mmu_headers);
+EXPORT_SYMBOL_GPL(codec_hevc_free_fbc_buffers);
 
-static int codec_hevc_alloc_mmu_headers(struct amvdec_session *sess,
+static int codec_hevc_alloc_fbc_buffers(struct amvdec_session *sess,
 					struct codec_hevc_common *comm)
 {
 	struct device *dev = sess->core->dev;
 	struct v4l2_m2m_buffer *buf;
+	const u32 revision = sess->core->platform->revision;
+	const u32 is_10bit = sess->bitdepth == 10 ? 1 : 0;
+	u32 use_mmu = codec_hevc_use_mmu(revision, sess->pixfmt_cap,
+					 is_10bit);
+	u32 am21_size = amvdec_amfbc_size(sess->width, sess->height,
+					  is_10bit,
+					  use_mmu);
 
-	comm->mmu_map_vaddr = dma_alloc_coherent(dev, MMU_MAP_SIZE,
-						 &comm->mmu_map_paddr,
-						 GFP_KERNEL);
-	if (!comm->mmu_map_vaddr)
-		return -ENOMEM;
+	int ret;
 
 	v4l2_m2m_for_each_dst_buf(sess->m2m_ctx, buf) {
 		u32 idx = buf->vb.vb2_buf.index;
 		dma_addr_t paddr;
-		void *vaddr = dma_alloc_coherent(dev, MMU_COMPRESS_HEADER_SIZE,
-						 &paddr, GFP_KERNEL);
+		void *vaddr = dma_alloc_coherent(dev, am21_size, &paddr,
+						 GFP_KERNEL);
 		if (!vaddr) {
-			codec_hevc_free_mmu_headers(sess, comm);
+			codec_hevc_free_fbc_buffers(sess, comm);
 			return -ENOMEM;
 		}
 
-		comm->mmu_header_vaddr[idx] = vaddr;
-		comm->mmu_header_paddr[idx] = paddr;
+		comm->fbc_buffer_vaddr[idx] = vaddr;
+		comm->fbc_buffer_paddr[idx] = paddr;
+	}
+
+	if (codec_hevc_use_mmu(revision, sess->pixfmt_cap, is_10bit) &&
+	    codec_hevc_use_downsample(sess->pixfmt_cap, is_10bit)) {
+		ret = codec_hevc_alloc_mmu_headers(sess, comm);
+		if (ret) {
+			codec_hevc_free_fbc_buffers(sess, comm);
+			return ret;
+		}
 	}
 
 	return 0;
@@ -250,21 +281,24 @@
 			     int is_10bit)
 {
 	struct amvdec_core *core = sess->core;
+	struct device *dev = core->dev;
 	int ret;
 
-	if (codec_hevc_use_downsample(sess->pixfmt_cap, is_10bit)) {
-		ret = codec_hevc_alloc_fbc_buffers(sess, comm);
-		if (ret)
-			return ret;
+	if (codec_hevc_use_mmu(core->platform->revision,
+			       sess->pixfmt_cap, is_10bit)) {
+		comm->mmu_map_vaddr = dma_alloc_coherent(dev, MMU_MAP_SIZE,
+							 &comm->mmu_map_paddr,
+							 GFP_KERNEL);
+		if (!comm->mmu_map_vaddr)
+			return -ENOMEM;
 	}
 
 	if (codec_hevc_use_mmu(core->platform->revision,
-			       sess->pixfmt_cap, is_10bit)) {
-		ret = codec_hevc_alloc_mmu_headers(sess, comm);
-		if (ret) {
-			codec_hevc_free_fbc_buffers(sess, comm);
+			       sess->pixfmt_cap, is_10bit) ||
+	    codec_hevc_use_downsample(sess->pixfmt_cap, is_10bit)) {
+		ret = codec_hevc_alloc_fbc_buffers(sess, comm);
+		if (ret)
 			return ret;
-		}
 	}
 
 	if (core->platform->revision == VDEC_REVISION_GXBB)
@@ -278,19 +312,19 @@
 
 void codec_hevc_fill_mmu_map(struct amvdec_session *sess,
 			     struct codec_hevc_common *comm,
-			     struct vb2_buffer *vb)
+			     struct vb2_buffer *vb,
+			     u32 is_10bit)
 {
-	u32 size = amvdec_am21c_size(sess->width, sess->height);
+	u32 use_mmu = codec_hevc_use_mmu(sess->core->platform->revision,
+					 sess->pixfmt_cap, is_10bit);
+	u32 size = amvdec_amfbc_size(sess->width, sess->height, is_10bit,
+				     use_mmu);
 	u32 nb_pages = size / PAGE_SIZE;
 	u32 *mmu_map = comm->mmu_map_vaddr;
 	u32 first_page;
 	u32 i;
 
-	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M)
-		first_page = comm->fbc_buffer_paddr[vb->index] >> PAGE_SHIFT;
-	else
-		first_page = vb2_dma_contig_plane_dma_addr(vb, 0) >> PAGE_SHIFT;
-
+	first_page = comm->fbc_buffer_paddr[vb->index] >> PAGE_SHIFT;
 	for (i = 0; i < nb_pages; ++i)
 		mmu_map[i] = first_page + i;
 }
diff -Naur a/drivers/staging/media/meson/vdec/codec_hevc_common.h b/drivers/staging/media/meson/vdec/codec_hevc_common.h
--- a/drivers/staging/media/meson/vdec/codec_hevc_common.h	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/codec_hevc_common.h	2022-05-31 11:56:48.081256256 +0800
@@ -66,6 +66,7 @@
 
 void codec_hevc_fill_mmu_map(struct amvdec_session *sess,
 			     struct codec_hevc_common *comm,
-			     struct vb2_buffer *vb);
+			     struct vb2_buffer *vb,
+			     u32 is_10bit);
 
 #endif
diff -Naur a/drivers/staging/media/meson/vdec/codec_hevc.h b/drivers/staging/media/meson/vdec/codec_hevc.h
--- a/drivers/staging/media/meson/vdec/codec_hevc.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/staging/media/meson/vdec/codec_hevc.h	2022-05-31 11:56:48.081256256 +0800
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2018 Maxime Jourdan <maxi.jourdan@wanadoo.fr>
+ */
+
+#ifndef __MESON_VDEC_CODEC_HEVC_H_
+#define __MESON_VDEC_CODEC_HEVC_H_
+
+#include "vdec.h"
+
+extern struct amvdec_codec_ops codec_hevc_ops;
+
+#endif
diff -Naur a/drivers/staging/media/meson/vdec/codec_vp9.c b/drivers/staging/media/meson/vdec/codec_vp9.c
--- a/drivers/staging/media/meson/vdec/codec_vp9.c	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/codec_vp9.c	2022-05-31 11:56:48.081256256 +0800
@@ -458,12 +458,6 @@
 	struct list_head ref_frames_list;
 	u32 frames_num;
 
-	/* In case of downsampling (decoding with FBC but outputting in NV12M),
-	 * we need to allocate additional buffers for FBC.
-	 */
-	void      *fbc_buffer_vaddr[MAX_REF_PIC_NUM];
-	dma_addr_t fbc_buffer_paddr[MAX_REF_PIC_NUM];
-
 	int ref_frame_map[REF_FRAMES];
 	int next_ref_frame_map[REF_FRAMES];
 	struct vp9_frame *frame_refs[REFS_PER_FRAME];
@@ -901,11 +895,8 @@
 		buf_y_paddr =
 		       vb2_dma_contig_plane_dma_addr(vb, 0);
 
-	if (codec_hevc_use_fbc(sess->pixfmt_cap, vp9->is_10bit)) {
-		val = amvdec_read_dos(core, HEVC_SAO_CTRL5) & ~0xff0200;
-		amvdec_write_dos(core, HEVC_SAO_CTRL5, val);
+	if (codec_hevc_use_fbc(sess->pixfmt_cap, vp9->is_10bit))
 		amvdec_write_dos(core, HEVC_CM_BODY_START_ADDR, buf_y_paddr);
-	}
 
 	if (sess->pixfmt_cap == V4L2_PIX_FMT_NV12M) {
 		buf_y_paddr =
@@ -920,8 +911,12 @@
 
 	if (codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,
 			       vp9->is_10bit)) {
-		amvdec_write_dos(core, HEVC_CM_HEADER_START_ADDR,
-				 vp9->common.mmu_header_paddr[vb->index]);
+		dma_addr_t header_adr;
+		if (codec_hevc_use_downsample(sess->pixfmt_cap, vp9->is_10bit))
+			header_adr = vp9->common.mmu_header_paddr[vb->index];
+		else
+			header_adr = vb2_dma_contig_plane_dma_addr(vb, 0);
+		amvdec_write_dos(core, HEVC_CM_HEADER_START_ADDR, header_adr);
 		/* use HEVC_CM_HEADER_START_ADDR */
 		amvdec_write_dos_bits(core, HEVC_SAO_CTRL5, BIT(10));
 	}
@@ -1147,6 +1142,8 @@
 			     struct codec_vp9 *vp9)
 {
 	struct amvdec_core *core = sess->core;
+	u32 use_mmu = codec_hevc_use_mmu(core->platform->revision,
+					 sess->pixfmt_cap, vp9->is_10bit);
 	u32 scale = 0;
 	u32 sz;
 	int i;
@@ -1166,8 +1163,9 @@
 		    vp9->frame_refs[i]->height != vp9->height)
 			scale = 1;
 
-		sz = amvdec_am21c_body_size(vp9->frame_refs[i]->width,
-					    vp9->frame_refs[i]->height);
+		sz = amvdec_amfbc_body_size(vp9->frame_refs[i]->width,
+					    vp9->frame_refs[i]->height,
+					    vp9->is_10bit, use_mmu);
 
 		amvdec_write_dos(core, VP9D_MPP_REFINFO_DATA,
 				 vp9->frame_refs[i]->width);
@@ -1283,7 +1281,8 @@
 	if (codec_hevc_use_mmu(core->platform->revision, sess->pixfmt_cap,
 			       vp9->is_10bit))
 		codec_hevc_fill_mmu_map(sess, &vp9->common,
-					&vp9->cur_frame->vbuf->vb2_buf);
+					&vp9->cur_frame->vbuf->vb2_buf,
+					vp9->is_10bit);
 
 	intra_only = param->p.show_frame ? 0 : param->p.intra_only;
 
@@ -2132,7 +2131,8 @@
 
 	codec_vp9_fetch_rpm(sess);
 	if (codec_vp9_process_rpm(vp9)) {
-		amvdec_src_change(sess, vp9->width, vp9->height, 16);
+		amvdec_src_change(sess, vp9->width, vp9->height, 16,
+				  vp9->is_10bit ? 10 : 8);
 
 		/* No frame is actually processed */
 		vp9->cur_frame = NULL;
diff -Naur a/drivers/staging/media/meson/vdec/esparser.c b/drivers/staging/media/meson/vdec/esparser.c
--- a/drivers/staging/media/meson/vdec/esparser.c	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/esparser.c	2022-05-31 11:56:48.081256256 +0800
@@ -309,12 +309,12 @@
 	 * they could pause when there is no capture buffer available and
 	 * resume on this notification.
 	 */
-	if (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9) {
+	if (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9 || sess->fmt_out->pixfmt ==V4L2_PIX_FMT_HEVC) {
 		if (codec_ops->num_pending_bufs)
 			num_dst_bufs = codec_ops->num_pending_bufs(sess);
 
 		num_dst_bufs += v4l2_m2m_num_dst_bufs_ready(sess->m2m_ctx);
-		if (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9)
+		if (sess->fmt_out->pixfmt == V4L2_PIX_FMT_VP9 || sess->fmt_out->pixfmt ==V4L2_PIX_FMT_HEVC)
 			num_dst_bufs -= 3;
 
 		if (esparser_vififo_get_free_space(sess) < payload_size ||
diff -Naur a/drivers/staging/media/meson/vdec/hevc_regs.h b/drivers/staging/media/meson/vdec/hevc_regs.h
--- a/drivers/staging/media/meson/vdec/hevc_regs.h	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/hevc_regs.h	2022-05-31 11:56:48.081256256 +0800
@@ -205,6 +205,7 @@
 #define HEVC_CM_HEADER_START_ADDR 0xd8a0
 #define HEVC_CM_HEADER_LENGTH 0xd8a4
 #define HEVC_CM_HEADER_OFFSET 0xd8ac
+#define HEVC_SAO_CTRL9 0xd8b4
 #define HEVC_SAO_MMU_VH0_ADDR 0xd8e8
 #define HEVC_SAO_MMU_VH1_ADDR 0xd8ec
 
diff -Naur a/drivers/staging/media/meson/vdec/Makefile b/drivers/staging/media/meson/vdec/Makefile
--- a/drivers/staging/media/meson/vdec/Makefile	2022-05-27 17:20:17.521925890 +0800
+++ b/drivers/staging/media/meson/vdec/Makefile	2022-05-31 11:56:48.081256256 +0800
@@ -3,6 +3,6 @@
 
 meson-vdec-objs = esparser.o vdec.o vdec_helpers.o vdec_platform.o
 meson-vdec-objs += vdec_1.o vdec_hevc.o
-meson-vdec-objs += codec_mpeg12.o codec_h264.o codec_hevc_common.o codec_vp9.o
+meson-vdec-objs += codec_mpeg12.o codec_h264.o codec_hevc_common.o codec_hevc.o codec_vp9.o
 
 obj-$(CONFIG_VIDEO_MESON_VDEC) += meson-vdec.o
diff -Naur a/drivers/staging/media/meson/vdec/vdec.c b/drivers/staging/media/meson/vdec/vdec.c
--- a/drivers/staging/media/meson/vdec/vdec.c	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/vdec.c	2022-05-31 11:56:48.085256221 +0800
@@ -1131,6 +1131,6 @@
 };
 module_platform_driver(meson_vdec_driver);
 
-MODULE_DESCRIPTION("Meson video decoder driver for GXBB/GXL/GXM");
+MODULE_DESCRIPTION("Meson video decoder driver for GXBB/GXL/GXM/G12/SM1");
 MODULE_AUTHOR("Maxime Jourdan <mjourdan@baylibre.com>");
 MODULE_LICENSE("GPL");
diff -Naur a/drivers/staging/media/meson/vdec/vdec.h b/drivers/staging/media/meson/vdec/vdec.h
--- a/drivers/staging/media/meson/vdec/vdec.h	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/vdec.h	2022-05-31 11:56:48.085256221 +0800
@@ -234,6 +234,7 @@
 	u32 width;
 	u32 height;
 	u32 colorspace;
+	u32 bitdepth;
 	u8 ycbcr_enc;
 	u8 quantization;
 	u8 xfer_func;
diff -Naur a/drivers/staging/media/meson/vdec/vdec_helpers.c b/drivers/staging/media/meson/vdec/vdec_helpers.c
--- a/drivers/staging/media/meson/vdec/vdec_helpers.c	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/vdec_helpers.c	2022-05-31 11:56:48.085256221 +0800
@@ -50,32 +50,40 @@
 }
 EXPORT_SYMBOL_GPL(amvdec_write_parser);
 
-/* 4 KiB per 64x32 block */
-u32 amvdec_am21c_body_size(u32 width, u32 height)
+/* AMFBC body is made out of 64x32 blocks with varying block size */
+u32 amvdec_amfbc_body_size(u32 width, u32 height, u32 is_10bit, u32 use_mmu)
 {
 	u32 width_64 = ALIGN(width, 64) / 64;
 	u32 height_32 = ALIGN(height, 32) / 32;
+	u32 blk_size = 4096;
 
-	return SZ_4K * width_64 * height_32;
+	if (!is_10bit) {
+		if (use_mmu)
+			blk_size = 3200;
+		else
+			blk_size = 3072;
+	}
+
+	return blk_size * width_64 * height_32;
 }
-EXPORT_SYMBOL_GPL(amvdec_am21c_body_size);
+EXPORT_SYMBOL_GPL(amvdec_amfbc_body_size);
 
 /* 32 bytes per 128x64 block */
-u32 amvdec_am21c_head_size(u32 width, u32 height)
+u32 amvdec_amfbc_head_size(u32 width, u32 height)
 {
 	u32 width_128 = ALIGN(width, 128) / 128;
 	u32 height_64 = ALIGN(height, 64) / 64;
 
 	return 32 * width_128 * height_64;
 }
-EXPORT_SYMBOL_GPL(amvdec_am21c_head_size);
+EXPORT_SYMBOL_GPL(amvdec_amfbc_head_size);
 
-u32 amvdec_am21c_size(u32 width, u32 height)
+u32 amvdec_amfbc_size(u32 width, u32 height, u32 is_10bit, u32 use_mmu)
 {
-	return ALIGN(amvdec_am21c_body_size(width, height) +
-		     amvdec_am21c_head_size(width, height), SZ_64K);
+	return ALIGN(amvdec_amfbc_body_size(width, height, is_10bit, use_mmu) +
+		     amvdec_amfbc_head_size(width, height), SZ_64K);
 }
-EXPORT_SYMBOL_GPL(amvdec_am21c_size);
+EXPORT_SYMBOL_GPL(amvdec_amfbc_size);
 
 static int canvas_alloc(struct amvdec_session *sess, u8 *canvas_id)
 {
@@ -436,7 +444,7 @@
 EXPORT_SYMBOL_GPL(amvdec_set_par_from_dar);
 
 void amvdec_src_change(struct amvdec_session *sess, u32 width,
-		       u32 height, u32 dpb_size)
+		       u32 height, u32 dpb_size, u32 bitdepth)
 {
 	static const struct v4l2_event ev = {
 		.type = V4L2_EVENT_SOURCE_CHANGE,
@@ -444,25 +452,27 @@
 
 	v4l2_ctrl_s_ctrl(sess->ctrl_min_buf_capture, dpb_size);
 
+	sess->bitdepth = bitdepth;
+
 	/*
 	 * Check if the capture queue is already configured well for our
-	 * usecase. If so, keep decoding with it and do not send the event
+	 * usecase. If so, keep decoding with it.
 	 */
 	if (sess->streamon_cap &&
 	    sess->width == width &&
 	    sess->height == height &&
 	    dpb_size <= sess->num_dst_bufs) {
 		sess->fmt_out->codec_ops->resume(sess);
-		return;
+	} else {
+		sess->status = STATUS_NEEDS_RESUME;
+		sess->changed_format = 0;
 	}
 
-	sess->changed_format = 0;
 	sess->width = width;
 	sess->height = height;
-	sess->status = STATUS_NEEDS_RESUME;
 
-	dev_dbg(sess->core->dev, "Res. changed (%ux%u), DPB size %u\n",
-		width, height, dpb_size);
+	dev_dbg(sess->core->dev, "Res. changed (%ux%u), DPB %u, bitdepth %u\n",
+		width, height, dpb_size, bitdepth);
 	v4l2_event_queue_fh(&sess->fh, &ev);
 }
 EXPORT_SYMBOL_GPL(amvdec_src_change);
diff -Naur a/drivers/staging/media/meson/vdec/vdec_helpers.h b/drivers/staging/media/meson/vdec/vdec_helpers.h
--- a/drivers/staging/media/meson/vdec/vdec_helpers.h	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/vdec_helpers.h	2022-05-31 11:56:48.085256221 +0800
@@ -27,9 +27,10 @@
 u32 amvdec_read_parser(struct amvdec_core *core, u32 reg);
 void amvdec_write_parser(struct amvdec_core *core, u32 reg, u32 val);
 
-u32 amvdec_am21c_body_size(u32 width, u32 height);
-u32 amvdec_am21c_head_size(u32 width, u32 height);
-u32 amvdec_am21c_size(u32 width, u32 height);
+/* Helpers for the Amlogic compressed framebuffer format */
+u32 amvdec_amfbc_body_size(u32 width, u32 height, u32 is_10bit, u32 use_mmu);
+u32 amvdec_amfbc_head_size(u32 width, u32 height);
+u32 amvdec_amfbc_size(u32 width, u32 height, u32 is_10bit, u32 use_mmu);
 
 /**
  * amvdec_dst_buf_done_idx() - Signal that a buffer is done decoding
@@ -76,9 +77,10 @@
  * @width: picture width detected by the hardware
  * @height: picture height detected by the hardware
  * @dpb_size: Decoded Picture Buffer size (= amount of buffers for decoding)
+ * @bitdepth: Bit depth (usually 10 or 8) of the coded content
  */
 void amvdec_src_change(struct amvdec_session *sess, u32 width,
-		       u32 height, u32 dpb_size);
+		       u32 height, u32 dpb_size, u32 bitdepth);
 
 /**
  * amvdec_abort() - Abort the current decoding session
diff -Naur a/drivers/staging/media/meson/vdec/vdec_platform.c b/drivers/staging/media/meson/vdec/vdec_platform.c
--- a/drivers/staging/media/meson/vdec/vdec_platform.c	2022-05-27 17:20:17.525925941 +0800
+++ b/drivers/staging/media/meson/vdec/vdec_platform.c	2022-05-31 11:56:48.085256221 +0800
@@ -11,6 +11,7 @@
 #include "vdec_hevc.h"
 #include "codec_mpeg12.h"
 #include "codec_h264.h"
+#include "codec_hevc.h"
 #include "codec_vp9.h"
 
 static const struct amvdec_format vdec_formats_gxbb[] = {
@@ -65,6 +66,18 @@
 		.flags = V4L2_FMT_FLAG_COMPRESSED |
 			 V4L2_FMT_FLAG_DYN_RESOLUTION,
 	}, {
+		.pixfmt = V4L2_PIX_FMT_HEVC,
+		.min_buffers = 4,
+		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
+		.vdec_ops = &vdec_hevc_ops,
+		.codec_ops = &codec_hevc_ops,
+		.firmware_path = "meson/vdec/gxl_hevc.bin",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
+		.flags = V4L2_FMT_FLAG_COMPRESSED |
+			 V4L2_FMT_FLAG_DYN_RESOLUTION,
+	}, {
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.min_buffers = 2,
 		.max_buffers = 24,
@@ -115,6 +128,18 @@
 		.flags = V4L2_FMT_FLAG_COMPRESSED |
 			 V4L2_FMT_FLAG_DYN_RESOLUTION,
 	}, {
+		.pixfmt = V4L2_PIX_FMT_HEVC,
+		.min_buffers = 4,
+		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
+		.vdec_ops = &vdec_hevc_ops,
+		.codec_ops = &codec_hevc_ops,
+		.firmware_path = "meson/vdec/gxl_hevc.bin",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
+		.flags = V4L2_FMT_FLAG_COMPRESSED |
+			 V4L2_FMT_FLAG_DYN_RESOLUTION,
+	}, {
 		.pixfmt = V4L2_PIX_FMT_MPEG1,
 		.min_buffers = 8,
 		.max_buffers = 8,
@@ -153,6 +178,18 @@
 		.flags = V4L2_FMT_FLAG_COMPRESSED |
 			 V4L2_FMT_FLAG_DYN_RESOLUTION,
 	}, {
+		.pixfmt = V4L2_PIX_FMT_HEVC,
+		.min_buffers = 4,
+		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
+		.vdec_ops = &vdec_hevc_ops,
+		.codec_ops = &codec_hevc_ops,
+		.firmware_path = "meson/vdec/g12a_hevc_mmu.bin",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
+		.flags = V4L2_FMT_FLAG_COMPRESSED |
+			 V4L2_FMT_FLAG_DYN_RESOLUTION,
+	},{
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.min_buffers = 2,
 		.max_buffers = 24,
@@ -202,6 +239,18 @@
 		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
 		.flags = V4L2_FMT_FLAG_COMPRESSED |
 			 V4L2_FMT_FLAG_DYN_RESOLUTION,
+	}, {
+		.pixfmt = V4L2_PIX_FMT_HEVC,
+		.min_buffers = 4,
+		.max_buffers = 24,
+		.max_width = 3840,
+		.max_height = 2160,
+		.vdec_ops = &vdec_hevc_ops,
+		.codec_ops = &codec_hevc_ops,
+		.firmware_path = "meson/vdec/sm1_hevc_mmu.bin",
+		.pixfmts_cap = { V4L2_PIX_FMT_NV12M, 0 },
+		.flags = V4L2_FMT_FLAG_COMPRESSED |
+			 V4L2_FMT_FLAG_DYN_RESOLUTION,
 	}, {
 		.pixfmt = V4L2_PIX_FMT_H264,
 		.min_buffers = 2,
diff -Naur a/drivers/thermal/amlogic_thermal.c b/drivers/thermal/amlogic_thermal.c
--- a/drivers/thermal/amlogic_thermal.c	2022-05-27 17:20:17.609927025 +0800
+++ b/drivers/thermal/amlogic_thermal.c	2022-05-31 11:56:48.085256221 +0800
@@ -29,6 +29,7 @@
 #include <linux/thermal.h>
 
 #include "thermal_core.h"
+#include "thermal_hwmon.h"
 
 #define TSENSOR_CFG_REG1			0x4
 	#define TSENSOR_CFG_REG1_RSET_VBG	BIT(12)
@@ -291,6 +292,9 @@
 	if (ret)
 		return ret;
 
+	if (devm_thermal_add_hwmon_sysfs(pdata->tzd))
+		dev_warn(&pdev->dev, "failed to add hwmon sysfs attributes\n");
+
 	ret = amlogic_thermal_enable(pdata);
 
 	return ret;
diff -Naur a/drivers/tty/serial/meson_uart.c b/drivers/tty/serial/meson_uart.c
--- a/drivers/tty/serial/meson_uart.c	2022-05-27 17:20:17.641927438 +0800
+++ b/drivers/tty/serial/meson_uart.c	2022-05-31 11:56:48.085256200 +0800
@@ -2,15 +2,19 @@
 /*
  *  Based on meson_uart.c, by AMLOGIC, INC.
  *
- * Copyright (C) 2014 Carlo Caione <carlo@caione.org>
+ * Copyright (C) 2019 Amlogic, Inc. All rights reserved.
  */
+#define SKIP_IO_TRACE
+
+#if defined(CONFIG_SERIAL_MESON_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
 
 #include <linux/clk.h>
 #include <linux/console.h>
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/io.h>
-#include <linux/iopoll.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/of.h>
@@ -19,6 +23,7 @@
 #include <linux/serial_core.h>
 #include <linux/tty.h>
 #include <linux/tty_flip.h>
+#include <linux/pinctrl/consumer.h>
 
 /* Register offsets */
 #define AML_UART_WFIFO			0x00
@@ -31,15 +36,9 @@
 /* AML_UART_CONTROL bits */
 #define AML_UART_TX_EN			BIT(12)
 #define AML_UART_RX_EN			BIT(13)
-#define AML_UART_TWO_WIRE_EN		BIT(15)
-#define AML_UART_STOP_BIT_LEN_MASK	(0x03 << 16)
-#define AML_UART_STOP_BIT_1SB		(0x00 << 16)
-#define AML_UART_STOP_BIT_2SB		(0x01 << 16)
-#define AML_UART_PARITY_TYPE		BIT(18)
-#define AML_UART_PARITY_EN		BIT(19)
 #define AML_UART_TX_RST			BIT(22)
 #define AML_UART_RX_RST			BIT(23)
-#define AML_UART_CLEAR_ERR		BIT(24)
+#define AML_UART_CLR_ERR		BIT(24)
 #define AML_UART_RX_INT_EN		BIT(27)
 #define AML_UART_TX_INT_EN		BIT(28)
 #define AML_UART_DATA_LEN_MASK		(0x03 << 20)
@@ -55,10 +54,20 @@
 #define AML_UART_RX_EMPTY		BIT(20)
 #define AML_UART_TX_FULL		BIT(21)
 #define AML_UART_TX_EMPTY		BIT(22)
-#define AML_UART_XMIT_BUSY		BIT(25)
+#define AML_UART_RX_FIFO_OVERFLOW	BIT(24)
 #define AML_UART_ERR			(AML_UART_PARITY_ERR | \
 					 AML_UART_FRAME_ERR  | \
-					 AML_UART_TX_FIFO_WERR)
+					 AML_UART_RX_FIFO_OVERFLOW)
+
+/* AML_UART_CONTROL bits */
+#define AML_UART_TWO_WIRE_EN		BIT(15)
+#define AML_UART_PARITY_TYPE		BIT(18)
+#define AML_UART_PARITY_EN		BIT(19)
+#define AML_UART_CLEAR_ERR		BIT(24)
+#define AML_UART_STOP_BIN_LEN_MASK	(0x03 << 16)
+#define AML_UART_STOP_BIN_1SB		(0x00 << 16)
+#define AML_UART_STOP_BIN_2SB		(0x01 << 16)
+#define UART_CTS_EN		(0x01 << 31)
 
 /* AML_UART_MISC bits */
 #define AML_UART_XMIT_IRQ(c)		(((c) & 0xff) << 8)
@@ -68,17 +77,28 @@
 #define AML_UART_BAUD_MASK		0x7fffff
 #define AML_UART_BAUD_USE		BIT(23)
 #define AML_UART_BAUD_XTAL		BIT(24)
+#define AML_UART_BAUD_XTAL_TICK	BIT(26)
+#define AML_UART_BAUD_XTAL_DIV2	BIT(27)
 
-#define AML_UART_PORT_NUM		12
+#define AML_UART_PORT_MAX		12
 #define AML_UART_PORT_OFFSET		6
-#define AML_UART_DEV_NAME		"ttyAML"
 
-#define AML_UART_POLL_USEC		5
-#define AML_UART_TIMEOUT_USEC		10000
+#define AML_UART_DEV_NAME		"ttyS"
 
 static struct uart_driver meson_uart_driver;
+static int support_sysrq;
+unsigned int xtal_tick_en;
 
-static struct uart_port *meson_ports[AML_UART_PORT_NUM];
+struct meson_uart_port {
+	struct uart_port	port;
+	spinlock_t wr_lock;
+	unsigned long baud;
+	struct pinctrl *p;
+};
+
+static struct meson_uart_port *meson_ports[AML_UART_PORT_MAX];
+
+#define to_meson_port(uport)  container_of(uport, struct meson_uart_port, port)
 
 static void meson_uart_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
@@ -93,27 +113,27 @@
 {
 	u32 val;
 
-	val = readl(port->membase + AML_UART_STATUS);
-	val &= (AML_UART_TX_EMPTY | AML_UART_XMIT_BUSY);
-	return (val == AML_UART_TX_EMPTY) ? TIOCSER_TEMT : 0;
+	val = readl_relaxed(port->membase + AML_UART_STATUS);
+	return (val & AML_UART_TX_EMPTY) ? TIOCSER_TEMT : 0;
 }
 
 static void meson_uart_stop_tx(struct uart_port *port)
 {
 	u32 val;
-
-	val = readl(port->membase + AML_UART_CONTROL);
-	val &= ~AML_UART_TX_INT_EN;
-	writel(val, port->membase + AML_UART_CONTROL);
+	if (port->line == 0)
+		return;
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
+	val &= ~AML_UART_TX_EN;
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
 }
 
 static void meson_uart_stop_rx(struct uart_port *port)
 {
 	u32 val;
 
-	val = readl(port->membase + AML_UART_CONTROL);
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
 	val &= ~AML_UART_RX_EN;
-	writel(val, port->membase + AML_UART_CONTROL);
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
 }
 
 static void meson_uart_shutdown(struct uart_port *port)
@@ -121,14 +141,16 @@
 	unsigned long flags;
 	u32 val;
 
-	free_irq(port->irq, port);
+	if (port->line == 0)
+		return;
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	val = readl(port->membase + AML_UART_CONTROL);
-	val &= ~AML_UART_RX_EN;
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
+	val &= ~(AML_UART_RX_EN | AML_UART_TX_EN);
 	val &= ~(AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);
-	writel(val, port->membase + AML_UART_CONTROL);
+	val |= UART_CTS_EN;
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
 
 	spin_unlock_irqrestore(&port->lock, flags);
 }
@@ -137,115 +159,147 @@
 {
 	struct circ_buf *xmit = &port->state->xmit;
 	unsigned int ch;
-	u32 val;
-
-	if (uart_tx_stopped(port)) {
-		meson_uart_stop_tx(port);
-		return;
-	}
-
-	while (!(readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL)) {
-		if (port->x_char) {
-			writel(port->x_char, port->membase + AML_UART_WFIFO);
-			port->icount.tx++;
-			port->x_char = 0;
-			continue;
-		}
+	struct meson_uart_port *mup = to_meson_port(port);
+	unsigned long flags;
 
-		if (uart_circ_empty(xmit))
+	spin_lock_irqsave(&mup->wr_lock, flags);
+	while (!uart_circ_empty(xmit)) {
+		if (readl_relaxed(port->membase + AML_UART_STATUS)
+			& AML_UART_TX_FULL)
 			break;
 
 		ch = xmit->buf[xmit->tail];
-		writel(ch, port->membase + AML_UART_WFIFO);
-		xmit->tail = (xmit->tail+1) & (SERIAL_XMIT_SIZE - 1);
+		writel_relaxed(ch, port->membase + AML_UART_WFIFO);
+		xmit->tail = (xmit->tail + 1) & (SERIAL_XMIT_SIZE - 1);
 		port->icount.tx++;
 	}
+	spin_unlock_irqrestore(&mup->wr_lock, flags);
+}
+
+static void meson_transmit_chars(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	struct meson_uart_port *mup = to_meson_port(port);
+	unsigned int ch;
+	int count = 256;
 
-	if (!uart_circ_empty(xmit)) {
-		val = readl(port->membase + AML_UART_CONTROL);
-		val |= AML_UART_TX_INT_EN;
-		writel(val, port->membase + AML_UART_CONTROL);
+	spin_lock(&port->lock);
+	if (port->x_char) {
+		writel_relaxed(port->x_char, port->membase + AML_UART_WFIFO);
+		port->icount.tx++;
+		port->x_char = 0;
+		goto clear_and_return;
 	}
 
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port))
+		goto clear_and_return;
+
+	spin_lock(&mup->wr_lock);
+	while (!uart_circ_empty(xmit) && count-- > 0) {
+		if (readl_relaxed(port->membase + AML_UART_STATUS)
+			& AML_UART_TX_FULL)
+			break;
+		ch = xmit->buf[xmit->tail];
+		writel_relaxed(ch, port->membase + AML_UART_WFIFO);
+		xmit->tail = (xmit->tail + 1) & (SERIAL_XMIT_SIZE - 1);
+		port->icount.tx++;
+	}
+	spin_unlock(&mup->wr_lock);
+
 	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
 		uart_write_wakeup(port);
+
+ clear_and_return:
+	spin_unlock(&port->lock);
+	return;
+
 }
 
 static void meson_receive_chars(struct uart_port *port)
 {
 	struct tty_port *tport = &port->state->port;
 	char flag;
-	u32 ostatus, status, ch, mode;
+	u32 status, ch, mode;
 
+	spin_lock(&port->lock);
 	do {
 		flag = TTY_NORMAL;
 		port->icount.rx++;
-		ostatus = status = readl(port->membase + AML_UART_STATUS);
+		status = readl_relaxed(port->membase + AML_UART_STATUS);
 
 		if (status & AML_UART_ERR) {
-			if (status & AML_UART_TX_FIFO_WERR)
+			if (status & AML_UART_RX_FIFO_OVERFLOW)
 				port->icount.overrun++;
 			else if (status & AML_UART_FRAME_ERR)
 				port->icount.frame++;
 			else if (status & AML_UART_PARITY_ERR)
 				port->icount.frame++;
 
-			mode = readl(port->membase + AML_UART_CONTROL);
+			mode = readl_relaxed(port->membase + AML_UART_CONTROL);
 			mode |= AML_UART_CLEAR_ERR;
-			writel(mode, port->membase + AML_UART_CONTROL);
+			writel_relaxed(mode, port->membase + AML_UART_CONTROL);
 
 			/* It doesn't clear to 0 automatically */
 			mode &= ~AML_UART_CLEAR_ERR;
-			writel(mode, port->membase + AML_UART_CONTROL);
+			writel_relaxed(mode, port->membase + AML_UART_CONTROL);
 
 			status &= port->read_status_mask;
-			if (status & AML_UART_FRAME_ERR)
+			if (status & (AML_UART_FRAME_ERR |
+				AML_UART_RX_FIFO_OVERFLOW))
 				flag = TTY_FRAME;
 			else if (status & AML_UART_PARITY_ERR)
 				flag = TTY_PARITY;
 		}
 
-		ch = readl(port->membase + AML_UART_RFIFO);
+		ch = readl_relaxed(port->membase + AML_UART_RFIFO);
 		ch &= 0xff;
 
-		if ((ostatus & AML_UART_FRAME_ERR) && (ch == 0)) {
-			port->icount.brk++;
-			flag = TTY_BREAK;
-			if (uart_handle_break(port))
-				continue;
-		}
-
-		if (uart_handle_sysrq_char(port, ch))
-			continue;
-
-		if ((status & port->ignore_status_mask) == 0)
-			tty_insert_flip_char(tport, ch, flag);
+#ifdef SUPPORT_SYSRQ
+		if (support_sysrq == 1) {
+			if (status == 0 && ch == 0) {
+				port->icount.brk++;
+				if (uart_handle_break(port))
+					continue;
+			}
 
-		if (status & AML_UART_TX_FIFO_WERR)
-			tty_insert_flip_char(tport, 0, TTY_OVERRUN);
+			if (port->sysrq)
+				flag = TTY_BREAK;
 
-	} while (!(readl(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY));
+			if (uart_handle_sysrq_char(port, ch))
+				continue;
+		}
+#endif
 
+		uart_insert_char(port, status, AML_UART_RX_FIFO_OVERFLOW,
+				 ch, flag);
+		/*
+		 * if ((status & port->ignore_status_mask) == 0)
+		 *	tty_insert_flip_char(tport, ch, flag);
+		 *
+		 * if (status & AML_UART_TX_FIFO_WERR)
+		 *	tty_insert_flip_char(tport, 0, TTY_OVERRUN);
+		 */
+	} while (!(readl_relaxed(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY));
 	spin_unlock(&port->lock);
+
 	tty_flip_buffer_push(tport);
-	spin_lock(&port->lock);
+
 }
 
 static irqreturn_t meson_uart_interrupt(int irq, void *dev_id)
 {
 	struct uart_port *port = (struct uart_port *)dev_id;
+	u32 val;
 
 	spin_lock(&port->lock);
-
-	if (!(readl(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY))
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
+	spin_unlock(&port->lock);
+	if (!(readl_relaxed(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY))
 		meson_receive_chars(port);
 
-	if (!(readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL)) {
-		if (readl(port->membase + AML_UART_CONTROL) & AML_UART_TX_INT_EN)
-			meson_uart_start_tx(port);
-	}
-
-	spin_unlock(&port->lock);
+	if ((val & AML_UART_TX_EN) && (!(readl_relaxed(port->membase + AML_UART_STATUS) &
+				AML_UART_TX_FULL)))
+		meson_transmit_chars(port);
 
 	return IRQ_HANDLED;
 }
@@ -255,40 +309,25 @@
 	return (port->type == PORT_MESON) ? "meson_uart" : NULL;
 }
 
-static void meson_uart_reset(struct uart_port *port)
-{
-	u32 val;
-
-	val = readl(port->membase + AML_UART_CONTROL);
-	val |= (AML_UART_RX_RST | AML_UART_TX_RST | AML_UART_CLEAR_ERR);
-	writel(val, port->membase + AML_UART_CONTROL);
-
-	val &= ~(AML_UART_RX_RST | AML_UART_TX_RST | AML_UART_CLEAR_ERR);
-	writel(val, port->membase + AML_UART_CONTROL);
-}
-
 static int meson_uart_startup(struct uart_port *port)
 {
 	u32 val;
 	int ret = 0;
 
-	val = readl(port->membase + AML_UART_CONTROL);
-	val |= AML_UART_CLEAR_ERR;
-	writel(val, port->membase + AML_UART_CONTROL);
-	val &= ~AML_UART_CLEAR_ERR;
-	writel(val, port->membase + AML_UART_CONTROL);
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
+	val |= (AML_UART_RX_RST | AML_UART_TX_RST | AML_UART_CLR_ERR);
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
+
+	val &= ~(AML_UART_RX_RST | AML_UART_TX_RST | AML_UART_CLR_ERR);
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
 
 	val |= (AML_UART_RX_EN | AML_UART_TX_EN);
-	writel(val, port->membase + AML_UART_CONTROL);
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
 
 	val |= (AML_UART_RX_INT_EN | AML_UART_TX_INT_EN);
-	writel(val, port->membase + AML_UART_CONTROL);
-
-	val = (AML_UART_RECV_IRQ(1) | AML_UART_XMIT_IRQ(port->fifosize / 2));
-	writel(val, port->membase + AML_UART_MISC);
+	val &= ~UART_CTS_EN;
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
 
-	ret = request_irq(port->irq, meson_uart_interrupt, 0,
-			  port->name, port);
 
 	return ret;
 }
@@ -296,18 +335,37 @@
 static void meson_uart_change_speed(struct uart_port *port, unsigned long baud)
 {
 	u32 val;
+	struct meson_uart_port *mup = to_meson_port(port);
+	struct platform_device *pdev = to_platform_device(port->dev);
 
-	while (!meson_uart_tx_empty(port))
+	while (!(readl_relaxed(port->membase + AML_UART_STATUS) & AML_UART_TX_EMPTY))
 		cpu_relax();
 
+	val = readl_relaxed(port->membase + AML_UART_REG5);
+	val &= ~AML_UART_BAUD_MASK;
 	if (port->uartclk == 24000000) {
-		val = ((port->uartclk / 3) / baud) - 1;
-		val |= AML_UART_BAUD_XTAL;
+		if (xtal_tick_en) {
+			val = (port->uartclk / 2 + baud / 2) / baud  - 1;
+			val |= (AML_UART_BAUD_USE | AML_UART_BAUD_XTAL |
+				AML_UART_BAUD_XTAL_DIV2);
+		} else {
+			val = ((port->uartclk / 3) + baud / 2) / baud  - 1;
+			val &= (~(AML_UART_BAUD_XTAL_TICK |
+				AML_UART_BAUD_XTAL_DIV2));
+			val |= (AML_UART_BAUD_USE | AML_UART_BAUD_XTAL);
+		}
 	} else {
+		dev_info(&pdev->dev, "ttyS%d use clk81 %d change %ld to %ld\n",
+				port->line, port->uartclk,
+				mup->baud, baud);
 		val = ((port->uartclk * 10 / (baud * 4) + 5) / 10) - 1;
+		val &= (~(AML_UART_BAUD_XTAL | AML_UART_BAUD_XTAL_TICK |
+			AML_UART_BAUD_XTAL_DIV2));
+		val |= AML_UART_BAUD_USE;
 	}
-	val |= AML_UART_BAUD_USE;
-	writel(val, port->membase + AML_UART_REG5);
+	writel_relaxed(val, port->membase + AML_UART_REG5);
+
+	mup->baud = baud;
 }
 
 static void meson_uart_set_termios(struct uart_port *port,
@@ -323,7 +381,7 @@
 	cflags = termios->c_cflag;
 	iflags = termios->c_iflag;
 
-	val = readl(port->membase + AML_UART_CONTROL);
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
 
 	val &= ~AML_UART_DATA_LEN_MASK;
 	switch (cflags & CSIZE) {
@@ -351,34 +409,34 @@
 	else
 		val &= ~AML_UART_PARITY_TYPE;
 
-	val &= ~AML_UART_STOP_BIT_LEN_MASK;
+	val &= ~AML_UART_STOP_BIN_LEN_MASK;
 	if (cflags & CSTOPB)
-		val |= AML_UART_STOP_BIT_2SB;
+		val |= AML_UART_STOP_BIN_2SB;
 	else
-		val |= AML_UART_STOP_BIT_1SB;
+		val &= ~AML_UART_STOP_BIN_1SB;
 
 	if (cflags & CRTSCTS)
 		val &= ~AML_UART_TWO_WIRE_EN;
 	else
 		val |= AML_UART_TWO_WIRE_EN;
 
-	writel(val, port->membase + AML_UART_CONTROL);
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
+	spin_unlock_irqrestore(&port->lock, flags);
 
-	baud = uart_get_baud_rate(port, termios, old, 50, 4000000);
+	baud = uart_get_baud_rate(port, termios, old, 2400, 4000000);
 	meson_uart_change_speed(port, baud);
 
-	port->read_status_mask = AML_UART_TX_FIFO_WERR;
+	port->read_status_mask = AML_UART_RX_FIFO_OVERFLOW;
 	if (iflags & INPCK)
 		port->read_status_mask |= AML_UART_PARITY_ERR |
-					  AML_UART_FRAME_ERR;
+		    AML_UART_FRAME_ERR;
 
 	port->ignore_status_mask = 0;
 	if (iflags & IGNPAR)
 		port->ignore_status_mask |= AML_UART_PARITY_ERR |
-					    AML_UART_FRAME_ERR;
+		    AML_UART_FRAME_ERR;
 
 	uart_update_timeout(port, termios->c_cflag, baud);
-	spin_unlock_irqrestore(&port->lock, flags);
 }
 
 static int meson_uart_verify_port(struct uart_port *port,
@@ -397,25 +455,51 @@
 
 static void meson_uart_release_port(struct uart_port *port)
 {
-	devm_iounmap(port->dev, port->membase);
-	port->membase = NULL;
-	devm_release_mem_region(port->dev, port->mapbase, port->mapsize);
+	if (port->flags & UPF_IOREMAP) {
+		iounmap(port->membase);
+		port->membase = NULL;
+	}
 }
 
 static int meson_uart_request_port(struct uart_port *port)
 {
-	if (!devm_request_mem_region(port->dev, port->mapbase, port->mapsize,
+	struct platform_device *pdev = to_platform_device(port->dev);
+	struct resource *res;
+	int size, ret;
+	u32 val;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "cannot obtain I/O memory region");
+		return -ENODEV;
+	}
+	size = resource_size(res);
+
+	if (!devm_request_mem_region(port->dev, port->mapbase, size,
 				     dev_name(port->dev))) {
 		dev_err(port->dev, "Memory region busy\n");
 		return -EBUSY;
 	}
 
-	port->membase = devm_ioremap(port->dev, port->mapbase,
-					     port->mapsize);
-	if (!port->membase)
-		return -ENOMEM;
+	if (port->flags & UPF_IOREMAP) {
+		port->membase = devm_ioremap(port->dev,
+						     port->mapbase, size);
+		if (!port->membase)
+			return -ENOMEM;
+	}
+
+	dev_info(&pdev->dev, "==uart%d reg addr = %px\n",
+						port->line, port->membase);
+	val = (AML_UART_RECV_IRQ(1) | AML_UART_XMIT_IRQ(port->fifosize / 2));
+	writel_relaxed(val, port->membase + AML_UART_MISC);
 
+	writel_relaxed(readl_relaxed(port->membase + AML_UART_CONTROL) | UART_CTS_EN,
+			port->membase + AML_UART_CONTROL);
+
+	ret = devm_request_irq(port->dev, port->irq, meson_uart_interrupt,
+							IRQF_SHARED, port->name, port);
 	return 0;
+
 }
 
 static void meson_uart_config_port(struct uart_port *port, int flags)
@@ -426,64 +510,6 @@
 	}
 }
 
-#ifdef CONFIG_CONSOLE_POLL
-/*
- * Console polling routines for writing and reading from the uart while
- * in an interrupt or debug context (i.e. kgdb).
- */
-
-static int meson_uart_poll_get_char(struct uart_port *port)
-{
-	u32 c;
-	unsigned long flags;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	if (readl(port->membase + AML_UART_STATUS) & AML_UART_RX_EMPTY)
-		c = NO_POLL_CHAR;
-	else
-		c = readl(port->membase + AML_UART_RFIFO);
-
-	spin_unlock_irqrestore(&port->lock, flags);
-
-	return c;
-}
-
-static void meson_uart_poll_put_char(struct uart_port *port, unsigned char c)
-{
-	unsigned long flags;
-	u32 reg;
-	int ret;
-
-	spin_lock_irqsave(&port->lock, flags);
-
-	/* Wait until FIFO is empty or timeout */
-	ret = readl_poll_timeout_atomic(port->membase + AML_UART_STATUS, reg,
-					reg & AML_UART_TX_EMPTY,
-					AML_UART_POLL_USEC,
-					AML_UART_TIMEOUT_USEC);
-	if (ret == -ETIMEDOUT) {
-		dev_err(port->dev, "Timeout waiting for UART TX EMPTY\n");
-		goto out;
-	}
-
-	/* Write the character */
-	writel(c, port->membase + AML_UART_WFIFO);
-
-	/* Wait until FIFO is empty or timeout */
-	ret = readl_poll_timeout_atomic(port->membase + AML_UART_STATUS, reg,
-					reg & AML_UART_TX_EMPTY,
-					AML_UART_POLL_USEC,
-					AML_UART_TIMEOUT_USEC);
-	if (ret == -ETIMEDOUT)
-		dev_err(port->dev, "Timeout waiting for UART TX EMPTY\n");
-
-out:
-	spin_unlock_irqrestore(&port->lock, flags);
-}
-
-#endif /* CONFIG_CONSOLE_POLL */
-
 static const struct uart_ops meson_uart_ops = {
 	.set_mctrl      = meson_uart_set_mctrl,
 	.get_mctrl      = meson_uart_get_mctrl,
@@ -499,10 +525,6 @@
 	.request_port	= meson_uart_request_port,
 	.release_port	= meson_uart_release_port,
 	.verify_port	= meson_uart_verify_port,
-#ifdef CONFIG_CONSOLE_POLL
-	.poll_get_char	= meson_uart_poll_get_char,
-	.poll_put_char	= meson_uart_poll_put_char,
-#endif
 };
 
 #ifdef CONFIG_SERIAL_MESON_CONSOLE
@@ -510,9 +532,9 @@
 {
 	u32 val;
 
-	val = readl(port->membase + AML_UART_CONTROL);
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
 	val |= AML_UART_TX_EN;
-	writel(val, port->membase + AML_UART_CONTROL);
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
 }
 
 static void meson_console_putchar(struct uart_port *port, int ch)
@@ -520,9 +542,10 @@
 	if (!port->membase)
 		return;
 
-	while (readl(port->membase + AML_UART_STATUS) & AML_UART_TX_FULL)
+	while (readl_relaxed(port->membase + AML_UART_STATUS) &
+	       AML_UART_TX_FULL)
 		cpu_relax();
-	writel(ch, port->membase + AML_UART_WFIFO);
+	writel_relaxed(ch, port->membase + AML_UART_WFIFO);
 }
 
 static void meson_serial_port_write(struct uart_port *port, const char *s,
@@ -542,12 +565,12 @@
 		locked = 1;
 	}
 
-	val = readl(port->membase + AML_UART_CONTROL);
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
 	tmp = val & ~(AML_UART_TX_INT_EN | AML_UART_RX_INT_EN);
-	writel(tmp, port->membase + AML_UART_CONTROL);
+	writel_relaxed(tmp, port->membase + AML_UART_CONTROL);
 
 	uart_console_write(port, s, count, meson_console_putchar);
-	writel(val, port->membase + AML_UART_CONTROL);
+	writel_relaxed(val, port->membase + AML_UART_CONTROL);
 
 	if (locked)
 		spin_unlock(&port->lock);
@@ -559,7 +582,7 @@
 {
 	struct uart_port *port;
 
-	port = meson_ports[co->index];
+	port = &meson_ports[co->index]->port;
 	if (!port)
 		return;
 
@@ -574,10 +597,10 @@
 	int parity = 'n';
 	int flow = 'n';
 
-	if (co->index < 0 || co->index >= AML_UART_PORT_NUM)
+	if (co->index < 0 || co->index >= AML_UART_PORT_MAX)
 		return -EINVAL;
 
-	port = meson_ports[co->index];
+	port = &meson_ports[co->index]->port;
 	if (!port || !port->membase)
 		return -ENODEV;
 
@@ -616,7 +639,8 @@
 }
 
 static int __init
-meson_serial_early_console_setup(struct earlycon_device *device, const char *opt)
+meson_serial_early_console_setup(struct earlycon_device *device,
+				 const char *opt)
 {
 	if (!device->port.membase)
 		return -ENODEV;
@@ -641,10 +665,72 @@
 	.owner		= THIS_MODULE,
 	.driver_name	= "meson_uart",
 	.dev_name	= AML_UART_DEV_NAME,
-	.nr		= AML_UART_PORT_NUM,
+	.nr		= AML_UART_PORT_MAX,
 	.cons		= MESON_SERIAL_CONSOLE,
 };
 
+#ifdef CONFIG_HIBERNATION
+static u32 save_mode;
+
+static int meson_uart_freeze(struct device *dev)
+{
+	struct platform_device *pdev;
+	struct uart_port *port;
+
+	pdev = to_platform_device(dev);
+	port = platform_get_drvdata(pdev);
+
+	save_mode = readl_relaxed(port->membase + AML_UART_CONTROL);
+
+	pr_debug("uart freeze, mode: %x\n", save_mode);
+
+	return 0;
+}
+
+static int meson_uart_thaw(struct device *dev)
+{
+	return 0;
+}
+
+static int meson_uart_restore(struct device *dev)
+{
+	struct platform_device *pdev;
+	struct uart_port *port;
+
+	pdev = to_platform_device(dev);
+	port = platform_get_drvdata(pdev);
+
+	writel_relaxed(save_mode, port->membase + AML_UART_CONTROL);
+	pr_debug("uart restore, mode: %x\n", save_mode);
+	return 0;
+}
+
+static int meson_uart_suspend(struct platform_device *pdev,
+			      pm_message_t state);
+static int meson_uart_resume(struct platform_device *pdev);
+static int meson_uart_pm_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return meson_uart_suspend(pdev, PMSG_SUSPEND);
+}
+
+static int meson_uart_pm_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	return meson_uart_resume(pdev);
+}
+
+const struct dev_pm_ops meson_uart_pm = {
+	.freeze		= meson_uart_freeze,
+	.thaw		= meson_uart_thaw,
+	.restore	= meson_uart_restore,
+	.suspend	= meson_uart_pm_suspend,
+	.resume		= meson_uart_pm_resume,
+};
+#endif
+
 static inline struct clk *meson_uart_probe_clock(struct device *dev,
 						 const char *id)
 {
@@ -715,22 +801,15 @@
 {
 	struct resource *res_mem, *res_irq;
 	struct uart_port *port;
+	struct meson_uart_port *mup;
+	struct clk *clk;
+	const void *prop;
 	int ret = 0;
-	int id = -1;
 
 	if (pdev->dev.of_node)
 		pdev->id = of_alias_get_id(pdev->dev.of_node, "serial");
 
-	if (pdev->id < 0) {
-		for (id = AML_UART_PORT_OFFSET; id < AML_UART_PORT_NUM; id++) {
-			if (!meson_ports[id]) {
-				pdev->id = id;
-				break;
-			}
-		}
-	}
-
-	if (pdev->id < 0 || pdev->id >= AML_UART_PORT_NUM)
+	if (pdev->id < 0 || pdev->id >= AML_UART_PORT_MAX)
 		return -EINVAL;
 
 	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -746,10 +825,14 @@
 		return -EBUSY;
 	}
 
-	port = devm_kzalloc(&pdev->dev, sizeof(struct uart_port), GFP_KERNEL);
-	if (!port)
+	mup = devm_kzalloc(&pdev->dev,
+		sizeof(struct meson_uart_port), GFP_KERNEL);
+	if (!mup)
 		return -ENOMEM;
 
+	spin_lock_init(&mup->wr_lock);
+	port = &mup->port;
+
 	/* Use legacy way until all platforms switch to new bindings */
 	if (of_device_is_compatible(pdev->dev.of_node, "amlogic,meson-uart"))
 		ret = meson_uart_probe_clocks_legacy(pdev, port);
@@ -757,34 +840,45 @@
 		ret = meson_uart_probe_clocks(pdev, port);
 
 	if (ret)
-		return ret;
+		return ret;	/* Use legacy way until all platforms switch to new bindings */
+
+	port->fifosize = 64;
+
+	prop = of_get_property(pdev->dev.of_node, "fifosize", NULL);
+	if (prop)
+		port->fifosize = of_read_ulong(prop, 1);
+
+	if (!xtal_tick_en) {
+		prop = of_get_property(pdev->dev.of_node, "xtal_tick_en", NULL);
+		if (prop)
+			xtal_tick_en = of_read_ulong(prop, 1);
+	}
 
 	port->iotype = UPIO_MEM;
 	port->mapbase = res_mem->start;
-	port->mapsize = resource_size(res_mem);
 	port->irq = res_irq->start;
-	port->flags = UPF_BOOT_AUTOCONF | UPF_LOW_LATENCY;
-	port->has_sysrq = IS_ENABLED(CONFIG_SERIAL_MESON_CONSOLE);
+	port->flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP | UPF_LOW_LATENCY;
 	port->dev = &pdev->dev;
 	port->line = pdev->id;
 	port->type = PORT_MESON;
 	port->x_char = 0;
 	port->ops = &meson_uart_ops;
-	port->fifosize = 64;
 
-	meson_ports[pdev->id] = port;
+	meson_ports[pdev->id] = mup;
 	platform_set_drvdata(pdev, port);
-
-	/* reset port before registering (and possibly registering console) */
-	if (meson_uart_request_port(port) >= 0) {
-		meson_uart_reset(port);
-		meson_uart_release_port(port);
+	if (of_get_property(pdev->dev.of_node, "pinctrl-names", NULL)) {
+		mup->p = devm_pinctrl_get_select_default(&pdev->dev);
+		/* if (!mup->p) */
+		/* return -1; */
 	}
-
 	ret = uart_add_one_port(&meson_uart_driver, port);
 	if (ret)
 		meson_ports[pdev->id] = NULL;
 
+	prop = of_get_property(pdev->dev.of_node, "support-sysrq", NULL);
+	if (prop)
+		support_sysrq = of_read_ulong(prop, 1);
+
 	return ret;
 }
 
@@ -799,6 +893,59 @@
 	return 0;
 }
 
+static int meson_uart_resume(struct platform_device *pdev)
+{
+	struct uart_port *port;
+	u32 val;
+
+	port = platform_get_drvdata(pdev);
+	if (!port) {
+		dev_err(&pdev->dev, "port is NULL");
+		return 0;
+	}
+
+	if (port->line == 0)
+		return 0;
+	uart_resume_port(&meson_uart_driver, port);
+
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
+	if (!(val & AML_UART_TWO_WIRE_EN)) {
+		val &= ~(0x1 << 31);
+		writel_relaxed(val, port->membase + AML_UART_CONTROL);
+	}
+
+	return 0;
+}
+
+static int meson_uart_suspend(struct platform_device *pdev,
+			      pm_message_t state)
+{
+	struct uart_port *port;
+	u32 val;
+
+	port = platform_get_drvdata(pdev);
+	if (!port) {
+		dev_err(&pdev->dev, "port is NULL");
+		return 0;
+	}
+
+	if (port->line == 0)
+		return 0;
+	uart_suspend_port(&meson_uart_driver, port);
+
+	val = readl_relaxed(port->membase + AML_UART_CONTROL);
+	/* if rts/cts is open, pull up rts pin
+	 * when in suspend
+	 */
+	if (!(val & AML_UART_TWO_WIRE_EN)) {
+		dev_info(&pdev->dev, "pull up rts");
+		val |= (0x1 << 31);
+		writel_relaxed(val, port->membase + AML_UART_CONTROL);
+	}
+
+	return 0;
+}
+
 static const struct of_device_id meson_uart_dt_match[] = {
 	/* Legacy bindings, should be removed when no more used */
 	{ .compatible = "amlogic,meson-uart" },
@@ -814,9 +961,15 @@
 static  struct platform_driver meson_uart_platform_driver = {
 	.probe		= meson_uart_probe,
 	.remove		= meson_uart_remove,
-	.driver		= {
-		.name		= "meson_uart",
-		.of_match_table	= meson_uart_dt_match,
+	.suspend	= meson_uart_suspend,
+	.resume		= meson_uart_resume,
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "meson_uart",
+		   .of_match_table = meson_uart_dt_match,
+#ifdef CONFIG_HIBERNATION
+		.pm = &meson_uart_pm,
+#endif
 	},
 };
 
diff -Naur a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c
--- a/drivers/usb/chipidea/core.c	2022-06-30 21:35:01.824331749 +0800
+++ b/drivers/usb/chipidea/core.c	2022-05-27 17:20:17.661927695 +0800
@@ -509,7 +509,7 @@
 	return 0;
 }
 
-static irqreturn_t ci_irq_handler(int irq, void *data)
+static irqreturn_t ci_irq(int irq, void *data)
 {
 	struct ci_hdrc *ci = data;
 	irqreturn_t ret = IRQ_NONE;
@@ -562,15 +562,6 @@
 	return ret;
 }
 
-static void ci_irq(struct ci_hdrc *ci)
-{
-	unsigned long flags;
-
-	local_irq_save(flags);
-	ci_irq_handler(ci->irq, ci);
-	local_irq_restore(flags);
-}
-
 static int ci_cable_notifier(struct notifier_block *nb, unsigned long event,
 			     void *ptr)
 {
@@ -580,7 +571,7 @@
 	cbl->connected = event;
 	cbl->changed = true;
 
-	ci_irq(ci);
+	ci_irq(ci->irq, ci);
 	return NOTIFY_DONE;
 }
 
@@ -621,7 +612,7 @@
 	if (cable) {
 		cable->changed = true;
 		cable->connected = false;
-		ci_irq(ci);
+		ci_irq(ci->irq, ci);
 		spin_unlock_irqrestore(&ci->lock, flags);
 		if (ci->wq && role != USB_ROLE_NONE)
 			flush_workqueue(ci->wq);
@@ -639,7 +630,7 @@
 	if (cable) {
 		cable->changed = true;
 		cable->connected = true;
-		ci_irq(ci);
+		ci_irq(ci->irq, ci);
 	}
 	spin_unlock_irqrestore(&ci->lock, flags);
 	pm_runtime_put_sync(ci->dev);
@@ -1175,7 +1166,7 @@
 		}
 	}
 
-	ret = devm_request_irq(dev, ci->irq, ci_irq_handler, IRQF_SHARED,
+	ret = devm_request_irq(dev, ci->irq, ci_irq, IRQF_SHARED,
 			ci->platdata->name, ci);
 	if (ret)
 		goto stop;
@@ -1296,11 +1287,11 @@
 
 	if (!IS_ERR(cable_id->edev) && ci->is_otg &&
 		(otgsc & OTGSC_IDIE) && (otgsc & OTGSC_IDIS))
-		ci_irq(ci);
+		ci_irq(ci->irq, ci);
 
 	if (!IS_ERR(cable_vbus->edev) && ci->is_otg &&
 		(otgsc & OTGSC_BSVIE) && (otgsc & OTGSC_BSVIS))
-		ci_irq(ci);
+		ci_irq(ci->irq, ci);
 }
 
 static int ci_controller_resume(struct device *dev)
diff -Naur a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
--- a/drivers/usb/core/hub.c	2022-05-27 17:20:17.665927747 +0800
+++ b/drivers/usb/core/hub.c	2022-05-31 11:56:48.085256221 +0800
@@ -1826,7 +1826,8 @@
 	 * bus_resume methods.
 	 */
 	if (hdev->parent) {		/* normal device */
-		usb_enable_autosuspend(hdev);
+		if (!(hdev->parent->quirks & USB_QUIRK_AUTO_SUSPEND))
+			usb_enable_autosuspend(hdev);
 	} else {			/* root hub */
 		const struct hc_driver *drv = bus_to_hcd(hdev->bus)->driver;
 
diff -Naur a/drivers/usb/dwc3/dwc3-meson-g12a.c b/drivers/usb/dwc3/dwc3-meson-g12a.c
--- a/drivers/usb/dwc3/dwc3-meson-g12a.c	2022-05-27 17:20:17.673927851 +0800
+++ b/drivers/usb/dwc3/dwc3-meson-g12a.c	2022-06-02 17:31:15.284653437 +0800
@@ -269,6 +269,59 @@
 	const struct dwc3_meson_g12a_drvdata *drvdata;
 };
 
+union u2p_r0_v2 {
+	/** raw register data */
+	uint32_t d32;
+	/** register bits */
+	struct {
+		unsigned host_device:1;
+		unsigned power_ok:1;
+		unsigned hast_mode:1;
+		unsigned power_on_reset:1;
+		unsigned id_pullup:1;
+		unsigned drv_vbus:1;
+		unsigned reserved:26;
+	} b;
+};
+
+static ssize_t phy_meson_g12a_usb_mode_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+    struct dwc3_meson_g12a *priv = dev_get_drvdata(dev);
+    union u2p_r0_v2 reg0;
+
+    regmap_read(priv->u2p_regmap[1], U2P_R0, &reg0.d32);
+    printk(KERN_INFO "USB Mode is %s\n", reg0.b.id_pullup ? "OTG" : "Host");
+
+	return 0;
+}
+
+static ssize_t phy_meson_g12a_usb_mode_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+    struct dwc3_meson_g12a *priv = dev_get_drvdata(dev);
+	int id_pullup = 0;
+
+    id_pullup = simple_strtoul(buf, NULL, 16);
+    printk(KERN_INFO "USB Mode : %s\n", id_pullup ? "OTG" : "Host");
+
+    if (id_pullup) {
+        regmap_update_bits(priv->u2p_regmap[1], U2P_R0,
+                    U2P_R0_HOST_DEVICE | U2P_R0_ID_PULLUP | U2P_R0_DRV_VBUS,
+                    U2P_R0_ID_PULLUP | U2P_R0_DRV_VBUS);
+    } else {
+        regmap_update_bits(priv->u2p_regmap[1], U2P_R0,
+                    U2P_R0_HOST_DEVICE | U2P_R0_ID_PULLUP | U2P_R0_DRV_VBUS,
+                    U2P_R0_HOST_DEVICE | U2P_R0_DRV_VBUS);
+    }
+
+	return count;
+}
+
+static DEVICE_ATTR(usb_mode, 0664, phy_meson_g12a_usb_mode_show, phy_meson_g12a_usb_mode_store);
+
 static int dwc3_meson_gxl_set_phy_mode(struct dwc3_meson_g12a *priv,
 					 int i, enum phy_mode mode)
 {
@@ -436,6 +489,10 @@
 
 	dwc3_meson_g12a_usb_otg_apply_mode(priv, mode);
 
+    ret = device_create_file(priv->dev, &dev_attr_usb_mode);
+    if (ret != 0)
+        dev_err(priv->dev, "failed create usb mode file\n");
+
 	return 0;
 }
 
diff -Naur a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
--- a/drivers/usb/gadget/composite.c	2022-05-27 17:20:17.673927851 +0800
+++ b/drivers/usb/gadget/composite.c	2022-05-31 11:56:48.085256221 +0800
@@ -2061,7 +2061,7 @@
 	return value;
 }
 
-void composite_disconnect(struct usb_gadget *gadget)
+static void __composite_disconnect(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
 	unsigned long			flags;
@@ -2078,6 +2078,23 @@
 	spin_unlock_irqrestore(&cdev->lock, flags);
 }
 
+void composite_disconnect(struct usb_gadget *gadget)
+{
+	usb_gadget_vbus_draw(gadget, 0);
+	__composite_disconnect(gadget);
+}
+
+void composite_reset(struct usb_gadget *gadget)
+{
+	/*
+	 * Section 1.4.13 Standard Downstream Port of the USB battery charging
+	 * specification v1.2 states that a device connected on a SDP shall only
+	 * draw at max 100mA while in a connected, but unconfigured state.
+	 */
+	usb_gadget_vbus_draw(gadget, 100);
+	__composite_disconnect(gadget);
+}
+
 /*-------------------------------------------------------------------------*/
 
 static ssize_t suspended_show(struct device *dev, struct device_attribute *attr,
@@ -2398,7 +2415,7 @@
 	.unbind		= composite_unbind,
 
 	.setup		= composite_setup,
-	.reset		= composite_disconnect,
+	.reset		= composite_reset,
 	.disconnect	= composite_disconnect,
 
 	.suspend	= composite_suspend,
diff -Naur a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c
--- a/drivers/usb/gadget/configfs.c	2022-05-27 17:20:17.673927851 +0800
+++ b/drivers/usb/gadget/configfs.c	2022-05-31 11:56:48.085256221 +0800
@@ -10,6 +10,32 @@
 #include "u_f.h"
 #include "u_os_desc.h"
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+#include <linux/platform_device.h>
+#include <linux/kdev_t.h>
+#include <linux/usb/ch9.h>
+
+#ifdef CONFIG_USB_CONFIGFS_F_ACC
+extern int acc_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl);
+void acc_disconnect(void);
+#endif
+static struct class *android_class;
+static struct device *android_device;
+static int index;
+static int gadget_index;
+
+struct device *create_function_device(char *name)
+{
+	if (android_device && !IS_ERR(android_device))
+		return device_create(android_class, android_device,
+			MKDEV(0, index++), NULL, name);
+	else
+		return ERR_PTR(-EINVAL);
+}
+EXPORT_SYMBOL_GPL(create_function_device);
+#endif
+
 int check_user_usb_string(const char *name,
 		struct usb_gadget_strings *stringtab_dev)
 {
@@ -51,6 +77,12 @@
 	char qw_sign[OS_STRING_QW_SIGN_LEN];
 	spinlock_t spinlock;
 	bool unbind;
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	bool connected;
+	bool sw_connected;
+	struct work_struct work;
+	struct device *dev;
+#endif
 };
 
 static inline struct gadget_info *to_gadget_info(struct config_item *item)
@@ -272,7 +304,7 @@
 
 	mutex_lock(&gi->lock);
 
-	if (!strlen(name)) {
+	if (!strlen(name) || strcmp(name, "none") == 0) {
 		ret = unregister_gadget(gi);
 		if (ret)
 			goto err;
@@ -1270,6 +1302,9 @@
 					f->name, f);
 				f->unbind(c, f);
 			}
+
+			if (f->bind_deactivated)
+				usb_function_activate(f);
 		}
 		c->next_interface_id = 0;
 		memset(c->interface, 0, sizeof(c->interface));
@@ -1422,6 +1457,57 @@
 	return ret;
 }
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+static void android_work(struct work_struct *data)
+{
+	struct gadget_info *gi = container_of(data, struct gadget_info, work);
+	struct usb_composite_dev *cdev = &gi->cdev;
+	char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };
+	char *connected[2]    = { "USB_STATE=CONNECTED", NULL };
+	char *configured[2]   = { "USB_STATE=CONFIGURED", NULL };
+	/* 0-connected 1-configured 2-disconnected*/
+	bool status[3] = { false, false, false };
+	unsigned long flags;
+	bool uevent_sent = false;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		status[1] = true;
+
+	if (gi->connected != gi->sw_connected) {
+		if (gi->connected)
+			status[0] = true;
+		else
+			status[2] = true;
+		gi->sw_connected = gi->connected;
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	if (status[0]) {
+		kobject_uevent_env(&gi->dev->kobj, KOBJ_CHANGE, connected);
+		pr_info("%s: sent uevent %s\n", __func__, connected[0]);
+		uevent_sent = true;
+	}
+
+	if (status[1]) {
+		kobject_uevent_env(&gi->dev->kobj, KOBJ_CHANGE, configured);
+		pr_info("%s: sent uevent %s\n", __func__, configured[0]);
+		uevent_sent = true;
+	}
+
+	if (status[2]) {
+		kobject_uevent_env(&gi->dev->kobj, KOBJ_CHANGE, disconnected);
+		pr_info("%s: sent uevent %s\n", __func__, disconnected[0]);
+		uevent_sent = true;
+	}
+
+	if (!uevent_sent) {
+		pr_info("%s: did not send uevent (%d %d %p)\n", __func__,
+			gi->connected, gi->sw_connected, cdev->config);
+	}
+}
+#endif
+
 static void configfs_composite_unbind(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev	*cdev;
@@ -1447,6 +1533,51 @@
 	spin_unlock_irqrestore(&gi->spinlock, flags);
 }
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+static int android_setup(struct usb_gadget *gadget,
+			const struct usb_ctrlrequest *c)
+{
+	struct usb_composite_dev *cdev = get_gadget_data(gadget);
+	unsigned long flags;
+	struct gadget_info *gi = container_of(cdev, struct gadget_info, cdev);
+	int value = -EOPNOTSUPP;
+	struct usb_function_instance *fi;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (c->bRequest == USB_REQ_GET_DESCRIPTOR &&
+	    (c->wValue >> 8) == USB_DT_CONFIG && !gi->connected) {
+		gi->connected = 1;
+		schedule_work(&gi->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+	list_for_each_entry(fi, &gi->available_func, cfs_list) {
+		if (fi != NULL && fi->f != NULL && fi->f->setup != NULL) {
+			value = fi->f->setup(fi->f, c);
+			if (value >= 0)
+				break;
+		}
+	}
+
+#ifdef CONFIG_USB_CONFIGFS_F_ACC
+	if (value < 0)
+		value = acc_ctrlrequest(cdev, c);
+#endif
+
+	if (value < 0)
+		value = composite_setup(gadget, c);
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (c->bRequest == USB_REQ_SET_CONFIGURATION &&
+						cdev->config) {
+		schedule_work(&gi->work);
+	}
+	spin_unlock_irqrestore(&cdev->lock, flags);
+
+	return value;
+}
+
+#else // CONFIG_USB_CONFIGFS_UEVENT
+
 static int configfs_composite_setup(struct usb_gadget *gadget,
 		const struct usb_ctrlrequest *ctrl)
 {
@@ -1472,6 +1603,8 @@
 	return ret;
 }
 
+#endif // CONFIG_USB_CONFIGFS_UEVENT
+
 static void configfs_composite_disconnect(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev *cdev;
@@ -1482,6 +1615,14 @@
 	if (!cdev)
 		return;
 
+#ifdef CONFIG_USB_CONFIGFS_F_ACC
+	/*
+	 * accessory HID support can be active while the
+	 * accessory function is not actually enabled,
+	 * so we need to inform it when we are disconnected.
+	 */
+	acc_disconnect();
+#endif
 	gi = container_of(cdev, struct gadget_info, cdev);
 	spin_lock_irqsave(&gi->spinlock, flags);
 	cdev = get_gadget_data(gadget);
@@ -1490,10 +1631,36 @@
 		return;
 	}
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	gi->connected = 0;
+	schedule_work(&gi->work);
+#endif
 	composite_disconnect(gadget);
 	spin_unlock_irqrestore(&gi->spinlock, flags);
 }
 
+static void configfs_composite_reset(struct usb_gadget *gadget)
+{
+	struct usb_composite_dev *cdev;
+	struct gadget_info *gi;
+	unsigned long flags;
+
+	cdev = get_gadget_data(gadget);
+	if (!cdev)
+		return;
+
+	gi = container_of(cdev, struct gadget_info, cdev);
+	spin_lock_irqsave(&gi->spinlock, flags);
+	cdev = get_gadget_data(gadget);
+	if (!cdev || gi->unbind) {
+		spin_unlock_irqrestore(&gi->spinlock, flags);
+		return;
+	}
+
+	composite_reset(gadget);
+	spin_unlock_irqrestore(&gi->spinlock, flags);
+}
+
 static void configfs_composite_suspend(struct usb_gadget *gadget)
 {
 	struct usb_composite_dev *cdev;
@@ -1542,10 +1709,13 @@
 	.bind           = configfs_composite_bind,
 	.unbind         = configfs_composite_unbind,
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	.setup          = android_setup,
+#else
 	.setup          = configfs_composite_setup,
-	.reset          = configfs_composite_disconnect,
+#endif
+	.reset          = configfs_composite_reset,
 	.disconnect     = configfs_composite_disconnect,
-
 	.suspend	= configfs_composite_suspend,
 	.resume		= configfs_composite_resume,
 
@@ -1557,6 +1727,91 @@
 	.match_existing_only = 1,
 };
 
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+static ssize_t state_show(struct device *pdev, struct device_attribute *attr,
+			char *buf)
+{
+	struct gadget_info *dev = dev_get_drvdata(pdev);
+	struct usb_composite_dev *cdev;
+	char *state = "DISCONNECTED";
+	unsigned long flags;
+
+	if (!dev)
+		goto out;
+
+	cdev = &dev->cdev;
+
+	if (!cdev)
+		goto out;
+
+	spin_lock_irqsave(&cdev->lock, flags);
+	if (cdev->config)
+		state = "CONFIGURED";
+	else if (dev->connected)
+		state = "CONNECTED";
+	spin_unlock_irqrestore(&cdev->lock, flags);
+out:
+	return sprintf(buf, "%s\n", state);
+}
+
+static DEVICE_ATTR(state, S_IRUGO, state_show, NULL);
+
+static struct device_attribute *android_usb_attributes[] = {
+	&dev_attr_state,
+	NULL
+};
+
+static int android_device_create(struct gadget_info *gi)
+{
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+
+	INIT_WORK(&gi->work, android_work);
+	gi->dev = device_create(android_class, NULL,
+			MKDEV(0, 0), NULL, "android%d", gadget_index++);
+	if (IS_ERR(gi->dev))
+		return PTR_ERR(gi->dev);
+
+	dev_set_drvdata(gi->dev, gi);
+	if (!android_device)
+		android_device = gi->dev;
+
+	attrs = android_usb_attributes;
+	while ((attr = *attrs++)) {
+		int err;
+
+		err = device_create_file(gi->dev, attr);
+		if (err) {
+			device_destroy(gi->dev->class,
+				       gi->dev->devt);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static void android_device_destroy(struct gadget_info *gi)
+{
+	struct device_attribute **attrs;
+	struct device_attribute *attr;
+
+	attrs = android_usb_attributes;
+	while ((attr = *attrs++))
+		device_remove_file(gi->dev, attr);
+	device_destroy(gi->dev->class, gi->dev->devt);
+}
+#else
+static inline int android_device_create(struct gadget_info *gi)
+{
+	return 0;
+}
+
+static inline void android_device_destroy(struct gadget_info *gi)
+{
+}
+#endif
+
 static struct config_group *gadgets_make(
 		struct config_group *group,
 		const char *name)
@@ -1609,7 +1864,11 @@
 	if (!gi->composite.gadget_driver.function)
 		goto err;
 
+	if (android_device_create(gi) < 0)
+		goto err;
+
 	return &gi->group;
+
 err:
 	kfree(gi);
 	return ERR_PTR(-ENOMEM);
@@ -1617,7 +1876,11 @@
 
 static void gadgets_drop(struct config_group *group, struct config_item *item)
 {
+	struct gadget_info *gi;
+
+	gi = container_of(to_config_group(item), struct gadget_info, group);
 	config_item_put(item);
+	android_device_destroy(gi);
 }
 
 static struct configfs_group_operations gadgets_ops = {
@@ -1657,6 +1920,13 @@
 	config_group_init(&gadget_subsys.su_group);
 
 	ret = configfs_register_subsystem(&gadget_subsys);
+
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	android_class = class_create(THIS_MODULE, "android_usb");
+	if (IS_ERR(android_class))
+		return PTR_ERR(android_class);
+#endif
+
 	return ret;
 }
 module_init(gadget_cfs_init);
@@ -1664,5 +1934,10 @@
 static void __exit gadget_cfs_exit(void)
 {
 	configfs_unregister_subsystem(&gadget_subsys);
+#ifdef CONFIG_USB_CONFIGFS_UEVENT
+	if (!IS_ERR(android_class))
+		class_destroy(android_class);
+#endif
+
 }
 module_exit(gadget_cfs_exit);
diff -Naur a/drivers/usb/gadget/function/f_generic.c b/drivers/usb/gadget/function/f_generic.c
--- a/drivers/usb/gadget/function/f_generic.c	2022-06-28 19:20:24.331709124 +0800
+++ b/drivers/usb/gadget/function/f_generic.c	1970-01-01 08:00:00.000000000 +0800
@@ -1,3779 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * f_fs.c -- user mode file system API for USB composite function controllers
- *
- * Copyright (C) 2010 Samsung Electronics
- * Author: Michal Nazarewicz <mina86@mina86.com>
- *
- * Based on inode.c (GadgetFS) which was:
- * Copyright (C) 2003-2004 David Brownell
- * Copyright (C) 2003 Agilent Technologies
- */
-
-/* #define DEBUG */
-/* #define VERBOSE_DEBUG */
-
-#include <linux/export.h>
-#include <linux/hid.h>
-#include <linux/miscdevice.h>
-#include <linux/usb/functionfs.h>
-#include <linux/kfifo.h>
-#include <linux/module.h>
-#include <linux/poll.h>
-#include <linux/eventfd.h>
-#include <linux/dma-mapping.h>
-#include <linux/usb/cdc.h>
-#include <linux/interrupt.h>
-#include "u_generic.h"
-#include "u_f.h"
-#include "u_os_desc.h"
-#include "configfs.h"
-
-#define FUNCTIONFS_MAGIC    0xa647361 /* Chosen by a honest dice roll ;) */
-
-/* Reference counter handling */
-static void ffs_data_get(struct ffs_data *ffs);
-static void ffs_data_put(struct ffs_data *ffs);
-/* Creates new ffs_data object. */
-static struct ffs_data *__must_check ffs_data_new(const char *dev_name)
-    __attribute__((malloc));
-
-/* Called with ffs->mutex held; take over ownership of data. */
-static int __must_check
-__ffs_data_got_descs(struct ffs_data *ffs, char *data, size_t len);
-static int __must_check
-__ffs_data_got_strings(struct ffs_data *ffs, char *data, size_t len);
-
-/* The function structure ***************************************************/
-
-struct ffs_ep;
-
-struct ffs_function {
-    struct usb_configuration    *conf;
-    struct usb_gadget        *gadget;
-    struct ffs_data            *ffs;
-
-    struct ffs_ep            *eps;
-    u8                eps_revmap[16];
-    short                *interfaces_nums;
-
-    struct usb_function        function;
-};
-static struct ffs_function *ffs_func_from_usb(struct usb_function *f)
-{
-    return container_of(f, struct ffs_function, function);
-}
-static inline enum ffs_setup_state ffs_setup_state_clear_cancelled(struct ffs_data *ffs)
-{
-    return (enum ffs_setup_state)
-        cmpxchg(&ffs->setup_state, FFS_SETUP_CANCELLED, FFS_NO_SETUP);
-}
-static void ffs_func_eps_disable(struct ffs_function *func);
-static int __must_check ffs_func_eps_enable(struct ffs_function *func);
-
-static int ffs_func_bind(struct usb_configuration *,
-             struct usb_function *);
-static int ffs_func_set_alt(struct usb_function *, unsigned, unsigned);
-static void ffs_func_disable(struct usb_function *);
-static int ffs_func_setup(struct usb_function *,
-              const struct usb_ctrlrequest *);
-static bool ffs_func_req_match(struct usb_function *,
-                   const struct usb_ctrlrequest *,
-                   bool config0);
-static void ffs_func_suspend(struct usb_function *);
-static void ffs_func_resume(struct usb_function *);
-
-static int ffs_func_revmap_ep(struct ffs_function *func, u8 num);
-static int ffs_func_revmap_intf(struct ffs_function *func, u8 intf);
-
-/* The endpoints structures *************************************************/
-struct ffs_ep {
-    struct usb_ep            *ep;    /* P: ffs->eps_lock */
-    struct usb_request        *req;    /* P: epfile->mutex */
-
-    /* [0]: full speed, [1]: high speed, [2]: super speed */
-    struct usb_endpoint_descriptor    *descs[3];
-
-    u8                num;
-
-    int                status;    /* P: epfile->mutex */
-};
-
-struct ffs_epfile {
-    /* Protects ep->ep and ep->req. */
-    struct mutex            mutex;
-    struct list_head         memory_list;
-    struct ffs_data            *ffs;
-    struct ffs_ep            *ep;    /* P: ffs->eps_lock */
-    /*
-     * Buffer for holding data from partial reads which may happen since
-     * were rounding user read requests to a multiple of a max packet size.
-     *
-     * The pointer is initialised with NULL value and may be set by
-     * __ffs_epfile_read_data function to point to a temporary buffer.
-     *
-     * In normal operation, calls to __ffs_epfile_read_buffered will consume
-     * data from said buffer and eventually free it.  Importantly, while the
-     * function is using the buffer, it sets the pointer to NULL.  This is
-     * all right since __ffs_epfile_read_data and __ffs_epfile_read_buffered
-     * can never run concurrently (they are synchronised by epfile->mutex)
-     * so the latter will not assign a new value to the pointer.
-     *
-     * Meanwhile ffs_func_eps_disable frees the buffer (if the pointer is
-     * valid) and sets the pointer to READ_BUFFER_DROP value.  This special
-     * value is crux of the synchronisation between ffs_func_eps_disable and
-     * __ffs_epfile_read_data.
-     *
-     * Once __ffs_epfile_read_data is about to finish it will try to set the
-     * pointer back to its old value (as described above), but seeing as the
-     * pointer is not-NULL (namely READ_BUFFER_DROP) it will instead free
-     * the buffer.
-     *
-     * == State transitions ==
-     *
-     *  ptr == NULL:  (initial state)
-     *    __ffs_epfile_read_buffer_free: go to ptr == DROP
-     *    __ffs_epfile_read_buffered:    nop
-     *    __ffs_epfile_read_data allocates temp buffer: go to ptr == buf
-     *    reading finishes:              n/a, not in and reading state
-     *  ptr == DROP:
-     *    __ffs_epfile_read_buffer_free: nop
-     *    __ffs_epfile_read_buffered:    go to ptr == NULL
-     *    __ffs_epfile_read_data allocates temp buffer: free buf, nop
-     *    reading finishes:              n/a, not in and reading state
-     *  ptr == buf:
-     *    __ffs_epfile_read_buffer_free: free buf, go to ptr == DROP
-     *    __ffs_epfile_read_buffered:    go to ptr == NULL and reading
-     *    __ffs_epfile_read_data:        n/a, __ffs_epfile_read_buffered
-     *                                    is always called first
-     *    reading finishes:              n/a, not in and reading state
-     *  ptr == NULL and reading:
-     *    __ffs_epfile_read_buffer_free: go to ptr == DROP and reading
-     *    __ffs_epfile_read_buffered:    n/a, mutex is held
-     *    __ffs_epfile_read_data:        n/a, mutex is held
-     *    reading finishes and 
-     *      all data read:               free buf, go to ptr == NULL
-     *      otherwise:                   go to ptr == buf and reading
-     *  ptr == DROP and reading:
-     *    __ffs_epfile_read_buffer_free: nop
-     *    __ffs_epfile_read_buffered:    n/a, mutex is held
-     *    __ffs_epfile_read_data:        n/a, mutex is held
-     *    reading finishes:              free buf, go to ptr == DROP
-     */
-    struct ffs_buffer        *read_buffer;
-#define READ_BUFFER_DROP ((struct ffs_buffer *)ERR_PTR(-ESHUTDOWN))
-
-    char                name[MAX_NAMELEN];
-    dev_t                devno;
-    struct cdev         cdev;
-    struct device         *device;
-
-    unsigned char            in;    /* P: ffs->eps_lock */
-    unsigned char            isoc;    /* P: ffs->eps_lock */
-
-    struct kfifo        reqEventFifo;
-    wait_queue_head_t   wait_que;
-
-    unsigned char            _pad;
-};
-
-struct ffs_buffer {
-    size_t length;
-    char *data;
-    char storage[];
-};
-
-/*  ffs_io_data structure ***************************************************/
-
-struct ffs_io_data {
-    uint32_t aio;
-    uint32_t read;
-    uint32_t len;
-    uint32_t timeout;
-    uint64_t buf;
-    uint32_t actual;
-    int      status;
-    struct tasklet_struct task;
-    struct usb_ep *ep;
-    struct usb_request *req;
-    struct ffs_epfile *epfile;
-    struct ffs_data *ffs;
-};
-
-struct ffs_desc_helper {
-    struct ffs_data *ffs;
-    unsigned interfaces_count;
-    unsigned eps_count;
-};
-
-static int  __must_check ffs_epfiles_create(struct ffs_data *ffs);
-static void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count);
-
-/* Devices management *******************************************************/
-
-DEFINE_MUTEX(ffs_lock_adapter);
-EXPORT_SYMBOL_GPL(ffs_lock_adapter);
-
-static struct ffs_dev *_ffs_find_dev(const char *name);
-static struct ffs_dev *_ffs_alloc_dev(void);
-static void _ffs_free_dev(struct ffs_dev *dev);
-static void *ffs_acquire_dev(const char *dev_name);
-static void ffs_release_dev(struct ffs_data *ffs_data);
-static int ffs_ready(struct ffs_data *ffs);
-static void ffs_closed(struct ffs_data *ffs);
-
-/* Misc helper functions ****************************************************/
-
-static int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)
-    __attribute__((warn_unused_result, nonnull));
-static char *ffs_prepare_buffer(const char __user *buf, size_t len)
-    __attribute__((warn_unused_result, nonnull));
-
-struct class *ffs_class;
-static char *ffs_devnode(struct device *dev, umode_t *mode)
-{
-    if (mode)
-        *mode = 0666;
-    return kasprintf(GFP_KERNEL, "functionfs/%s", dev_name(dev));
-}
-
-/* Control file aka ep0 *****************************************************/
-static struct ffs_memory *generic_find_ep0_memory_area(struct ffs_data *ffs, uint64_t buf, uint32_t len)
-{
-    struct ffs_memory *ffsm = NULL;
-    struct ffs_memory *iter = NULL;
-    uint64_t buf_start = buf;
-    unsigned long flags;
-
-    spin_lock_irqsave(&ffs->mem_lock, flags);
-    list_for_each_entry(iter, &ffs->memory_list, memlist) {
-        if (buf_start >= iter->vm_start &&
-            buf_start < iter->vm_start + iter->size) {
-            if (len <= iter->vm_start + iter->size - buf_start) {
-                ffsm = iter;
-                break;
-            }
-        }
-    }
-    spin_unlock_irqrestore(&ffs->mem_lock, flags);
-    return ffsm;
-}
-
-static void ffs_ep0_complete(struct usb_ep *ep, struct usb_request *req)
-{
-    struct ffs_data *ffs = req->context;
-
-    complete(&ffs->ep0req_completion);
-
-    ffs->setup_state = FFS_NO_SETUP;
-}
-
-static void ffs_ep0_async_io_complete(struct usb_ep *_ep, struct usb_request *req)
-{
-    struct ffs_io_data *io_data = req->context;
-    struct ffs_data *ffs = io_data->ffs;
-    ENTER();
-
-    io_data->status = io_data->req->status;
-    io_data->actual = io_data->req->actual;
-    kfifo_in(&ffs->reqEventFifo, &io_data->buf, sizeof(struct UsbFnReqEvent));
-    wake_up_all(&ffs->wait_que);
-
-    list_del(&req->list);
-    usb_ep_free_request(io_data->ep, io_data->req);
-    kfree(io_data);
-
-}
-
-static int __ffs_ep0_queue_wait(struct ffs_data *ffs, char *data, size_t len)
-    __releases(&ffs->ev.waitq.lock)
-{
-    struct usb_request *req = ffs->ep0req;
-    int ret;
-
-    req->zero     = len < le16_to_cpu(ffs->ev.setup.wLength);
-
-    spin_unlock_irq(&ffs->ev.waitq.lock);
-
-    req->buf      = data;
-    req->length   = len;
-
-    /*
-     * UDC layer requires to provide a buffer even for ZLP, but should
-     * not use it at all. Let's provide some poisoned pointer to catch
-     * possible bug in the driver.
-     */
-    if (req->buf == NULL)
-        req->buf = (void *)0xDEADBABE;
-
-    reinit_completion(&ffs->ep0req_completion);
-
-    ret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);
-    if (unlikely(ret < 0))
-        return ret;
-
-    ret = wait_for_completion_interruptible(&ffs->ep0req_completion);
-    if (unlikely(ret)) {
-        usb_ep_dequeue(ffs->gadget->ep0, req);
-        return -EINTR;
-    }
-
-    ffs->setup_state = FFS_NO_SETUP;
-    return req->status ? req->status : req->actual;
-}
-
-static int __ffs_ep0_stall(struct ffs_data *ffs)
-{
-    if (ffs->ev.can_stall) {
-        pr_vdebug("ep0 stall\n");
-        usb_ep_set_halt(ffs->gadget->ep0);
-        ffs->setup_state = FFS_NO_SETUP;
-        return -EL2HLT;
-    } else {
-        pr_debug("bogus ep0 stall!\n");
-        return -ESRCH;
-    }
-}
-
-static ssize_t ffs_ep0_write(struct file *file, const char __user *buf, size_t len, loff_t *ptr)
-{
-    struct ffs_data *ffs = file->private_data;
-    ssize_t ret;
-    char *data = NULL;
-
-    ENTER();
-
-    /* Fast check if setup was canceled */
-    if (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)
-        return -EIDRM;
-
-    /* Acquire mutex */
-    ret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);
-    if (unlikely(ret < 0))
-        return ret;
-
-    /* Check state */
-    switch (ffs->state) {
-    case FFS_READ_DESCRIPTORS:
-    case FFS_READ_STRINGS:
-        /* Copy data */
-        if (unlikely(len < 16)) {
-            ret = -EINVAL;
-            break;
-        }
-
-        data = ffs_prepare_buffer(buf, len);
-        if (IS_ERR(data)) {
-            ret = PTR_ERR(data);
-            break;
-        }
-
-        /* Handle data */
-        if (ffs->state == FFS_READ_DESCRIPTORS) {
-            pr_info("read descriptors\n");
-            ret = __ffs_data_got_descs(ffs, data, len);
-            if (unlikely(ret < 0))
-                break;
-
-            ffs->state = FFS_READ_STRINGS;
-            ret = len;
-        } else {
-            pr_info("read strings\n");
-            ret = __ffs_data_got_strings(ffs, data, len);
-            if (unlikely(ret < 0))
-                break;
-
-            ret = ffs_epfiles_create(ffs);
-            if (unlikely(ret)) {
-                ffs->state = FFS_CLOSING;
-                break;
-            }
-
-            ffs->state = FFS_ACTIVE;
-            mutex_unlock(&ffs->mutex);
-
-            ret = ffs_ready(ffs);
-            if (unlikely(ret < 0)) {
-                ffs->state = FFS_CLOSING;
-                return ret;
-            }
-
-            return len;
-        }
-        break;
-
-    case FFS_ACTIVE:
-        data = NULL;
-        /*
-         * We're called from user space, we can use _irq
-         * rather then _irqsave
-         */
-        spin_lock_irq(&ffs->ev.waitq.lock);
-        switch (ffs_setup_state_clear_cancelled(ffs)) {
-        case FFS_SETUP_CANCELLED:
-            ret = -EIDRM;
-            goto done_spin;
-
-        case FFS_NO_SETUP:
-            ret = -ESRCH;
-            goto done_spin;
-
-        case FFS_SETUP_PENDING:
-            break;
-        }
-
-        /* FFS_SETUP_PENDING */
-        if (!(ffs->ev.setup.bRequestType & USB_DIR_IN)) {
-            spin_unlock_irq(&ffs->ev.waitq.lock);
-            ret = __ffs_ep0_stall(ffs);
-            break;
-        }
-
-        /* FFS_SETUP_PENDING and not stall */
-        len = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));
-
-        spin_unlock_irq(&ffs->ev.waitq.lock);
-
-        data = ffs_prepare_buffer(buf, len);
-        if (IS_ERR(data)) {
-            ret = PTR_ERR(data);
-            break;
-        }
-
-        spin_lock_irq(&ffs->ev.waitq.lock);
-
-        /*
-         * We are guaranteed to be still in FFS_ACTIVE state
-         * but the state of setup could have changed from
-         * FFS_SETUP_PENDING to FFS_SETUP_CANCELLED so we need
-         * to check for that.  If that happened we copied data
-         * from user space in vain but it's unlikely.
-         *
-         * For sure we are not in FFS_NO_SETUP since this is
-         * the only place FFS_SETUP_PENDING -> FFS_NO_SETUP
-         * transition can be performed and it's protected by
-         * mutex.
-         */
-        if (ffs_setup_state_clear_cancelled(ffs) ==
-                FFS_SETUP_CANCELLED) {
-                ret = -EIDRM;
-done_spin:
-            spin_unlock_irq(&ffs->ev.waitq.lock);
-        } else {
-            /* unlocks spinlock */
-            ret = __ffs_ep0_queue_wait(ffs, data, len);
-        }
-        kfree(data);
-        break;
-
-    default:
-        ret = -EBADFD;
-        break;
-    }
-
-    mutex_unlock(&ffs->mutex);
-    return ret;
-}
-
-/* Called with ffs->ev.waitq.lock and ffs->mutex held, both released on exit. */
-static ssize_t __ffs_ep0_read_events(struct ffs_data *ffs, char __user *buf, size_t n)
-    __releases(&ffs->ev.waitq.lock)
-{ 
-    /*
-     * n cannot be bigger than ffs->ev.count, which cannot be bigger than
-     * size of ffs->ev.types array (which is four) so that's how much space
-     * we reserve.
-     */
-    struct usb_functionfs_event events[ARRAY_SIZE(ffs->ev.types)];
-    const size_t size = n * sizeof *events;
-    unsigned i = 0;
-
-    memset(events, 0, size);
-
-    do {
-        events[i].type = ffs->ev.types[i];
-        if (events[i].type == FUNCTIONFS_SETUP) {
-            events[i].u.setup = ffs->ev.setup;
-            ffs->setup_state = FFS_SETUP_PENDING;
-        }
-    } while (++i < n);
-
-    ffs->ev.count -= n;
-    if (ffs->ev.count)
-        memmove(ffs->ev.types, ffs->ev.types + n, ffs->ev.count * sizeof *ffs->ev.types);
-
-    spin_unlock_irq(&ffs->ev.waitq.lock);
-    mutex_unlock(&ffs->mutex);
-
-    return unlikely(copy_to_user(buf, events, size)) ? -EFAULT : size;
-}
-
-static ssize_t ffs_ep0_read(struct file *file, char __user *buf, size_t len, loff_t *ptr)
-{
-    struct ffs_data *ffs = file->private_data;
-    char *data = NULL;
-    size_t n;
-    int ret;
-
-    ENTER();
-
-    /* Fast check if setup was canceled */
-    if (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)
-        return -EIDRM;
-
-    /* Acquire mutex */
-    ret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);
-    if (unlikely(ret < 0))
-        return ret;
-
-    /* Check state */
-    if (ffs->state != FFS_ACTIVE) {
-        ret = -EBADFD;
-        goto done_mutex;
-    }
-
-    /*
-     * We're called from user space, we can use _irq rather then
-     * _irqsave
-     */
-    spin_lock_irq(&ffs->ev.waitq.lock);
-
-    switch (ffs_setup_state_clear_cancelled(ffs)) {
-    case FFS_SETUP_CANCELLED:
-        ret = -EIDRM;
-        break;
-
-    case FFS_NO_SETUP:
-        n = len / sizeof(struct usb_functionfs_event);
-        if (unlikely(!n)) {
-            ret = -EINVAL;
-            break;
-        }
-
-        if ((file->f_flags & O_NONBLOCK) && !ffs->ev.count) {
-            ret = -EAGAIN;
-            break;
-        }
-
-        if (wait_event_interruptible_exclusive_locked_irq(ffs->ev.waitq,
-                            ffs->ev.count)) {
-            ret = -EINTR;
-            break;
-        }
-
-        /* unlocks spinlock */
-        return __ffs_ep0_read_events(ffs, buf,
-                         min(n, (size_t)ffs->ev.count));
-
-    case FFS_SETUP_PENDING:
-        if (ffs->ev.setup.bRequestType & USB_DIR_IN) {
-            spin_unlock_irq(&ffs->ev.waitq.lock);
-            ret = __ffs_ep0_stall(ffs);
-            goto done_mutex;
-        }
-
-        len = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));
-
-        spin_unlock_irq(&ffs->ev.waitq.lock);
-
-        if (likely(len)) {
-            data = kmalloc(len, GFP_KERNEL);
-            if (unlikely(!data)) {
-                ret = -ENOMEM;
-                goto done_mutex;
-            }
-        }
-
-        spin_lock_irq(&ffs->ev.waitq.lock);
-
-        /* See ffs_ep0_write() */
-        if (ffs_setup_state_clear_cancelled(ffs) ==
-            FFS_SETUP_CANCELLED) {
-            ret = -EIDRM;
-            break;
-        }
-
-        /* unlocks spinlock */
-        ret = __ffs_ep0_queue_wait(ffs, data, len);
-        if (likely(ret > 0) && unlikely(copy_to_user(buf, data, len)))
-            ret = -EFAULT;
-        goto done_mutex;
-
-    default:
-        ret = -EBADFD;
-        break;
-    }
-
-    spin_unlock_irq(&ffs->ev.waitq.lock);
-done_mutex:
-    mutex_unlock(&ffs->mutex);
-    kfree(data);
-    return ret;
-}
-
-static int ffs_ep0_open(struct inode *inode, struct file *file)
-{
-    struct ffs_data *ffs  = container_of(inode->i_cdev, struct ffs_data, cdev);
-    ENTER();
-
-    if (unlikely(ffs->state == FFS_CLOSING))
-        return -EBUSY;
-
-    file->private_data = ffs;
-    return 0;
-}
-
-static int ffs_ep0_release(struct inode *inode, struct file *file)
-{
-    ENTER();
-    return 0;
-}
-
-static ssize_t ffs_ep0_iorw(struct file *file, struct ffs_io_data *io_data)
-{
-    struct ffs_data *ffs = file->private_data;
-    struct usb_request *req = NULL;
-    ssize_t ret, data_len = io_data->len;
-    bool interrupted = false;
-    struct ffs_memory *ffsm = NULL;
-
-    /* Are we still active? */
-    if (WARN_ON(ffs->state != FFS_ACTIVE))
-        return -ENODEV;
-    ffsm = generic_find_ep0_memory_area(ffs, io_data->buf, data_len);
-    if (ffsm == NULL)
-    {
-        return -ENODEV;
-    }
-    if (!io_data->aio) {
-        reinit_completion(&ffs->ep0req_completion);
-
-        req = ffs->ep0req;
-        req->buf      = (void *)(ffsm->mem + io_data->buf - ffsm->vm_start);
-        req->length   = data_len;
-        req->complete = ffs_ep0_complete;
-
-        ret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);
-        if (unlikely(ret < 0))
-            goto error;
-
-        if (io_data->timeout > 0) {
-            ret = wait_for_completion_interruptible_timeout(&ffs->ep0req_completion, io_data->timeout);
-            if (ret < 0) {
-                /*
-                 * To avoid race condition with ffs_epfile_io_complete,
-                 * dequeue the request first then check
-                 * status. usb_ep_dequeue API should guarantee no race
-                 * condition with req->complete callback.
-                 */
-                usb_ep_dequeue(ffs->gadget->ep0, req);
-                wait_for_completion(&ffs->ep0req_completion);
-                interrupted = req->status < 0;
-            } else if (ret == 0) {
-                ret = -EBUSY;
-                usb_ep_dequeue(ffs->gadget->ep0, req);
-                wait_for_completion(&ffs->ep0req_completion);
-                goto error;
-            }
-        } else {
-            ret = wait_for_completion_interruptible(&ffs->ep0req_completion);
-            if (ret < 0) {
-                usb_ep_dequeue(ffs->gadget->ep0, req);
-                wait_for_completion(&ffs->ep0req_completion);
-                interrupted = req->status < 0;
-            }
-        }
-
-        if (interrupted) {
-            ret = -EINTR;
-        } else {
-            ret = req->actual;
-        }
-        goto error;
-    }
-    else if (!(req = usb_ep_alloc_request(ffs->gadget->ep0, GFP_ATOMIC))) {
-        ret = -ENOMEM;
-    }
-    else {
-        req->buf     = (void *)(ffsm->mem + io_data->buf - ffsm->vm_start);
-        req->length   = data_len;
-
-        io_data->ep = ffs->gadget->ep0;
-        io_data->req = req;
-        io_data->ffs = ffs;
-
-        req->context  = io_data;
-        req->complete = ffs_ep0_async_io_complete;
-        list_add(&req->list, &ffs->ep0req->list);
-        ret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);
-        if (unlikely(ret)) {
-            usb_ep_free_request(ffs->gadget->ep0, req);
-            goto error;
-        }
-
-        ret = -EIOCBQUEUED;
-    }
-
-error:
-    return ret;
-}
-
-static long ffs_ep0_ioctl(struct file *file, unsigned code, unsigned long value)
-{
-    struct ffs_data *ffs = file->private_data;
-    long ret = 0;
-    unsigned int copied = 0;
-    struct ffs_memory *ffsm = NULL;
-    struct generic_memory mem;
-
-    ENTER();
-
-    switch (code) {
-    case FUNCTIONFS_ENDPOINT_QUEUE_INIT:
-        ret = kfifo_alloc(&ffs->reqEventFifo, MAX_REQUEST * sizeof(struct UsbFnReqEvent), GFP_KERNEL);
-        break;
-    case FUNCTIONFS_ENDPOINT_QUEUE_DEL:
-        kfifo_free(&ffs->reqEventFifo);
-        break;
-    case FUNCTIONFS_ENDPOINT_RELEASE_BUF:
-        if (copy_from_user(&mem, (void __user *)value, sizeof(mem)))
-        {
-            pr_info("copy from user failed\n");
-            return -EFAULT;
-        }
-        ffsm = generic_find_ep0_memory_area(ffs, mem.buf, mem.size);
-        if (ffsm == NULL)
-        {
-            return -EFAULT;
-        }
-        list_del(&ffsm->memlist);
-        kfree((void *)ffsm->mem);
-        kfree(ffsm);
-        break;
-    case FUNCTIONFS_ENDPOINT_READ:
-    case FUNCTIONFS_ENDPOINT_WRITE:
-    {
-        struct IoData myIoData;
-        struct ffs_io_data io_data, *p = &io_data;
-        ret = copy_from_user(&myIoData, (void __user *)value, sizeof(struct IoData));
-        if (unlikely(ret)) {
-            return -EFAULT;
-        }
-        if (myIoData.aio) {
-            p = kmalloc(sizeof(io_data), GFP_KERNEL);
-            if (unlikely(!p))
-                return -ENOMEM;
-        } else {
-            memset(p, 0, sizeof(*p));
-        }
-        memcpy(p, &myIoData, sizeof(struct IoData));
-        
-        ret = ffs_ep0_iorw(file, p);
-        if (ret == -EIOCBQUEUED) {
-            return 0;
-        }
-        if (p->aio)
-            kfree(p);
-        return ret;
-    }
-    case FUNCTIONFS_ENDPOINT_RW_CANCEL:
-    {
-        struct usb_request *req;
-        struct IoData myIoData;
-        ret = copy_from_user(&myIoData, (void __user *)value, sizeof(struct IoData));
-        if (unlikely(ret)) {
-            return -EFAULT;
-        }
-        ffsm = generic_find_ep0_memory_area(ffs, myIoData.buf, myIoData.len);
-        if (ffsm == NULL)
-        {
-            return -EFAULT;
-        }
-        list_for_each_entry(req, &ffs->ep0req->list, list) {
-            if (req->buf == (void *)(ffsm->mem + myIoData.buf - ffsm->vm_start)) {
-                usb_ep_dequeue(ffs->gadget->ep0, req);
-                return 0;
-            }
-        }
-        return -EFAULT;
-    }
-    case FUNCTIONFS_ENDPOINT_GET_REQ_STATUS:
-    {
-        struct usb_request *req;
-        struct IoData myIoData;
-        ret = copy_from_user(&myIoData, (void __user *)value, sizeof(struct IoData));
-        if (unlikely(ret)) {
-            return -EFAULT;
-        }
-        ffsm = generic_find_ep0_memory_area(ffs, myIoData.buf, myIoData.len);
-        if (ffsm == NULL)
-        {
-            return -EFAULT;
-        }
-        list_for_each_entry(req, &ffs->ep0req->list, list) {
-            if (req->buf == (void *)(ffsm->mem + myIoData.buf - ffsm->vm_start)) {
-                return req->status;
-            }
-        }
-        return -EFAULT;
-    }
-    case FUNCTIONFS_ENDPOINT_GET_EP0_EVENT:
-        if (!kfifo_is_empty(&ffs->reqEventFifo)) {
-            ret = kfifo_to_user(&ffs->reqEventFifo, (void __user *)value,
-            sizeof(struct UsbFnReqEvent), &copied) == 0 ? copied : -1;
-            if (ret > 0) {
-                ffs->setup_state = FFS_NO_SETUP;
-                return ret;
-            }
-        }
-
-        return -EFAULT;
-    }
-
-    return ret;
-}
-
-#ifdef CONFIG_COMPAT
-static long ffs_ep0_compat_ioctl(struct file *file, unsigned code,
-        unsigned long value)
-{
-    return ffs_ep0_ioctl(file, code, value);
-}
-#endif
-
-static __poll_t ffs_ep0_poll(struct file *file, poll_table *wait)
-{
-    struct ffs_data *ffs = file->private_data;
-    __poll_t mask = EPOLLWRNORM;
-    int ret;
-
-    ret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);
-    if (unlikely(ret < 0))
-        return mask;
-
-    switch (ffs->state) {
-    case FFS_READ_DESCRIPTORS:
-    case FFS_READ_STRINGS:
-        mask |= EPOLLOUT;
-        break;
-
-    case FFS_ACTIVE:
-        switch (ffs->setup_state) {
-        case FFS_NO_SETUP:
-            poll_wait(file, &ffs->ev.waitq, wait);
-            if (ffs->ev.count)
-                mask |= EPOLLIN;
-            break;
-
-        case FFS_SETUP_PENDING:
-        case FFS_SETUP_CANCELLED:
-            poll_wait(file, &ffs->wait_que, wait);
-            if (!kfifo_is_empty(&ffs->reqEventFifo))
-            {
-                mask |= EPOLLOUT;
-            }
-            break;
-        }
-    case FFS_CLOSING:
-        break;
-    case FFS_DEACTIVATED:
-        break;
-    }
-
-    mutex_unlock(&ffs->mutex);
-
-    return mask;
-}
-
-static int ffs_ep0_mmap(struct file *file, struct vm_area_struct *vma)
-{
-    struct ffs_data *ffs = file->private_data;
-    size_t size = vma->vm_end - vma->vm_start;
-    unsigned long flags;
-    struct ffs_memory *ffsm = NULL;
-    void *virt_mem = NULL;
-
-    if (ffs == NULL) {
-        pr_info("Invalid private parameter!\n");
-        return -EINVAL;
-    }
-    virt_mem = kmalloc(size, GFP_KERNEL);
-    if (virt_mem == NULL)
-    {
-        pr_info("%s alloc memory failed!\n", __FUNCTION__);
-        return -ENOMEM;
-    }
-    ffsm = kmalloc(sizeof(struct ffs_memory), GFP_KERNEL);
-    if (ffsm == NULL)
-    {
-        pr_info("%s alloc memory failed!\n", __FUNCTION__);
-        goto error_free_mem;
-    }
-    if (remap_pfn_range(vma, vma->vm_start, virt_to_phys(virt_mem)>>PAGE_SHIFT,
-        vma->vm_end - vma->vm_start, vma->vm_page_prot)) {
-        goto error_free_ffsm;
-    }
-    ffsm->mem      = (uint64_t)virt_mem;
-    ffsm->size     = size;
-    ffsm->vm_start = vma->vm_start;
-    INIT_LIST_HEAD(&ffsm->memlist);
-    spin_lock_irqsave(&ffs->mem_lock, flags);
-    list_add_tail(&ffsm->memlist, &ffs->memory_list);
-    spin_unlock_irqrestore(&ffs->mem_lock, flags);
-    return 0;
-error_free_ffsm:
-    kfree(ffsm);
-error_free_mem:
-    kfree(virt_mem);
-    return -1;
-}
-
-static const struct file_operations ffs_ep0_operations = {
-    .owner   = THIS_MODULE,
-    .llseek =    no_llseek,
-    .open =        ffs_ep0_open,
-    .write =    ffs_ep0_write,
-    .read =        ffs_ep0_read,
-    .release =    ffs_ep0_release,
-    .unlocked_ioctl =    ffs_ep0_ioctl,
-#ifdef CONFIG_COMPAT
-    .compat_ioctl = ffs_ep0_compat_ioctl,
-#endif
-    .poll =        ffs_ep0_poll,
-    .mmap =     ffs_ep0_mmap,
-};
-
-/* "Normal" endpoints operations ********************************************/
-static struct ffs_memory *generic_find_memory_area(struct ffs_epfile *epfile, uint64_t buf, uint32_t len)
-{
-    struct ffs_memory *ffsm = NULL, *iter = NULL;
-    uint64_t buf_start = buf;
-
-    list_for_each_entry(iter, &epfile->memory_list, memlist) {
-        if (buf_start >= iter->vm_start &&
-            buf_start < iter->vm_start + iter->size) {
-            if (len <= iter->vm_start + iter->size - buf_start) {
-                ffsm = iter;
-                break;
-            }
-        }
-    }
-    return ffsm;
-}
-
-static void ffs_epfile_io_complete(struct usb_ep *_ep, struct usb_request *req)
-{
-    ENTER();
-    if (likely(req->context)) {
-        struct ffs_ep *ep = _ep->driver_data;
-        ep->status = req->status ? req->status : req->actual;
-        complete(req->context);
-    }
-}
-
-static void epfile_task_proc(unsigned long context)
-{
-    struct ffs_io_data *io_data = (struct ffs_io_data *)context;
-    struct ffs_epfile *epfile = io_data->epfile;
-    unsigned long flags;
-
-    spin_lock_irqsave(&epfile->ffs->eps_lock, flags);
-    io_data->status = io_data->req->status;
-    io_data->actual = io_data->req->actual;
-    kfifo_in(&epfile->reqEventFifo, &io_data->buf, sizeof(struct UsbFnReqEvent));
-    list_del(&io_data->req->list);
-    usb_ep_free_request(io_data->ep, io_data->req);
-    kfree(io_data);
-    spin_unlock_irqrestore(&epfile->ffs->eps_lock, flags);
-    wake_up_all(&epfile->wait_que);
-}
-
-static void ffs_epfile_async_io_complete(struct usb_ep *_ep, struct usb_request *req)
-{
-    struct ffs_io_data *io_data = req->context;
-
-    tasklet_init(&io_data->task, epfile_task_proc, (uintptr_t)io_data);
-    tasklet_schedule(&io_data->task);
-
-}
-
-static int ffs_epfile_open(struct inode *inode, struct file *file)
-{
-    struct ffs_epfile *epfile  = container_of(inode->i_cdev, struct ffs_epfile, cdev);
-    ENTER();
-    if (WARN_ON(epfile->ffs->state != FFS_ACTIVE))
-        return -ENODEV;
-
-    file->private_data = epfile;
-    return 0;
-}
-
-static int ffs_epfile_release(struct inode *inode, struct file *file)
-{
-    ENTER();
-    return 0;
-}
-
-static int ffs_epfile_mmap(struct file *file, struct vm_area_struct *vma)
-{
-    struct ffs_epfile *epfile = file->private_data;
-    size_t size = vma->vm_end - vma->vm_start;
-    struct ffs_memory *ffsm = NULL;
-    unsigned long flags;
-    void *virt_mem = NULL;
-
-    if (epfile == NULL)
-    {
-        pr_info("Invalid private parameter!\n");
-        return -EINVAL;
-    }
-    virt_mem = kmalloc(size, GFP_KERNEL);
-    if (virt_mem == NULL)
-    {
-        pr_info("%s alloc memory failed!\n", __FUNCTION__);
-        return -ENOMEM;
-    }
-    ffsm = kmalloc(sizeof(struct ffs_memory), GFP_KERNEL);
-    if (ffsm == NULL)
-    {
-        pr_info("%s alloc memory failed!\n", __FUNCTION__);
-        goto error_free_mem;
-    }
-    if (remap_pfn_range(vma, vma->vm_start, virt_to_phys(virt_mem)>>PAGE_SHIFT,
-                vma->vm_end - vma->vm_start, vma->vm_page_prot))
-    {
-        goto error_free_ffsm;
-    }
-    ffsm->mem = (uint64_t)virt_mem;
-    ffsm->size = size;
-    ffsm->vm_start = vma->vm_start;
-    INIT_LIST_HEAD(&ffsm->memlist);
-    spin_lock_irqsave(&epfile->ffs->eps_lock, flags);
-    list_add_tail(&ffsm->memlist, &epfile->memory_list);
-    spin_unlock_irqrestore(&epfile->ffs->eps_lock, flags);
-
-    return 0;
-error_free_ffsm:
-    kfree(ffsm);
-error_free_mem:
-    kfree(virt_mem);
-
-    return -1;
-}
-
-static ssize_t ffs_epfile_iorw(struct file *file, struct ffs_io_data *io_data)
-{
-    struct ffs_epfile *epfile = file->private_data;
-    struct usb_request *req = NULL;
-    struct ffs_ep *ep = NULL;
-    struct ffs_memory *ffsm = NULL;
-    ssize_t ret, data_len = -EINVAL;
-    int halt;
-
-    /* Are we still active? */
-    if (WARN_ON(epfile->ffs->state != FFS_ACTIVE))
-        return -ENODEV;
-
-    /* Wait for endpoint to be enabled */
-    ep = epfile->ep;
-    if (!ep) {
-        if (file->f_flags & O_NONBLOCK)
-            return -EAGAIN;
-
-        ret = wait_event_interruptible(
-                epfile->ffs->wait, (ep = epfile->ep));
-        if (ret)
-            return -EINTR;
-    }
-
-    /* Do we halt? */
-    halt = (!io_data->read == !epfile->in);
-    if (halt && epfile->isoc)
-        return -EINVAL;
-
-    /* We will be using request and read_buffer */
-    ret = ffs_mutex_lock(&epfile->mutex, file->f_flags & O_NONBLOCK);
-    if (unlikely(ret))
-        goto error;
-
-    /* Allocate & copy */
-    if (!halt) {
-        struct usb_gadget *gadget;
-        /*
-         * if we _do_ wait above, the epfile->ffs->gadget might be NULL
-         * before the waiting completes, so do not assign to 'gadget'
-         * earlier
-         */
-        gadget = epfile->ffs->gadget;
-
-        spin_lock_irq(&epfile->ffs->eps_lock);
-        /* In the meantime, endpoint got disabled or changed. */
-        if (epfile->ep != ep) {
-            ret = -ESHUTDOWN;
-            goto error_lock;
-        }
-        data_len = io_data->len;
-        /*
-         * Controller may require buffer size to be aligned to
-         * maxpacketsize of an out endpoint.
-         */
-        if (io_data->read)
-            data_len = usb_ep_align_maybe(gadget, ep->ep, data_len);
-        spin_unlock_irq(&epfile->ffs->eps_lock);
-    }
-
-    spin_lock_irq(&epfile->ffs->eps_lock);
-    ffsm = generic_find_memory_area(epfile, io_data->buf, io_data->len);
-    if (ffsm == NULL)
-    {
-        return -EFAULT;
-    }
-    if (epfile->ep != ep) {
-        /* In the meantime, endpoint got disabled or changed. */
-        ret = -ESHUTDOWN;
-    }
-    else if (halt) {
-        ret = usb_ep_set_halt(ep->ep);
-        if (!ret)
-            ret = -EBADMSG;
-    }
-    else if (!io_data->aio) {
-        DECLARE_COMPLETION_ONSTACK(done);
-        bool interrupted = false;
-
-        req = ep->req;
-        req->buf      = (void *)(ffsm->mem + io_data->buf - ffsm->vm_start);
-        req->length   = data_len;
-
-        req->context  = &done;
-        req->complete = ffs_epfile_io_complete;
-
-        ret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);
-        if (unlikely(ret < 0))
-            goto error_lock;
-
-        spin_unlock_irq(&epfile->ffs->eps_lock);
-        if (io_data->timeout > 0) {
-            ret = wait_for_completion_interruptible_timeout(&done, io_data->timeout);
-            if (ret < 0) {
-                /*
-                 * To avoid race condition with ffs_epfile_io_complete,
-                 * dequeue the request first then check
-                 * status. usb_ep_dequeue API should guarantee no race
-                 * condition with req->complete callback.
-                 */
-                usb_ep_dequeue(ep->ep, req);
-                wait_for_completion(&done);
-                interrupted = ep->status < 0;
-            } else if (ret == 0) {
-                ret = -EBUSY;
-                usb_ep_dequeue(ep->ep, req);
-                wait_for_completion(&done);
-                goto error_mutex;
-            }
-        } else {
-            ret = wait_for_completion_interruptible(&done);
-            if (ret < 0) {
-                usb_ep_dequeue(ep->ep, req);
-                wait_for_completion(&done);
-                interrupted = ep->status < 0;
-            }
-        }
-
-        if (interrupted) {
-            ret = -EINTR;
-        } else {
-            ret = req->actual;
-        }
-        goto error_mutex;
-    }
-    else if (!(req = usb_ep_alloc_request(ep->ep, GFP_ATOMIC))) {
-        ret = -ENOMEM;
-    }
-    else {
-        req->buf     = (void *)(ffsm->mem + io_data->buf - ffsm->vm_start);
-        req->length  = data_len;
-
-        io_data->ep     = ep->ep;
-        io_data->req    = req;
-        io_data->epfile = epfile;
-
-        req->context  = io_data;
-        req->complete = ffs_epfile_async_io_complete;
-        list_add(&req->list, &ep->req->list);
-        ret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);
-        if (unlikely(ret)) {
-            usb_ep_free_request(ep->ep, req);
-            goto error_lock;
-        }
-
-        ret = -EIOCBQUEUED;
-    }
-
-error_lock:
-    spin_unlock_irq(&epfile->ffs->eps_lock);
-error_mutex:
-    mutex_unlock(&epfile->mutex);
-error:
-    return ret;
-}
-
-static long ffs_epfile_ioctl(struct file *file, unsigned code, unsigned long value)
-{
-    struct ffs_epfile *epfile = file->private_data;
-    struct ffs_ep *ep = epfile->ep;
-    int ret = 0;
-    struct generic_memory mem;
-    struct ffs_memory *ffsm = NULL;
-
-    ENTER();
-
-    if (WARN_ON(epfile->ffs->state != FFS_ACTIVE))
-        return -ENODEV;
-
-    spin_lock_irq(&epfile->ffs->eps_lock);
-
-    switch (code) {
-    case FUNCTIONFS_ENDPOINT_QUEUE_INIT:
-        ret = kfifo_alloc(&epfile->reqEventFifo, MAX_REQUEST * sizeof(struct UsbFnReqEvent), GFP_KERNEL);
-        break;
-    case FUNCTIONFS_ENDPOINT_QUEUE_DEL:
-        kfifo_free(&epfile->reqEventFifo);
-        break;
-    case FUNCTIONFS_ENDPOINT_RELEASE_BUF:
-        if (copy_from_user(&mem, (void __user *)value, sizeof(mem)))
-        {
-            pr_info("copy from user failed\n");
-            return -EFAULT;
-        }
-        ffsm = generic_find_memory_area(epfile, mem.buf, mem.size);
-        if (ffsm == NULL)
-        {
-            return -EFAULT;
-        }
-        list_del(&ffsm->memlist);
-        kfree((void *)ffsm->mem);
-        kfree(ffsm);
-        break;
-    case FUNCTIONFS_ENDPOINT_READ:
-    case FUNCTIONFS_ENDPOINT_WRITE:
-    {
-        struct IoData myIoData;
-        struct ffs_io_data io_data, *p = &io_data;
-        ret = copy_from_user(&myIoData, (void __user *)value, sizeof(struct IoData));
-        if (unlikely(ret)) {
-            spin_unlock_irq(&epfile->ffs->eps_lock);
-            return -EFAULT;
-        }
-        if (myIoData.aio) {
-            p = kmalloc(sizeof(io_data), GFP_KERNEL);
-            if (unlikely(!p)) {
-                spin_unlock_irq(&epfile->ffs->eps_lock);
-                return -ENOMEM;
-            }
-        } else {
-            memset(p,  0, sizeof(*p));
-        }
-        memcpy(p, &myIoData, sizeof(struct IoData));
-
-        spin_unlock_irq(&epfile->ffs->eps_lock);
-        ret = ffs_epfile_iorw(file, p);
-        if (ret == -EIOCBQUEUED) {
-            return 0;
-        }
-        if (p->aio)
-            kfree(p);
-        return ret;
-    }
-    case FUNCTIONFS_ENDPOINT_RW_CANCEL:
-    {
-        struct usb_request *req;
-        struct IoData myIoData;
-        if (!ep) {
-            spin_unlock_irq(&epfile->ffs->eps_lock);
-            return -EFAULT;
-        }
-        ret = copy_from_user(&myIoData, (void __user *)value, sizeof(struct IoData));
-        if (unlikely(ret)) {
-            spin_unlock_irq(&epfile->ffs->eps_lock);
-            return -EFAULT;
-        }
-        ffsm = generic_find_memory_area(epfile, myIoData.buf, myIoData.len);
-        if (ffsm == NULL)
-        {
-            return -EFAULT;
-        }
-        list_for_each_entry(req, &epfile->ep->req->list, list) {
-            if (req->buf == (void *)(ffsm->mem + myIoData.buf - ffsm->vm_start)) {
-                usb_ep_dequeue(epfile->ep->ep, req);
-                spin_unlock_irq(&epfile->ffs->eps_lock);
-                return 0;
-            }
-        }
-        spin_unlock_irq(&epfile->ffs->eps_lock);
-        return -EFAULT;
-    }
-    case FUNCTIONFS_ENDPOINT_GET_REQ_STATUS:
-    {
-        struct usb_request *req;
-        struct IoData myIoData;
-        if (!ep) {
-            spin_unlock_irq(&epfile->ffs->eps_lock);
-            return -EFAULT;
-        }
-        ret = copy_from_user(&myIoData,(void __user *)value, sizeof(struct IoData));
-        if (unlikely(ret)) {
-            spin_unlock_irq(&epfile->ffs->eps_lock);
-            return -EFAULT;
-        }
-        ffsm = generic_find_memory_area(epfile, myIoData.buf, myIoData.len);
-        if (ffsm == NULL)
-        {
-            return -EFAULT;
-        }
-        list_for_each_entry(req, &epfile->ep->req->list, list) {
-            if (req->buf == (void *)(ffsm->mem + myIoData.buf - ffsm->vm_start)) {
-                spin_unlock_irq(&epfile->ffs->eps_lock);
-                return req->status;
-            }
-        }
-        spin_unlock_irq(&epfile->ffs->eps_lock);
-        return -EFAULT;
-    }
-    case FUNCTIONFS_FIFO_STATUS:
-        ret = usb_ep_fifo_status(epfile->ep->ep);
-        break;
-    case FUNCTIONFS_FIFO_FLUSH:
-        usb_ep_fifo_flush(epfile->ep->ep);
-        ret = 0;
-        break;
-    case FUNCTIONFS_CLEAR_HALT:
-        ret = usb_ep_clear_halt(epfile->ep->ep);
-        break;
-    case FUNCTIONFS_ENDPOINT_REVMAP:
-        ret = epfile->ep->num;
-        break;
-    case FUNCTIONFS_ENDPOINT_DESC:
-    {
-        int desc_idx;
-        int i;
-        struct usb_endpoint_descriptor *desc;
-
-        switch (epfile->ffs->speed) {
-        case USB_SPEED_SUPER:
-            desc_idx = 2;
-            break;
-        case USB_SPEED_HIGH:
-            desc_idx = 1;
-            break;
-        default:
-            desc_idx = 1;
-        }
-        for (i = 0; i < epfile->ffs->eps_count; i++) {
-            if (epfile->ffs->epfiles + i == epfile)
-                break;
-        }
-        ep = epfile->ffs->eps + i;
-        desc = ep->descs[desc_idx];
-        spin_unlock_irq(&epfile->ffs->eps_lock);
-        ret = copy_to_user((void __user *)value, desc, desc->bLength);
-        if (ret)
-            ret = -EFAULT;
-        return ret;
-    }
-    default:
-        ret = -ENOTTY;
-    }
-    spin_unlock_irq(&epfile->ffs->eps_lock);
-
-    return ret;
-}
-
-static ssize_t ffs_epfile_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
-{
-    int status = 0;
-    unsigned int copied = 0;
-    unsigned long flags;
-    struct ffs_epfile *epfile = file->private_data;
-    ENTER();
-    if (kfifo_is_empty(&epfile->reqEventFifo)) {
-        return 0;
-    }
-    spin_lock_irqsave(&epfile->ffs->eps_lock, flags);
-    status = kfifo_to_user(&epfile->reqEventFifo, buf, count, &copied) == 0 ? copied : -1;
-    spin_unlock_irqrestore(&epfile->ffs->eps_lock, flags);
-
-    return status;
-}
-
-static ssize_t ffs_epfile_write(struct file *file, const char __user *buf, size_t count, loff_t *f_pos)
-{
-    return count;
-}
-
-static unsigned int ffs_epfile_poll(struct file *file, struct poll_table_struct * wait)
-{
-    unsigned int mask = 0;
-    struct ffs_epfile *epfile = file->private_data;
-    ENTER();
-    poll_wait(file, &epfile->wait_que, wait);
-    if (!kfifo_is_empty(&epfile->reqEventFifo)) {
-        mask |= POLLIN;
-    }
-    return mask;
-}
-
-#ifdef CONFIG_COMPAT
-static long ffs_epfile_compat_ioctl(struct file *file, unsigned code,
-        unsigned long value)
-{
-    return ffs_epfile_ioctl(file, code, value);
-}
-#endif
-
-static const struct file_operations ffs_epfile_operations = {
-    .owner   = THIS_MODULE,
-    .llseek =    no_llseek,
-    .mmap = ffs_epfile_mmap,
-    .read    = ffs_epfile_read,
-    .write   = ffs_epfile_write,
-    .poll = ffs_epfile_poll,
-    .open =        ffs_epfile_open,
-    .release =    ffs_epfile_release,
-    .unlocked_ioctl =    ffs_epfile_ioctl,
-#ifdef CONFIG_COMPAT
-    .compat_ioctl = ffs_epfile_compat_ioctl,
-#endif
-};
-
-/* ffs_data and ffs_function construction and destruction code **************/
-static void ffs_data_clear(struct ffs_data *ffs);
-static void ffs_data_reset(struct ffs_data *ffs);
-static dev_t g_dev;
-#define MAX_EP_DEV 10
-static long usbfn_ioctl(struct file *file, unsigned int cmd, unsigned long value)
-{
-    long ret;
-    ENTER();
-    switch(cmd)
-    {
-        case FUNCTIONFS_NEWFN:
-        {
-            struct ffs_dev *ffs_dev;
-            struct ffs_data    *ffs;
-            struct FuncNew newfn;
-            char nameEp0[MAX_NAMELEN];
-            ret = copy_from_user(&newfn, (void __user *)value, sizeof(struct FuncNew ));
-            if (unlikely(ret)) {
-                return -EFAULT;
-            }
-            ffs = ffs_data_new(newfn.name);
-            if (unlikely(!ffs)) {
-                return (-ENOMEM);
-            }
-
-            memcpy(ffs->dev_name, newfn.name, newfn.nameLen);
-            
-            if (unlikely(!ffs->dev_name)) {
-                ffs_data_put(ffs);
-                return (-ENOMEM);
-            }
-
-            if (sprintf(nameEp0, "%s.ep%u", ffs->dev_name, 0) < 0) {
-                ffs_data_put(ffs);
-                return -EFAULT;
-            }
-            ffs_dev = ffs_acquire_dev(newfn.name);
-            if (IS_ERR(ffs_dev)) {
-                ffs_data_put(ffs);
-                return (-ENODEV);
-            }
-            ffs->private_data = ffs_dev;
-
-            ret = alloc_chrdev_region(&g_dev, 0, MAX_EP_DEV, nameEp0);
-            if (ret < 0) {
-                ffs_release_dev(ffs);
-                ffs_data_put(ffs);
-                return -EBUSY;
-            }
-            cdev_init(&ffs->cdev, &ffs_ep0_operations);
-            ffs->devno = MKDEV(MAJOR(g_dev), 0);
-            ret = cdev_add(&ffs->cdev, ffs->devno, 1);
-            if (ret) {
-                ffs_release_dev(ffs);
-                ffs_data_put(ffs);
-                return -EBUSY;
-            }
-
-            ffs->fn_device = device_create(ffs_class, NULL, ffs->devno, NULL, nameEp0);
-            if (IS_ERR(ffs->fn_device)) {
-                cdev_del(&ffs->cdev);
-                ffs_release_dev(ffs);
-                ffs_data_put(ffs);
-                return -EBUSY;
-            }
-            return 0;
-        }
-        case FUNCTIONFS_DELFN:
-        {
-            struct FuncNew newfn;
-            struct ffs_data    *ffs;
-            struct ffs_dev *ffs_dev;
-            ret = copy_from_user(&newfn, (void __user *)value, sizeof(struct FuncNew ));
-            if (unlikely(ret)) {
-                return -EFAULT;
-            }
-
-            ffs_dev = _ffs_find_dev(newfn.name);
-            if (IS_ERR(ffs_dev)) {
-                return -EFAULT;
-            }
-            ffs = ffs_dev->ffs_data;
-            device_destroy(ffs_class, ffs->devno);
-            cdev_del(&ffs->cdev);
-            unregister_chrdev_region(g_dev, MAX_EP_DEV);
-            ffs_release_dev(ffs);
-            ffs_data_clear(ffs);
-            destroy_workqueue(ffs->io_completion_wq);
-            kfree(ffs);
-            return 0;
-        }
-        default:
-            ret = -ENOTTY;
-        }
-
-    return ret;
-}
-
-static int usbfn_open(struct inode *inode, struct file *file)
-{
-    return 0;
-}
-
-static int usbfn_release(struct inode *inode, struct file *file)
-{
-    return 0;
-}
-
-static struct file_operations usbfn_fops = {
-    .owner   = THIS_MODULE,
-    .unlocked_ioctl   = usbfn_ioctl,
-    .open    = usbfn_open,
-    .release = usbfn_release,
-#ifdef CONFIG_COMPAT
-    .compat_ioctl = usbfn_ioctl,
-#endif
-};
-
-static struct miscdevice usbfn_misc = {
-    .minor = MISC_DYNAMIC_MINOR,
-    .name = "usbfn",
-    .fops = &usbfn_fops,
-};
-
-/* Driver's main init/cleanup functions *************************************/
-static int functionfs_init(void)
-{
-    int ret;
-
-    ENTER();
-    ret = misc_register(&usbfn_misc);
-    if (likely(!ret))
-        pr_info("file system registered\n");
-    else
-        pr_err("failed registering file system (%d)\n", ret);
-
-    ffs_class = class_create(THIS_MODULE, "functionfs");
-    if (IS_ERR(ffs_class))
-        return PTR_ERR(ffs_class);
-
-    ffs_class->devnode = ffs_devnode;
-
-    return ret;
-}
-
-static void functionfs_cleanup(void)
-{
-    ENTER();
-    class_destroy(ffs_class);
-    misc_deregister(&usbfn_misc);
-}
-
-static void ffs_data_get(struct ffs_data *ffs)
-{
-    ENTER();
-    refcount_inc(&ffs->ref);
-}
-
-static void ffs_data_put(struct ffs_data *ffs)
-{
-    ENTER();
-    if (unlikely(refcount_dec_and_test(&ffs->ref))) {
-        pr_info("%s(): freeing\n", __func__);
-        ffs_data_clear(ffs);
-        BUG_ON(waitqueue_active(&ffs->ev.waitq) ||
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
-            swait_active(&ffs->ep0req_completion.wait) ||
-#else
-            waitqueue_active(&ffs->ep0req_completion.wait) ||
-#endif
-               waitqueue_active(&ffs->wait) ||
-               waitqueue_active(&ffs->wait_que));
-        destroy_workqueue(ffs->io_completion_wq);
-        kfree(ffs);
-    }
-}
-
-static struct ffs_data *ffs_data_new(const char *dev_name)
-{
-    struct ffs_data *ffs = kzalloc(sizeof *ffs, GFP_KERNEL);
-    if (unlikely(!ffs))
-        return NULL;
-
-    ENTER();
-
-    ffs->io_completion_wq = alloc_ordered_workqueue("%s", 0, dev_name);
-    if (!ffs->io_completion_wq) {
-        kfree(ffs);
-        return NULL;
-    }
-
-    refcount_set(&ffs->ref, 1);
-    atomic_set(&ffs->opened, 0);
-    ffs->state = FFS_READ_DESCRIPTORS;
-    mutex_init(&ffs->mutex);
-    spin_lock_init(&ffs->eps_lock);
-    spin_lock_init(&ffs->mem_lock);
-    init_waitqueue_head(&ffs->ev.waitq);
-    init_waitqueue_head(&ffs->wait);
-    init_waitqueue_head(&ffs->wait_que);
-    init_completion(&ffs->ep0req_completion);
-    INIT_LIST_HEAD(&ffs->memory_list);
-    ffs->ev.can_stall = 1;
-
-    return ffs;
-}
-
-static void ffs_data_clear(struct ffs_data *ffs)
-{
-    ENTER();
-
-    ffs_closed(ffs);
-
-    BUG_ON(ffs->gadget);
-
-    if (ffs->epfiles)
-        ffs_epfiles_destroy(ffs->epfiles, ffs->eps_count);
-
-    if (ffs->ffs_eventfd)
-        eventfd_ctx_put(ffs->ffs_eventfd);
-
-    kfree(ffs->raw_descs_data);
-    kfree(ffs->raw_strings);
-    kfree(ffs->stringtabs);
-}
-
-static void ffs_data_reset(struct ffs_data *ffs)
-{
-    ENTER();
-
-    ffs_data_clear(ffs);
-
-    ffs->epfiles = NULL;
-    ffs->raw_descs_data = NULL;
-    ffs->raw_descs = NULL;
-    ffs->raw_strings = NULL;
-    ffs->stringtabs = NULL;
-
-    ffs->raw_descs_length = 0;
-    ffs->fs_descs_count = 0;
-    ffs->hs_descs_count = 0;
-    ffs->ss_descs_count = 0;
-
-    ffs->strings_count = 0;
-    ffs->interfaces_count = 0;
-    ffs->eps_count = 0;
-
-    ffs->ev.count = 0;
-
-    ffs->state = FFS_READ_DESCRIPTORS;
-    ffs->setup_state = FFS_NO_SETUP;
-    ffs->flags = 0;
-}
-
-static int functionfs_bind(struct ffs_data *ffs, struct usb_composite_dev *cdev)
-{
-    struct usb_gadget_strings **lang;
-    int first_id;
-
-    ENTER();
-
-    if (WARN_ON(ffs->state != FFS_ACTIVE
-         || test_and_set_bit(FFS_FL_BOUND, &ffs->flags)))
-        return -EBADFD;
-
-    first_id = usb_string_ids_n(cdev, ffs->strings_count);
-    if (unlikely(first_id < 0))
-        return first_id;
-
-    ffs->ep0req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);
-    if (unlikely(!ffs->ep0req))
-        return -ENOMEM;
-    ffs->ep0req->complete = ffs_ep0_complete;
-    ffs->ep0req->context = ffs;
-    INIT_LIST_HEAD(&ffs->ep0req->list);
-
-    lang = ffs->stringtabs;
-    if (lang) {
-        for (; *lang; ++lang) {
-            struct usb_string *str = (*lang)->strings;
-            int id = first_id;
-            for (; str->s; ++id, ++str)
-                str->id = id;
-        }
-    }
-
-    ffs->gadget = cdev->gadget;
-    ffs->speed = cdev->gadget->speed;
-    ffs_data_get(ffs);
-    return 0;
-}
-
-static void functionfs_unbind(struct ffs_data *ffs)
-{
-    ENTER();
-
-    if (!WARN_ON(!ffs->gadget)) {
-        usb_ep_free_request(ffs->gadget->ep0, ffs->ep0req);
-        ffs->ep0req = NULL;
-        ffs->gadget = NULL;
-        clear_bit(FFS_FL_BOUND, &ffs->flags);
-        ffs_data_put(ffs);
-    }
-}
-
-static int ffs_epfiles_create(struct ffs_data *ffs)
-{
-    struct ffs_epfile *epfile = NULL, *epfiles = NULL;
-    unsigned int i, count ,ret;
-
-    ENTER();
-
-    count = ffs->eps_count;
-    epfiles = kcalloc(count, sizeof(*epfiles), GFP_KERNEL);
-    if (!epfiles)
-        return -ENOMEM;
-
-    epfile = epfiles;
-    for (i = 1; i <= count; ++i, ++epfile) {
-        epfile->ffs = ffs;
-        mutex_init(&epfile->mutex);
-        INIT_LIST_HEAD(&epfile->memory_list);
-        init_waitqueue_head(&epfile->wait_que);
-        if (ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR) {
-            if (sprintf(epfile->name, "%s.ep%02x", ffs->dev_name, ffs->eps_addrmap[i]) < 0) {
-                return -EFAULT;
-            }
-        } else {
-            if (sprintf(epfile->name, "%s.ep%u", ffs->dev_name, i) < 0) {
-                return -EFAULT;
-            }
-        }
-
-        cdev_init(&epfile->cdev, &ffs_epfile_operations);
-        epfile->devno=MKDEV(MAJOR(ffs->devno), i);
-        ret = cdev_add(&epfile->cdev, epfile->devno, 1);
-        if (ret)
-        {
-            ffs_epfiles_destroy(epfiles, i - 1);
-            return -EBUSY;
-        }
-
-        epfile->device = device_create(ffs_class, NULL, epfile->devno, NULL, epfile->name);
-        if (IS_ERR(epfile->device))
-        {
-            cdev_del(&epfile->cdev);
-            ffs_epfiles_destroy(epfiles, i - 1);
-            return -EBUSY;
-        }
-    }
-
-    ffs->epfiles = epfiles;
-    return 0;
-}
-
-static void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count)
-{
-    struct ffs_epfile *epfile = epfiles;
-
-    ENTER();
-
-    for (; count; --count, ++epfile) {
-        BUG_ON(mutex_is_locked(&epfile->mutex));
-        device_destroy(ffs_class, epfile->devno);
-        cdev_del(&epfile->cdev);
-    }
-
-    kfree(epfiles);
-}
-
-static void ffs_func_eps_disable(struct ffs_function *func)
-{
-    struct ffs_ep *ep         = func->eps;
-    struct ffs_epfile *epfile = func->ffs->epfiles;
-    unsigned count            = func->ffs->eps_count;
-    unsigned long flags;
-
-    spin_lock_irqsave(&func->ffs->eps_lock, flags);
-    while (count--) {
-        /* pending requests get nuked */
-        if (likely(ep->ep))
-            usb_ep_disable(ep->ep);
-        ++ep;
-
-        if (epfile) {
-            epfile->ep = NULL;
-            ++epfile;
-        }
-    }
-    spin_unlock_irqrestore(&func->ffs->eps_lock, flags);
-}
-
-static int ffs_func_eps_enable(struct ffs_function *func)
-{
-    struct ffs_data *ffs      = func->ffs;
-    struct ffs_ep *ep         = func->eps;
-    struct ffs_epfile *epfile = ffs->epfiles;
-    unsigned count            = ffs->eps_count;
-    unsigned long flags;
-    int ret = 0;
-
-    spin_lock_irqsave(&func->ffs->eps_lock, flags);
-    while(count--) {
-        ep->ep->driver_data = ep;
-
-        ret = config_ep_by_speed(func->gadget, &func->function, ep->ep);
-        if (ret) {
-            pr_err("%s: config_ep_by_speed(%s) returned %d\n",
-                    __func__, ep->ep->name, ret);
-            break;
-        }
-
-        ret = usb_ep_enable(ep->ep);
-        if (likely(!ret)) {
-            epfile->ep = ep;
-            epfile->in = usb_endpoint_dir_in(ep->ep->desc);
-            epfile->isoc = usb_endpoint_xfer_isoc(ep->ep->desc);
-        } else {
-            break;
-        }
-
-        ++ep;
-        ++epfile;
-    }
-
-    wake_up_interruptible(&ffs->wait);
-    spin_unlock_irqrestore(&func->ffs->eps_lock, flags);
-
-    return ret;
-}
-
-/* Parsing and building descriptors and strings *****************************/
-
-/*
- * This validates if data pointed by data is a valid USB descriptor as
- * well as record how many interfaces, endpoints and strings are
- * required by given configuration.  Returns address after the
- * descriptor or NULL if data is invalid.
- */
-enum ffs_entity_type {
-    FFS_DESCRIPTOR, FFS_INTERFACE, FFS_STRING, FFS_ENDPOINT
-};
-
-enum ffs_os_desc_type {
-    FFS_OS_DESC, FFS_OS_DESC_EXT_COMPAT, FFS_OS_DESC_EXT_PROP
-};
-
-typedef int (*ffs_entity_callback)(enum ffs_entity_type entity, u8 *valuep,
-                struct usb_descriptor_header *desc,
-                void *priv);
-
-typedef int (*ffs_os_desc_callback)(enum ffs_os_desc_type entity,
-                struct usb_os_desc_header *h, void *data,
-                unsigned len, void *priv);
-
-static int __must_check ffs_do_single_desc(char *data, unsigned len,
-                ffs_entity_callback entity,
-                void *priv)
-{
-    struct usb_descriptor_header *_ds = (void *)data;
-    u8 length;
-    int ret;
-
-    ENTER();
-
-    /* At least two bytes are required: length and type */
-    if (len < 2) {
-        pr_vdebug("descriptor too short\n");
-        return -EINVAL;
-    }
-
-    /* If we have at least as many bytes as the descriptor takes? */
-    length = _ds->bLength;
-    if (len < length) {
-        pr_vdebug("descriptor longer then available data\n");
-        return -EINVAL;
-    }
-
-#define __entity_check_INTERFACE(val)  1
-#define __entity_check_STRING(val)     (val)
-#define __entity_check_ENDPOINT(val)   ((val) & USB_ENDPOINT_NUMBER_MASK)
-#define __entity(type, val) do {                    \
-        pr_vdebug("entity " #type "(%02x)\n", (val));        \
-        if (unlikely(!__entity_check_ ##type(val))) {        \
-            pr_vdebug("invalid entity's value\n");        \
-            return -EINVAL;                    \
-        }                            \
-        ret = entity(FFS_ ##type, &val, _ds, priv);        \
-        if (unlikely(ret < 0)) {                \
-            pr_debug("entity " #type "(%02x); ret = %d\n",    \
-                 (val), ret);                \
-            return ret;                    \
-        }                            \
-    } while (0)
-
-    /* Parse descriptor depending on type. */
-    switch (_ds->bDescriptorType) {
-    case USB_DT_DEVICE:
-    case USB_DT_CONFIG:
-    case USB_DT_STRING:
-    case USB_DT_DEVICE_QUALIFIER:
-        /* function can't have any of those */
-        pr_vdebug("descriptor reserved for gadget: %d\n",
-              _ds->bDescriptorType);
-        return -EINVAL;
-
-    case USB_DT_INTERFACE: {
-        struct usb_interface_descriptor *ds = (void *)_ds;
-        pr_vdebug("interface descriptor\n");
-        if (length != sizeof *ds)
-            goto inv_length;
-
-        __entity(INTERFACE, ds->bInterfaceNumber);
-        if (ds->iInterface)
-            __entity(STRING, ds->iInterface);
-    }
-        break;
-
-    case USB_DT_ENDPOINT: {
-        struct usb_endpoint_descriptor *ds = (void *)_ds;
-        pr_vdebug("endpoint descriptor\n");
-        if (length != USB_DT_ENDPOINT_SIZE &&
-            length != USB_DT_ENDPOINT_AUDIO_SIZE)
-            goto inv_length;
-        __entity(ENDPOINT, ds->bEndpointAddress);
-    }
-        break;
-
-    case HID_DT_HID:
-        pr_vdebug("hid descriptor\n");
-        if (length != sizeof(struct hid_descriptor))
-            goto inv_length;
-        break;
-
-    case USB_DT_OTG:
-        if (length != sizeof(struct usb_otg_descriptor))
-            goto inv_length;
-        break;
-
-    case USB_DT_INTERFACE_ASSOCIATION: {
-        struct usb_interface_assoc_descriptor *ds = (void *)_ds;
-        pr_vdebug("interface association descriptor\n");
-        if (length != sizeof *ds)
-            goto inv_length;
-        if (ds->iFunction)
-            __entity(STRING, ds->iFunction);
-    }
-        break;
-
-    case USB_DT_SS_ENDPOINT_COMP:
-        pr_vdebug("EP SS companion descriptor\n");
-        if (length != sizeof(struct usb_ss_ep_comp_descriptor))
-            goto inv_length;
-        break;
-
-    case USB_DT_OTHER_SPEED_CONFIG:
-    case USB_DT_INTERFACE_POWER:
-    case USB_DT_DEBUG:
-    case USB_DT_SECURITY:
-    case USB_DT_CS_RADIO_CONTROL:
-        pr_vdebug("unimplemented descriptor: %d\n", _ds->bDescriptorType);
-        break;
-    default:
-        /* We should never be here */
-        pr_vdebug("unknown descriptor: %d\n", _ds->bDescriptorType);
-        break;
-inv_length:
-        pr_vdebug("invalid length: %d (descriptor %d)\n",
-              _ds->bLength, _ds->bDescriptorType);
-        return -EINVAL;
-    }
-
-#undef __entity
-#undef __entity_check_DESCRIPTOR
-#undef __entity_check_INTERFACE
-#undef __entity_check_STRING
-#undef __entity_check_ENDPOINT
-
-    return length;
-}
-
-static int __must_check ffs_do_descs(unsigned count, char *data, unsigned len,
-                ffs_entity_callback entity, void *priv)
-{
-    const unsigned _len = len;
-    uintptr_t num = 0;
-
-    ENTER();
-
-    for (;;) {
-        int ret;
-
-        if (num == count)
-            data = NULL;
-
-        /* Record "descriptor" entity */
-        ret = entity(FFS_DESCRIPTOR, (u8 *)num, (void *)data, priv);
-        if (unlikely(ret < 0)) {
-            pr_debug("entity DESCRIPTOR(%02lx); ret = %d\n",
-                 num, ret);
-            return ret;
-        }
-
-        if (!data)
-            return _len - len;
-
-        ret = ffs_do_single_desc(data, len, entity, priv);
-        if (unlikely(ret < 0)) {
-            pr_debug("%s returns %d\n", __func__, ret);
-            return ret;
-        }
-
-        len -= ret;
-        data += ret;
-        ++num;
-    }
-}
-
-static int __ffs_data_do_entity(enum ffs_entity_type type,
-                u8 *valuep, struct usb_descriptor_header *desc,
-                void *priv)
-{
-    struct ffs_desc_helper *helper = priv;
-    struct usb_endpoint_descriptor *d = NULL;
-
-    ENTER();
-
-    switch (type) {
-    case FFS_DESCRIPTOR:
-        break;
-
-    case FFS_INTERFACE:
-        /*
-         * Interfaces are indexed from zero so if we
-         * encountered interface "n" then there are at least
-         * "n+1" interfaces.
-         */
-        if (*valuep >= helper->interfaces_count)
-            helper->interfaces_count = *valuep + 1;
-        break;
-
-    case FFS_STRING:
-        /*
-         * Strings are indexed from 1 (0 is reserved
-         * for languages list)
-         */
-        if (*valuep > helper->ffs->strings_count)
-            helper->ffs->strings_count = *valuep;
-        break;
-
-    case FFS_ENDPOINT:
-        d = (void *)desc;
-        helper->eps_count++;
-        if (helper->eps_count >= FFS_MAX_EPS_COUNT)
-            return -EINVAL;
-        /* Check if descriptors for any speed were already parsed */
-        if (!helper->ffs->eps_count && !helper->ffs->interfaces_count)
-            helper->ffs->eps_addrmap[helper->eps_count] =
-                d->bEndpointAddress;
-        else if (helper->ffs->eps_addrmap[helper->eps_count] !=
-                d->bEndpointAddress)
-            return -EINVAL;
-        break;
-    }
-
-    return 0;
-}
-
-static int __ffs_do_os_desc_header(enum ffs_os_desc_type *next_type,
-                struct usb_os_desc_header *desc)
-{
-    u16 bcd_version = le16_to_cpu(desc->bcdVersion);
-    u16 w_index = le16_to_cpu(desc->wIndex);
-
-    if (bcd_version != 1) {
-        pr_vdebug("unsupported os descriptors version: %d",
-              bcd_version);
-        return -EINVAL;
-    }
-    switch (w_index) {
-    case 0x4:
-        *next_type = FFS_OS_DESC_EXT_COMPAT;
-        break;
-    case 0x5:
-        *next_type = FFS_OS_DESC_EXT_PROP;
-        break;
-    default:
-        pr_vdebug("unsupported os descriptor type: %d", w_index);
-        return -EINVAL;
-    }
-
-    return sizeof(*desc);
-}
-
-/*
- * Process all extended compatibility/extended property descriptors
- * of a feature descriptor
- */
-static int __must_check ffs_do_single_os_desc(char *data, unsigned len,
-                enum ffs_os_desc_type type,
-                u16 feature_count,
-                ffs_os_desc_callback entity,
-                void *priv,
-                struct usb_os_desc_header *h)
-{
-    int ret;
-    const unsigned _len = len;
-
-    ENTER();
-
-    /* loop over all ext compat/ext prop descriptors */
-    while (feature_count--) {
-        ret = entity(type, h, data, len, priv);
-        if (unlikely(ret < 0)) {
-            pr_debug("bad OS descriptor, type: %d\n", type);
-            return ret;
-        }
-        data += ret;
-        len -= ret;
-    }
-    return _len - len;
-}
-
-/* Process a number of complete Feature Descriptors (Ext Compat or Ext Prop) */
-static int __must_check ffs_do_os_descs(unsigned count,
-                char *data, unsigned len,
-                ffs_os_desc_callback entity, void *priv)
-{
-    const unsigned _len = len;
-    unsigned long num = 0;
-
-    ENTER();
-
-    for (num = 0; num < count; ++num) {
-        int ret;
-        enum ffs_os_desc_type type;
-        u16 feature_count;
-        struct usb_os_desc_header *desc = (void *)data;
-
-        if (len < sizeof(*desc))
-            return -EINVAL;
-
-        /*
-         * Record "descriptor" entity.
-         * Process dwLength, bcdVersion, wIndex, get b/wCount.
-         * Move the data pointer to the beginning of extended
-         * compatibilities proper or extended properties proper
-         * portions of the data
-         */
-        if (le32_to_cpu(desc->dwLength) > len)
-            return -EINVAL;
-
-        ret = __ffs_do_os_desc_header(&type, desc);
-        if (unlikely(ret < 0)) {
-            pr_debug("entity OS_DESCRIPTOR(%02lx); ret = %d\n",
-                 num, ret);
-            return ret;
-        }
-        /*
-         * 16-bit hex "?? 00" Little Endian looks like 8-bit hex "??"
-         */
-        feature_count = le16_to_cpu(desc->wCount);
-        if (type == FFS_OS_DESC_EXT_COMPAT &&
-            (feature_count > 255 || desc->Reserved))
-                return -EINVAL;
-        len -= ret;
-        data += ret;
-
-        /*
-         * Process all function/property descriptors
-         * of this Feature Descriptor
-         */
-        ret = ffs_do_single_os_desc(data, len, type,
-                        feature_count, entity, priv, desc);
-        if (unlikely(ret < 0)) {
-            pr_debug("%s returns %d\n", __func__, ret);
-            return ret;
-        }
-
-        len -= ret;
-        data += ret;
-    }
-    return _len - len;
-}
-
-/**
- * Validate contents of the buffer from userspace related to OS descriptors.
- */
-static int __ffs_data_do_os_desc(enum ffs_os_desc_type type,
-                 struct usb_os_desc_header *h, void *data,
-                 unsigned len, void *priv)
-{
-    struct ffs_data *ffs = priv;
-    u8 length;
-
-    ENTER();
-
-    switch (type) {
-    case FFS_OS_DESC_EXT_COMPAT: {
-        struct usb_ext_compat_desc *d = data;
-        int i;
-
-        if (len < sizeof(*d) ||
-            d->bFirstInterfaceNumber >= ffs->interfaces_count)
-            return -EINVAL;
-        if (d->Reserved1 != 1) {
-            /*
-             * According to the spec, Reserved1 must be set to 1
-             * but older kernels incorrectly rejected non-zero
-             * values.  We fix it here to avoid returning EINVAL
-             * in response to values we used to accept.
-             */
-            pr_debug("usb_ext_compat_desc::Reserved1 forced to 1\n");
-            d->Reserved1 = 1;
-        }
-        for (i = 0; i < ARRAY_SIZE(d->Reserved2); ++i)
-            if (d->Reserved2[i])
-                return -EINVAL;
-
-        length = sizeof(struct usb_ext_compat_desc);
-    }
-        break;
-    case FFS_OS_DESC_EXT_PROP: {
-        struct usb_ext_prop_desc *d = data;
-        u32 type, pdl;
-        u16 pnl;
-
-        if (len < sizeof(*d) || h->interface >= ffs->interfaces_count)
-            return -EINVAL;
-        length = le32_to_cpu(d->dwSize);
-        if (len < length)
-            return -EINVAL;
-        type = le32_to_cpu(d->dwPropertyDataType);
-        if (type < USB_EXT_PROP_UNICODE ||
-            type > USB_EXT_PROP_UNICODE_MULTI) {
-            pr_vdebug("unsupported os descriptor property type: %d",
-                  type);
-            return -EINVAL;
-        }
-        pnl = le16_to_cpu(d->wPropertyNameLength);
-        if (length < 14 + pnl) {
-            pr_vdebug("invalid os descriptor length: %d pnl:%d (descriptor %d)\n",
-                  length, pnl, type);
-            return -EINVAL;
-        }
-        pdl = le32_to_cpu(*(__le32 *)((u8 *)data + 10 + pnl));
-        if (length != 14 + pnl + pdl) {
-            pr_vdebug("invalid os descriptor length: %d pnl:%d pdl:%d (descriptor %d)\n",
-                  length, pnl, pdl, type);
-            return -EINVAL;
-        }
-        ++ffs->ms_os_descs_ext_prop_count;
-        /* property name reported to the host as "WCHAR"s */
-        ffs->ms_os_descs_ext_prop_name_len += pnl * 2;
-        ffs->ms_os_descs_ext_prop_data_len += pdl;
-    }
-        break;
-    default:
-        pr_vdebug("unknown descriptor: %d\n", type);
-        return -EINVAL;
-    }
-    return length;
-}
-
-static int __ffs_data_got_descs(struct ffs_data *ffs,
-                char *const _data, size_t len)
-{
-    char *data = _data, *raw_descs = NULL;
-    unsigned os_descs_count = 0, counts[3], flags;
-    int ret = -EINVAL, i;
-    struct ffs_desc_helper helper;
-
-    ENTER();
-
-    if (get_unaligned_le32(data + 4) != len)
-        goto error;
-
-    switch (get_unaligned_le32(data)) {
-    case FUNCTIONFS_DESCRIPTORS_MAGIC:
-        flags = FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC;
-        data += 8;
-        len  -= 8;
-        break;
-    case FUNCTIONFS_DESCRIPTORS_MAGIC_V2:
-        flags = get_unaligned_le32(data + 8);
-        ffs->user_flags = flags;
-        if (flags & ~(FUNCTIONFS_HAS_FS_DESC |
-                  FUNCTIONFS_HAS_HS_DESC |
-                  FUNCTIONFS_HAS_SS_DESC |
-                  FUNCTIONFS_HAS_MS_OS_DESC |
-                  FUNCTIONFS_VIRTUAL_ADDR |
-                  FUNCTIONFS_EVENTFD |
-                  FUNCTIONFS_ALL_CTRL_RECIP |
-                  FUNCTIONFS_CONFIG0_SETUP)) {
-            ret = -ENOSYS;
-            goto error;
-        }
-        data += 12;
-        len  -= 12;
-        break;
-    default:
-        goto error;
-    }
-
-    if (flags & FUNCTIONFS_EVENTFD) {
-        if (len < 4)
-            goto error;
-        ffs->ffs_eventfd =
-            eventfd_ctx_fdget((int)get_unaligned_le32(data));
-        if (IS_ERR(ffs->ffs_eventfd)) {
-            ret = PTR_ERR(ffs->ffs_eventfd);
-            ffs->ffs_eventfd = NULL;
-            goto error;
-        }
-        data += 4;
-        len  -= 4;
-    }
-
-    /* Read fs_count, hs_count and ss_count (if present) */
-    for (i = 0; i < 3; ++i) {
-        if (!(flags & (1 << i))) {
-            counts[i] = 0;
-        } else if (len < 4) {
-            goto error;
-        } else {
-            counts[i] = get_unaligned_le32(data);
-            data += 4;
-            len  -= 4;
-        }
-    }
-    if (flags & (1 << i)) {
-        if (len < 4) {
-            goto error;
-        }
-        os_descs_count = get_unaligned_le32(data);
-        data += 4;
-        len -= 4;
-    }
-
-    /* Read descriptors */
-    raw_descs = data;
-    helper.ffs = ffs;
-    for (i = 0; i < 3; ++i) {
-        if (!counts[i])
-            continue;
-        helper.interfaces_count = 0;
-        helper.eps_count = 0;
-        ret = ffs_do_descs(counts[i], data, len,
-                   __ffs_data_do_entity, &helper);
-        if (ret < 0)
-            goto error;
-        if (!ffs->eps_count && !ffs->interfaces_count) {
-            ffs->eps_count = helper.eps_count;
-            ffs->interfaces_count = helper.interfaces_count;
-        } else {
-            if (ffs->eps_count != helper.eps_count) {
-                ret = -EINVAL;
-                goto error;
-            }
-            if (ffs->interfaces_count != helper.interfaces_count) {
-                ret = -EINVAL;
-                goto error;
-            }
-        }
-        data += ret;
-        len  -= ret;
-    }
-    if (os_descs_count) {
-        ret = ffs_do_os_descs(os_descs_count, data, len,
-                      __ffs_data_do_os_desc, ffs);
-        if (ret < 0)
-            goto error;
-        data += ret;
-        len -= ret;
-    }
-
-    if (raw_descs == data || len) {
-        ret = -EINVAL;
-        goto error;
-    }
-
-    ffs->raw_descs_data    = _data;
-    ffs->raw_descs        = raw_descs;
-    ffs->raw_descs_length    = data - raw_descs;
-    ffs->fs_descs_count    = counts[0];
-    ffs->hs_descs_count    = counts[1];
-    ffs->ss_descs_count    = counts[2];
-    ffs->ms_os_descs_count    = os_descs_count;
-
-    return 0;
-
-error:
-    kfree(_data);
-    return ret;
-}
-
-static int __ffs_data_got_strings(struct ffs_data *ffs,
-                char *const _data, size_t len)
-{
-    u32 str_count, needed_count, lang_count;
-    struct usb_gadget_strings **stringtabs = NULL, *t = NULL;
-    const char *data = _data;
-    struct usb_string *s = NULL;
-
-    ENTER();
-
-    if (unlikely(len < 16 ||
-             get_unaligned_le32(data) != FUNCTIONFS_STRINGS_MAGIC ||
-             get_unaligned_le32(data + 4) != len))
-        goto error;
-    str_count  = get_unaligned_le32(data + 8);
-    lang_count = get_unaligned_le32(data + 12);
-
-    /* if one is zero the other must be zero */
-    if (unlikely(!str_count != !lang_count))
-        goto error;
-
-    /* Do we have at least as many strings as descriptors need? */
-    needed_count = ffs->strings_count;
-    if (unlikely(str_count < needed_count))
-        goto error;
-
-    /*
-     * If we don't need any strings just return and free all
-     * memory.
-     */
-    if (!needed_count) {
-        kfree(_data);
-        return 0;
-    }
-
-    /* Allocate everything in one chunk so there's less maintenance. */
-    {
-        unsigned i = 0;
-        vla_group(d);
-        vla_item(d, struct usb_gadget_strings *, stringtabs,
-            lang_count + 1);
-        vla_item(d, struct usb_gadget_strings, stringtab, lang_count);
-        vla_item(d, struct usb_string, strings,
-            lang_count*(needed_count+1));
-
-        char *vlabuf = kmalloc(vla_group_size(d), GFP_KERNEL);
-
-        if (unlikely(!vlabuf)) {
-            kfree(_data);
-            return -ENOMEM;
-        }
-
-        /* Initialize the VLA pointers */
-        stringtabs = vla_ptr(vlabuf, d, stringtabs);
-        t = vla_ptr(vlabuf, d, stringtab);
-        i = lang_count;
-        do {
-            *stringtabs++ = t++;
-        } while (--i);
-        *stringtabs = NULL;
-
-        /* stringtabs = vlabuf = d_stringtabs for later kfree */
-        stringtabs = vla_ptr(vlabuf, d, stringtabs);
-        t = vla_ptr(vlabuf, d, stringtab);
-        s = vla_ptr(vlabuf, d, strings);
-    }
-
-    /* For each language */
-    data += 16;
-    len -= 16;
-
-    do { /* lang_count > 0 so we can use do-while */
-        unsigned needed = needed_count;
-
-        if (unlikely(len < 3))
-            goto error_free;
-        t->language = get_unaligned_le16(data);
-        t->strings  = s;
-        ++t;
-
-        data += 2;
-        len -= 2;
-
-        /* For each string */
-        do { /* str_count > 0 so we can use do-while */
-            size_t length = strnlen(data, len);
-
-            if (unlikely(length == len))
-                goto error_free;
-
-            /*
-             * User may provide more strings then we need,
-             * if that's the case we simply ignore the
-             * rest
-             */
-            if (likely(needed)) {
-                /*
-                 * s->id will be set while adding
-                 * function to configuration so for
-                 * now just leave garbage here.
-                 */
-                s->s = data;
-                --needed;
-                ++s;
-            }
-
-            data += length + 1;
-            len -= length + 1;
-        } while (--str_count);
-
-        s->id = 0;   /* terminator */
-        s->s = NULL;
-        ++s;
-
-    } while (--lang_count);
-
-    /* Some garbage left? */
-    if (unlikely(len))
-        goto error_free;
-
-    /* Done! */
-    ffs->stringtabs = stringtabs;
-    ffs->raw_strings = _data;
-
-    return 0;
-
-error_free:
-    kfree(stringtabs);
-error:
-    kfree(_data);
-    return -EINVAL;
-}
-
-/* Events handling and management *******************************************/
-static void __ffs_event_add(struct ffs_data *ffs,
-                enum usb_functionfs_event_type type)
-{
-    enum usb_functionfs_event_type rem_type1, rem_type2 = type;
-    int neg = 0;
-
-    /*
-     * Abort any unhandled setup
-     *
-     * We do not need to worry about some cmpxchg() changing value
-     * of ffs->setup_state without holding the lock because when
-     * state is FFS_SETUP_PENDING cmpxchg() in several places in
-     * the source does nothing.
-     */
-    if (ffs->setup_state == FFS_SETUP_PENDING)
-        ffs->setup_state = FFS_SETUP_CANCELLED;
-
-    /*
-     * Logic of this function guarantees that there are at most four pending
-     * evens on ffs->ev.types queue.  This is important because the queue
-     * has space for four elements only and __ffs_ep0_read_events function
-     * depends on that limit as well.  If more event types are added, those
-     * limits have to be revisited or guaranteed to still hold.
-     */
-    switch (type) {
-    case FUNCTIONFS_RESUME:
-        rem_type2 = FUNCTIONFS_SUSPEND;
-        /* FALL THROUGH */
-    case FUNCTIONFS_SUSPEND:
-    case FUNCTIONFS_SETUP:
-        rem_type1 = type;
-        /* Discard all similar events */
-        break;
-
-    case FUNCTIONFS_BIND:
-    case FUNCTIONFS_UNBIND:
-    case FUNCTIONFS_DISABLE:
-    case FUNCTIONFS_ENABLE:
-        /* Discard everything other then power management. */
-        rem_type1 = FUNCTIONFS_SUSPEND;
-        rem_type2 = FUNCTIONFS_RESUME;
-        neg = 1;
-        break;
-
-    default:
-        WARN(1, "%d: unknown event, this should not happen\n", type);
-        return;
-    }
-
-    {
-        u8 *ev  = ffs->ev.types, *out = ev;
-        unsigned n = ffs->ev.count;
-        for (; n; --n, ++ev)
-            if ((*ev == rem_type1 || *ev == rem_type2) == neg)
-                *out++ = *ev;
-            else
-                pr_vdebug("purging event %d\n", *ev);
-        ffs->ev.count = out - ffs->ev.types;
-    }
-
-    pr_vdebug("adding event %d\n", type);
-    ffs->ev.types[ffs->ev.count++] = type;
-    wake_up_locked(&ffs->ev.waitq);
-    if (ffs->ffs_eventfd)
-        eventfd_signal(ffs->ffs_eventfd, 1);
-}
-
-static void ffs_event_add(struct ffs_data *ffs,
-              enum usb_functionfs_event_type type)
-{
-    unsigned long flags;
-    spin_lock_irqsave(&ffs->ev.waitq.lock, flags);
-    __ffs_event_add(ffs, type);
-    spin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);
-}
-
-/* Bind/unbind USB function hooks *******************************************/
-
-static int ffs_ep_addr2idx(struct ffs_data *ffs, u8 endpoint_address)
-{
-    int i;
-
-    for (i = 1; i < ARRAY_SIZE(ffs->eps_addrmap); ++i)
-        if (ffs->eps_addrmap[i] == endpoint_address)
-            return i;
-    return -ENOENT;
-}
-
-static int __ffs_func_bind_do_descs(enum ffs_entity_type type, u8 *valuep,
-                struct usb_descriptor_header *desc,
-                void *priv)
-{
-    struct usb_endpoint_descriptor *ds = (void *)desc;
-    struct ffs_function *func = priv;
-    struct ffs_ep *ffs_ep = NULL;
-    unsigned ep_desc_id;
-    int idx;
-    static const char *speed_names[] = { "full", "high", "super" };
-
-    if (type != FFS_DESCRIPTOR)
-        return 0;
-
-    /*
-     * If ss_descriptors is not NULL, we are reading super speed
-     * descriptors; if hs_descriptors is not NULL, we are reading high
-     * speed descriptors; otherwise, we are reading full speed
-     * descriptors.
-     */
-    if (func->function.ss_descriptors) {
-        ep_desc_id = 2;
-        func->function.ss_descriptors[(uintptr_t)valuep] = desc;
-    } else if (func->function.hs_descriptors) {
-        ep_desc_id = 1;
-        func->function.hs_descriptors[(uintptr_t)valuep] = desc;
-    } else {
-        ep_desc_id = 0;
-        func->function.fs_descriptors[(uintptr_t)valuep]    = desc;
-    }
-
-    if (!desc || desc->bDescriptorType != USB_DT_ENDPOINT)
-        return 0;
-
-    idx = ffs_ep_addr2idx(func->ffs, ds->bEndpointAddress) - 1;
-    if (idx < 0)
-        return idx;
-
-    ffs_ep = func->eps + idx;
-
-    if (unlikely(ffs_ep->descs[ep_desc_id])) {
-        pr_err("two %sspeed descriptors for EP %d\n",
-              speed_names[ep_desc_id],
-              ds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
-        return -EINVAL;
-    }
-    ffs_ep->descs[ep_desc_id] = ds;
-
-    ffs_dump_mem(": Original  ep desc", ds, ds->bLength);
-    if (ffs_ep->ep) {
-        ds->bEndpointAddress = ffs_ep->descs[0]->bEndpointAddress;
-        if (!ds->wMaxPacketSize)
-            ds->wMaxPacketSize = ffs_ep->descs[0]->wMaxPacketSize;
-    } else {
-        struct usb_request *req = NULL;
-        struct usb_ep *ep = NULL;
-        u8 bEndpointAddress;
-
-        /*
-         * We back up bEndpointAddress because autoconfig overwrites
-         * it with physical endpoint address.
-         */
-        bEndpointAddress = ds->bEndpointAddress;
-        pr_vdebug("autoconfig\n");
-        ep = usb_ep_autoconfig(func->gadget, ds);
-        if (unlikely(!ep))
-            return -ENOTSUPP;
-        ep->driver_data = func->eps + idx;
-
-        req = usb_ep_alloc_request(ep, GFP_KERNEL);
-        if (unlikely(!req))
-            return -ENOMEM;
-
-        ffs_ep->ep  = ep;
-        ffs_ep->req = req;
-            INIT_LIST_HEAD(&ffs_ep->req->list);
-        func->eps_revmap[ds->bEndpointAddress &
-                 USB_ENDPOINT_NUMBER_MASK] = idx + 1;
-        /*
-         * If we use virtual address mapping, we restore
-         * original bEndpointAddress value.
-         */
-        if (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)
-            ds->bEndpointAddress = bEndpointAddress;
-    }
-    ffs_dump_mem(": Rewritten ep desc", ds, ds->bLength);
-
-    return 0;
-}
-
-static int __ffs_func_bind_do_nums(enum ffs_entity_type type, u8 *valuep,
-                struct usb_descriptor_header *desc,
-                void *priv)
-{
-    struct ffs_function *func = priv;
-    unsigned idx;
-    u8 newValue;
-
-    switch (type) {
-    default:
-    case FFS_DESCRIPTOR:
-        /* Handled in previous pass by __ffs_func_bind_do_descs() */
-        return 0;
-
-    case FFS_INTERFACE:
-        idx = *valuep;
-        if (func->interfaces_nums[idx] < 0) {
-            int id = usb_interface_id(func->conf, &func->function);
-            if (unlikely(id < 0))
-                return id;
-            func->interfaces_nums[idx] = id;
-        }
-        newValue = func->interfaces_nums[idx];
-        break;
-
-    case FFS_STRING:
-        /* String' IDs are allocated when fsf_data is bound to cdev */
-        newValue = func->ffs->stringtabs[0]->strings[*valuep - 1].id;
-        break;
-
-    case FFS_ENDPOINT:
-        /*
-         * USB_DT_ENDPOINT are handled in
-         * __ffs_func_bind_do_descs().
-         */
-        if (desc->bDescriptorType == USB_DT_ENDPOINT)
-            return 0;
-
-        idx = (*valuep & USB_ENDPOINT_NUMBER_MASK) - 1;
-        if (unlikely(!func->eps[idx].ep))
-            return -EINVAL;
-
-        {
-            struct usb_endpoint_descriptor **descs;
-            descs = func->eps[idx].descs;
-            newValue = descs[descs[0] ? 0 : 1]->bEndpointAddress;
-        }
-        break;
-    }
-
-    pr_vdebug("%02x -> %02x\n", *valuep, newValue);
-    *valuep = newValue;
-    return 0;
-}
-
-static int __ffs_func_bind_do_os_desc(enum ffs_os_desc_type type,
-                struct usb_os_desc_header *h, void *data,
-                unsigned len, void *priv)
-{
-    struct ffs_function *func = priv;
-    u8 length = 0;
-
-    switch (type) {
-    case FFS_OS_DESC_EXT_COMPAT: {
-        struct usb_ext_compat_desc *desc = data;
-        struct usb_os_desc_table *t;
-
-        t = &func->function.os_desc_table[desc->bFirstInterfaceNumber];
-        t->if_id = func->interfaces_nums[desc->bFirstInterfaceNumber];
-        memcpy(t->os_desc->ext_compat_id, &desc->CompatibleID,
-            ARRAY_SIZE(desc->CompatibleID) + ARRAY_SIZE(desc->SubCompatibleID));
-        length = sizeof(*desc);
-    }
-        break;
-    case FFS_OS_DESC_EXT_PROP: {
-        struct usb_ext_prop_desc *desc = data;
-        struct usb_os_desc_table *t;
-        struct usb_os_desc_ext_prop *ext_prop;
-        char *ext_prop_name;
-        char *ext_prop_data;
-
-        t = &func->function.os_desc_table[h->interface];
-        t->if_id = func->interfaces_nums[h->interface];
-
-        ext_prop = func->ffs->ms_os_descs_ext_prop_avail;
-        func->ffs->ms_os_descs_ext_prop_avail += sizeof(*ext_prop);
-
-        ext_prop->type = le32_to_cpu(desc->dwPropertyDataType);
-        ext_prop->name_len = le16_to_cpu(desc->wPropertyNameLength);
-        ext_prop->data_len = le32_to_cpu(*(__le32 *)
-            usb_ext_prop_data_len_ptr(data, ext_prop->name_len));
-        length = ext_prop->name_len + ext_prop->data_len + 14;
-
-        ext_prop_name = func->ffs->ms_os_descs_ext_prop_name_avail;
-        func->ffs->ms_os_descs_ext_prop_name_avail +=
-            ext_prop->name_len;
-
-        ext_prop_data = func->ffs->ms_os_descs_ext_prop_data_avail;
-        func->ffs->ms_os_descs_ext_prop_data_avail +=
-            ext_prop->data_len;
-        memcpy(ext_prop_data, usb_ext_prop_data_ptr(data, ext_prop->name_len),
-            ext_prop->data_len);
-        /* unicode data reported to the host as "WCHAR"s */
-        switch (ext_prop->type) {
-        case USB_EXT_PROP_UNICODE:
-        case USB_EXT_PROP_UNICODE_ENV:
-        case USB_EXT_PROP_UNICODE_LINK:
-        case USB_EXT_PROP_UNICODE_MULTI:
-            ext_prop->data_len *= 2;
-            break;
-        }
-        ext_prop->data = ext_prop_data;
-
-        memcpy(ext_prop_name, usb_ext_prop_name_ptr(data),
-            ext_prop->name_len);
-		/* property name reported to the host as "WCHAR"s */
-        ext_prop->name_len *= 2;
-        ext_prop->name = ext_prop_name;
-
-        t->os_desc->ext_prop_len +=
-            ext_prop->name_len + ext_prop->data_len + 14;
-        ++t->os_desc->ext_prop_count;
-        list_add_tail(&ext_prop->entry, &t->os_desc->ext_prop);
-    }
-        break;
-    default:
-        pr_vdebug("unknown descriptor: %d\n", type);
-    }
-
-    return length;
-}
-
-static inline struct f_fs_opts *ffs_do_functionfs_bind(struct usb_function *f,
-                struct usb_configuration *c)
-{
-    struct ffs_function *func = ffs_func_from_usb(f);
-    struct f_fs_opts *ffs_opts =
-        container_of(f->fi, struct f_fs_opts, func_inst);
-    int ret;
-
-    ENTER();
-
-    /*
-     * Legacy gadget triggers binding in functionfs_ready_callback,
-     * which already uses locking; taking the same lock here would
-     * cause a deadlock.
-     *
-     * Configfs-enabled gadgets however do need ffs_dev_lock.
-     */
-    if (!ffs_opts->no_configfs)
-        ffs_dev_lock();
-    ret = ffs_opts->dev->desc_ready ? 0 : -ENODEV;
-    func->ffs = ffs_opts->dev->ffs_data;
-    if (!ffs_opts->no_configfs)
-        ffs_dev_unlock();
-    if (ret)
-        return ERR_PTR(ret);
-
-    func->conf = c;
-    func->gadget = c->cdev->gadget;
-
-    /*
-     * in drivers/usb/gadget/configfs.c:configfs_composite_bind()
-     * configurations are bound in sequence with list_for_each_entry,
-     * in each configuration its functions are bound in sequence
-     * with list_for_each_entry, so we assume no race condition
-     * with regard to ffs_opts->bound access
-     */
-    if (!ffs_opts->refcnt) {
-        ret = functionfs_bind(func->ffs, c->cdev);
-        if (ret)
-            return ERR_PTR(ret);
-    }
-    ffs_opts->refcnt++;
-    func->function.strings = func->ffs->stringtabs;
-
-    return ffs_opts;
-}
-
-static int _ffs_func_bind(struct usb_configuration *c, struct usb_function *f)
-{
-    struct ffs_function *func = ffs_func_from_usb(f);
-    struct ffs_data *ffs = func->ffs;
-
-    const int full = !!func->ffs->fs_descs_count;
-    const int high = !!func->ffs->hs_descs_count;
-    const int super = !!func->ffs->ss_descs_count;
-
-    int fs_len, hs_len, ss_len, ret, i;
-    struct ffs_ep *eps_ptr = NULL;
-    struct usb_descriptor_header *des_head = NULL;
-    struct usb_interface_descriptor *intf_ctl = NULL;
-    struct usb_interface_descriptor *intf_data = NULL;
-    /* Make it a single chunk, less management later on */
-    vla_group(d);
-    vla_item_with_sz(d, struct ffs_ep, eps, ffs->eps_count);
-    vla_item_with_sz(d, struct usb_descriptor_header *, fs_descs,
-        full ? ffs->fs_descs_count + 1 : 0);
-    vla_item_with_sz(d, struct usb_descriptor_header *, hs_descs,
-        high ? ffs->hs_descs_count + 1 : 0);
-    vla_item_with_sz(d, struct usb_descriptor_header *, ss_descs,
-        super ? ffs->ss_descs_count + 1 : 0);
-    vla_item_with_sz(d, short, inums, ffs->interfaces_count);
-    vla_item_with_sz(d, struct usb_os_desc_table, os_desc_table,
-             c->cdev->use_os_string ? ffs->interfaces_count : 0);
-    vla_item_with_sz(d, char[16], ext_compat,
-             c->cdev->use_os_string ? ffs->interfaces_count : 0);
-    vla_item_with_sz(d, struct usb_os_desc, os_desc,
-             c->cdev->use_os_string ? ffs->interfaces_count : 0);
-    vla_item_with_sz(d, struct usb_os_desc_ext_prop, ext_prop,
-             ffs->ms_os_descs_ext_prop_count);
-    vla_item_with_sz(d, char, ext_prop_name,
-             ffs->ms_os_descs_ext_prop_name_len);
-    vla_item_with_sz(d, char, ext_prop_data,
-             ffs->ms_os_descs_ext_prop_data_len);
-    vla_item_with_sz(d, char, raw_descs, ffs->raw_descs_length);
-    char *vlabuf = NULL;
-
-    ENTER();
-
-    /* Has descriptors only for speeds gadget does not support */
-    if (unlikely(!(full | high | super)))
-        return -ENOTSUPP;
-
-    /* Allocate a single chunk, less management later on */
-    vlabuf = kzalloc(vla_group_size(d), GFP_KERNEL);
-    if (unlikely(!vlabuf))
-        return -ENOMEM;
-
-    ffs->ms_os_descs_ext_prop_avail = vla_ptr(vlabuf, d, ext_prop);
-    ffs->ms_os_descs_ext_prop_name_avail =
-        vla_ptr(vlabuf, d, ext_prop_name);
-    ffs->ms_os_descs_ext_prop_data_avail =
-        vla_ptr(vlabuf, d, ext_prop_data);
-
-    /* Copy descriptors  */
-    memcpy(vla_ptr(vlabuf, d, raw_descs), ffs->raw_descs, ffs->raw_descs_length);
-
-    memset(vla_ptr(vlabuf, d, inums), 0xff, d_inums__sz);
-
-    eps_ptr = vla_ptr(vlabuf, d, eps);
-    for (i = 0; i < ffs->eps_count; i++)
-        eps_ptr[i].num = -1;
-
-    /* Save pointers
-     * d_eps == vlabuf, func->eps used to kfree vlabuf later
-    */
-    func->eps             = vla_ptr(vlabuf, d, eps);
-    func->interfaces_nums = vla_ptr(vlabuf, d, inums);
-
-    /*
-     * Go through all the endpoint descriptors and allocate
-     * endpoints first, so that later we can rewrite the endpoint
-     * numbers without worrying that it may be described later on.
-     */
-    if (likely(full)) {
-        func->function.fs_descriptors = vla_ptr(vlabuf, d, fs_descs);
-        fs_len = ffs_do_descs(ffs->fs_descs_count,
-                      vla_ptr(vlabuf, d, raw_descs),
-                      d_raw_descs__sz,
-                      __ffs_func_bind_do_descs, func);
-        if (unlikely(fs_len < 0)) {
-            ret = fs_len;
-            goto error;
-        }
-    } else {
-        fs_len = 0;
-    }
-    if (likely(high)) {
-        func->function.hs_descriptors = vla_ptr(vlabuf, d, hs_descs);
-        hs_len = ffs_do_descs(ffs->hs_descs_count,
-                      vla_ptr(vlabuf, d, raw_descs) + fs_len,
-                      d_raw_descs__sz - fs_len,
-                      __ffs_func_bind_do_descs, func);
-        if (unlikely(hs_len < 0)) {
-            ret = hs_len;
-            goto error;
-        }
-    } else {
-        hs_len = 0;
-    }
-    if (likely(super)) {
-        func->function.ss_descriptors = vla_ptr(vlabuf, d, ss_descs);
-        ss_len = ffs_do_descs(ffs->ss_descs_count,
-                vla_ptr(vlabuf, d, raw_descs) + fs_len + hs_len,
-                d_raw_descs__sz - fs_len - hs_len,
-                __ffs_func_bind_do_descs, func);
-        if (unlikely(ss_len < 0)) {
-            ret = ss_len;
-            goto error;
-        }
-    } else {
-        ss_len = 0;
-    }
-    /*
-     * Now handle interface numbers allocation and interface and
-     * endpoint numbers rewriting.  We can do that in one go
-     * now.
-     */
-    ret = ffs_do_descs(ffs->fs_descs_count +
-               (high ? ffs->hs_descs_count : 0) +
-               (super ? ffs->ss_descs_count : 0),
-               vla_ptr(vlabuf, d, raw_descs), d_raw_descs__sz,
-               __ffs_func_bind_do_nums, func);
-    if (unlikely(ret < 0))
-        goto error;
-
-    func->function.os_desc_table = vla_ptr(vlabuf, d, os_desc_table);
-    if (c->cdev->use_os_string) {
-        for (i = 0; i < ffs->interfaces_count; ++i) {
-            struct usb_os_desc *desc;
-
-            desc = func->function.os_desc_table[i].os_desc =
-                vla_ptr(vlabuf, d, os_desc) +
-                i * sizeof(struct usb_os_desc);
-            desc->ext_compat_id =
-                vla_ptr(vlabuf, d, ext_compat) + i * 16;
-            INIT_LIST_HEAD(&desc->ext_prop);
-        }
-        ret = ffs_do_os_descs(ffs->ms_os_descs_count,
-                      vla_ptr(vlabuf, d, raw_descs) +
-                      fs_len + hs_len + ss_len,
-                      d_raw_descs__sz - fs_len - hs_len -
-                      ss_len,
-                      __ffs_func_bind_do_os_desc, func);
-        if (unlikely(ret < 0))
-            goto error;
-    }
-    func->function.os_desc_n =
-        c->cdev->use_os_string ? ffs->interfaces_count : 0;
-
-    for (i = 0; i< func->ffs->fs_descs_count; i++) {
-        des_head = func->function.fs_descriptors[i];
-        if (des_head->bDescriptorType == USB_DT_INTERFACE) {
-            struct usb_interface_descriptor *intf = (struct usb_interface_descriptor *)des_head;
-            if (intf->bNumEndpoints > 0) {
-                if (intf_ctl == NULL) {
-                    intf_ctl = intf;
-                } else {
-                    intf_data = intf;
-                    break;
-                }
-            }
-        }
-    }
-    for (i = 0; i< func->ffs->fs_descs_count; i++) {
-        des_head = func->function.fs_descriptors[i];
-        if (des_head->bDescriptorType == USB_DT_INTERFACE_ASSOCIATION) {
-            struct usb_interface_assoc_descriptor *a_dec = (struct usb_interface_assoc_descriptor *)des_head;
-            a_dec->bFirstInterface = intf_ctl->bInterfaceNumber;
-        } else if (des_head->bDescriptorType == USB_DT_CS_INTERFACE) {
-            struct usb_cdc_header_desc *cs_des = (struct usb_cdc_header_desc *)des_head;
-            if (cs_des->bDescriptorSubType == USB_CDC_CALL_MANAGEMENT_TYPE) {
-                struct usb_cdc_call_mgmt_descriptor *mgmt_des = (struct usb_cdc_call_mgmt_descriptor *)des_head;
-                mgmt_des->bDataInterface = intf_data->bInterfaceNumber;
-            } else if (cs_des->bDescriptorSubType == USB_CDC_UNION_TYPE) {
-                struct usb_cdc_union_desc *union_des = (struct usb_cdc_union_desc *)des_head;
-                union_des->bMasterInterface0 = intf_ctl->bInterfaceNumber;
-                union_des->bSlaveInterface0 = intf_data->bInterfaceNumber;
-            } else if (cs_des->bDescriptorSubType == USB_CDC_ETHERNET_TYPE) {
-                struct usb_cdc_ether_desc *ether_des = (struct usb_cdc_ether_desc *)des_head;
-                ether_des->iMACAddress = intf_ctl->iInterface + 1;
-            }
-        }
-    }
-    for (i = 0; i< func->ffs->hs_descs_count; i++) {
-        des_head = func->function.hs_descriptors[i];
-        if (des_head->bDescriptorType == USB_DT_INTERFACE_ASSOCIATION) {
-            struct usb_interface_assoc_descriptor *a_dec = (struct usb_interface_assoc_descriptor *)des_head;
-            a_dec->bFirstInterface = intf_ctl->bInterfaceNumber;
-        } else if (des_head->bDescriptorType == USB_DT_CS_INTERFACE) {
-            struct usb_cdc_header_desc *cs_des = (struct usb_cdc_header_desc *)des_head;
-            if (cs_des->bDescriptorSubType == USB_CDC_CALL_MANAGEMENT_TYPE) {
-                struct usb_cdc_call_mgmt_descriptor *mgmt_des = (struct usb_cdc_call_mgmt_descriptor *)des_head;
-                mgmt_des->bDataInterface = intf_data->bInterfaceNumber;
-            } else if (cs_des->bDescriptorSubType == USB_CDC_UNION_TYPE) {
-                struct usb_cdc_union_desc *union_des = (struct usb_cdc_union_desc *)des_head;
-                union_des->bMasterInterface0 = intf_ctl->bInterfaceNumber;
-                union_des->bSlaveInterface0 = intf_data->bInterfaceNumber;
-            } else if (cs_des->bDescriptorSubType == USB_CDC_ETHERNET_TYPE) {
-                struct usb_cdc_ether_desc *ether_des = (struct usb_cdc_ether_desc *)des_head;
-                ether_des->iMACAddress = intf_ctl->iInterface + 1;
-            }
-        }
-    }
-    for (i = 0; i< func->ffs->ss_descs_count; i++) {
-        des_head = func->function.ss_descriptors[i];
-        if (des_head->bDescriptorType == USB_DT_INTERFACE_ASSOCIATION) {
-            struct usb_interface_assoc_descriptor *a_dec = (struct usb_interface_assoc_descriptor *)des_head;
-            a_dec->bFirstInterface = intf_ctl->bInterfaceNumber;
-        } else if (des_head->bDescriptorType == USB_DT_CS_INTERFACE) {
-            struct usb_cdc_header_desc *cs_des = (struct usb_cdc_header_desc *)des_head;
-            if (cs_des->bDescriptorSubType == USB_CDC_CALL_MANAGEMENT_TYPE) {
-                struct usb_cdc_call_mgmt_descriptor *mgmt_des = (struct usb_cdc_call_mgmt_descriptor *)des_head;
-                mgmt_des->bDataInterface = intf_data->bInterfaceNumber;
-            } else if (cs_des->bDescriptorSubType == USB_CDC_UNION_TYPE) {
-                struct usb_cdc_union_desc *union_des = (struct usb_cdc_union_desc *)des_head;
-                union_des->bMasterInterface0 = intf_ctl->bInterfaceNumber;
-                union_des->bSlaveInterface0 = intf_data->bInterfaceNumber;
-            } else if (cs_des->bDescriptorSubType == USB_CDC_ETHERNET_TYPE) {
-                struct usb_cdc_ether_desc *ether_des = (struct usb_cdc_ether_desc *)des_head;
-                ether_des->iMACAddress = intf_ctl->iInterface + 1;
-            }
-        }
-    }
-    /* And we're done */
-    ffs->eps = func->eps;
-    ffs_event_add(ffs, FUNCTIONFS_BIND);
-    return 0;
-
-error:
-    /* XXX Do we need to release all claimed endpoints here? */
-    return ret;
-}
-
-static int ffs_func_bind(struct usb_configuration *c, struct usb_function *f)
-{
-    struct f_fs_opts *ffs_opts = ffs_do_functionfs_bind(f, c);
-    struct ffs_function *func = ffs_func_from_usb(f);
-    int ret;
-
-    if (IS_ERR(ffs_opts))
-        return PTR_ERR(ffs_opts);
-
-    ret = _ffs_func_bind(c, f);
-    if (ret && !--ffs_opts->refcnt)
-        functionfs_unbind(func->ffs);
-
-    return ret;
-}
-
-/* Other USB function hooks *************************************************/
-static void ffs_reset_work(struct work_struct *work)
-{
-    struct ffs_data *ffs = container_of(work,
-        struct ffs_data, reset_work);
-    ffs_data_reset(ffs);
-}
-
-static int ffs_func_set_alt(struct usb_function *f,
-                unsigned interface, unsigned alt)
-{
-    struct ffs_function *func = ffs_func_from_usb(f);
-    struct ffs_data *ffs = func->ffs;
-    int ret = 0, intf;
-
-    if (alt != (unsigned)-1) {
-        intf = ffs_func_revmap_intf(func, interface);
-        if (unlikely(intf < 0))
-            return intf;
-    }
-
-    if (ffs->func)
-        ffs_func_eps_disable(ffs->func);
-
-    if (ffs->state == FFS_DEACTIVATED) {
-        ffs->state = FFS_CLOSING;
-        INIT_WORK(&ffs->reset_work, ffs_reset_work);
-        schedule_work(&ffs->reset_work);
-        return -ENODEV;
-    }
-
-    if (ffs->state != FFS_ACTIVE)
-        return -ENODEV;
-
-    if (alt == (unsigned)-1) {
-        ffs->func = NULL;
-        ffs_event_add(ffs, FUNCTIONFS_DISABLE);
-        return 0;
-    }
-
-    ffs->func = func;
-    ret = ffs_func_eps_enable(func);
-    if (likely(ret >= 0))
-        ffs_event_add(ffs, FUNCTIONFS_ENABLE);
-    return ret;
-}
-
-static void ffs_func_disable(struct usb_function *f)
-{
-    ffs_func_set_alt(f, 0, (unsigned)-1);
-}
-
-static int ffs_func_setup(struct usb_function *f, const struct usb_ctrlrequest *creq)
-{
-    struct ffs_function *func = ffs_func_from_usb(f);
-    struct ffs_data *ffs = func->ffs;
-    unsigned long flags;
-    int ret;
-
-    ENTER();
-
-    pr_vdebug("creq->bRequestType = %02x\n", creq->bRequestType);
-    pr_vdebug("creq->bRequest     = %02x\n", creq->bRequest);
-    pr_vdebug("creq->wValue       = %04x\n", le16_to_cpu(creq->wValue));
-    pr_vdebug("creq->wIndex       = %04x\n", le16_to_cpu(creq->wIndex));
-    pr_vdebug("creq->wLength      = %04x\n", le16_to_cpu(creq->wLength));
-
-    /*
-     * Most requests directed to interface go through here
-     * (notable exceptions are set/get interface) so we need to
-     * handle them.  All other either handled by composite or
-     * passed to usb_configuration->setup() (if one is set).  No
-     * matter, we will handle requests directed to endpoint here
-     * as well (as it's straightforward).  Other request recipient
-     * types are only handled when the user flag FUNCTIONFS_ALL_CTRL_RECIP
-     * is being used.
-     */
-    if (ffs->state != FFS_ACTIVE)
-        return -ENODEV;
-
-    switch (creq->bRequestType & USB_RECIP_MASK) {
-    case USB_RECIP_INTERFACE:
-        ret = ffs_func_revmap_intf(func, le16_to_cpu(creq->wIndex));
-        if (unlikely(ret < 0))
-            return ret;
-        break;
-
-    case USB_RECIP_ENDPOINT:
-        ret = ffs_func_revmap_ep(func, le16_to_cpu(creq->wIndex));
-        if (unlikely(ret < 0))
-            return ret;
-        if (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)
-            ret = func->ffs->eps_addrmap[ret];
-        break;
-
-    default:
-        if (func->ffs->user_flags & FUNCTIONFS_ALL_CTRL_RECIP)
-            ret = le16_to_cpu(creq->wIndex);
-        else
-            return -EOPNOTSUPP;
-    }
-
-    spin_lock_irqsave(&ffs->ev.waitq.lock, flags);
-    ffs->ev.setup = *creq;
-    ffs->ev.setup.wIndex = cpu_to_le16(ret);
-    __ffs_event_add(ffs, FUNCTIONFS_SETUP);
-    spin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);
-
-    return creq->wLength == 0 ? USB_GADGET_DELAYED_STATUS : 0;
-}
-
-static bool ffs_func_req_match(struct usb_function *f,
-                const struct usb_ctrlrequest *creq,
-                bool config0)
-{
-    struct ffs_function *func = ffs_func_from_usb(f);
-
-    if (config0 && !(func->ffs->user_flags & FUNCTIONFS_CONFIG0_SETUP))
-        return false;
-
-    switch (creq->bRequestType & USB_RECIP_MASK) {
-    case USB_RECIP_INTERFACE:
-        return (ffs_func_revmap_intf(func,
-                         le16_to_cpu(creq->wIndex)) >= 0);
-    case USB_RECIP_ENDPOINT:
-        return (ffs_func_revmap_ep(func,
-                       le16_to_cpu(creq->wIndex)) >= 0);
-    default:
-        return (bool) (func->ffs->user_flags &
-                   FUNCTIONFS_ALL_CTRL_RECIP);
-    }
-}
-
-static void ffs_func_suspend(struct usb_function *f)
-{
-    ENTER();
-    ffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_SUSPEND);
-}
-
-static void ffs_func_resume(struct usb_function *f)
-{
-    ENTER();
-    ffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_RESUME);
-}
-
-/* Endpoint and interface numbers reverse mapping ***************************/
-static int ffs_func_revmap_ep(struct ffs_function *func, u8 num)
-{
-    num = func->eps_revmap[num & USB_ENDPOINT_NUMBER_MASK];
-    return num ? num : -EDOM;
-}
-
-static int ffs_func_revmap_intf(struct ffs_function *func, u8 intf)
-{
-    short *nums = func->interfaces_nums;
-    unsigned count = func->ffs->interfaces_count;
-
-    for (; count; --count, ++nums) {
-        if (*nums >= 0 && *nums == intf)
-            return nums - func->interfaces_nums;
-    }
-
-    return -EDOM;
-}
-
-/* Devices management *******************************************************/
-static LIST_HEAD(ffs_devices);
-
-static struct ffs_dev *_ffs_do_find_dev(const char *name)
-{
-    struct ffs_dev *dev = NULL;
-
-    if (!name)
-        return NULL;
-
-    list_for_each_entry(dev, &ffs_devices, entry) {
-        if (!dev->name)
-            return NULL;
-        if (strcmp(dev->name, name) == 0)
-            return dev;
-    }
-
-    return NULL;
-}
-
-/*
- * ffs_lock must be taken by the caller of this function
- */
-static struct ffs_dev *_ffs_get_single_dev(void)
-{
-    struct ffs_dev *dev = NULL;
-
-    if (list_is_singular(&ffs_devices)) {
-        dev = list_first_entry(&ffs_devices, struct ffs_dev, entry);
-        if (dev->single)
-            return dev;
-    }
-
-    return NULL;
-}
-
-/*
- * ffs_lock must be taken by the caller of this function
- */
-static struct ffs_dev *_ffs_find_dev(const char *name)
-{
-    struct ffs_dev *dev;
-
-    dev = _ffs_get_single_dev();
-    if (dev)
-        return dev;
-
-    return _ffs_do_find_dev(name);
-}
-
-/* Configfs support *********************************************************/
-static inline struct f_fs_opts *to_ffs_opts(struct config_item *item)
-{
-    return container_of(to_config_group(item), struct f_fs_opts,
-                func_inst.group);
-}
-
-static void ffs_attr_release(struct config_item *item)
-{
-    struct f_fs_opts *opts = to_ffs_opts(item);
-
-    usb_put_function_instance(&opts->func_inst);
-}
-
-static struct configfs_item_operations ffs_item_ops = {
-    .release    = ffs_attr_release,
-};
-
-static const struct config_item_type ffs_func_type = {
-    .ct_item_ops    = &ffs_item_ops,
-    .ct_owner    = THIS_MODULE,
-};
-
-/* Function registration interface ******************************************/
-static void ffs_free_inst(struct usb_function_instance *f)
-{
-    struct f_fs_opts *opts;
-
-    opts = to_f_fs_opts(f);
-    ffs_dev_lock();
-    _ffs_free_dev(opts->dev);
-    ffs_dev_unlock();
-    kfree(opts);
-}
-
-static int ffs_set_inst_name(struct usb_function_instance *fi, const char *name)
-{
-    char name_dev[MAX_NAMELEN] = {0};
-    if (snprintf(name_dev, MAX_NAMELEN - 1, "%s.%s", FUNCTION_GENERIC, name) < 0) {
-        return -EFAULT;
-    }
-    if (strlen(name_dev) >= sizeof_field(struct ffs_dev, name))
-        return -ENAMETOOLONG;
-    return ffs_name_dev_adapter(to_f_fs_opts(fi)->dev, name_dev);
-}
-
-static struct usb_function_instance *ffs_alloc_inst(void)
-{
-    struct f_fs_opts *opts = NULL;
-    struct ffs_dev *dev = NULL;
-
-    opts = kzalloc(sizeof(*opts), GFP_KERNEL);
-    if (!opts)
-        return ERR_PTR(-ENOMEM);
-
-    opts->func_inst.set_inst_name = ffs_set_inst_name;
-    opts->func_inst.free_func_inst = ffs_free_inst;
-    ffs_dev_lock();
-    dev = _ffs_alloc_dev();
-    ffs_dev_unlock();
-    if (IS_ERR(dev)) {
-        kfree(opts);
-        return ERR_CAST(dev);
-    }
-    opts->dev = dev;
-    dev->opts = opts;
-
-    config_group_init_type_name(&opts->func_inst.group, "",
-                    &ffs_func_type);
-    return &opts->func_inst;
-}
-
-static void ffs_free(struct usb_function *f)
-{
-    kfree(ffs_func_from_usb(f));
-}
-
-static void ffs_func_unbind(struct usb_configuration *c,
-                struct usb_function *f)
-{
-    struct ffs_function *func = ffs_func_from_usb(f);
-    struct ffs_data *ffs = func->ffs;
-    struct f_fs_opts *opts =
-        container_of(f->fi, struct f_fs_opts, func_inst);
-    struct ffs_ep *ep = func->eps;
-    unsigned count = ffs->eps_count;
-    unsigned long flags;
-
-    ENTER();
-    if (ffs->func == func) {
-        ffs_func_eps_disable(func);
-        ffs->func = NULL;
-    }
-
-    if (!--opts->refcnt)
-        functionfs_unbind(ffs);
-
-    /* cleanup after autoconfig */
-    spin_lock_irqsave(&func->ffs->eps_lock, flags);
-    while (count--) {
-        if (ep->ep && ep->req)
-            usb_ep_free_request(ep->ep, ep->req);
-        ep->req = NULL;
-        ++ep;
-    }
-    spin_unlock_irqrestore(&func->ffs->eps_lock, flags);
-    kfree(func->eps);
-    func->eps = NULL;
-    /*
-     * eps, descriptors and interfaces_nums are allocated in the
-     * same chunk so only one free is required.
-     */
-    func->function.fs_descriptors = NULL;
-    func->function.hs_descriptors = NULL;
-    func->function.ss_descriptors = NULL;
-    func->interfaces_nums = NULL;
-
-    ffs_event_add(ffs, FUNCTIONFS_UNBIND);
-}
-
-static int ffs_func_get_alt(struct usb_function *f, unsigned intf)
-{
-    if (intf == 0)
-        return 0;
-    return 1;
-}
-
-static struct usb_function *ffs_alloc(struct usb_function_instance *fi)
-{
-    struct ffs_function *func = NULL;
-
-    ENTER();
-
-    func = kzalloc(sizeof(*func), GFP_KERNEL);
-    if (unlikely(!func))
-        return ERR_PTR(-ENOMEM);
-
-    func->function.name    = "FunctionFS Adapter";
-
-    func->function.bind    = ffs_func_bind;
-    func->function.unbind  = ffs_func_unbind;
-    func->function.set_alt = ffs_func_set_alt;
-    func->function.get_alt = ffs_func_get_alt;
-    func->function.disable = ffs_func_disable;
-    func->function.setup   = ffs_func_setup;
-    func->function.req_match = ffs_func_req_match;
-    func->function.suspend = ffs_func_suspend;
-    func->function.resume  = ffs_func_resume;
-    func->function.free_func = ffs_free;
-
-    return &func->function;
-}
-
-/*
- * ffs_lock must be taken by the caller of this function
- */
-static struct ffs_dev *_ffs_alloc_dev(void)
-{
-    struct ffs_dev *dev = NULL;
-    int ret;
-
-    if (_ffs_get_single_dev())
-            return ERR_PTR(-EBUSY);
-
-    dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-    if (!dev)
-        return ERR_PTR(-ENOMEM);
-
-    if (list_empty(&ffs_devices)) {
-        ret = functionfs_init();
-        if (ret) {
-            kfree(dev);
-            return ERR_PTR(ret);
-        }
-    }
-
-    list_add(&dev->entry, &ffs_devices);
-
-    return dev;
-}
-
-int ffs_name_dev_adapter(struct ffs_dev *dev, const char *name)
-{
-    struct ffs_dev *existing = NULL;
-    int ret = 0;
-
-    ffs_dev_lock();
-
-    existing = _ffs_do_find_dev(name);
-    if (!existing)
-        strlcpy(dev->name, name, ARRAY_SIZE(dev->name));
-    else if (existing != dev)
-        ret = -EBUSY;
-
-    ffs_dev_unlock();
-
-    return ret;
-}
-EXPORT_SYMBOL_GPL(ffs_name_dev_adapter);
-
-int ffs_single_dev_adapter(struct ffs_dev *dev)
-{
-    int ret;
-
-    ret = 0;
-    ffs_dev_lock();
-
-    if (!list_is_singular(&ffs_devices))
-        ret = -EBUSY;
-    else
-        dev->single = true;
-
-    ffs_dev_unlock();
-    return ret;
-}
-EXPORT_SYMBOL_GPL(ffs_single_dev_adapter);
-/*
- * ffs_lock must be taken by the caller of this function
- */
-static void _ffs_free_dev(struct ffs_dev *dev)
-{
-    list_del(&dev->entry);
-
-    /* Clear the private_data pointer to stop incorrect dev access */
-    if (dev->ffs_data)
-        dev->ffs_data->private_data = NULL;
-
-    kfree(dev);
-    if (list_empty(&ffs_devices))
-        functionfs_cleanup();
-}
-
-static void *ffs_acquire_dev(const char *dev_name)
-{
-    struct ffs_dev *ffs_dev = NULL;
-
-    ENTER();
-    ffs_dev_lock();
-
-    ffs_dev = _ffs_find_dev(dev_name);
-    if (!ffs_dev)
-        ffs_dev = ERR_PTR(-ENOENT);
-    else if (ffs_dev->mounted)
-        ffs_dev = ERR_PTR(-EBUSY);
-    else if (ffs_dev->ffs_acquire_dev_callback &&
-        ffs_dev->ffs_acquire_dev_callback(ffs_dev))
-        ffs_dev = ERR_PTR(-ENOENT);
-    else
-        ffs_dev->mounted = true;
-
-    ffs_dev_unlock();
-    return ffs_dev;
-}
-
-static void ffs_release_dev(struct ffs_data *ffs_data)
-{
-    struct ffs_dev *ffs_dev = NULL;
-
-    ENTER();
-    ffs_dev_lock();
-
-    ffs_dev = ffs_data->private_data;
-    if (ffs_dev) {
-        ffs_dev->mounted = false;
-
-        if (ffs_dev->ffs_release_dev_callback)
-            ffs_dev->ffs_release_dev_callback(ffs_dev);
-    }
-
-    ffs_dev_unlock();
-}
-
-static int ffs_ready(struct ffs_data *ffs)
-{
-    struct ffs_dev *ffs_obj = NULL;
-    int ret = 0;
-
-    ENTER();
-    ffs_dev_lock();
-
-    ffs_obj = ffs->private_data;
-    if (!ffs_obj) {
-        ret = -EINVAL;
-        goto done;
-    }
-    if (WARN_ON(ffs_obj->desc_ready)) {
-        ret = -EBUSY;
-        goto done;
-    }
-
-    ffs_obj->desc_ready = true;
-    ffs_obj->ffs_data = ffs;
-
-    if (ffs_obj->ffs_ready_callback) {
-        ret = ffs_obj->ffs_ready_callback(ffs);
-        if (ret)
-            goto done;
-    }
-
-    set_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags);
-done:
-    ffs_dev_unlock();
-    return ret;
-}
-
-static void ffs_closed(struct ffs_data *ffs)
-{
-    struct ffs_dev *ffs_obj = NULL;
-    struct f_fs_opts *opts = NULL;
-    struct config_item *ci = NULL;
-
-    ENTER();
-    ffs_dev_lock();
-
-    ffs_obj = ffs->private_data;
-    if (!ffs_obj)
-        goto done;
-
-    ffs_obj->desc_ready = false;
-    ffs_obj->ffs_data = NULL;
-
-    if (test_and_clear_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags) &&
-        ffs_obj->ffs_closed_callback)
-        ffs_obj->ffs_closed_callback(ffs);
-
-    if (ffs_obj->opts)
-        opts = ffs_obj->opts;
-    else
-        goto done;
-
-    if (opts->no_configfs || !opts->func_inst.group.cg_item.ci_parent
-        || !kref_read(&opts->func_inst.group.cg_item.ci_kref))
-        goto done;
-
-    ci = opts->func_inst.group.cg_item.ci_parent->ci_parent;
-    ffs_dev_unlock();
-
-    if (test_bit(FFS_FL_BOUND, &ffs->flags))
-        unregister_gadget_item(ci);
-    return;
-done:
-    ffs_dev_unlock();
-}
-
-/* Misc helper functions ****************************************************/
-static int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)
-{
-    return nonblock
-        ? likely(mutex_trylock(mutex)) ? 0 : -EAGAIN
-        : mutex_lock_interruptible(mutex);
-}
-
-static char *ffs_prepare_buffer(const char __user *buf, size_t len)
-{
-    char *data = NULL;
-
-    if (unlikely(!len))
-        return NULL;
-
-    data = kmalloc(len, GFP_KERNEL);
-    if (unlikely(!data))
-        return ERR_PTR(-ENOMEM);
-
-    if (unlikely(copy_from_user(data, buf, len))) {
-        kfree(data);
-        return ERR_PTR(-EFAULT);
-    }
-
-    pr_vdebug("Buffer from user space:\n");
-    ffs_dump_mem("", data, len);
-
-    return data;
-}
-
-DECLARE_USB_FUNCTION_INIT(f_generic, ffs_alloc_inst, ffs_alloc);
-MODULE_LICENSE("GPL");
\ No newline at end of file
diff -Naur a/drivers/usb/gadget/function/u_generic.h b/drivers/usb/gadget/function/u_generic.h
--- a/drivers/usb/gadget/function/u_generic.h	2022-06-28 19:20:24.331709124 +0800
+++ b/drivers/usb/gadget/function/u_generic.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,356 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * u_fs.h
- *
- * Utility definitions for the FunctionFS
- *
- * Copyright (c) 2013 Samsung Electronics Co., Ltd.
- *		http://www.samsung.com
- *
- * Author: Andrzej Pietrasiewicz <andrzej.p@samsung.com>
- */
-
-#ifndef U_GENERIC_H
-#define U_GENERIC_H
-
-#include <linux/usb/composite.h>
-#include <linux/list.h>
-#include <linux/mutex.h>
-#include <linux/workqueue.h>
-#include <linux/refcount.h>
-#include <linux/cdev.h>
-#ifdef VERBOSE_DEBUG
-#ifndef pr_vdebug
-#  define pr_vdebug pr_debug
-#endif /* pr_vdebug */
-#  define ffs_dump_mem(prefix, ptr, len) \
-	print_hex_dump_bytes(pr_fmt(prefix ": "), DUMP_PREFIX_NONE, ptr, len)
-#else
-#ifndef pr_vdebug
-#  define pr_vdebug(...)                 do { } while (0)
-#endif /* pr_vdebug */
-#  define ffs_dump_mem(prefix, ptr, len) do { } while (0)
-#endif /* VERBOSE_DEBUG */
-
-#define ENTER()    pr_vdebug("%s()\n", __func__)
-
-#define MAX_REQUEST 64
-#define MAX_NAMELEN 64
-#define FUNCTION_GENERIC "f_generic"
-
-struct FuncNew {
-	uint32_t nameLen;
-	char     name[MAX_NAMELEN];
-};
-
-struct IoData {
-	uint32_t aio;
-	uint32_t read;
-	uint32_t len;
-	uint32_t timeout;
-	uint64_t buf;
-};
-
-struct UsbFnReqEvent {
-	uint64_t buf;
-	uint32_t actual;
-	int      status;
-};
-
-struct ffs_memory{
-  uint64_t mem;
-  uint64_t vm_start;
-  uint32_t size;
-  struct list_head memlist;
-};
-
-struct generic_memory{
-  uint32_t size;
-  uint64_t buf;
-};
-
-
-#define FUNCTIONFS_NEWFN                     _IOW('g', 60, struct FuncNew)
-#define FUNCTIONFS_DELFN                     _IOW('g', 61, struct FuncNew)
-#define FUNCTIONFS_ENDPOINT_GET_REQ_STATUS   _IOW('g', 48, struct IoData)
-#define FUNCTIONFS_ENDPOINT_WRITE            _IOW('g', 49, struct IoData)
-#define FUNCTIONFS_ENDPOINT_READ             _IOW('g', 50, struct IoData)
-#define FUNCTIONFS_ENDPOINT_RW_CANCEL        _IOW('g', 51, struct IoData)
-#define FUNCTIONFS_ENDPOINT_QUEUE_INIT       _IO('g', 52)
-#define FUNCTIONFS_ENDPOINT_QUEUE_DEL        _IO('g', 53)
-#define FUNCTIONFS_ENDPOINT_RELEASE_BUF      _IOR('g', 54, struct generic_memory)
-#define FUNCTIONFS_ENDPOINT_GET_EP0_EVENT    _IOR('g', 56, struct UsbFnReqEvent)
-
-struct f_fs_opts;
-
-struct ffs_dev {
-	struct ffs_data *ffs_data;
-	struct f_fs_opts *opts;
-	struct list_head entry;
-
-	char name[MAX_NAMELEN];
-
-	bool mounted;
-	bool desc_ready;
-	bool single;
-
-	int (*ffs_ready_callback)(struct ffs_data *ffs);
-	void (*ffs_closed_callback)(struct ffs_data *ffs);
-	void *(*ffs_acquire_dev_callback)(struct ffs_dev *dev);
-	void (*ffs_release_dev_callback)(struct ffs_dev *dev);
-};
-
-extern struct mutex ffs_lock_adapter;
-
-static inline void ffs_dev_lock(void)
-{
-	mutex_lock(&ffs_lock_adapter);
-}
-
-static inline void ffs_dev_unlock(void)
-{
-	mutex_unlock(&ffs_lock_adapter);
-}
-
-int ffs_name_dev_adapter(struct ffs_dev *dev, const char *name);
-int ffs_single_dev_adapter(struct ffs_dev *dev);
-
-struct ffs_epfile;
-struct ffs_function;
-
-enum ffs_state {
-	/*
-	 * Waiting for descriptors and strings.
-	 *
-	 * In this state no open(2), read(2) or write(2) on epfiles
-	 * may succeed (which should not be the problem as there
-	 * should be no such files opened in the first place).
-	 */
-	FFS_READ_DESCRIPTORS,
-	FFS_READ_STRINGS,
-
-	/*
-	 * We've got descriptors and strings.  We are or have called
-	 * functionfs_ready_callback().  functionfs_bind() may have
-	 * been called but we don't know.
-	 *
-	 * This is the only state in which operations on epfiles may
-	 * succeed.
-	 */
-	FFS_ACTIVE,
-
-	/*
-	 * Function is visible to host, but it's not functional. All
-	 * setup requests are stalled and transfers on another endpoints
-	 * are refused. All epfiles, except ep0, are deleted so there
-	 * is no way to perform any operations on them.
-	 *
-	 * This state is set after closing all functionfs files, when
-	 * mount parameter "no_disconnect=1" has been set. Function will
-	 * remain in deactivated state until filesystem is umounted or
-	 * ep0 is opened again. In the second case functionfs state will
-	 * be reset, and it will be ready for descriptors and strings
-	 * writing.
-	 *
-	 * This is useful only when functionfs is composed to gadget
-	 * with another function which can perform some critical
-	 * operations, and it's strongly desired to have this operations
-	 * completed, even after functionfs files closure.
-	 */
-	FFS_DEACTIVATED,
-
-	/*
-	 * All endpoints have been closed.  This state is also set if
-	 * we encounter an unrecoverable error.  The only
-	 * unrecoverable error is situation when after reading strings
-	 * from user space we fail to initialise epfiles or
-	 * functionfs_ready_callback() returns with error (<0).
-	 *
-	 * In this state no open(2), read(2) or write(2) (both on ep0
-	 * as well as epfile) may succeed (at this point epfiles are
-	 * unlinked and all closed so this is not a problem; ep0 is
-	 * also closed but ep0 file exists and so open(2) on ep0 must
-	 * fail).
-	 */
-	FFS_CLOSING
-};
-
-enum ffs_setup_state {
-	/* There is no setup request pending. */
-	FFS_NO_SETUP,
-	/*
-	 * User has read events and there was a setup request event
-	 * there.  The next read/write on ep0 will handle the
-	 * request.
-	 */
-	FFS_SETUP_PENDING,
-	/*
-	 * There was event pending but before user space handled it
-	 * some other event was introduced which canceled existing
-	 * setup.  If this state is set read/write on ep0 return
-	 * -EIDRM.  This state is only set when adding event.
-	 */
-	FFS_SETUP_CANCELLED
-};
-
-struct ffs_data {
-	struct usb_gadget		*gadget;
-	struct list_head         entry;
-	struct list_head         memory_list;
-	/*
-	 * Protect access read/write operations, only one read/write
-	 * at a time.  As a consequence protects ep0req and company.
-	 * While setup request is being processed (queued) this is
-	 * held.
-	 */
-	struct mutex			mutex;
-
-	/*
-	 * Protect access to endpoint related structures (basically
-	 * usb_ep_queue(), usb_ep_dequeue(), etc. calls) except for
-	 * endpoint zero.
-	 */
-	spinlock_t			eps_lock;
-	spinlock_t			mem_lock;
-
-	/*
-	 * XXX REVISIT do we need our own request? Since we are not
-	 * handling setup requests immediately user space may be so
-	 * slow that another setup will be sent to the gadget but this
-	 * time not to us but another function and then there could be
-	 * a race.  Is that the case? Or maybe we can use cdev->req
-	 * after all, maybe we just need some spinlock for that?
-	 */
-	struct usb_request		*ep0req;		/* P: mutex */
-	struct completion		ep0req_completion;	/* P: mutex */
-
-	/* reference counter */
-	refcount_t			ref;
-	/* how many files are opened (EP0 and others) */
-	atomic_t			opened;
-
-	/* EP0 state */
-	enum ffs_state			state;
-
-	/*
-	 * Possible transitions:
-	 * + FFS_NO_SETUP        -> FFS_SETUP_PENDING  -- P: ev.waitq.lock
-	 *               happens only in ep0 read which is P: mutex
-	 * + FFS_SETUP_PENDING   -> FFS_NO_SETUP       -- P: ev.waitq.lock
-	 *               happens only in ep0 i/o  which is P: mutex
-	 * + FFS_SETUP_PENDING   -> FFS_SETUP_CANCELLED -- P: ev.waitq.lock
-	 * + FFS_SETUP_CANCELLED -> FFS_NO_SETUP        -- cmpxchg
-	 *
-	 * This field should never be accessed directly and instead
-	 * ffs_setup_state_clear_cancelled function should be used.
-	 */
-	enum ffs_setup_state		setup_state;
-
-	/* Events & such. */
-	struct {
-		u8				types[4];
-		unsigned short			count;
-		/* XXX REVISIT need to update it in some places, or do we? */
-		unsigned short			can_stall;
-		struct usb_ctrlrequest		setup;
-
-		wait_queue_head_t		waitq;
-	} ev; /* the whole structure, P: ev.waitq.lock */
-
-	/* Flags */
-	unsigned long			flags;
-#define FFS_FL_CALL_CLOSED_CALLBACK 0
-#define FFS_FL_BOUND                1
-
-	/* For waking up blocked threads when function is enabled. */
-	wait_queue_head_t		wait;
-
-	/* Active function */
-	struct ffs_function		*func;
-
-
-	char					dev_name[MAX_NAMELEN];
-	struct cdev 			cdev;
-	dev_t 					devno;
-	struct device 			*fn_device;
-
-	struct kfifo            reqEventFifo;
-	wait_queue_head_t       wait_que;
-	/* Private data for our user (ie. gadget).  Managed by user. */
-	void				*private_data;
-	/* filled by __ffs_data_got_descs() */
-	/*
-	 * raw_descs is what you kfree, real_descs points inside of raw_descs,
-	 * where full speed, high speed and super speed descriptors start.
-	 * real_descs_length is the length of all those descriptors.
-	 */
-	const void			*raw_descs_data;
-	const void			*raw_descs;
-	unsigned			raw_descs_length;
-	unsigned			fs_descs_count;
-	unsigned			hs_descs_count;
-	unsigned			ss_descs_count;
-	unsigned			ms_os_descs_count;
-	unsigned			ms_os_descs_ext_prop_count;
-	unsigned			ms_os_descs_ext_prop_name_len;
-	unsigned			ms_os_descs_ext_prop_data_len;
-	void				*ms_os_descs_ext_prop_avail;
-	void				*ms_os_descs_ext_prop_name_avail;
-	void				*ms_os_descs_ext_prop_data_avail;
-
-	unsigned			user_flags;
-
-#define FFS_MAX_EPS_COUNT 31
-	u8				eps_addrmap[FFS_MAX_EPS_COUNT];
-
-	unsigned short			strings_count;
-	unsigned short			interfaces_count;
-	unsigned short			eps_count;
-	unsigned short			_pad1;
-
-	/* filled by __ffs_data_got_strings() */
-	/* ids in stringtabs are set in functionfs_bind() */
-	const void			*raw_strings;
-	struct usb_gadget_strings	**stringtabs;
-
-	/*
-	 * File system's super block, write once when file system is
-	 * mounted.
-	 */
-	struct super_block		*sb;
-
-	/* File permissions, written once when fs is mounted */
-	struct ffs_file_perms {
-		umode_t				mode;
-		kuid_t				uid;
-		kgid_t				gid;
-	}				file_perms;
-
-	struct eventfd_ctx *ffs_eventfd;
-	struct workqueue_struct *io_completion_wq;
-	bool no_disconnect;
-	struct work_struct reset_work;
-
-	/*
-	 * The endpoint files, filled by ffs_epfiles_create(),
-	 * destroyed by ffs_epfiles_destroy().
-	 */
-	struct ffs_epfile		*epfiles;
-	struct ffs_ep			*eps;
-	enum usb_device_speed	speed;
-};
-
-
-struct f_fs_opts {
-	struct usb_function_instance	func_inst;
-	struct ffs_dev			*dev;
-	unsigned			refcnt;
-	bool				no_configfs;
-};
-
-static inline struct f_fs_opts *to_f_fs_opts(struct usb_function_instance *fi)
-{
-	return container_of(fi, struct f_fs_opts, func_inst);
-}
-
-#endif /* U_GENERIC_H */
\ No newline at end of file
diff -Naur a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
--- a/drivers/usb/gadget/Kconfig	2022-05-27 17:20:17.673927851 +0800
+++ b/drivers/usb/gadget/Kconfig	2022-05-31 11:56:48.085256221 +0800
@@ -216,6 +216,12 @@
 config USB_F_TCM
 	tristate
 
+config USB_F_ACC
+	tristate
+
+config USB_F_AUDIO_SRC
+	tristate
+
 # this first set of drivers all depend on bulk-capable hardware.
 
 config USB_CONFIGFS
@@ -230,6 +236,14 @@
 	  appropriate symbolic links.
 	  For more information see Documentation/usb/gadget_configfs.rst.
 
+config USB_CONFIGFS_UEVENT
+	bool "Uevent notification of Gadget state"
+	depends on USB_CONFIGFS
+	help
+	  Enable uevent notifications to userspace when the gadget
+	  state changes. The gadget can be in any of the following
+	  three states: "CONNECTED/DISCONNECTED/CONFIGURED"
+
 config USB_CONFIGFS_SERIAL
 	bool "Generic serial bulk in/out"
 	depends on USB_CONFIGFS
@@ -371,6 +385,23 @@
 	  implemented in kernel space (for instance Ethernet, serial or
 	  mass storage) and other are implemented in user space.
 
+config USB_CONFIGFS_F_ACC
+	bool "Accessory gadget"
+	depends on USB_CONFIGFS
+	depends on HID=y
+	select USB_F_ACC
+	help
+	  USB gadget Accessory support
+
+config USB_CONFIGFS_F_AUDIO_SRC
+	bool "Audio Source gadget"
+	depends on USB_CONFIGFS
+	depends on SND
+	select SND_PCM
+	select USB_F_AUDIO_SRC
+	help
+	  USB gadget Audio Source support
+
 config USB_CONFIGFS_F_UAC1
 	bool "Audio Class 1.0"
 	depends on USB_CONFIGFS
diff -Naur a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c
--- a/drivers/usb/gadget/udc/core.c	2022-05-27 17:20:17.685928005 +0800
+++ b/drivers/usb/gadget/udc/core.c	2022-05-31 11:56:48.085256221 +0800
@@ -755,7 +755,7 @@
 {
 	int ret = 0;
 
-	if (gadget->deactivated)
+	if (!gadget || gadget->deactivated)
 		goto out;
 
 	if (gadget->connected) {
diff -Naur a/drivers/usb/serial/ch341.c b/drivers/usb/serial/ch341.c
--- a/drivers/usb/serial/ch341.c	2022-05-27 17:20:17.725928520 +0800
+++ b/drivers/usb/serial/ch341.c	2022-05-31 11:56:48.085256221 +0800
@@ -85,6 +85,7 @@
 	{ USB_DEVICE(0x1a86, 0x5523) },
 	{ USB_DEVICE(0x1a86, 0x7522) },
 	{ USB_DEVICE(0x1a86, 0x7523) },
+	{ USB_DEVICE(0x1a86, 0xe019) },
 	{ USB_DEVICE(0x4348, 0x5523) },
 	{ USB_DEVICE(0x9986, 0x7523) },
 	{ },
diff -Naur a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c
--- a/drivers/usb/serial/keyspan.c	2022-06-30 21:35:01.828331831 +0800
+++ b/drivers/usb/serial/keyspan.c	2022-05-27 17:20:17.729928572 +0800
@@ -2910,22 +2910,22 @@
 	for (i = 0; i < ARRAY_SIZE(p_priv->in_buffer); ++i) {
 		p_priv->in_buffer[i] = kzalloc(IN_BUFLEN, GFP_KERNEL);
 		if (!p_priv->in_buffer[i])
-			goto err_free_in_buffer;
+			goto err_in_buffer;
 	}
 
 	for (i = 0; i < ARRAY_SIZE(p_priv->out_buffer); ++i) {
 		p_priv->out_buffer[i] = kzalloc(OUT_BUFLEN, GFP_KERNEL);
 		if (!p_priv->out_buffer[i])
-			goto err_free_out_buffer;
+			goto err_out_buffer;
 	}
 
 	p_priv->inack_buffer = kzalloc(INACK_BUFLEN, GFP_KERNEL);
 	if (!p_priv->inack_buffer)
-		goto err_free_out_buffer;
+		goto err_inack_buffer;
 
 	p_priv->outcont_buffer = kzalloc(OUTCONT_BUFLEN, GFP_KERNEL);
 	if (!p_priv->outcont_buffer)
-		goto err_free_inack_buffer;
+		goto err_outcont_buffer;
 
 	p_priv->device_details = d_details;
 
@@ -2971,14 +2971,15 @@
 
 	return 0;
 
-err_free_inack_buffer:
+err_outcont_buffer:
 	kfree(p_priv->inack_buffer);
-err_free_out_buffer:
+err_inack_buffer:
 	for (i = 0; i < ARRAY_SIZE(p_priv->out_buffer); ++i)
 		kfree(p_priv->out_buffer[i]);
-err_free_in_buffer:
+err_out_buffer:
 	for (i = 0; i < ARRAY_SIZE(p_priv->in_buffer); ++i)
 		kfree(p_priv->in_buffer[i]);
+err_in_buffer:
 	kfree(p_priv);
 
 	return -ENOMEM;
diff -Naur a/drivers/video/fbdev/core/fbcon.c b/drivers/video/fbdev/core/fbcon.c
--- a/drivers/video/fbdev/core/fbcon.c	2022-05-27 17:20:17.765929037 +0800
+++ b/drivers/video/fbdev/core/fbcon.c	2022-05-31 11:56:48.085256221 +0800
@@ -365,6 +365,7 @@
 
 static void fb_flashcursor(struct work_struct *work)
 {
+#ifdef CONSOLE_CURSOR_ON
 	struct fb_info *info = container_of(work, struct fb_info, queue);
 	struct fbcon_ops *ops = info->fbcon_par;
 	struct vc_data *vc = NULL;
@@ -395,6 +396,7 @@
 	ops->cursor(vc, info, mode, get_color(vc, info, c, 1),
 		    get_color(vc, info, c, 0));
 	console_unlock();
+#endif
 }
 
 static void cursor_timer_handler(struct timer_list *t)
@@ -1328,6 +1330,7 @@
 
 static void fbcon_cursor(struct vc_data *vc, int mode)
 {
+#ifdef CONSOLE_CURSOR_ON
 	struct fb_info *info = registered_fb[con2fb_map[vc->vc_num]];
 	struct fbcon_ops *ops = info->fbcon_par;
  	int c = scr_readw((u16 *) vc->vc_pos);
@@ -1349,6 +1352,7 @@
 
 	ops->cursor(vc, info, mode, get_color(vc, info, c, 1),
 		    get_color(vc, info, c, 0));
+#endif
 }
 
 static int scrollback_phys_max = 0;
diff -Naur a/drivers/video/fbdev/core/fbmem.c b/drivers/video/fbdev/core/fbmem.c
--- a/drivers/video/fbdev/core/fbmem.c	2022-05-27 17:20:17.765929037 +0800
+++ b/drivers/video/fbdev/core/fbmem.c	2022-05-31 11:56:48.089256185 +0800
@@ -53,9 +53,9 @@
 int num_registered_fb __read_mostly;
 EXPORT_SYMBOL(num_registered_fb);
 
-bool fb_center_logo __read_mostly;
+bool fb_center_logo = true;
 
-int fb_logo_count __read_mostly = -1;
+int fb_logo_count = 1;
 
 static struct fb_info *get_fb_info(unsigned int idx)
 {
diff -Naur a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c
--- a/fs/notify/fanotify/fanotify_user.c	2022-06-21 15:22:57.075397772 +0800
+++ b/fs/notify/fanotify/fanotify_user.c	2022-05-27 17:20:17.989931926 +0800
@@ -366,6 +366,9 @@
 	if (fanotify_is_perm_event(event->mask))
 		FANOTIFY_PERM(event)->fd = fd;
 
+	if (f)
+		fd_install(fd, f);
+
 	/* Event info records order is: dir fid + name, child fid */
 	if (fanotify_event_dir_fh_len(event)) {
 		info_type = info->name_len ? FAN_EVENT_INFO_TYPE_DFID_NAME :
@@ -429,9 +432,6 @@
 		count -= ret;
 	}
 
-	if (f)
-		fd_install(fd, f);
-
 	return metadata.event_len;
 
 out_close_fd:
diff -Naur a/include/drm/bridge/dw_hdmi.h b/include/drm/bridge/dw_hdmi.h
--- a/include/drm/bridge/dw_hdmi.h	2022-05-27 17:20:18.077933060 +0800
+++ b/include/drm/bridge/dw_hdmi.h	2022-05-31 11:56:48.089256185 +0800
@@ -126,6 +126,8 @@
 struct dw_hdmi_plat_data {
 	struct regmap *regm;
 
+	unsigned int output_port;
+
 	unsigned long input_bus_encoding;
 	bool use_drm_infoframe;
 	bool ycbcr_420_allowed;
@@ -153,6 +155,8 @@
 	const struct dw_hdmi_phy_config *phy_config;
 	int (*configure_phy)(struct dw_hdmi *hdmi, void *data,
 			     unsigned long mpixelclock);
+
+	unsigned int disable_cec : 1;
 };
 
 struct dw_hdmi *dw_hdmi_probe(struct platform_device *pdev,
diff -Naur a/include/drm/bridge/dw_mipi_dsi.h b/include/drm/bridge/dw_mipi_dsi.h
--- a/include/drm/bridge/dw_mipi_dsi.h	2022-05-27 17:20:18.077933060 +0800
+++ b/include/drm/bridge/dw_mipi_dsi.h	2022-05-31 11:56:48.089256185 +0800
@@ -51,7 +51,9 @@
 	unsigned int max_data_lanes;
 
 	enum drm_mode_status (*mode_valid)(void *priv_data,
-					   const struct drm_display_mode *mode);
+					   const struct drm_display_mode *mode,
+					   unsigned long mode_flags,
+					   u32 lanes, u32 format);
 
 	const struct dw_mipi_dsi_phy_ops *phy_ops;
 	const struct dw_mipi_dsi_host_ops *host_ops;
diff -Naur a/include/drm/drm_aperture.h b/include/drm/drm_aperture.h
--- a/include/drm/drm_aperture.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/drm/drm_aperture.h	2022-05-31 11:56:48.089256185 +0800
@@ -0,0 +1,39 @@
+/* SPDX-License-Identifier: MIT */
+
+#ifndef _DRM_APERTURE_H_
+#define _DRM_APERTURE_H_
+
+#include <linux/types.h>
+
+struct drm_device;
+struct drm_driver;
+struct pci_dev;
+
+int devm_aperture_acquire_from_firmware(struct drm_device *dev, resource_size_t base,
+					resource_size_t size);
+
+int drm_aperture_remove_conflicting_framebuffers(resource_size_t base, resource_size_t size,
+						 bool primary, const struct drm_driver *req_driver);
+
+int drm_aperture_remove_conflicting_pci_framebuffers(struct pci_dev *pdev,
+						     const struct drm_driver *req_driver);
+
+/**
+ * drm_aperture_remove_framebuffers - remove all existing framebuffers
+ * @primary: also kick vga16fb if present
+ * @req_driver: requesting DRM driver
+ *
+ * This function removes all graphics device drivers. Use this function on systems
+ * that can have their framebuffer located anywhere in memory.
+ *
+ * Returns:
+ * 0 on success, or a negative errno code otherwise
+ */
+static inline int
+drm_aperture_remove_framebuffers(bool primary, const struct drm_driver *req_driver)
+{
+	return drm_aperture_remove_conflicting_framebuffers(0, (resource_size_t)-1, primary,
+							    req_driver);
+}
+
+#endif
diff -Naur a/include/drm/drm_atomic_helper.h b/include/drm/drm_atomic_helper.h
--- a/include/drm/drm_atomic_helper.h	2022-05-27 17:20:18.077933060 +0800
+++ b/include/drm/drm_atomic_helper.h	2022-05-31 11:56:48.089256185 +0800
@@ -167,7 +167,7 @@
 	drm_for_each_plane_mask(plane, (crtc)->dev, (crtc)->state->plane_mask)
 
 /**
- * drm_crtc_atomic_state_for_each_plane - iterate over attached planes in new state
+ * drm_atomic_crtc_state_for_each_plane - iterate over attached planes in new state
  * @plane: the loop cursor
  * @crtc_state: the incoming CRTC state
  *
@@ -180,7 +180,7 @@
 	drm_for_each_plane_mask(plane, (crtc_state)->state->dev, (crtc_state)->plane_mask)
 
 /**
- * drm_crtc_atomic_state_for_each_plane_state - iterate over attached planes in new state
+ * drm_atomic_crtc_state_for_each_plane_state - iterate over attached planes in new state
  * @plane: the loop cursor
  * @plane_state: loop cursor for the plane's state, must be const
  * @crtc_state: the incoming CRTC state
diff -Naur a/include/drm/drm_connector.h b/include/drm/drm_connector.h
--- a/include/drm/drm_connector.h	2022-05-27 17:20:18.077933060 +0800
+++ b/include/drm/drm_connector.h	2022-05-31 11:56:48.089256185 +0800
@@ -1622,6 +1622,9 @@
 					       u32 scaling_mode_mask);
 int drm_connector_attach_vrr_capable_property(
 		struct drm_connector *connector);
+int drm_connector_attach_hdr_output_metadata_property(struct drm_connector *connector);
+bool drm_connector_atomic_hdr_metadata_equal(struct drm_connector_state *old_state,
+					     struct drm_connector_state *new_state);
 int drm_mode_create_aspect_ratio_property(struct drm_device *dev);
 int drm_mode_create_hdmi_colorspace_property(struct drm_connector *connector);
 int drm_mode_create_dp_colorspace_property(struct drm_connector *connector);
diff -Naur a/include/dt-bindings/clock/g12a-clkc.h b/include/dt-bindings/clock/g12a-clkc.h
--- a/include/dt-bindings/clock/g12a-clkc.h	2022-05-27 17:20:18.089933214 +0800
+++ b/include/dt-bindings/clock/g12a-clkc.h	2022-05-31 11:56:48.093256151 +0800
@@ -147,5 +147,23 @@
 #define CLKID_SPICC1_SCLK			261
 #define CLKID_NNA_AXI_CLK			264
 #define CLKID_NNA_CORE_CLK			267
+#define CLKID_MIPI_DSI_PXCLK_SEL		269
+#define CLKID_MIPI_DSI_PXCLK			270
+#define CLKID_24M						271
+#define CLKID_MIPI_ISP_CLK_COMP			272
+#define CLKID_MIPI_CSI_PHY_CLK0_COMP	273
 
+#define CLKID_VDEC_P0_COMP				274
+#define CLKID_VDEC_P1_COMP				275
+#define CLKID_VDEC_MUX					276
+#define CLKID_HCODEC_P0_COMP			277
+#define CLKID_HCODEC_P1_COMP			278
+#define CLKID_HCODEC_MUX				279
+#define CLKID_HEVC_P0_COMP				280
+#define CLKID_HEVC_P1_COMP				281
+#define CLKID_HEVC_MUX					282
+#define CLKID_HEVCF_P0_COMP				283
+#define CLKID_HEVCF_P1_COMP				284
+#define CLKID_HEVCF_MUX					285
+	
 #endif /* __G12A_CLKC_H */
diff -Naur a/include/linux/amlogic/aml_gpio_consumer.h b/include/linux/amlogic/aml_gpio_consumer.h
--- a/include/linux/amlogic/aml_gpio_consumer.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/aml_gpio_consumer.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,43 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/gpio.h>
+#ifndef __AML_GPIO_CONSUMER_H__
+#define __AML_GPIO_CONSUMER_H__
+#include <linux/gpio/consumer.h>
+#include <linux/of_gpio.h>
+#define AML_GPIO_IRQ(irq_bank, filter, type) \
+(((irq_bank) & 0x7 | (filter) & 0x7) << 8 | (type & 0x3) << 16)
+
+enum {
+	GPIO_IRQ0 = 0,
+	GPIO_IRQ1,
+	GPIO_IRQ2,
+	GPIO_IRQ3,
+	GPIO_IRQ4,
+	GPIO_IRQ5,
+	GPIO_IRQ6,
+	GPIO_IRQ7,
+};
+
+enum {
+	GPIO_IRQ_HIGH = 0,
+	GPIO_IRQ_LOW,
+	GPIO_IRQ_RISING,
+	GPIO_IRQ_FALLING,
+};
+
+enum {
+	FILTER_NUM0 = 0,
+	FILTER_NUM1,
+	FILTER_NUM2,
+	FILTER_NUM3,
+	FILTER_NUM4,
+	FILTER_NUM5,
+	FILTER_NUM6,
+	FILTER_NUM7,
+};
+
+#endif
diff -Naur a/include/linux/amlogic/aml_key.h b/include/linux/amlogic/aml_key.h
--- a/include/linux/amlogic/aml_key.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/aml_key.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,76 @@
+/* SPDX-License-Identifier: LGPL-2.1+ WITH Linux-syscall-note */
+/*
+ * include/linux/amlogic/aml_key.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _AML_KEY_H_
+#define _AML_KEY_H_
+
+enum user_id {
+	DSC_LOC_DEC,
+	DSC_NETWORK,
+	DSC_LOC_ENC,
+
+	CRYPTO_T0 = 0x100,
+	CRYPTO_T1 = 0x101,
+	CRYPTO_T2 = 0x102,
+	CRYPTO_T3 = 0x103,
+	CRYPTO_T4 = 0x104,
+	CRYPTO_T5 = 0x105,
+	CRYPTO_ANY = 0x106,
+};
+
+enum key_algo {
+	KEY_ALGO_AES,
+	KEY_ALGO_TDES,
+	KEY_ALGO_DES,
+	KEY_ALGO_CSA2,
+	KEY_ALGO_CSA3,
+	KEY_ALGO_NDL,
+	KEY_ALGO_ND,
+	KEY_ALGO_S17
+};
+
+struct key_descr {
+	unsigned int key_index;
+	unsigned int key_len;
+	unsigned char key[32];
+};
+
+struct key_config {
+	unsigned int key_index;
+	int key_userid;
+	int key_algo;
+	//cur just for s17 algo
+	unsigned int ext_value;
+};
+
+struct key_alloc {
+	int is_iv;
+	unsigned int key_index;
+};
+
+#define KEY_ALLOC         _IOWR('o', 64, struct key_alloc)
+#define KEY_FREE          _IO('o', 65)
+#define KEY_SET           _IOR('o', 66, struct key_descr)
+#define KEY_CONFIG        _IOR('o', 67, struct key_config)
+#define KEY_GET_FLAG      _IOWR('o', 68, struct key_descr)
+
+//int dmx_key_init(void);
+//void dmx_key_exit(void);
+
+#endif
+
diff -Naur a/include/linux/amlogic/aml_sd.h b/include/linux/amlogic/aml_sd.h
--- a/include/linux/amlogic/aml_sd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/aml_sd.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,424 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * include/linux/amlogic/aml_sd.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_SD_H__
+#define __AML_SD_H__
+
+#include <linux/mmc/card.h>
+#include <linux/interrupt.h>
+/* unknown */
+#define CARD_TYPE_UNKNOWN		0
+/* MMC card */
+#define CARD_TYPE_MMC			1
+/* SD card */
+#define CARD_TYPE_SD			2
+/* SDIO card */
+#define CARD_TYPE_SDIO			3
+/* SD combo (IO+mem) card */
+#define CARD_TYPE_SD_COMBO		4
+/* NON sdio device (means SD/MMC card) */
+#define CARD_TYPE_NON_SDIO		5
+
+#define aml_card_type_unknown(c)	((c)->card_type == CARD_TYPE_UNKNOWN)
+#define aml_card_type_mmc(c)		((c)->card_type == CARD_TYPE_MMC)
+#define aml_card_type_sd(c)		((c)->card_type == CARD_TYPE_SD)
+#define aml_card_type_sdio(c)		((c)->card_type == CARD_TYPE_SDIO)
+#define aml_card_type_non_sdio(c)	((c)->card_type == CARD_TYPE_NON_SDIO)
+
+/* flag is "@ML" */
+#define TUNED_FLAG            0x004C4D40
+/* version is "V1" */
+#define TUNED_VERSION         0x00003156
+/* magic is 0x00487e44 */
+#define TUNED_MAGIC           0x00487e44
+
+struct mmc_phase {
+	unsigned int core_phase;
+	unsigned int tx_phase;
+	unsigned int rx_phase;
+	unsigned int tx_delay;
+};
+
+struct para_e {
+	struct mmc_phase init;
+	struct mmc_phase hs;
+	struct mmc_phase hs2;
+	struct mmc_phase hs4;
+};
+
+#define LATCHING_RXPHASE 0
+#define LATCHING_TXPHASE 1
+#define LATCHING_FIXADJ 2
+
+struct meson_mmc_data {
+	unsigned int tx_delay_mask;
+	unsigned int rx_delay_mask;
+	unsigned int always_on;
+	unsigned int adjust;
+	u8 latching_mode;
+};
+
+enum aml_host_bus_fsm { /* Host bus fsm status */
+	BUS_FSM_IDLE,           /* 0, idle */
+	BUS_FSM_SND_CMD,        /* 1, send cmd */
+	BUS_FSM_CMD_DONE,       /* 2, wait for cmd done */
+	BUS_FSM_RESP_START,     /* 3, resp start */
+	BUS_FSM_RESP_DONE,      /* 4, wait for resp done */
+	BUS_FSM_DATA_START,     /* 5, data start */
+	BUS_FSM_DATA_DONE,      /* 6, wait for data done */
+	BUS_FSM_DESC_WRITE_BACK,/* 7, wait for desc write back */
+	BUS_FSM_IRQ_SERVICE,    /* 8, wait for irq service */
+};
+
+struct sd_emmc_desc {
+	u32 cmd_cfg;
+	u32 cmd_arg;
+	u32 cmd_data;
+	u32 cmd_resp;
+};
+
+struct meson_mmc_hole {
+	u8 start;
+	u8 size;
+};
+
+struct hs400_para {
+	unsigned int delay1;
+	unsigned int delay2;
+	unsigned int intf3;
+	unsigned int flag;
+};
+
+struct hs200_para {
+	unsigned int adjust;
+};
+
+struct hs_para {
+	unsigned int adjust;
+};
+
+struct aml_tuning_para {
+	unsigned int chip_id[4];
+	unsigned int magic;
+	unsigned int vddee;
+	struct hs400_para hs4[7];
+	struct hs200_para hs2;
+	struct hs_para hs;
+	unsigned int version;
+	unsigned int busmode;
+	unsigned int update;
+	int temperature;
+	long long checksum;
+
+};
+
+struct meson_host {
+	struct	device		*dev;
+	struct	meson_mmc_data *data;
+	struct	mmc_host	*mmc;
+	struct	mmc_command	*cmd;
+
+	void __iomem *regs;
+	void __iomem *pin_mux_base;
+	void __iomem *clk_tree_base;
+	struct resource *res[3];
+	struct clk *core_clk;
+	struct clk *tx_clk;
+	struct clk *mmc_clk;
+	struct clk *mux[2];
+	struct clk *mux1_in;
+	struct clk *clk[3];
+	unsigned long req_rate;
+	bool ddr;
+
+	bool dram_access_quirk;
+
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_clk_gate;
+
+	unsigned int bounce_buf_size;
+	void *bounce_buf;
+	dma_addr_t bounce_dma_addr;
+	struct sd_emmc_desc *descs;
+	dma_addr_t descs_dma_addr;
+
+	int irq;
+
+	bool vqmmc_enabled;
+	struct para_e sdmmc;
+	char is_tuning;
+	unsigned int delay_cell;
+	bool needs_pre_post_req;
+	int sd_sdio_switch_volat_done;
+	int irq_sdio_sleep;
+	int sdio_irqen;
+	unsigned int emmc_boot_base;
+	u32 pin_mux_val;
+	u32 clk_tree_val;
+	u32 host_clk_val;
+	int debug_flag;
+	unsigned int card_type;
+	unsigned int card_insert;
+	u8 fixadj_have_hole;
+	struct meson_mmc_hole hole[3];
+	u8 fix_hole;
+	u64 align[10];
+	char cmd_retune;
+	unsigned int win_start;
+	u8 *blk_test;
+	u8 *adj_win;
+	unsigned int cmd_c;
+	int cd_irq;
+	irqreturn_t (*cd_gpio_isr)(int irq, void *dev_id);
+	int is_uart;
+	int sd_uart_init;
+	int first_temp_index;
+	int cur_temp_index;
+	int compute_cmd_delay;
+	int compute_coef;
+	unsigned int save_para;
+	unsigned int src_clk_rate;
+	struct aml_tuning_para para;
+	int run_pxp_flag;
+	int nwr_cnt;
+	bool ignore_desc_busy;
+	bool use_intf3_tuning;
+	bool src_clk_cfg_done;
+	struct dentry *debugfs_root;
+};
+
+int sdio_reset_comm(struct mmc_card *card);
+void sdio_reinit(void);
+const char *get_wifi_inf(void);
+int sdio_get_vendor(void);
+void aml_host_bus_fsm_show(struct mmc_host *mmc, int status);
+
+#define   DRIVER_NAME "meson-gx-mmc"
+
+#define	  SD_EMMC_CLOCK 0x0
+#define   CLK_DIV_MASK GENMASK(5, 0)
+#define   CLK_SRC_MASK GENMASK(7, 6)
+#define   CLK_CORE_PHASE_MASK GENMASK(9, 8)
+#define   CLK_TX_PHASE_MASK GENMASK(11, 10)
+#define   CLK_RX_PHASE_MASK GENMASK(13, 12)
+#define   CLK_PHASE_0 0
+#define   CLK_PHASE_180 2
+#define   CLK_V2_TX_DELAY_MASK GENMASK(19, 16)
+#define   CLK_V2_RX_DELAY_MASK GENMASK(23, 20)
+#define   CLK_V2_ALWAYS_ON BIT(24)
+
+#define   CLK_V3_TX_DELAY_MASK GENMASK(21, 16)
+#define   CLK_V3_RX_DELAY_MASK GENMASK(27, 22)
+#define   CLK_V3_ALWAYS_ON BIT(28)
+#define   CFG_IRQ_SDIO_SLEEP BIT(29)
+#define   CFG_IRQ_SDIO_SLEEP_DS BIT(30)
+
+#define   CLK_TX_DELAY_MASK(h)    ((h)->data->tx_delay_mask)
+#define   CLK_RX_DELAY_MASK(h)    ((h)->data->rx_delay_mask)
+#define   CLK_ALWAYS_ON(h)        ((h)->data->always_on)
+
+#define SD_EMMC_DELAY 0x4
+
+#define SD_EMMC_ADJUST 0x8
+#define   ADJUST_ADJ_DELAY_MASK GENMASK(21, 16)
+#define   ADJUST_DS_EN BIT(15)
+#define   ADJUST_ADJ_EN BIT(13)
+
+#define SD_EMMC_DELAY1 0x4
+#define SD_EMMC_DELAY2 0x8
+#define SD_EMMC_V3_ADJUST 0xc
+#define	  CALI_SEL_MASK GENMASK(11, 8)
+#define	  CALI_ENABLE BIT(12)
+#define	  CFG_ADJUST_ENABLE BIT(13)
+#define	  CALI_RISE BIT(14)
+#define	  DS_ENABLE BIT(15)
+#define	  CLK_ADJUST_DELAY GENMASK(21, 16)
+#define	  ADJ_AUTO BIT(22)
+
+#define SD_EMMC_CALOUT 0x10
+#define SD_EMMC_ADJ_IDX_LOG 0x20
+#define SD_EMMC_CLKTEST_LOG 0x24
+#define   CLKTEST_TIMES_MASK GENMASK(30, 0)
+#define   CLKTEST_DONE BIT(31)
+#define SD_EMMC_CLKTEST_OUT 0x28
+#define SD_EMMC_EYETEST_LOG 0x2c
+#define   EYETEST_TIMES_MASK GENMASK(30, 0)
+#define   EYETEST_DONE BIT(31)
+#define SD_EMMC_EYETEST_OUT0 0x30
+#define SD_EMMC_EYETEST_OUT1 0x34
+#define SD_EMMC_INTF3 0x38
+#define   CLKTEST_EXP_MASK GENMASK(4, 0)
+#define   CLKTEST_ON_M BIT(5)
+#define   EYETEST_EXP_MASK GENMASK(10, 6)
+#define   EYETEST_ON BIT(11)
+#define   DS_SHT_M_MASK GENMASK(17, 12)
+#define   DS_SHT_EXP_MASK GENMASK(21, 18)
+#define   SD_INTF3 BIT(22)
+
+#define   EYETEST_SEL BIT(26)
+#define   RESP_SEL BIT(27)
+#define   CFG_RX_SEL BIT(26)
+#define   CFG_RX_PN BIT(27)
+#define   RESP_OLD BIT(28)
+#define   RESP_PN BIT(29)
+#define   RESP_DS BIT(30)
+
+#define SD_EMMC_START 0x40
+#define   START_DESC_INIT BIT(0)
+#define   START_DESC_BUSY BIT(1)
+#define   START_DESC_ADDR_MASK GENMASK(31, 2)
+
+#define SD_EMMC_CFG 0x44
+#define   CFG_BUS_WIDTH_MASK GENMASK(1, 0)
+#define   CFG_BUS_WIDTH_1 0x0
+#define   CFG_BUS_WIDTH_4 0x1
+#define   CFG_BUS_WIDTH_8 0x2
+#define   CFG_DDR BIT(2)
+#define   CFG_BLK_LEN_MASK GENMASK(7, 4)
+#define   CFG_RESP_TIMEOUT_MASK GENMASK(11, 8)
+#define   CFG_RC_CC_MASK GENMASK(15, 12)
+#define   CFG_STOP_CLOCK BIT(22)
+#define   CFG_CLK_ALWAYS_ON BIT(18)
+#define   CFG_CHK_DS BIT(20)
+#define   CFG_AUTO_CLK BIT(23)
+#define   CFG_ERR_ABORT BIT(27)
+
+#define SD_EMMC_STATUS 0x48
+#define   STATUS_BUSY BIT(31)
+#define   STATUS_DESC_BUSY BIT(30)
+#define   STATUS_DATI GENMASK(23, 16)
+
+#define SD_EMMC_IRQ_EN 0x4c
+#define   IRQ_RXD_ERR_MASK GENMASK(7, 0)
+#define   IRQ_TXD_ERR BIT(8)
+#define   IRQ_DESC_ERR BIT(9)
+#define   IRQ_RESP_ERR BIT(10)
+#define   IRQ_CRC_ERR \
+	(IRQ_RXD_ERR_MASK | IRQ_TXD_ERR | IRQ_DESC_ERR | IRQ_RESP_ERR)
+#define   IRQ_RESP_TIMEOUT BIT(11)
+#define   IRQ_DESC_TIMEOUT BIT(12)
+#define   IRQ_TIMEOUTS \
+	(IRQ_RESP_TIMEOUT | IRQ_DESC_TIMEOUT)
+#define   IRQ_END_OF_CHAIN BIT(13)
+#define   IRQ_RESP_STATUS BIT(14)
+#define   IRQ_SDIO BIT(15)
+#define   CFG_CMD_SETUP BIT(17)
+#define   BUS_FSM_MASK GENMASK(29, 26)
+#define   IRQ_EN_MASK \
+	(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN | IRQ_RESP_STATUS |\
+	 IRQ_SDIO)
+
+#define SD_EMMC_CMD_CFG 0x50
+#define SD_EMMC_CMD_ARG 0x54
+#define SD_EMMC_CMD_DAT 0x58
+#define SD_EMMC_CMD_RSP 0x5c
+#define SD_EMMC_CMD_RSP1 0x60
+#define SD_EMMC_CMD_RSP2 0x64
+#define SD_EMMC_CMD_RSP3 0x68
+
+#define SD_EMMC_RXD 0x94
+#define SD_EMMC_TXD 0x94
+#define SD_EMMC_LAST_REG SD_EMMC_TXD
+
+#define SD_EMMC_SRAM_DESC_BUF_OFF 0x200
+#define SD_EMMC_SRAM_DATA_BUF_LEN 1024
+#define SD_EMMC_SRAM_DATA_BUF_OFF 0x400
+#define SD_EMMC_MAX_SEGS 256
+#define SD_EMMC_MAX_REQ_SIZE (128 * 1024)
+
+#define SD_EMMC_CFG_BLK_SIZE 512 /* internal buffer max: 512 bytes */
+#define SD_EMMC_CFG_RESP_TIMEOUT 256 /* in clock cycles */
+#define SD_EMMC_CMD_TIMEOUT 1024 /* in ms */
+#define SD_EMMC_CMD_TIMEOUT_DATA 4096 /* in ms */
+#define SD_EMMC_CFG_CMD_GAP 16 /* in clock cycles */
+#define SD_EMMC_DESC_BUF_LEN PAGE_SIZE
+
+#define SD_EMMC_PRE_REQ_DONE BIT(0)
+#define SD_EMMC_DESC_CHAIN_MODE BIT(1)
+
+#define MUX_CLK_NUM_PARENTS 2
+
+#define CMD_CFG_LENGTH_MASK GENMASK(8, 0)
+#define CMD_CFG_BLOCK_MODE BIT(9)
+#define CMD_CFG_R1B BIT(10)
+#define CMD_CFG_END_OF_CHAIN BIT(11)
+#define CMD_CFG_TIMEOUT_MASK GENMASK(15, 12)
+#define CMD_CFG_NO_RESP BIT(16)
+#define CMD_CFG_NO_CMD BIT(17)
+#define CMD_CFG_DATA_IO BIT(18)
+#define CMD_CFG_DATA_WR BIT(19)
+#define CMD_CFG_RESP_NOCRC BIT(20)
+#define CMD_CFG_RESP_128 BIT(21)
+#define CMD_CFG_RESP_NUM BIT(22)
+#define CMD_CFG_DATA_NUM BIT(23)
+#define CMD_CFG_CMD_INDEX_MASK GENMASK(29, 24)
+#define CMD_CFG_ERROR BIT(30)
+#define CMD_CFG_OWNER BIT(31)
+
+#define CMD_DATA_MASK GENMASK(31, 2)
+#define CMD_DATA_BIG_ENDIAN BIT(1)
+#define CMD_DATA_SRAM BIT(0)
+#define CMD_RESP_MASK GENMASK(31, 1)
+#define CMD_RESP_SRAM BIT(0)
+#define EMMC_SDIO_CLOCK_FELD    0Xffff
+#define CALI_HS_50M_ADJUST      0
+#define ERROR   1
+#define FIXED   2
+#define		SZ_1M			0x00100000
+#define	MMC_PATTERN_NAME		"pattern"
+#define	MMC_PATTERN_OFFSET		((SZ_1M * (36 + 3)) / 512)
+#define	MMC_MAGIC_NAME			"magic"
+#define	MMC_MAGIC_OFFSET		((SZ_1M * (36 + 6)) / 512)
+#define	MMC_RANDOM_NAME			"random"
+#define	MMC_RANDOM_OFFSET		((SZ_1M * (36 + 7)) / 512)
+#define	MMC_DTB_NAME			"dtb"
+#define	MMC_DTB_OFFSET			((SZ_1M * (36 + 4)) / 512)
+#define CALI_BLK_CNT	80
+#define CALI_HS_50M_ADJUST	0
+#define EMMC_SDIO_CLOCK_FELD	0Xffff
+#define MMC_PM_TIMEOUT	(2000)
+#define ERROR	1
+#define FIXED	2
+#define RETUNING	3
+#define	DATA3_PINMUX_MASK GENMASK(15, 12)
+
+#define TUNING_NUM_PER_POINT 40
+#define MAX_TUNING_RETRY 4
+#define AML_FIXED_ADJ_MAX 6
+#define AML_FIXED_ADJ_MIN 5
+#define AML_FIXADJ_STEP 4
+#define ADJ_WIN_PRINT_MAXLEN 256
+#define NO_FIXED_ADJ_MID BIT(31)
+#define AML_MV_DLY2_NOMMC_CMD(x) ((x) << 24)
+
+#define SD_EMMC_FIXED_ADJ_HS200
+#define EMMC_CMD_WIN_MAX_SIZE	50
+#define EMMC_CMD_WIN_FULL_SIZE	64
+
+#define DBG_COMMON        BIT(0)
+#define DBG_HS200         BIT(1)
+#define Print_dbg(dbg_level, fmt, args...) do {\
+		if ((dbg_level) & mmc_debug)	\
+			pr_info("[%s]" fmt, __func__, ##args);	\
+} while (0)
+
+/* delay_cell=70ps,1ns/delay_cell */
+#define DELAY_CELL_COUNTS 14
+#endif /*__AML_SD_H__*/
+
diff -Naur a/include/linux/amlogic/bt_device.h b/include/linux/amlogic/bt_device.h
--- a/include/linux/amlogic/bt_device.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/bt_device.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __PLAT_MESON_BT_DEVICE_H
+#define __PLAT_MESON_BT_DEVICE_H
+
+struct bt_dev_data {
+	int gpio_reset;
+	int gpio_en;
+	int gpio_hostwake;
+	int gpio_btwakeup;
+	int power_low_level;
+	int power_on_pin_OD;
+	int power_off_flag;
+	int power_down_disable;
+	int irqno_wakeup;
+	struct work_struct btwakeup_work;
+	struct input_dev *input_dev;
+	struct hrtimer timer;
+};
+
+int sdio_get_vendor(void);
+
+#endif
diff -Naur a/include/linux/amlogic/cpu_info.h b/include/linux/amlogic/cpu_info.h
--- a/include/linux/amlogic/cpu_info.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/cpu_info.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __CPU_INFO_H_
+#define __CPU_INFO_H_
+
+#define CHIPID_LEN 16
+void cpuinfo_get_chipid(unsigned char *cid, unsigned int size);
+
+#endif
diff -Naur a/include/linux/amlogic/cpu_version.h b/include/linux/amlogic/cpu_version.h
--- a/include/linux/amlogic/cpu_version.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/cpu_version.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,234 @@
+/*
+ * include/linux/amlogic/cpu_version.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/*
+ * All of these api should be call after early_initcall stage
+ */
+#ifndef __PLAT_MESON_CPU_H
+#define __PLAT_MESON_CPU_H
+
+#define MESON_CPU_MAJOR_ID_M8B		0x1B
+#define MESON_CPU_MAJOR_ID_GXBB		0x1F
+#define MESON_CPU_MAJOR_ID_GXTVBB	0x20
+#define MESON_CPU_MAJOR_ID_GXL		0x21
+#define MESON_CPU_MAJOR_ID_GXM		0x22
+#define MESON_CPU_MAJOR_ID_TXL		0x23
+#define MESON_CPU_MAJOR_ID_TXLX		0x24
+#define MESON_CPU_MAJOR_ID_AXG		0x25
+#define MESON_CPU_MAJOR_ID_GXLX		0x26
+#define MESON_CPU_MAJOR_ID_TXHD		0x27
+
+#define MESON_CPU_MAJOR_ID_G12A		0x28
+#define MESON_CPU_MAJOR_ID_G12B		0x29
+#define MESON_CPU_MAJOR_ID_SM1		0x2B
+
+#define MESON_CPU_MAJOR_ID_TL1		0x2E
+#define MESON_CPU_MAJOR_ID_TM2		0x2F
+
+#define MESON_CPU_VERSION_LVL_MAJOR	0
+#define MESON_CPU_VERSION_LVL_MINOR	1
+#define MESON_CPU_VERSION_LVL_PACK	2
+#define MESON_CPU_VERSION_LVL_MISC	3
+#define MESON_CPU_VERSION_LVL_MAX	MESON_CPU_VERSION_LVL_MISC
+
+#define CHIPID_LEN 16
+void cpuinfo_get_chipid(unsigned char *cid, unsigned int size);
+int  meson_cpu_version_init(void);
+#ifdef CONFIG_AMLOGIC_CPU_VERSION
+int get_meson_cpu_version(int level);
+int arch_big_cpu(int cpu);
+#else
+static inline int get_meson_cpu_version(int level)
+{
+	return -1;
+}
+
+static inline int arch_big_cpu(int cpu)
+{
+	return 0;
+}
+#endif
+
+static inline int get_cpu_type(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR);
+}
+
+static inline u32 get_cpu_package(void)
+{
+	unsigned int pk;
+
+	pk = get_meson_cpu_version(MESON_CPU_VERSION_LVL_PACK) & 0xF0;
+	return pk;
+}
+
+static inline bool package_id_is(unsigned int id)
+{
+	return get_cpu_package() == id;
+}
+
+static inline bool is_meson_m8b_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8B;
+}
+
+static inline bool is_meson_gxbb_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB;
+}
+
+static inline bool is_meson_gxtvbb_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB;
+}
+
+static inline bool is_meson_gxbb_package_905(void)
+{
+	return (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) &&
+		(get_cpu_package() != 0x20);
+}
+
+static inline bool is_meson_gxbb_package_905m(void)
+{
+	return (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) &&
+		(get_cpu_package() == 0x20);
+}
+
+static inline bool is_meson_gxl_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXL;
+}
+
+static inline bool is_meson_gxl_package_905D(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x0);
+}
+static inline bool is_meson_gxl_package_905X(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x80);
+}
+
+static inline bool is_meson_gxl_package_905L(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xc0);
+}
+
+static inline bool is_meson_gxl_package_905M2(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xe0);
+}
+
+static inline bool is_meson_gxl_package_805X(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x30);
+}
+
+static inline bool is_meson_gxl_package_805Y(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xb0);
+}
+
+static inline bool is_meson_gxm_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXM;
+}
+
+static inline bool is_meson_txl_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXL;
+}
+
+static inline bool is_meson_txl_package_950(void)
+{
+	return is_meson_txl_cpu() && package_id_is(0x20);
+}
+
+static inline bool is_meson_txlx_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXLX;
+}
+
+static inline bool is_meson_axg_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_AXG;
+}
+
+static inline bool is_meson_gxlx_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXLX;
+}
+
+static inline bool is_meson_txhd_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXHD;
+}
+
+static inline bool is_meson_g12a_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_G12A;
+}
+
+static inline bool is_meson_g12b_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_G12B;
+}
+
+static inline bool is_meson_tl1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TL1;
+}
+
+static inline bool is_meson_sm1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_SM1;
+}
+static inline bool is_meson_tm2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TM2;
+}
+
+static inline bool cpu_after_eq(unsigned int id)
+{
+	return get_cpu_type() >= id;
+}
+
+static inline bool is_meson_txlx_package_962X(void)
+{
+	return is_meson_txlx_cpu() && package_id_is(0x10);
+}
+
+static inline bool is_meson_txlx_package_962E(void)
+{
+	return is_meson_txlx_cpu() && package_id_is(0x20);
+}
+
+static inline bool is_meson_rev_a(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xA);
+}
+
+static inline bool is_meson_rev_b(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xB);
+}
+
+static inline bool is_meson_rev_c(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xC);
+}
+
+#endif
diff -Naur a/include/linux/amlogic/efuse.h b/include/linux/amlogic/efuse.h
--- a/include/linux/amlogic/efuse.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/efuse.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,37 @@
+/*
+ * include/linux/amlogic/efuse.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __EFUSE_AMLOGIC_H
+#define __EFUSE_AMLOGIC_H
+
+#if defined(CONFIG_ARM64) || defined(CONFIG_ARM64_A32)
+struct efusekey_info {
+	char keyname[32];
+	unsigned int offset;
+	unsigned int size;
+};
+
+extern int efusekeynum;
+
+int efuse_getinfo(char *item, struct efusekey_info *info);
+ssize_t efuse_user_attr_show(char *name, char *buf);
+ssize_t efuse_user_attr_store(char *name, const char *buf, size_t count);
+ssize_t efuse_user_attr_read(char *name, char *buf);
+#else
+int efuse_read_intlItem(char *intl_item, char *buf, int size);
+#endif
+#endif
diff -Naur a/include/linux/amlogic/i2c-amlogic.h b/include/linux/amlogic/i2c-amlogic.h
--- a/include/linux/amlogic/i2c-amlogic.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/i2c-amlogic.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,34 @@
+/*
+ * include/linux/amlogic/i2c-amlogic.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/platform_device.h>
+
+#define AML_I2C_SPEED_50K			50000
+#define AML_I2C_SPEED_100K			100000
+#define AML_I2C_SPEED_200K			200000
+#define AML_I2C_SPEED_300K			300000
+#define AML_I2C_SPEED_400K			400000
+#define AML_I2C_SPEED_1000K			1000000
+#define AML_I2C_SPEED_2000K			2000000
+#define AML_I2C_SPEED_3000K			3000000
+#define AML_I2C_SPEED_3400K			3400000
+
+#define AML_I2C_MASTER_AO			0
+#define AML_I2C_MASTER_A			1
+#define AML_I2C_MASTER_B			2
+#define AML_I2C_MASTER_C			3
+#define AML_I2C_MASTER_D			4
diff -Naur a/include/linux/amlogic/iomap.h b/include/linux/amlogic/iomap.h
--- a/include/linux/amlogic/iomap.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/iomap.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,129 @@
+/*
+ * include/linux/amlogic/iomap.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __SOC_IO_H
+#define __SOC_IO_H
+
+enum{
+	IO_CBUS_BASE = 0,
+	IO_APB_BUS_BASE,
+	IO_AOBUS_BASE,
+	IO_VAPB_BUS_BASE,
+	IO_HIUBUS_BASE,
+	IO_BUS_MAX,
+};
+
+extern inline int aml_reg_read(u32 bus_type, u32 reg, u32 *val);
+extern inline int aml_reg_write(u32 bus_type, u32 reg, u32 val);
+extern int aml_regmap_update_bits(u32 bus_type,
+			unsigned int reg, unsigned int mask,
+			unsigned int val);
+/*
+ ** CBUS REG Read Write and Update some bits
+ */
+extern  int aml_read_cbus(unsigned int reg);
+
+
+extern   void aml_write_cbus(unsigned int reg, unsigned int val);
+
+
+extern  void aml_cbus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+/*
+ ** AO REG Read Write and Update some bits
+ */
+extern  int aml_read_aobus(unsigned int reg);
+
+
+extern  void aml_write_aobus(unsigned int reg, unsigned int val);
+
+
+extern  void aml_aobus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+
+
+/*
+ ** VCBUS Bus REG Read Write and Update some bits
+ */
+extern  int aml_read_vcbus(unsigned int reg);
+
+extern  void aml_write_vcbus(unsigned int reg, unsigned int val);
+
+extern  void aml_vcbus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+
+/*
+ ** DOS BUS Bus REG Read Write and Update some bits
+ */
+extern  int aml_read_dosbus(unsigned int reg);
+
+extern  void aml_write_dosbus(unsigned int reg, unsigned int val);
+
+extern  void aml_dosbus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+extern int  aml_read_sec_reg(unsigned int reg);
+extern void  aml_write_sec_reg(unsigned int reg, unsigned int val);
+
+/*
+ ** HIUBUS REG Read Write and Update some bits
+ */
+extern  int aml_read_hiubus(unsigned int reg);
+
+
+extern  void aml_write_hiubus(unsigned int reg, unsigned int val);
+
+
+extern  void aml_hiubus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+#include <linux/io.h>
+extern void __iomem *vpp_base;
+extern uint vpp_max;
+
+static inline int aml_reg_vcbus_invalid(unsigned int reg)
+{
+	return !(vpp_base && (vpp_max >= reg));
+}
+
+static inline int aml_read_vcbus_s(unsigned int reg)
+{
+	return readl((vpp_base + (reg << 2)));
+}
+
+static inline void aml_write_vcbus_s(unsigned int reg, unsigned int val)
+{
+	writel(val, (vpp_base + (reg << 2)));
+}
+
+static inline void aml_vcbus_update_bits_s(unsigned int reg, unsigned int value,
+					   unsigned int start, unsigned int len)
+{
+	unsigned int tmp, orig;
+	unsigned int mask = (((1L << len) - 1) << start);
+	int r = (reg << 2);
+
+	orig =  readl((vpp_base + r));
+	tmp = orig  & ~mask;
+	tmp |= (value << start) & mask;
+	writel(tmp, (vpp_base + r));
+}
+
+#endif
diff -Naur a/include/linux/amlogic/key_manage.h b/include/linux/amlogic/key_manage.h
--- a/include/linux/amlogic/key_manage.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/key_manage.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,28 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __KEYMANAGE__
+#define __KEYMANAGE__
+
+enum {
+	UNIFYKEY_STORAGE_TYPE_INVALID = 0,
+	UNIFYKEY_STORAGE_TYPE_EMMC,
+	UNIFYKEY_STORAGE_TYPE_NAND,
+	UNIFYKEY_STORAGE_TYPE_MAX
+};
+
+struct unifykey_storage_ops {
+	s32 (*read)(u8 *buf, u32 len, u32 *actual_len);
+	s32 (*write)(u8 *buf, u32 len, u32 *actual_len);
+};
+
+struct unifykey_type {
+	u32 storage_type;
+	struct unifykey_storage_ops *ops;
+};
+
+int register_unifykey_types(struct unifykey_type *uk_type);
+
+#endif /*__KEYMANAGE__*/
diff -Naur a/include/linux/amlogic/media/canvas/canvas.h b/include/linux/amlogic/media/canvas/canvas.h
--- a/include/linux/amlogic/media/canvas/canvas.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/canvas/canvas.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,94 @@
+/*
+ * include/linux/amlogic/media/canvas/canvas.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef CANVAS_H
+#define CANVAS_H
+
+#include <linux/types.h>
+#include <linux/kobject.h>
+
+struct canvas_s {
+	struct kobject kobj;
+	u32 index;
+	ulong addr;
+	u32 width;
+	u32 height;
+	u32 wrap;
+	u32 blkmode;
+	u32 endian;
+	u32 dataL;
+	u32 dataH;
+	u32 used;
+};
+
+struct canvas_config_s {
+	u32 phy_addr;
+	u32 width;
+	u32 height;
+	u32 block_mode;
+	u32 endian;
+};
+
+#define CANVAS_ADDR_NOWRAP      0x00
+#define CANVAS_ADDR_WRAPX       0x01
+#define CANVAS_ADDR_WRAPY       0x02
+#define CANVAS_BLKMODE_MASK     3
+#define CANVAS_BLKMODE_BIT      24
+#define CANVAS_BLKMODE_LINEAR   0x00
+#define CANVAS_BLKMODE_32X32    0x01
+#define CANVAS_BLKMODE_64X32    0x02
+
+#define PPMGR_CANVAS_INDEX 0x70
+#define PPMGR_DOUBLE_CANVAS_INDEX 0x74	/*for double canvas use */
+#define PPMGR_DEINTERLACE_BUF_CANVAS 0x7a	/*for progressive mjpeg use */
+
+/*for progressive mjpeg (nv21 output)use*/
+#define PPMGR_DEINTERLACE_BUF_NV21_CANVAS 0x7e
+
+#define PPMGR2_MAX_CANVAS 16
+#define PPMGR2_CANVAS_INDEX 0x70    /* 0x70-0x7f for PPMGR2 (IONVIDEO)/ */
+
+/*
+ *the following reserved canvas index value
+ * should match the configurations defined
+ * in canvas_mgr.c canvas_pool_config().
+ */
+#define AMVDEC_CANVAS_MAX1        0xbf
+#define AMVDEC_CANVAS_MAX2        0x25
+#define AMVDEC_CANVAS_START_INDEX 0x78
+
+extern void canvas_config_config(u32 index, struct canvas_config_s *cfg);
+
+extern void canvas_config(u32 index, ulong addr, u32 width, u32 height,
+	u32 wrap, u32 blkmode);
+
+void canvas_config_ex(u32 index, ulong addr, u32 width, u32 height, u32 wrap,
+	u32 blkmode, u32 endian);
+
+extern void canvas_read(u32 index, struct canvas_s *p);
+
+extern void canvas_copy(unsigned int src, unsigned int dst);
+
+extern void canvas_update_addr(u32 index, u32 addr);
+
+extern unsigned int canvas_get_addr(u32 index);
+
+extern unsigned int canvas_get_width(u32 index);
+
+extern unsigned int canvas_get_height(u32 index);
+
+#endif /* CANVAS_H */
diff -Naur a/include/linux/amlogic/media/codec_mm/codec_mm.h b/include/linux/amlogic/media/codec_mm/codec_mm.h
--- a/include/linux/amlogic/media/codec_mm/codec_mm.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/codec_mm/codec_mm.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,167 @@
+/*
+ * include/linux/amlogic/media/codec_mm/codec_mm.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CODEC_MM_API_HEADER
+#define CODEC_MM_API_HEADER
+#include <linux/dma-direction.h>
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+
+/*
+*memflags
+*/
+#define CODEC_MM_FLAGS_DMA 1
+#define CODEC_MM_FLAGS_CPU 2
+#define CODEC_MM_FLAGS_TVP 4
+
+#define CODEC_MM_FLAGS_RESERVED 0x100
+#define CODEC_MM_FLAGS_CMA		0x200
+
+/*
+*alloc from cma first,
+*cma->then ..reserved.
+*for less memory fragment;
+*/
+#define CODEC_MM_FLAGS_CMA_FIRST 0x400
+
+/*
+*flags can used for DRM:
+*/
+#define CODEC_MM_FLAGS_FOR_VDECODER 0x1000
+#define CODEC_MM_FLAGS_FOR_ADECODER 0x2000
+#define CODEC_MM_FLAGS_FOR_ENCODER  0x4000
+
+/*
+*if cma,
+*clear thie buffer cache.
+*/
+#define CODEC_MM_FLAGS_CMA_CLEAR 0x10000
+
+/*
+*used in codec_mm owner.
+*don't not set on others.
+*/
+#define CODEC_MM_FLAGS_FOR_LOCAL_MGR  0x8000000
+
+/*used scatter manager*/
+#define CODEC_MM_FLAGS_FOR_SCATTER  0x10000000
+
+/*used for cnt phys vmaped*/
+#define CODEC_MM_FLAGS_FOR_PHYS_VMAPED  0x20000000
+
+#define CODEC_MM_FLAGS_FROM_MASK \
+	(CODEC_MM_FLAGS_DMA |\
+	CODEC_MM_FLAGS_CPU |\
+	CODEC_MM_FLAGS_TVP)
+
+#define CODEC_MM_FLAGS_DMA_CPU  (CODEC_MM_FLAGS_DMA | CODEC_MM_FLAGS_CPU)
+#define CODEC_MM_FLAGS_ANY	CODEC_MM_FLAGS_DMA_CPU
+
+/*--------------------------------------------------*/
+struct codec_mm_s {
+	/*can be shared by many user */
+	const char *owner[8];
+	int ins_id;/*used by with channel?*/
+	int ins_buffer_id;/*canbe for buffer id*/
+	/*virtual buffer of this memory */
+	char *vbuffer;
+	void *mem_handle;	/*used for top level.alloc/free */
+	void *from_ext;		/*alloced from pool*/
+	ulong phy_addr;		/*if phy continue or one page only */
+	int buffer_size;
+	int page_count;
+	int align2n;
+	/*if vbuffer is no cache set*/
+	   /*AMPORTS_MEM_FLAGS_NOCACHED  to flags */
+#define AMPORTS_MEM_FLAGS_NOCACHED (1<<0)
+	/*phy continue,need dma
+	 */
+#define AMPORTS_MEM_FLAGS_DMA (1<<1)
+	int flags;
+#define AMPORTS_MEM_FLAGS_FROM_SYS 1
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES 2
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED 3
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA 4
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP 5
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES 6
+#define AMPORTS_MEM_FLAGS_FROM_GET_FROM_COHERENT 7
+	int from_flags;
+	/*may can be shared on many user..*/
+	   /*decoder/di/ppmgr,*/
+	atomic_t use_cnt;
+	spinlock_t lock;
+	char *pagemap;
+	int pagemap_size;
+	int alloced_page_num;
+	u64 alloced_jiffies;
+	int mem_id;
+	int next_bit;
+	struct list_head list;
+	u32 tvp_handle;
+};
+struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
+		int align2n, int memflags);
+unsigned long codec_mm_alloc_for_dma_ex(
+		const char *owner,
+		int page_cnt,
+		int align2n,
+		int memflags,
+		int ins_id,
+		int buffer_id);
+
+void codec_mm_release(struct codec_mm_s *mem, const char *owner);
+int codec_mm_has_owner(struct codec_mm_s *mem, const char *owner);
+int codec_mm_request_shared_mem(struct codec_mm_s *mem, const char *owner);
+/*call if not make sure valid data.*/
+void codec_mm_release_with_check(struct codec_mm_s *mem, const char *owner);
+unsigned long dma_get_cma_size_int_byte(struct device *dev);
+
+
+/*---------------------------------------------------------------*/
+
+unsigned long codec_mm_alloc_for_dma(const char *owner, int page_cnt,
+	int align2n, int memflags);
+int codec_mm_free_for_dma(const char *owner, unsigned long phy_addr);
+
+void *codec_mm_phys_to_virt(unsigned long phy_addr);
+unsigned long codec_mm_virt_to_phys(void *vaddr);
+u8 *codec_mm_vmap(ulong addr, u32 size);
+void codec_mm_unmap_phyaddr(u8 *vaddr);
+
+void codec_mm_dma_flush(void *vaddr,
+	int size,
+	enum dma_data_direction dir);
+
+int codec_mm_get_total_size(void);
+int codec_mm_get_free_size(void);
+int codec_mm_get_reserved_size(void);
+int codec_mm_enough_for_size(int size, int with_wait);
+int codec_mm_disable_tvp(void);
+int codec_mm_enable_tvp(void);
+int codec_mm_video_tvp_enabled(void);
+void *codec_mm_dma_alloc_coherent(const char *owner, int size,
+			dma_addr_t *dma_handle, gfp_t flag, int memflags);
+void codec_mm_dma_free_coherent(const char *owner, int size,
+			void *cpu_addr, dma_addr_t dma_handle, int memflags);
+
+struct device *v4l_get_dev_from_codec_mm(void);
+struct codec_mm_s *v4l_reqbufs_from_codec_mm(const char *owner,
+	unsigned int addr, unsigned int size, unsigned int index);
+void v4l_freebufs_back_to_codec_mm(const char *owner, struct codec_mm_s *mem);
+
+#endif
diff -Naur a/include/linux/amlogic/media/codec_mm/codec_mm_keeper.h b/include/linux/amlogic/media/codec_mm/codec_mm_keeper.h
--- a/include/linux/amlogic/media/codec_mm/codec_mm_keeper.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/codec_mm/codec_mm_keeper.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,35 @@
+/*
+ * include/linux/amlogic/media/codec_mm/codec_mm_keeper.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef CODEC_MM_KEEPER_HEADER
+#define CODEC_MM_KEEPER_HEADER
+
+#define MEM_TYPE_CODEC_MM			111
+#define MEM_TYPE_CODEC_MM_SCATTER	222
+
+/*
+ *don't call in interrupt;
+ */
+int codec_mm_keeper_mask_keep_mem(void *mem_handle, int type);
+
+int is_codec_mm_keeped(void *mem_handle);
+/*
+ *can call in irq
+ */
+int codec_mm_keeper_unmask_keeper(int keep_id, int delayms);
+
+#endif
diff -Naur a/include/linux/amlogic/media/codec_mm/codec_mm_scatter.h b/include/linux/amlogic/media/codec_mm/codec_mm_scatter.h
--- a/include/linux/amlogic/media/codec_mm/codec_mm_scatter.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/codec_mm/codec_mm_scatter.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,116 @@
+/*
+ * include/linux/amlogic/media/codec_mm/codec_mm_scatter.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CODEC_MM_SCATTER_HEADER
+#define CODEC_MM_SCATTER_HEADER
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+
+/*#define PHY_ADDR_NEED_64BITS*/
+#ifdef PHY_ADDR_NEED_64BITS
+#define phy_addr_type u64
+#else /* */
+#define phy_addr_type u32
+#endif
+#define page_sid_type u16
+
+#define PAGE_INDEX(page) (page >> PAGE_SHIFT)
+
+struct codec_mm_scatter {
+	void *manager;
+	phy_addr_type *pages_list;
+	int page_max_cnt;
+	int page_cnt;		/*page num */
+	int page_tail;		/*last page in list */
+	int page_used;
+	spinlock_t lock;
+	atomic_t user_cnt;
+	unsigned long tofree_jiffies;
+	struct mutex mutex;
+	struct list_head list;	/*hold list. */
+};
+
+enum e_mmu_free_status {
+		MMU_FREE_START,
+		MMU_FREE_START_LOCK,
+		MMU_FREE_SCATTER_START,
+		MMU_FREE_SCATTER_START_LOCK,
+		MMU_FREE_SCATTER_START_DTS,
+		MMU_FREE_SCATTER_START_DTS_LOCK,
+		MMU_FREE_SCATTER_START_SMGT,
+		MMU_FREE_SCATTER_START_SMGT_LOCK,
+		MMU_FREE_SCATTER_START_SMGT_LOCK_DONE,
+		MMU_FREE_SCATTER_START_DTS_LOCK_DONE,
+		MMU_FREE_SCATTER_START_LOCK_DONE,
+		MMU_FREE_START_LOCK_DONE,
+};
+
+enum e_mmu_alloc_status {
+		MMU_ALLOC_START,
+		MMU_ALLOC_START_LOCK,
+		MMU_ALLOC_SCATTER_START,
+		MMU_ALLOC_SCATTER_START_LOCK,
+		MMU_ALLOC_SCATTER_START_LOCK_DONE,
+		MMU_ALLOC_SCATTER_ALLOC_NEW,
+		MMU_ALLOC_SCATTER_ALLOC_NEW_END,
+		MMU_ALLOC_SCATTER_ALLOC_WANT_PAGE_IN,
+		MMU_ALLOC_SCATTER_LOCK,
+		MMU_ALLOC_SCATTER_LOCK_END,
+		MMU_ALLOC_from_cache_scatter,
+		MMU_ALLOC_from_cache_scatter_1,
+		MMU_ALLOC_from_cache_scatter_2,
+		MMU_ALLOC_from_cache_scatter_3,
+		MMU_ALLOC_from_cache_scatter_4,
+		MMU_ALLOC_from_cache_scatter_5,
+		MMU_ALLOC_from_cache_scatter_end,
+		MMU_ALLOC_from_free_scatter,
+		MMU_ALLOC_from_free_scatter_end,
+		MMU_ALLOC_from_slot,
+		MMU_ALLOC_from_slot_end,
+		MMU_ALLOC_LIST_LOCK_START,
+		MMU_ALLOC_LIST_LOCK,
+		MMU_ALLOC_LIST_LOCK_END,
+		MMU_ALLOC_SCATTER_ALLOC_WANT_PAGE_IN_END,
+		MMU_ALLOC_SCATTER_ALLOC_WANT_PAGE_IN_2,
+		MMU_ALLOC_SCATTER_ALLOC_WANT_PAGE_IN_2_END,
+		MMU_ALLOC_START_LOCK_DONE,
+};
+
+
+int codec_mm_scatter_free_all_pages(struct codec_mm_scatter *mms);
+
+int codec_mm_scatter_free_tail_pages(struct codec_mm_scatter *mms,
+	int start_free_id);
+int codec_mm_scatter_free_tail_pages_fast(struct codec_mm_scatter *mms,
+	int start_free_id);
+int codec_mm_scatter_free_tail_pages_fast(struct codec_mm_scatter *mms,
+	int start_free_id);
+
+struct codec_mm_scatter *codec_mm_scatter_alloc(int max_page,
+	int page_num, int istvp);
+int codec_mm_scatter_alloc_want_pages(struct codec_mm_scatter *mms,
+			int want_pages);
+int codec_mm_scatter_size(int is_tvp);
+int codec_mm_scatter_mgt_delay_free_swith(int on, int delay_ms,
+	int wait_size_M, int istvp);
+int codec_mm_dump_scatter(struct codec_mm_scatter *mms, void *buf, int size);
+int codec_mm_scatter_dec_owner_user(void *sc_mm, int delay_ms);
+
+#endif
diff -Naur a/include/linux/amlogic/media/codec_mm/configs_api.h b/include/linux/amlogic/media/codec_mm/configs_api.h
--- a/include/linux/amlogic/media/codec_mm/configs_api.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/codec_mm/configs_api.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,48 @@
+/*
+ * include/linux/amlogic/media/codec_mm/configs_api.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef AMLOGIC_MEDIA_CONFIG_API__
+#define AMLOGIC_MEDIA_CONFIG_API__
+#include <linux/ioctl.h>
+#define MAX_ITEM_NAME 128
+#define MAX_PREFIX_NAME 128
+#define MAX_VALUE_NAME  256
+struct media_config_io_str {
+	union{
+		int subcmd;
+		int ret;
+	};
+	union {
+		int para[10];
+		char cmd_path[MAX_PREFIX_NAME + MAX_ITEM_NAME + 4];
+	};
+	union {
+		char val[MAX_VALUE_NAME];
+		char *ptr;
+	};
+};
+
+
+#define AML_CONFIG  'C'
+#define MEDIA_CONFIG_SET_CMD_STR _IOW((AML_CONFIG), 0x1,\
+				struct media_config_io_str)
+#define MEDIA_CONFIG_GET_CMD_STR _IOWR((AML_CONFIG), 0x2,\
+				struct media_config_io_str)
+
+#endif
+
+
diff -Naur a/include/linux/amlogic/media/codec_mm/configs.h b/include/linux/amlogic/media/codec_mm/configs.h
--- a/include/linux/amlogic/media/codec_mm/configs.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/codec_mm/configs.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,270 @@
+/*
+ * include/linux/amlogic/media/codec_mm/configs.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef AMLOGIC_MEDIA_CONFIG_HEADER__
+#define AMLOGIC_MEDIA_CONFIG_HEADER__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/amlogic/media/codec_mm/configs_api.h>
+
+#define MAX_DEPTH 8
+
+typedef int (*get_fun)(const char *trigger, int id, char *buf, int size);
+
+typedef int (*set_fun)(const char *trigger, int id, const char *buf, int size);
+
+struct mconfig {
+#define CONFIG_TYPE_PI32 1
+#define CONFIG_TYPE_PU32 2
+#define CONFIG_TYPE_PU64 4
+#define CONFIG_TYPE_PBOOL 5
+
+#define CONFIG_TYPE_PSTR 7
+#define CONFIG_TYPE_PCSTR 8
+#define CONFIG_TYPE_I32 21
+#define CONFIG_TYPE_U32 22
+#define CONFIG_TYPE_U64 24
+#define CONFIG_TYPE_BOOL 25
+
+#define CONFIG_TYPE_FUN 100
+	int type;
+	int id;
+	const char *item_name;
+	union {
+		void *buf_ptr;
+		char *str;
+		const char *cstr;
+
+		int *pival;
+		u32 *pu32val;
+		u64 *pu64val;
+
+		int ival;
+		u32 u32val;
+		u32 u32mval[2];
+		u64 u64val;
+		bool boolval;
+		bool *pboolval;
+		char b[8];
+		long ldata[2];
+		struct {
+			get_fun f_get;	/*used 0 */
+			set_fun f_set;	/*used 1 */
+		};
+	};
+	int size;
+};
+
+struct mconfig_node {
+	char prefix[MAX_PREFIX_NAME];
+	const char *name;
+	int active;
+	int depth;
+	struct mconfig_node *parent_node;
+	struct list_head list;
+	int son_node_num;
+	struct list_head son_node_list;
+	struct mutex lock;
+	int configs_num;
+	struct mconfig *configs;
+	atomic_t ref_cnt;
+	 /*
+	  *rw_flags:
+	  * CONFIG_FOR_R: support read.
+	  * CONFIG_FOR_W: support write.
+	  * CONFIG_FOR_T: CONFIG FOR TRIGGER;
+	  */
+#define CONFIG_FOR_R 1
+#define CONFIG_FOR_W 2
+#define CONFIG_FOR_T 4
+#define CONFIG_FOR_RW (CONFIG_FOR_R | CONFIG_FOR_W)
+	int rw_flags;
+};
+
+#define MC_U32(n, v) \
+	{.type = CONFIG_TYPE_U32, .item_name = (n), .u32val = (v)}
+
+#define MC_I32(n, v) \
+	{.type = CONFIG_TYPE_I32, .item_name = (n), .ival = (v)}
+
+#define MC_U64(n, v) \
+	{.type = CONFIG_TYPE_U32, .item_name = (n), .u64val = (v)}
+#define MC_BOOL(n, v) \
+	{.type = CONFIG_TYPE_BOOL, .item_name = (n), .boolval = (v)}
+
+#define MC_STR(n, v) \
+	{.type = CONFIG_TYPE_PSTR, .item_name = (n), .str = (v)}
+
+#define MC_CSTR(n, v) \
+	{.type = CONFIG_TYPE_PCSTR, .item_name = (n), .cstr = (v)}
+
+#define MC_PI32(n, v) \
+	{.type = CONFIG_TYPE_PI32, .item_name = (n), .pival = (v)}
+
+#define MC_PU32(n, v) \
+	{.type = CONFIG_TYPE_PU32, .item_name = (n), .pu32val = (v)}
+
+#define MC_PU64(n, v) \
+	{.type = CONFIG_TYPE_PU64, .item_name = (n), .pu64val = (v)}
+
+#define MC_PBOOL(n, v) \
+	{.type = CONFIG_TYPE_PBOOL, .item_name = (n), .pboolval = (v)}
+
+#define MC_FUN(n, fget, fset) \
+	{.type = CONFIG_TYPE_FUN, .item_name = (n),\
+	.f_get = (fget), .f_set = (fset)}
+
+#define MC_FUN_ID(n, fget, fset, cid) \
+	{.type = CONFIG_TYPE_FUN, .item_name = (n),\
+	.f_get = (fget), .f_set = (fset), .id = (cid)}
+
+
+#define REG_CONFIGS(node, configs) \
+	configs_register_configs(node, configs,\
+	sizeof(configs)/sizeof(struct mconfig))
+
+#define REG_PATH_CONFIGS(path, configs) \
+		configs_register_path_configs(path, configs,\
+		sizeof(configs)/sizeof(struct mconfig))
+
+#define INIT_REG_NODE_CONFIGS(prefix, node, name, config, rw)\
+	do {\
+		configs_init_new_node(node, name, rw);\
+		REG_CONFIGS(node, config);\
+		configs_register_path_node(prefix, node);\
+	} while (0)
+
+int configs_inc_node_ref(struct mconfig_node *node);
+int configs_dec_node_ref(struct mconfig_node *node);
+
+int configs_init_new_node(
+	struct mconfig_node *node, const char *name,
+	int rw_flags);
+
+int configs_register_node(
+	struct mconfig_node *parent,
+	struct mconfig_node *new_node);
+int configs_register_path_node(
+	const char *path, struct mconfig_node *new_node);
+
+int configs_register_configs(
+	struct mconfig_node *node, struct mconfig *configs,
+	int num);
+int configs_register_path_configs(
+	const char *path, struct mconfig *configs,
+	int num);
+
+int configs_del_endnode(
+	struct mconfig_node *parent, struct mconfig_node *node);
+int configs_get_node_path_u32(
+	struct mconfig_node *topnode, const char *path,
+	u32 *val);
+int configs_get_node_path_u64(
+	struct mconfig_node *topnode, const char *path,
+	u64 *val);
+int configs_get_node_path_2u32(
+	struct mconfig_node *topnode, const char *path,
+	u32 *val);
+int configs_get_node_path_buf(
+	struct mconfig_node *topnode, const char *path,
+	char *buf, int size);
+int configs_set_node_path_u32(
+	struct mconfig_node *topnode, const char *path,
+	u32 val);
+int configs_set_node_path_u64(
+	struct mconfig_node *topnode, const char *path,
+	u64 val);
+int configs_set_node_path_2u32(
+	struct mconfig_node *topnode, const char *path,
+	u32 val1, u32 val2);
+
+int configs_set_node_path_str(
+	struct mconfig_node *topnode, const char *path,
+	const char *val);
+int configs_set_node_path_valonpath(
+	struct mconfig_node *topnode,
+	const char *path);
+
+static inline int configs_set_path_str(
+	const char *path, const char *val)
+{
+	return configs_set_node_path_str(NULL, path, val);
+}
+
+int configs_set_node_path_str(
+	struct mconfig_node *topnode, const char *path,
+	const char *val);
+
+int configs_set_node_nodepath_str(
+	struct mconfig_node *topnode,
+	const char *path, const char *val);
+
+static inline int configs_set_path_valonpath(
+	const char *path)
+{
+	return configs_set_node_path_valonpath(NULL, path);
+}
+
+int configs_set_prefix_path_valonpath(
+	const char *prfix, const char *pathval);
+int configs_set_prefix_path_str(
+	const char *prfix, const char *path,
+	const char *str);
+
+int configs_get_node_path_str(
+	struct mconfig_node *topnode, const char *path,
+	char *buf, int size);
+
+int configs_get_node_nodepath_str(
+	struct mconfig_node *topnode,
+	const char *path, char *buf, int size);
+
+#define LIST_MODE_LIST_RD			(CONFIG_FOR_R)
+#define LIST_MODE_LIST_WD			(CONFIG_FOR_W)
+#define LIST_MODE_LIST_RW (LIST_MODE_LIST_RD | LIST_MODE_LIST_WD)
+#define LIST_MODE_VAL				(1<<8)
+#define LIST_MODE_CONFIGS			(1<<9)
+#define LIST_MODE_CONFIGS_VAL	(LIST_MODE_VAL | LIST_MODE_CONFIGS)
+#define LIST_MODE_NODE_INFO		(1<<10)
+#define LIST_MODE_PATH_NODE		(1<<11)
+#define LIST_MODE_PATH_PREFIX	(1<<12)
+#define LIST_MODE_PATH_FULLPREFIX   (1<<13)
+#define LIST_MODE_SUB_NODES		(1<<15)
+
+#define LIST_MODE_NODE_PATH_CONFIGS \
+	(LIST_MODE_LIST_RW | LIST_MODE_PATH_PREFIX | LIST_MODE_CONFIGS)
+#define LIST_MODE_NODE_CMD_VAL \
+		(LIST_MODE_NODE_PATH_CONFIGS | LIST_MODE_VAL)
+#define LIST_MODE_NODE_CMD_ALL \
+	(LIST_MODE_NODE_CMD_VAL | LIST_MODE_SUB_NODES | LIST_MODE_NODE_INFO)
+#define LIST_MODE_NODE_CMDVAL_ALL \
+	(LIST_MODE_NODE_CMD_ALL | LIST_MODE_VAL)
+#define LIST_MODE_FULL_CMA_ALL \
+	(LIST_MODE_NODE_CMD_ALL | LIST_MODE_PATH_FULLPREFIX)
+#define LIST_MODE_FULL_CMDVAL_ALL \
+	(LIST_MODE_FULL_CMA_ALL | LIST_MODE_VAL)
+
+int configs_list_node_configs(struct mconfig_node *node, char *buf, int size,
+							  int mode);
+int configs_list_nodes(struct mconfig_node *node, char *buf, int size,
+					   int mode);
+int configs_list_path_nodes(const char *prefix, char *buf, int size, int mode);
+
+#endif
diff -Naur a/include/linux/amlogic/media/ge2d/ge2d_cmd.h b/include/linux/amlogic/media/ge2d/ge2d_cmd.h
--- a/include/linux/amlogic/media/ge2d/ge2d_cmd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/ge2d/ge2d_cmd.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,44 @@
+/*
+ * include/linux/amlogic/media/ge2d/ge2d_cmd.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2D_CMD_H_
+#define _GE2D_CMD_H_
+
+#define GE2D_GET_CAP                        0x470b
+#define GE2D_BLEND_NOALPHA_NOBLOCK          0x470a
+#define GE2D_BLEND_NOALPHA                  0x4709
+#define	GE2D_STRETCHBLIT_NOALPHA_NOBLOCK    0x4708
+#define	GE2D_BLIT_NOALPHA_NOBLOCK           0x4707
+#define	GE2D_BLEND_NOBLOCK                  0x4706
+#define	GE2D_BLIT_NOBLOCK                   0x4705
+#define	GE2D_STRETCHBLIT_NOBLOCK            0x4704
+#define	GE2D_FILLRECTANGLE_NOBLOCK          0x4703
+
+
+#define	GE2D_STRETCHBLIT_NOALPHA            0x4702
+#define	GE2D_BLIT_NOALPHA                   0x4701
+#define	GE2D_BLEND                          0x4700
+#define	GE2D_BLIT                           0x46ff
+#define	GE2D_STRETCHBLIT                    0x46fe
+#define	GE2D_FILLRECTANGLE                  0x46fd
+#define	GE2D_SRCCOLORKEY_OLD                0x46fc
+#define	GE2D_SET_COEF                       0x46fb
+#define	GE2D_CONFIG_EX_OLD                  0x46fa
+#define	GE2D_CONFIG_OLD                     0x46f9
+#define	GE2D_ANTIFLICKER_ENABLE             0x46f8
+
+#endif
diff -Naur a/include/linux/amlogic/media/ge2d/ge2d_func.h b/include/linux/amlogic/media/ge2d/ge2d_func.h
--- a/include/linux/amlogic/media/ge2d/ge2d_func.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/ge2d/ge2d_func.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,124 @@
+/*
+ * include/linux/amlogic/media/ge2d/ge2d_func.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2D_FUNC_H_
+#define _GE2D_FUNC_H_
+
+#define BLENDOP_ADD           0    /* Cd = Cs*Fs+Cd*Fd */
+#define BLENDOP_SUB           1    /* Cd = Cs*Fs-Cd*Fd */
+#define BLENDOP_REVERSE_SUB   2    /* Cd = Cd*Fd-Cs*Fs */
+#define BLENDOP_MIN           3    /* Cd = Min(Cd*Fd,Cs*Fs) */
+#define BLENDOP_MAX           4    /* Cd = Max(Cd*Fd,Cs*Fs) */
+#define BLENDOP_LOGIC         5    /* Cd = Cs op Cd */
+#define BLENDOP_LOGIC_CLEAR       (BLENDOP_LOGIC+0)
+#define BLENDOP_LOGIC_COPY        (BLENDOP_LOGIC+1)
+#define BLENDOP_LOGIC_NOOP        (BLENDOP_LOGIC+2)
+#define BLENDOP_LOGIC_SET         (BLENDOP_LOGIC+3)
+#define BLENDOP_LOGIC_COPY_INVERT (BLENDOP_LOGIC+4)
+#define BLENDOP_LOGIC_INVERT      (BLENDOP_LOGIC+5)
+#define BLENDOP_LOGIC_AND_REVERSE (BLENDOP_LOGIC+6)
+#define BLENDOP_LOGIC_OR_REVERSE  (BLENDOP_LOGIC+7)
+#define BLENDOP_LOGIC_AND         (BLENDOP_LOGIC+8)
+#define BLENDOP_LOGIC_OR          (BLENDOP_LOGIC+9)
+#define BLENDOP_LOGIC_NAND        (BLENDOP_LOGIC+10)
+#define BLENDOP_LOGIC_NOR         (BLENDOP_LOGIC+11)
+#define BLENDOP_LOGIC_XOR         (BLENDOP_LOGIC+12)
+#define BLENDOP_LOGIC_EQUIV       (BLENDOP_LOGIC+13)
+#define BLENDOP_LOGIC_AND_INVERT  (BLENDOP_LOGIC+14)
+#define BLENDOP_LOGIC_OR_INVERT   (BLENDOP_LOGIC+15)
+
+static inline unsigned int blendop(unsigned int color_blending_mode,
+			       unsigned int color_blending_src_factor,
+			       unsigned int color_blending_dst_factor,
+			       unsigned int alpha_blending_mode,
+			       unsigned int alpha_blending_src_factor,
+			       unsigned int alpha_blending_dst_factor)
+{
+	return (color_blending_mode << 24) |
+	       (color_blending_src_factor << 20) |
+	       (color_blending_dst_factor << 16) |
+	       (alpha_blending_mode << 8) |
+	       (alpha_blending_src_factor << 4) |
+	       (alpha_blending_dst_factor << 0);
+}
+
+/* GE2D bitblt functions */
+void bitblt(struct ge2d_context_s *wq,
+	    int src_x, int src_y, int w, int h,
+	    int dst_x, int dst_y);
+
+void bitblt_noblk(struct ge2d_context_s *wq,
+		  int src_x, int src_y, int w, int h,
+		  int dst_x, int dst_y);
+
+void bitblt_noalpha(struct ge2d_context_s *wq,
+		    int src_x, int src_y, int w, int h,
+		    int dst_x, int dst_y);
+
+void bitblt_noalpha_noblk(struct ge2d_context_s *wq,
+			  int src_x, int src_y, int w, int h,
+			  int dst_x, int dst_y);
+
+/* GE2D stretchblt functions */
+void stretchblt(struct ge2d_context_s *wq,
+		int src_x, int src_y, int src_w, int src_h,
+		int dst_x, int dst_y, int dst_w, int dst_h);
+
+void stretchblt_noblk(struct ge2d_context_s *wq,
+		      int src_x, int src_y, int src_w, int src_h,
+		      int dst_x, int dst_y, int dst_w, int dst_h);
+
+void stretchblt_noalpha(struct ge2d_context_s *wq,
+			int src_x, int src_y, int src_w, int src_h,
+			int dst_x, int dst_y, int dst_w, int dst_h);
+
+void stretchblt_noalpha_noblk(struct ge2d_context_s *wq,
+			      int src_x, int src_y, int src_w, int src_h,
+			      int dst_x, int dst_y, int dst_w, int dst_h);
+
+/* GE2D fillrect functions */
+void fillrect(struct ge2d_context_s *wq,
+	      int x, int y, int w, int h, unsigned int color);
+
+void fillrect_noblk(struct ge2d_context_s *wq,
+		    int x, int y, int w, int h, unsigned int color);
+
+/* GE2D blend functions */
+void blend(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op);
+
+void blend_noblk(struct ge2d_context_s *wq,
+		 int src_x, int src_y, int src_w, int src_h,
+		 int src2_x, int src2_y, int src2_w, int src2_h,
+		 int dst_x, int dst_y, int dst_w, int dst_h,
+		 int op);
+
+void blend_noalpha(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op);
+
+void blend_noalpha_noblk(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op);
+#endif
diff -Naur a/include/linux/amlogic/media/ge2d/ge2d.h b/include/linux/amlogic/media/ge2d/ge2d.h
--- a/include/linux/amlogic/media/ge2d/ge2d.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/media/ge2d/ge2d.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,1224 @@
+/*
+ * include/linux/amlogic/media/ge2d/ge2d.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2D_H_
+#define _GE2D_H_
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/semaphore.h>
+
+#include <linux/soc/amlogic/meson-canvas.h>
+
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+
+enum ge2d_memtype_s {
+	AML_GE2D_MEM_ION,
+	AML_GE2D_MEM_DMABUF,
+	AML_GE2D_MEM_INVALID,
+};
+
+#define MAX_PLANE         4
+#define MAX_BITBLT_WORK_CONFIG 4
+#define MAX_GE2D_CMD  32   /* 64 */
+
+#define CONFIG_GE2D_ADV_NUM
+#define CONFIG_GE2D_SRC2
+#define GE2D_STATE_IDLE                 0
+#define GE2D_STATE_RUNNING              1
+#define GE2D_STATE_CLEANUP              2
+#define GE2D_STATE_REMOVING_WQ          3
+#define	GE2D_PROCESS_QUEUE_START        0
+#define	GE2D_PROCESS_QUEUE_STOP         1
+
+#define RELEASE_SRC1_CANVAS 0x01
+#define RELEASE_SRC2_CANVAS 0x02
+#define RELEASE_SRC1_BUFFER 0x04
+#define RELEASE_SRC2_BUFFER 0x08
+#define RELEASE_CB          0x10
+#define RELEASE_REQUIRED    0x1f
+
+#define START_FLAG          0x20
+#define RELEASE_FLAG        0x40
+#define FINISH_FLAG         0x80
+
+#define FORMAT_8BIT_COMPONENT   0
+#define COMPONENT_Y_OR_R      0
+#define COMPONENT_Cb_OR_G     1
+#define COMPONENT_Cr_OR_B     2
+#define COMPONENT_ALPHA       3
+#define FORMAT_422_YUV          1
+#define FORMAT_444_YUV_OR_RGB   2
+#define FORMAT_YUVA_OR_RGBA     3
+
+#define FILL_MODE_BOUNDARY_PIXEL    0
+#define FILL_MODE_DEFAULT_COLOR     1
+
+#define OPERATION_ADD           0    /* Cd = Cs*Fs+Cd*Fd */
+#define OPERATION_SUB           1    /* Cd = Cs*Fs-Cd*Fd */
+#define OPERATION_REVERSE_SUB   2    /* Cd = Cd*Fd-Cs*Fs */
+#define OPERATION_MIN           3    /* Cd = Min(Cd*Fd,Cs*Fs) */
+#define OPERATION_MAX           4    /* Cd = Max(Cd*Fd,Cs*Fs) */
+#define OPERATION_LOGIC         5
+
+#define COLOR_FACTOR_ZERO                     0
+#define COLOR_FACTOR_ONE                      1
+#define COLOR_FACTOR_SRC_COLOR                2
+#define COLOR_FACTOR_ONE_MINUS_SRC_COLOR      3
+#define COLOR_FACTOR_DST_COLOR                4
+#define COLOR_FACTOR_ONE_MINUS_DST_COLOR      5
+#define COLOR_FACTOR_SRC_ALPHA                6
+#define COLOR_FACTOR_ONE_MINUS_SRC_ALPHA      7
+#define COLOR_FACTOR_DST_ALPHA                8
+#define COLOR_FACTOR_ONE_MINUS_DST_ALPHA      9
+#define COLOR_FACTOR_CONST_COLOR              10
+#define COLOR_FACTOR_ONE_MINUS_CONST_COLOR    11
+#define COLOR_FACTOR_CONST_ALPHA              12
+#define COLOR_FACTOR_ONE_MINUS_CONST_ALPHA    13
+#define COLOR_FACTOR_SRC_ALPHA_SATURATE       14
+
+#define ALPHA_FACTOR_ZERO                     0
+#define ALPHA_FACTOR_ONE                      1
+#define ALPHA_FACTOR_SRC_ALPHA                2
+#define ALPHA_FACTOR_ONE_MINUS_SRC_ALPHA      3
+#define ALPHA_FACTOR_DST_ALPHA                4
+#define ALPHA_FACTOR_ONE_MINUS_DST_ALPHA      5
+#define ALPHA_FACTOR_CONST_ALPHA              6
+#define ALPHA_FACTOR_ONE_MINUS_CONST_ALPHA    7
+
+#define LOGIC_OPERATION_CLEAR       0
+#define LOGIC_OPERATION_COPY        1
+#define LOGIC_OPERATION_NOOP        2
+#define LOGIC_OPERATION_SET         3
+#define LOGIC_OPERATION_COPY_INVERT 4
+#define LOGIC_OPERATION_INVERT      5
+#define LOGIC_OPERATION_AND_REVERSE 6
+#define LOGIC_OPERATION_OR_REVERSE  7
+#define LOGIC_OPERATION_AND         8
+#define LOGIC_OPERATION_OR          9
+#define LOGIC_OPERATION_NAND        10
+#define LOGIC_OPERATION_NOR         11
+#define LOGIC_OPERATION_XOR         12
+#define LOGIC_OPERATION_EQUIV       13
+#define LOGIC_OPERATION_AND_INVERT  14
+#define LOGIC_OPERATION_OR_INVERT   15
+
+#define DST_CLIP_MODE_INSIDE    0
+#define DST_CLIP_MODE_OUTSIDE   1
+
+#define FILTER_TYPE_BICUBIC     1
+#define FILTER_TYPE_BILINEAR    2
+#define FILTER_TYPE_TRIANGLE    3
+#define FILTER_TYPE_GAU0    4
+#define FILTER_TYPE_GAU0_BOT    5
+#define FILTER_TYPE_GAU1    6
+
+#define MATRIX_YCC_TO_RGB               (1 << 0)
+#define MATRIX_RGB_TO_YCC               (1 << 1)
+#define MATRIX_FULL_RANGE_YCC_TO_RGB    (1 << 2)
+#define MATRIX_RGB_TO_FULL_RANGE_YCC    (1 << 3)
+#define MATRIX_BT_STANDARD              (1 << 4)
+#define MATRIX_BT_601                   (0 << 4)
+#define MATRIX_BT_709                   (1 << 4)
+#define MATRIX_CUSTOM                   BIT(5)
+
+#define GE2D_FORMAT_BT_STANDARD         (1 << 28)
+#define GE2D_FORMAT_BT601               (0 << 28)
+#define GE2D_FORMAT_BT709               (1 << 28)
+#define GE2D_MATRIX_CUSTOM              BIT(29)
+
+#define GE2D_ENDIAN_SHIFT	24
+#define GE2D_ENDIAN_MASK            (0x1 << GE2D_ENDIAN_SHIFT)
+#define GE2D_BIG_ENDIAN             (0 << GE2D_ENDIAN_SHIFT)
+#define GE2D_LITTLE_ENDIAN          (1 << GE2D_ENDIAN_SHIFT)
+
+#define GE2D_COLOR_MAP_SHIFT        20
+#define GE2D_COLOR_MAP_MASK         (0xf << GE2D_COLOR_MAP_SHIFT)
+/* nv12 &nv21, only works on m6*/
+#define GE2D_COLOR_MAP_NV12		(15 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_NV21		(14 << GE2D_COLOR_MAP_SHIFT)
+
+/* deep color, only works after TXL */
+#define GE2D_COLOR_MAP_10BIT_YUV444		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_10BIT_VUY444		(5 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_10BIT_YUV422		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_10BIT_YVU422		(1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_12BIT_YUV422		(8 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_12BIT_YVU422		(9 << GE2D_COLOR_MAP_SHIFT)
+
+/* 16 bit */
+#define GE2D_COLOR_MAP_YUV422		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGB655		(1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUV655		(1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGB844		(2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUV844		(2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA6442     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA6442     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA4444     (4 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA4444     (4 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGB565       (5 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUV565       (5 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB4444		(6 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV4444		(6 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB1555     (7 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV1555     (7 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA4642     (8 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA4642     (8 << GE2D_COLOR_MAP_SHIFT)
+/* 24 bit */
+#define GE2D_COLOR_MAP_RGB888       (0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUV444       (0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA5658     (1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA5658     (1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB8565     (2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV8565     (2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_RGBA6666     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA6666     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB6666     (4 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV6666     (4 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_BGR888		(5 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_VUY888		(5 << GE2D_COLOR_MAP_SHIFT)
+/* 32 bit */
+#define GE2D_COLOR_MAP_RGBA8888		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_YUVA8888		(0 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ARGB8888     (1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AYUV8888     (1 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_ABGR8888     (2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_AVUY8888     (2 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_BGRA8888     (3 << GE2D_COLOR_MAP_SHIFT)
+#define GE2D_COLOR_MAP_VUYA8888     (3 << GE2D_COLOR_MAP_SHIFT)
+
+/*
+ * format code is defined as:
+ * [18] : 1-deep color mode(10/12 bit), 0-8bit mode
+ * [17] : 1-YUV color space, 0-RGB color space
+ * [16] : compress_range, 1-full ramge, 0-limited range
+ * [9:8]: format
+ * [7:6]: 8bit_mode_sel
+ * [5]  : LUT_EN
+ * [4:3]: PIC_STRUCT
+ * [2]  : SEP_EN
+ * [1:0]: X_YC_RATIO, SRC1_Y_YC_RATIO
+ */
+#define GE2D_FORMAT_MASK                0x0ffff
+#define GE2D_BPP_MASK                   0x00300
+#define GE2D_BPP_8BIT                   0x00000
+#define GE2D_BPP_16BIT                  0x00100
+#define GE2D_BPP_24BIT                  0x00200
+#define GE2D_BPP_32BIT                  0x00300
+#define GE2D_FORMAT_DEEP_COLOR   0x40000
+#define GE2D_FORMAT_YUV                 0x20000
+#define GE2D_FORMAT_FULL_RANGE          0x10000
+/*bit8(2)  format   bi6(2) mode_8b_sel  bit5(1)lut_en   bit2 sep_en*/
+/*M  separate block S one block.*/
+
+#define GE2D_FMT_S8_Y		0x00000 /* 00_00_0_00_0_00 */
+#define GE2D_FMT_S8_CB		0x00040 /* 00_01_0_00_0_00 */
+#define GE2D_FMT_S8_CR		0x00080 /* 00_10_0_00_0_00 */
+#define GE2D_FMT_S8_R		0x00000 /* 00_00_0_00_0_00 */
+#define GE2D_FMT_S8_G		0x00040 /* 00_01_0_00_0_00 */
+#define GE2D_FMT_S8_B		0x00080 /* 00_10_0_00_0_00 */
+#define GE2D_FMT_S8_A		0x000c0 /* 00_11_0_00_0_00 */
+#define GE2D_FMT_S8_LUT		0x00020 /* 00_00_1_00_0_00 */
+#define GE2D_FMT_S16_YUV422	0x20102 /* 01_00_0_00_0_00 */
+#define GE2D_FMT_S16_RGB (GE2D_LITTLE_ENDIAN|0x00100) /* 01_00_0_00_0_00 */
+#define GE2D_FMT_S24_YUV444	0x20200 /* 10_00_0_00_0_00 */
+#define GE2D_FMT_S24_RGB (GE2D_LITTLE_ENDIAN|0x00200) /* 10_00_0_00_0_00 */
+#define GE2D_FMT_S32_YUVA444	0x20300 /* 11_00_0_00_0_00 */
+#define GE2D_FMT_S32_RGBA (GE2D_LITTLE_ENDIAN|0x00300) /* 11_00_0_00_0_00 */
+#define GE2D_FMT_M24_YUV420	0x20007 /* 00_00_0_00_1_11 */
+#define GE2D_FMT_M24_YUV422	0x20006 /* 00_00_0_00_1_10 */
+#define GE2D_FMT_M24_YUV444	0x20004 /* 00_00_0_00_1_00 */
+#define GE2D_FMT_M24_RGB		0x00004 /* 00_00_0_00_1_00 */
+#define GE2D_FMT_M24_YUV420T	0x20017 /* 00_00_0_10_1_11 */
+#define GE2D_FMT_M24_YUV420B	0x2001f /* 00_00_0_11_1_11 */
+
+#define GE2D_FMT_M24_YUV420SP		0x20207
+#define GE2D_FMT_M24_YUV422SP           0x20206
+/* 01_00_0_00_1_11 nv12 &nv21, only works on m6. */
+#define GE2D_FMT_M24_YUV420SPT		0x20217
+/* 01_00_0_00_1_11 nv12 &nv21, only works on m6. */
+#define GE2D_FMT_M24_YUV420SPB		0x2021f
+
+#define GE2D_FMT_S16_YUV422T	0x20110 /* 01_00_0_10_0_00 */
+#define GE2D_FMT_S16_YUV422B	0x20138 /* 01_00_0_11_0_00 */
+#define GE2D_FMT_S24_YUV444T	0x20210 /* 10_00_0_10_0_00 */
+#define GE2D_FMT_S24_YUV444B	0x20218 /* 10_00_0_11_0_00 */
+
+/* only works after TXL and for src1. */
+#define GE2D_FMT_S24_10BIT_YUV444		0x60200
+#define GE2D_FMT_S24_10BIT_YUV444T		0x60210
+#define GE2D_FMT_S24_10BIT_YUV444B		0x60218
+
+#define GE2D_FMT_S16_10BIT_YUV422		0x60102
+#define GE2D_FMT_S16_10BIT_YUV422T		0x60112
+#define GE2D_FMT_S16_10BIT_YUV422B		0x6011a
+
+#define GE2D_FMT_S16_12BIT_YUV422		0x60102
+#define GE2D_FMT_S16_12BIT_YUV422T		0x60112
+#define GE2D_FMT_S16_12BIT_YUV422B		0x6011a
+
+
+/* back compatible defines */
+#define GE2D_FORMAT_S8_Y            (GE2D_FORMAT_YUV|GE2D_FMT_S8_Y)
+#define GE2D_FORMAT_S8_CB          (GE2D_FORMAT_YUV|GE2D_FMT_S8_CB)
+#define GE2D_FORMAT_S8_CR          (GE2D_FORMAT_YUV|GE2D_FMT_S8_CR)
+#define GE2D_FORMAT_S8_R            GE2D_FMT_S8_R
+#define GE2D_FORMAT_S8_G            GE2D_FMT_S8_G
+#define GE2D_FORMAT_S8_B            GE2D_FMT_S8_B
+#define GE2D_FORMAT_S8_A            GE2D_FMT_S8_A
+#define GE2D_FORMAT_S8_LUT          GE2D_FMT_S8_LUT
+/* nv12 &nv21, only works on m6. */
+#define GE2D_FORMAT_M24_NV12  (GE2D_FMT_M24_YUV420SP | GE2D_COLOR_MAP_NV12)
+#define GE2D_FORMAT_M24_NV12T (GE2D_FMT_M24_YUV420SPT | GE2D_COLOR_MAP_NV12)
+#define GE2D_FORMAT_M24_NV12B (GE2D_FMT_M24_YUV420SPB | GE2D_COLOR_MAP_NV12)
+#define GE2D_FORMAT_M24_NV21  (GE2D_FMT_M24_YUV420SP | GE2D_COLOR_MAP_NV21)
+#define GE2D_FORMAT_M24_NV21T (GE2D_FMT_M24_YUV420SPT | GE2D_COLOR_MAP_NV21)
+#define GE2D_FORMAT_M24_NV21B (GE2D_FMT_M24_YUV420SPB | GE2D_COLOR_MAP_NV21)
+
+
+#define GE2D_FORMAT_S12_RGB_655 (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_RGB655)
+#define GE2D_FORMAT_S16_YUV422 (GE2D_FMT_S16_YUV422 | GE2D_COLOR_MAP_YUV422)
+#define GE2D_FORMAT_S16_RGB_655 (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_RGB655)
+#define GE2D_FORMAT_S24_YUV444 (GE2D_FMT_S24_YUV444 | GE2D_COLOR_MAP_YUV444)
+#define GE2D_FORMAT_S24_RGB (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_RGB888)
+#define GE2D_FORMAT_S32_YUVA444 (GE2D_FMT_S32_YUVA444 | GE2D_COLOR_MAP_YUVA4444)
+#define GE2D_FORMAT_S32_RGBA (GE2D_FMT_S32_RGBA | GE2D_COLOR_MAP_RGBA8888)
+#define GE2D_FORMAT_M24_YUV420      GE2D_FMT_M24_YUV420
+#define GE2D_FORMAT_M24_YUV422      GE2D_FMT_M24_YUV422
+#define GE2D_FORMAT_M24_YUV444      GE2D_FMT_M24_YUV444
+#define GE2D_FORMAT_M24_RGB         GE2D_FMT_M24_RGB
+#define GE2D_FORMAT_M24_YUV420T     GE2D_FMT_M24_YUV420T
+#define GE2D_FORMAT_M24_YUV420B     GE2D_FMT_M24_YUV420B
+#define GE2D_FORMAT_M24_YUV422SP (GE2D_FMT_M24_YUV422SP | GE2D_COLOR_MAP_NV12)
+#define GE2D_FORMAT_S16_YUV422T (GE2D_FMT_S16_YUV422T | GE2D_COLOR_MAP_YUV422)
+#define GE2D_FORMAT_S16_YUV422B (GE2D_FMT_S16_YUV422B | GE2D_COLOR_MAP_YUV422)
+#define GE2D_FORMAT_S24_YUV444T (GE2D_FMT_S24_YUV444T | GE2D_COLOR_MAP_YUV444)
+#define GE2D_FORMAT_S24_YUV444B (GE2D_FMT_S24_YUV444B | GE2D_COLOR_MAP_YUV444)
+/* format added in A1H */
+/*16 bit*/
+#define GE2D_FORMAT_S16_RGB_565   (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_RGB565)
+#define GE2D_FORMAT_S16_RGB_844   (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_RGB844)
+#define GE2D_FORMAT_S16_RGBA_6442 (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_RGBA6442)
+#define GE2D_FORMAT_S16_RGBA_4444 (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_RGBA4444)
+#define GE2D_FORMAT_S16_ARGB_4444 (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_ARGB4444)
+#define GE2D_FORMAT_S16_ARGB_1555 (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_ARGB1555)
+#define GE2D_FORMAT_S16_RGBA_4642 (GE2D_FMT_S16_RGB | GE2D_COLOR_MAP_RGBA4642)
+/*24 bit*/
+#define GE2D_FORMAT_S24_RGBA_5658 (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_RGBA5658)
+#define GE2D_FORMAT_S24_ARGB_8565 (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_ARGB8565)
+#define GE2D_FORMAT_S24_RGBA_6666 (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_RGBA6666)
+#define GE2D_FORMAT_S24_ARGB_6666 (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_ARGB6666)
+#define GE2D_FORMAT_S24_BGR (GE2D_FMT_S24_RGB | GE2D_COLOR_MAP_BGR888)
+/*32 bit*/
+#define GE2D_FORMAT_S32_ARGB (GE2D_FMT_S32_RGBA | GE2D_COLOR_MAP_ARGB8888)
+#define GE2D_FORMAT_S32_ABGR (GE2D_FMT_S32_RGBA | GE2D_COLOR_MAP_ABGR8888)
+#define GE2D_FORMAT_S32_BGRA (GE2D_FMT_S32_RGBA | GE2D_COLOR_MAP_BGRA8888)
+
+/* format added in TXL */
+#define GE2D_FORMAT_S24_10BIT_YUV444 \
+	(GE2D_FMT_S24_10BIT_YUV444 | GE2D_COLOR_MAP_10BIT_YUV444)
+
+#define GE2D_FORMAT_S24_10BIT_VUY444 \
+	(GE2D_FMT_S24_10BIT_YUV444 | GE2D_COLOR_MAP_10BIT_VUY444)
+
+#define GE2D_FORMAT_S16_10BIT_YUV422 \
+	(GE2D_FMT_S16_10BIT_YUV422 | GE2D_COLOR_MAP_10BIT_YUV422)
+
+#define GE2D_FORMAT_S16_10BIT_YUV422T \
+	(GE2D_FMT_S16_10BIT_YUV422T | GE2D_COLOR_MAP_10BIT_YUV422)
+
+#define GE2D_FORMAT_S16_10BIT_YUV422B \
+		(GE2D_FMT_S16_10BIT_YUV422B | GE2D_COLOR_MAP_10BIT_YUV422)
+
+#define GE2D_FORMAT_S16_10BIT_YVU422 \
+	(GE2D_FMT_S16_10BIT_YUV422 | GE2D_COLOR_MAP_10BIT_YVU422)
+
+#define GE2D_FORMAT_S16_12BIT_YUV422 \
+	(GE2D_FMT_S16_12BIT_YUV422 | GE2D_COLOR_MAP_12BIT_YUV422)
+
+#define GE2D_FORMAT_S16_12BIT_YUV422T \
+	(GE2D_FMT_S16_12BIT_YUV422T | GE2D_COLOR_MAP_12BIT_YUV422)
+
+#define GE2D_FORMAT_S16_12BIT_YUV422B \
+	(GE2D_FMT_S16_12BIT_YUV422B | GE2D_COLOR_MAP_12BIT_YUV422)
+
+#define GE2D_FORMAT_S16_12BIT_YVU422 \
+	(GE2D_FMT_S16_12BIT_YUV422 | GE2D_COLOR_MAP_12BIT_YVU422)
+
+
+#define	UPDATE_SRC_DATA     0x01
+#define	UPDATE_SRC_GEN      0x02
+#define	UPDATE_DST_DATA     0x04
+#define	UPDATE_DST_GEN      0x08
+#define	UPDATE_DP_GEN       0x10
+#define	UPDATE_SCALE_COEF   0x20
+#define	UPDATE_ALL          0x3f
+
+struct rectangle_s {
+	int x;   /* X coordinate of its top-left point */
+	int y;   /* Y coordinate of its top-left point */
+	int w;   /* width of it */
+	int h;   /* height of it */
+};
+
+struct ge2d_para_s {
+	unsigned int    color;
+	struct rectangle_s src1_rect;
+	struct rectangle_s src2_rect;
+	struct rectangle_s dst_rect;
+	int op;
+};
+
+struct ge2d_gen_s {
+	unsigned char     interrupt_ctrl;
+
+	unsigned char     dp_onoff_mode;
+	unsigned char     vfmt_onoff_en;
+	unsigned int      dp_on_cnt;
+	unsigned int      dp_off_cnt;
+	unsigned int      fifo_size;
+	unsigned int      burst_ctrl;
+};
+
+struct ge2d_src1_data_s {
+	unsigned char     urgent_en;
+	unsigned char     ddr_burst_size_y;
+	unsigned char     ddr_burst_size_cb;
+	unsigned char     ddr_burst_size_cr;
+	unsigned int	  canaddr;
+	unsigned char     x_yc_ratio;
+	unsigned char     y_yc_ratio;
+	unsigned char     sep_en;
+	unsigned char     format;
+
+	unsigned char     endian;
+	unsigned char     color_map;
+
+	unsigned char     mode_8b_sel;
+	unsigned char     lut_en;
+	unsigned char     deep_color;
+	unsigned char     mult_rounding;
+	unsigned char     alpha_conv_mode0;
+	unsigned char     alpha_conv_mode1;
+	unsigned char     color_conv_mode0;
+	unsigned char     color_conv_mode1;
+	unsigned int      def_color;
+	unsigned int      format_all;
+	unsigned int      phy_addr;
+	unsigned int      stride;
+};
+
+struct ge2d_src1_gen_s {
+	int               clipx_start;
+	int               clipx_end;
+	int               clipy_start;
+	int               clipy_end;
+	unsigned char     clipx_start_ex;
+	unsigned char     clipx_end_ex;
+	unsigned char     clipy_start_ex;
+	unsigned char     clipy_end_ex;
+	unsigned char     pic_struct;
+	/* bit1 for outside alpha , bit0 for color data */
+	unsigned char     fill_mode;
+	unsigned int      outside_alpha;
+	unsigned char     chfmt_rpt_pix;
+	unsigned char     cvfmt_rpt_pix;
+};
+
+struct ge2d_src2_dst_data_s {
+	unsigned char     urgent_en;
+	unsigned char     ddr_burst_size;
+	unsigned char     src2_canaddr;
+	unsigned char     src2_format;
+
+	unsigned char     src2_endian;
+	unsigned char     src2_color_map;
+
+	unsigned char     src2_mode_8b_sel;
+	unsigned int      src2_def_color;
+
+	unsigned int     dst_canaddr;
+	unsigned char    dst_format;
+
+	unsigned char     dst_endian;
+	unsigned char     dst_color_map;
+
+	unsigned char     dst_mode_8b_sel;
+
+	unsigned int      src2_format_all;
+	unsigned int      dst_format_all;
+
+	/* only for m6 */
+	unsigned char	dst2_pixel_byte_width;
+	unsigned char	dst2_color_map;
+	unsigned char	dst2_discard_mode;
+	unsigned char	dst2_enable;
+
+	unsigned int src2_phyaddr;
+	unsigned int src2_stride;
+	unsigned int dst_phyaddr;
+	unsigned int dst_stride;
+};
+
+struct ge2d_src2_dst_gen_s {
+	int               src2_clipx_start;
+	int               src2_clipx_end;
+	int               src2_clipy_start;
+	int               src2_clipy_end;
+	unsigned char     src2_pic_struct;
+	/* bit1 for outside alpha , bit0 for color data */
+	unsigned char     src2_fill_mode;
+	unsigned int      src2_outside_alpha;
+
+	int               dst_clipx_start;
+	int               dst_clipx_end;
+	int               dst_clipy_start;
+	int               dst_clipy_end;
+	unsigned char     dst_clip_mode;
+	unsigned char     dst_pic_struct;
+};
+
+struct ge2d_dp_gen_s {
+	/* scaler related */
+	unsigned char     src1_vsc_bank_length;
+	unsigned char     src1_vsc_phase0_always_en;
+	unsigned char     src1_hsc_bank_length;
+	unsigned char     src1_hsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	unsigned char     src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	unsigned char     src1_vsc_rpt_ctrl;
+	unsigned char     src1_hsc_nearest_en;
+	unsigned char     src1_vsc_nearest_en;
+
+	unsigned char     antiflick_en;
+	unsigned char     antiflick_ycbcr_rgb_sel;
+	unsigned char     antiflick_cbcr_en;
+	/* Y= (R * r_coef + G * g_coef + B * b_coef)/256 */
+	unsigned int      antiflick_r_coef;
+	unsigned int      antiflick_g_coef;
+	unsigned int      antiflick_b_coef;
+	unsigned int      antiflick_color_filter_n1[4];
+	unsigned int      antiflick_color_filter_n2[4];
+	unsigned int      antiflick_color_filter_n3[4];
+	unsigned int      antiflick_color_filter_th[3];
+	unsigned int      antiflick_alpha_filter_n1[4];
+	unsigned int      antiflick_alpha_filter_n2[4];
+	unsigned int      antiflick_alpha_filter_n3[4];
+	unsigned int      antiflick_alpha_filter_th[3];
+	/* matrix related */
+	unsigned char     use_matrix_default;
+	unsigned char     conv_matrix_en;
+	unsigned char     matrix_sat_in_en;
+	unsigned char     matrix_minus_16_ctrl; /* 3bit */
+	unsigned char     matrix_sign_ctrl;     /* 3bit */
+	int               matrix_offset[3];
+	int               matrix_coef[9];
+
+	unsigned char     src1_gb_alpha_en;
+	unsigned char     src1_gb_alpha;
+#ifdef CONFIG_GE2D_SRC2
+	unsigned char     src2_gb_alpha_en;
+	unsigned char     src2_gb_alpha;
+	unsigned char     src2_cmult_ad;
+#endif
+	unsigned int      alu_const_color;
+
+	unsigned char     src1_key_en;
+	unsigned char     src2_key_en;
+	unsigned char     src1_key_mode;
+	unsigned char     src2_key_mode;
+	unsigned int      src1_key;
+	unsigned int      src2_key;
+	unsigned int      src1_key_mask;
+	unsigned int      src2_key_mask;
+	unsigned char     bitmask_en;
+	unsigned char     bytemask_only;
+	unsigned int      bitmask;
+
+};
+
+struct ge2d_cmd_s {
+	int              src1_x_start;
+	int              src1_y_start;
+	int              src1_x_end;
+	int              src1_y_end;
+	/* unsigned char    src1_x_start_ex; */
+	/* unsigned char    src1_y_start_ex; */
+	/* unsigned char    src1_x_end_ex; */
+	/* unsigned char    src1_y_end_ex; */
+
+	unsigned char    src1_x_rev;
+	unsigned char    src1_y_rev;
+	/* unsigned char    src1_x_chr_phase; */
+	/* unsigned char    src1_y_chr_phase; */
+	unsigned char    src1_fill_color_en;
+	unsigned int     src1_fmt;
+
+	int              src2_x_start;
+	int              src2_y_start;
+	int              src2_x_end;
+	int              src2_y_end;
+	unsigned char    src2_x_rev;
+	unsigned char    src2_y_rev;
+	unsigned char    src2_fill_color_en;
+	unsigned int     src2_fmt;
+
+	int              dst_x_start;
+	int              dst_y_start;
+	int              dst_x_end;
+	int              dst_y_end;
+	unsigned char    dst_xy_swap;
+	unsigned char    dst_x_rev;
+	unsigned char    dst_y_rev;
+	unsigned int     dst_fmt;
+
+	int              sc_prehsc_en;
+	int              sc_prevsc_en;
+	int              sc_hsc_en;
+	int              sc_vsc_en;
+	int              vsc_phase_step;
+	int              vsc_phase_slope;
+	unsigned char    vsc_rpt_l0_num;
+	int              vsc_ini_phase;
+	int              hsc_phase_step;
+	int              hsc_phase_slope;
+	unsigned char    hsc_rpt_p0_num;
+	int              hsc_ini_phase;
+	unsigned char    hsc_div_en;
+	unsigned int    hsc_div_length;
+	int              hsc_adv_num;
+	int              hsc_adv_phase;
+
+	unsigned char    src1_cmult_asel;
+	unsigned char    src2_cmult_asel;
+#ifdef CONFIG_GE2D_SRC2
+	unsigned char    src2_cmult_ad;
+#endif
+	unsigned char    color_blend_mode;
+	unsigned char    color_src_blend_factor;
+	unsigned char    color_dst_blend_factor;
+	unsigned char    color_logic_op;
+
+	unsigned char    alpha_blend_mode;
+	unsigned char    alpha_src_blend_factor;
+	unsigned char    alpha_dst_blend_factor;
+	unsigned char    alpha_logic_op;
+
+	int (*cmd_cb)(unsigned int);
+	unsigned int     cmd_cb_param;
+	unsigned int     src1_buffer;
+	unsigned int     src2_buffer;
+	unsigned char    release_flag;
+	unsigned char    wait_done_flag;
+	unsigned char    hang_flag;
+};
+
+struct ge2d_canvas_cfg_s {
+	int canvas_used;
+	int canvas_index;
+	unsigned int stride;
+	unsigned int height;
+	unsigned long phys_addr;
+};
+
+struct ge2d_dma_cfg_s {
+	int dma_used;
+	void *dma_cfg;
+};
+
+struct ge2d_matrix_s {
+	unsigned int pre_offset0;
+	unsigned int pre_offset1;
+	unsigned int pre_offset2;
+	unsigned int coef0;
+	unsigned int coef1;
+	unsigned int coef2;
+	unsigned int coef3;
+	unsigned int coef4;
+	unsigned int coef5;
+	unsigned int coef6;
+	unsigned int coef7;
+	unsigned int coef8;
+	unsigned int offset0;
+	unsigned int offset1;
+	unsigned int offset2;
+	/* input y/cb/cr saturation enable */
+	unsigned char sat_in_en;
+};
+
+struct ge2d_config_s {
+	struct ge2d_gen_s            gen;
+	struct ge2d_src1_data_s      src1_data;
+	struct ge2d_src1_gen_s       src1_gen;
+	struct ge2d_src2_dst_data_s  src2_dst_data;
+	struct ge2d_src2_dst_gen_s   src2_dst_gen;
+	struct ge2d_dp_gen_s         dp_gen;
+	unsigned int	v_scale_coef_type;
+	unsigned int	h_scale_coef_type;
+	unsigned int	update_flag;
+	struct ge2d_canvas_cfg_s src_canvas_cfg[MAX_PLANE];
+	struct ge2d_canvas_cfg_s src2_canvas_cfg[MAX_PLANE];
+	struct ge2d_canvas_cfg_s dst_canvas_cfg[MAX_PLANE];
+	struct ge2d_dma_cfg_s src_dma_cfg[MAX_PLANE];
+	struct ge2d_dma_cfg_s src2_dma_cfg[MAX_PLANE];
+	struct ge2d_dma_cfg_s dst_dma_cfg[MAX_PLANE];
+	struct ge2d_matrix_s matrix_custom;
+};
+
+struct ge2d_dma_buf_s {
+	dma_addr_t paddr;
+	void *vaddr;
+	int len;
+};
+
+enum ge2d_data_type_e {
+	AML_GE2D_SRC,
+	AML_GE2D_SRC2,
+	AML_GE2D_DST,
+	AML_GE2D_TYPE_INVALID,
+};
+
+enum ge2d_src_dst_e {
+	OSD0_OSD0 = 0,
+	OSD0_OSD1,
+	OSD1_OSD1,
+	OSD1_OSD0,
+	ALLOC_OSD0,
+	ALLOC_OSD1,
+	ALLOC_ALLOC,
+	TYPE_INVALID,
+};
+
+enum ge2d_src_canvas_type_e {
+	CANVAS_OSD0 = 0,
+	CANVAS_OSD1,
+	CANVAS_ALLOC,
+	CANVAS_TYPE_INVALID,
+};
+
+struct ge2d_queue_item_s {
+	struct list_head list;
+	struct ge2d_cmd_s cmd;
+	struct ge2d_config_s config;
+};
+
+struct ge2d_context_s {
+	/* connect all process in one queue for RR process. */
+	struct list_head   list;
+	/* current wq configuration */
+	struct ge2d_config_s       config;
+	struct ge2d_cmd_s		cmd;
+	struct list_head	work_queue;
+	struct list_head	free_queue;
+	wait_queue_head_t	cmd_complete;
+	int				queue_dirty;
+	int				queue_need_recycle;
+	int				ge2d_request_exit;
+
+
+	spinlock_t		lock;	/* for get and release item. */
+};
+
+struct ge2d_event_s {
+	wait_queue_head_t cmd_complete;
+	struct completion process_complete;
+	/* for queue switch and create destroy queue. */
+	spinlock_t sem_lock;
+	struct semaphore cmd_in_sem;
+};
+
+struct ge2d_manager_s {
+	struct list_head process_queue;
+	struct ge2d_context_s *current_wq;
+	struct ge2d_context_s *last_wq;
+	struct task_struct *ge2d_thread;
+	struct ge2d_event_s event;
+	struct aml_dma_buffer *buffer;
+	int irq_num;
+	int ge2d_state;
+	int process_queue_state;
+	int probe;
+	struct platform_device *pdev;
+	
+	struct meson_canvas *canvas;
+	uint8_t alloced_canvas_index[MAX_PLANE*3];	// alloced canvas index.
+};
+
+struct src_dst_para_s {
+	int  xres;
+	int  yres;
+	int  canvas_index;
+	int  bpp;
+	int  ge2d_color_index;
+	int  phy_addr;
+	int  stride;
+};
+
+enum ge2d_op_type_e {
+	GE2D_OP_DEFAULT = 0,
+	GE2D_OP_FILLRECT,
+	GE2D_OP_BLIT,
+	GE2D_OP_STRETCHBLIT,
+	GE2D_OP_BLEND,
+	GE2D_OP_MAXNUM
+};
+
+struct config_planes_s {
+	unsigned long addr;
+	unsigned int w;
+	unsigned int h;
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_config_planes_s {
+	compat_uptr_t addr;
+	unsigned int w;
+	unsigned int h;
+};
+#endif
+
+struct src_key_ctrl_s {
+	int key_enable;
+	int key_color;
+	int key_mask;
+	int key_mode;
+};
+
+struct config_para_s {
+	int  src_dst_type;
+	int  alu_const_color;
+	unsigned int src_format;
+	unsigned int dst_format; /* add for src&dst all in user space. */
+
+	struct config_planes_s src_planes[4];
+	struct config_planes_s dst_planes[4];
+	struct src_key_ctrl_s  src_key;
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_config_para_s {
+	int  src_dst_type;
+	int  alu_const_color;
+	unsigned int src_format;
+	unsigned int dst_format; /* add for src&dst all in user space. */
+
+	struct compat_config_planes_s src_planes[4];
+	struct compat_config_planes_s dst_planes[4];
+	struct src_key_ctrl_s  src_key;
+};
+#endif
+
+struct src_dst_para_ex_s {
+	int  canvas_index;
+	int  top;
+	int  left;
+	int  width;
+	int  height;
+	int  format;
+	int  mem_type;
+	int  color;
+	unsigned char x_rev;
+	unsigned char y_rev;
+	unsigned char fill_color_en;
+	unsigned char fill_mode;
+};
+
+struct config_para_ex_s {
+	struct src_dst_para_ex_s src_para;
+	struct src_dst_para_ex_s src2_para;
+	struct src_dst_para_ex_s dst_para;
+
+	/* key mask */
+	struct src_key_ctrl_s  src_key;
+	struct src_key_ctrl_s  src2_key;
+
+	int alu_const_color;
+	unsigned int src1_gb_alpha;
+#ifdef CONFIG_GE2D_SRC2
+	unsigned int src2_gb_alpha;
+#endif
+	unsigned int op_mode;
+	unsigned char bitmask_en;
+	unsigned char bytemask_only;
+	unsigned int  bitmask;
+	unsigned char dst_xy_swap;
+
+	/* scaler and phase related */
+	unsigned int hf_init_phase;
+	int hf_rpt_num;
+	unsigned int hsc_start_phase_step;
+	int hsc_phase_slope;
+	unsigned int vf_init_phase;
+	int vf_rpt_num;
+	unsigned int vsc_start_phase_step;
+	int vsc_phase_slope;
+	unsigned char src1_vsc_phase0_always_en;
+	unsigned char src1_hsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	unsigned char src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	unsigned char src1_vsc_rpt_ctrl;
+
+	/* canvas info */
+	struct config_planes_s src_planes[4];
+	struct config_planes_s src2_planes[4];
+	struct config_planes_s dst_planes[4];
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_config_para_ex_s {
+	struct src_dst_para_ex_s src_para;
+	struct src_dst_para_ex_s src2_para;
+	struct src_dst_para_ex_s dst_para;
+
+	/* key mask */
+	struct src_key_ctrl_s  src_key;
+	struct src_key_ctrl_s  src2_key;
+
+	int alu_const_color;
+	unsigned int src1_gb_alpha;
+#ifdef CONFIG_GE2D_SRC2
+	unsigned int src2_gb_alpha;
+#endif
+	unsigned int op_mode;
+	unsigned char bitmask_en;
+	unsigned char bytemask_only;
+	unsigned int  bitmask;
+	unsigned char dst_xy_swap;
+
+	/* scaler and phase related */
+	unsigned int hf_init_phase;
+	int hf_rpt_num;
+	unsigned int hsc_start_phase_step;
+	int hsc_phase_slope;
+	unsigned int vf_init_phase;
+	int vf_rpt_num;
+	unsigned int vsc_start_phase_step;
+	int vsc_phase_slope;
+	unsigned char src1_vsc_phase0_always_en;
+	unsigned char src1_hsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	unsigned char src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	unsigned char src1_vsc_rpt_ctrl;
+
+	/* canvas info */
+	struct compat_config_planes_s src_planes[4];
+	struct compat_config_planes_s src2_planes[4];
+	struct compat_config_planes_s dst_planes[4];
+};
+#endif
+
+struct config_planes_ion_s {
+	unsigned long addr;
+	unsigned int w;
+	unsigned int h;
+	int shared_fd;
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_config_planes_ion_s {
+	compat_uptr_t addr;
+	unsigned int w;
+	unsigned int h;
+	int shared_fd;
+};
+#endif
+
+struct config_para_ex_ion_s {
+	struct src_dst_para_ex_s src_para;
+	struct src_dst_para_ex_s src2_para;
+	struct src_dst_para_ex_s dst_para;
+
+	/* key mask */
+	struct src_key_ctrl_s  src_key;
+	struct src_key_ctrl_s  src2_key;
+
+	unsigned char src1_cmult_asel;
+	unsigned char src2_cmult_asel;
+#ifdef CONFIG_GE2D_SRC2
+	unsigned char src2_cmult_ad;
+#endif
+	int alu_const_color;
+	unsigned char src1_gb_alpha_en;
+	unsigned int src1_gb_alpha;
+#ifdef CONFIG_GE2D_SRC2
+	unsigned char src2_gb_alpha_en;
+	unsigned int src2_gb_alpha;
+#endif
+	unsigned int op_mode;
+	unsigned char bitmask_en;
+	unsigned char bytemask_only;
+	unsigned int  bitmask;
+	unsigned char dst_xy_swap;
+
+	/* scaler and phase related */
+	unsigned int hf_init_phase;
+	int hf_rpt_num;
+	unsigned int hsc_start_phase_step;
+	int hsc_phase_slope;
+	unsigned int vf_init_phase;
+	int vf_rpt_num;
+	unsigned int vsc_start_phase_step;
+	int vsc_phase_slope;
+	unsigned char src1_vsc_phase0_always_en;
+	unsigned char src1_hsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	unsigned char src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	unsigned char src1_vsc_rpt_ctrl;
+
+	/* canvas info */
+	struct config_planes_ion_s src_planes[4];
+	struct config_planes_ion_s src2_planes[4];
+	struct config_planes_ion_s dst_planes[4];
+};
+
+#ifdef CONFIG_COMPAT
+struct compat_config_para_ex_ion_s {
+	struct src_dst_para_ex_s src_para;
+	struct src_dst_para_ex_s src2_para;
+	struct src_dst_para_ex_s dst_para;
+
+	/* key mask */
+	struct src_key_ctrl_s  src_key;
+	struct src_key_ctrl_s  src2_key;
+
+	unsigned char src1_cmult_asel;
+	unsigned char src2_cmult_asel;
+#ifdef CONFIG_GE2D_SRC2
+	unsigned char src2_cmult_ad;
+#endif
+	int alu_const_color;
+	unsigned char src1_gb_alpha_en;
+	unsigned int src1_gb_alpha;
+#ifdef CONFIG_GE2D_SRC2
+	unsigned char src2_gb_alpha_en;
+	unsigned int src2_gb_alpha;
+#endif
+	unsigned int op_mode;
+	unsigned char bitmask_en;
+	unsigned char bytemask_only;
+	unsigned int  bitmask;
+	unsigned char dst_xy_swap;
+
+	/* scaler and phase related */
+	unsigned int hf_init_phase;
+	int hf_rpt_num;
+	unsigned int hsc_start_phase_step;
+	int hsc_phase_slope;
+	unsigned int vf_init_phase;
+	int vf_rpt_num;
+	unsigned int vsc_start_phase_step;
+	int vsc_phase_slope;
+	unsigned char src1_vsc_phase0_always_en;
+	unsigned char src1_hsc_phase0_always_en;
+	/* 1bit, 0: using minus, 1: using repeat data */
+	unsigned char src1_hsc_rpt_ctrl;
+	/* 1bit, 0: using minus  1: using repeat data */
+	unsigned char src1_vsc_rpt_ctrl;
+
+	/* canvas info */
+	struct compat_config_planes_ion_s src_planes[4];
+	struct compat_config_planes_ion_s src2_planes[4];
+	struct compat_config_planes_ion_s dst_planes[4];
+};
+#endif
+
+struct config_para_ex_memtype_s {
+	int ge2d_magic;
+	struct config_para_ex_ion_s _ge2d_config_ex;
+	/* memtype */
+	unsigned int src1_mem_alloc_type;
+	unsigned int src2_mem_alloc_type;
+	unsigned int dst_mem_alloc_type;
+	/* for customized matrix */
+	struct ge2d_matrix_s matrix_custom;
+};
+
+struct config_ge2d_para_ex_s {
+	union {
+		struct config_para_ex_ion_s para_config_ion;
+		struct config_para_ex_memtype_s para_config_memtype;
+	};
+};
+
+
+#ifdef CONFIG_COMPAT
+struct compat_config_para_ex_memtype_s {
+	int ge2d_magic;
+	struct compat_config_para_ex_ion_s _ge2d_config_ex;
+	/* memtype*/
+	unsigned int src1_mem_alloc_type;
+	unsigned int src2_mem_alloc_type;
+	unsigned int dst_mem_alloc_type;
+	/* for customized matrix */
+	struct ge2d_matrix_s matrix_custom;
+};
+
+struct compat_config_ge2d_para_ex_s {
+	union {
+		struct compat_config_para_ex_ion_s para_config_ion;
+		struct compat_config_para_ex_memtype_s para_config_memtype;
+	};
+};
+#endif
+
+/* for ge2d dma buf define */
+struct ge2d_dmabuf_req_s {
+	int index;
+	unsigned int len;
+	unsigned int dma_dir;
+};
+
+struct ge2d_dmabuf_exp_s {
+	int index;
+	unsigned int flags;
+	int fd;
+};
+/* end of ge2d dma buffer define */
+
+enum {
+	CBUS_BASE,
+	AOBUS_BASE,
+	HIUBUS_BASE,
+	GEN_PWR_SLEEP0,
+	GEN_PWR_ISO0,
+	MEM_PD_REG0,
+	PWR_DOMAIN_CTRL,
+};
+
+struct ge2d_ctrl_s {
+	unsigned int table_type;
+	unsigned int reg;
+	unsigned int val;
+	unsigned int start;
+	unsigned int len;
+	unsigned int udelay;
+};
+
+struct ge2d_power_table_s {
+	unsigned int table_size;
+	struct ge2d_ctrl_s *power_table;
+};
+
+struct ge2d_device_data_s {
+	int ge2d_rate;
+	int src2_alp;
+	int canvas_status;
+	int deep_color;
+	int hang_flag;
+	int fifo;
+	int has_self_pwr;
+	struct ge2d_power_table_s *poweron_table;
+	struct ge2d_power_table_s *poweroff_table;
+};
+extern struct ge2d_device_data_s ge2d_meson_dev;
+
+#define GE2D_IOC_MAGIC  'G'
+
+#define GE2D_CONFIG		_IOW(GE2D_IOC_MAGIC, 0x00, struct config_para_s)
+
+#ifdef CONFIG_COMPAT
+#define GE2D_CONFIG32	_IOW(GE2D_IOC_MAGIC, 0x00, struct compat_config_para_s)
+#endif
+
+#define GE2D_CONFIG_EX	 _IOW(GE2D_IOC_MAGIC, 0x01,  struct config_para_ex_s)
+
+#ifdef CONFIG_COMPAT
+#define GE2D_CONFIG_EX32  \
+	_IOW(GE2D_IOC_MAGIC, 0x01,  struct compat_config_para_ex_s)
+#endif
+
+#define	GE2D_SRCCOLORKEY     _IOW(GE2D_IOC_MAGIC, 0x02, struct config_para_s)
+
+#ifdef CONFIG_COMPAT
+#define	GE2D_SRCCOLORKEY32   \
+	_IOW(GE2D_IOC_MAGIC, 0x02, struct compat_config_para_s)
+#endif
+
+
+#define GE2D_CONFIG_EX_ION	 \
+	_IOW(GE2D_IOC_MAGIC, 0x03,  struct config_para_ex_ion_s)
+
+#ifdef CONFIG_COMPAT
+#define GE2D_CONFIG_EX32_ION  \
+	_IOW(GE2D_IOC_MAGIC, 0x03,  struct compat_config_para_ex_ion_s)
+#endif
+
+#define GE2D_REQUEST_BUFF _IOW(GE2D_IOC_MAGIC, 0x04, struct ge2d_dmabuf_req_s)
+#define GE2D_EXP_BUFF _IOW(GE2D_IOC_MAGIC, 0x05, struct ge2d_dmabuf_exp_s)
+#define GE2D_FREE_BUFF _IOW(GE2D_IOC_MAGIC, 0x06, int)
+
+#define GE2D_CONFIG_EX_MEM	 \
+	_IOW(GE2D_IOC_MAGIC, 0x07,  struct config_ge2d_para_ex_s)
+
+#ifdef CONFIG_COMPAT
+#define GE2D_CONFIG_EX32_MEM  \
+	_IOW(GE2D_IOC_MAGIC, 0x07,  struct compat_config_ge2d_para_ex_s)
+#endif
+
+#define GE2D_SYNC_DEVICE _IOW(GE2D_IOC_MAGIC, 0x08, int)
+#define GE2D_SYNC_CPU _IOW(GE2D_IOC_MAGIC, 0x09, int)
+
+extern void ge2d_set_src1_data(struct ge2d_src1_data_s *cfg);
+extern void ge2d_set_src1_gen(struct ge2d_src1_gen_s *cfg);
+extern void ge2d_set_src2_dst_data(struct ge2d_src2_dst_data_s *cfg);
+extern void ge2d_set_src2_dst_gen(struct ge2d_src2_dst_gen_s *cfg);
+void ge2d_set_dp_gen(struct ge2d_config_s *config);
+extern void ge2d_set_cmd(struct ge2d_cmd_s *cfg);
+extern void ge2d_wait_done(void);
+extern void ge2d_set_src1_scale_coef(unsigned int v_filt_type,
+				     unsigned int h_filt_type);
+extern void ge2d_set_gen(struct ge2d_gen_s *cfg);
+extern void ge2d_soft_rst(void);
+extern bool ge2d_is_busy(void);
+extern int ge2d_cmd_fifo_full(void);
+
+extern int ge2d_context_config(struct ge2d_context_s *context,
+			       struct config_para_s *ge2d_config);
+extern int ge2d_context_config_ex(struct ge2d_context_s *context,
+				  struct config_para_ex_s *ge2d_config);
+extern int ge2d_context_config_ex_ion(struct ge2d_context_s *context,
+			   struct config_para_ex_ion_s *ge2d_config);
+extern int ge2d_context_config_ex_mem(struct ge2d_context_s *context,
+			   struct config_para_ex_memtype_s *ge2d_config_mem);
+extern struct ge2d_context_s *create_ge2d_work_queue(void);
+extern int destroy_ge2d_work_queue(struct ge2d_context_s *wq);
+extern int ge2d_wq_remove_config(struct ge2d_context_s *wq);
+extern void ge2d_wq_set_scale_coef(struct ge2d_context_s *wq,
+				   unsigned int v_scale_coef,
+				   unsigned int h_scale_coef);
+extern int ge2d_antiflicker_enable(struct ge2d_context_s *context,
+				   unsigned long enable);
+extern struct ge2d_src1_data_s *ge2d_wq_get_src_data(struct ge2d_context_s *wq);
+extern struct ge2d_src1_gen_s *ge2d_wq_get_src_gen(struct ge2d_context_s *wq);
+extern struct ge2d_src2_dst_data_s
+*ge2d_wq_get_dst_data(struct ge2d_context_s *wq);
+extern struct ge2d_src2_dst_gen_s
+*ge2d_wq_get_dst_gen(struct ge2d_context_s *wq);
+extern struct ge2d_dp_gen_s *ge2d_wq_get_dp_gen(struct ge2d_context_s *wq);
+extern struct ge2d_cmd_s *ge2d_wq_get_cmd(struct ge2d_context_s *wq);
+extern int ge2d_wq_add_work(struct ge2d_context_s *wq);
+void ge2d_canv_config(u32 index, u32 addr, u32 stride);
+#include "ge2d_func.h"
+
+#endif
diff -Naur a/include/linux/amlogic/meson_atrace.h b/include/linux/amlogic/meson_atrace.h
--- a/include/linux/amlogic/meson_atrace.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/meson_atrace.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,123 @@
+/*
+ * include/trace/events/meson_atrace.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/*
+ * This file enables ftrace logging in a way that
+ * atrace/systrace would understand
+ * without any custom javascript change in chromium-trace
+ */
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM meson_atrace
+
+#if !defined(_TRACE_MESON_BASE_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_MESON_BASE_H
+
+#include <linux/tracepoint.h>
+
+
+#define KERNEL_ATRACE_COUNTER 0
+#define KERNEL_ATRACE_BEGIN 1
+#define KERNEL_ATRACE_END 2
+#define KERNEL_ATRACE_ASYNC_BEGIN 3
+#define KERNEL_ATRACE_ASYNC_END 4
+
+#if !defined(TRACE_HEADER_MULTI_READ)
+
+enum {
+	KERNEL_ATRACE_TAG_VIDEO,
+	KERNEL_ATRACE_TAG_CODEC_MM,
+	KERNEL_ATRACE_TAG_VDEC,
+	KERNEL_ATRACE_TAG_TSYNC,
+	KERNEL_ATRACE_TAG_IONVIDEO,
+	KERNEL_ATRACE_TAG_AMLVIDEO,
+	KERNEL_ATRACE_TAG_VIDEO_COMPOSER,
+	KERNEL_ATRACE_TAG_V4L2,
+	KERNEL_ATRACE_TAG_MAX = 64,
+	KERNEL_ATRACE_TAG_ALL
+};
+
+#endif
+
+#define print_flags_header(flags) __print_flags(flags, "",	\
+	{ (1UL << KERNEL_ATRACE_COUNTER),		"C" },	\
+	{ (1UL << KERNEL_ATRACE_BEGIN),			"B" },	\
+	{ (1UL << KERNEL_ATRACE_END),			"E" },	\
+	{ (1UL << KERNEL_ATRACE_ASYNC_BEGIN),		"S" },	\
+	{ (1UL << KERNEL_ATRACE_ASYNC_END),		"F" })
+
+
+#define print_flags_delim(flags) __print_flags(flags, "",	\
+	{ (1UL << KERNEL_ATRACE_COUNTER),		"|1|" },\
+	{ (1UL << KERNEL_ATRACE_BEGIN),			"|1|" },\
+	{ (1UL << KERNEL_ATRACE_END),			"" },	\
+	{ (1UL << KERNEL_ATRACE_ASYNC_BEGIN),		"|1|" },\
+	{ (1UL << KERNEL_ATRACE_ASYNC_END),		"|1|" })
+
+TRACE_EVENT(tracing_mark_write,
+
+	TP_PROTO(const char *name, unsigned int flags, unsigned int value),
+
+	TP_ARGS(name, flags, value),
+
+	TP_STRUCT__entry(
+		__string(name, name)
+		__field(unsigned int, flags)
+		__field(unsigned int, value)
+	),
+
+	TP_fast_assign(
+		__assign_str(name, name);
+		__entry->flags = flags;
+		__entry->value = value;
+	),
+
+	TP_printk("%s%s%s|%u", print_flags_header(__entry->flags),
+		print_flags_delim(__entry->flags),
+		__get_str(name), __entry->value)
+);
+
+#ifdef CONFIG_AMLOGIC_DEBUG_ATRACE
+void meson_atrace(int tag, const char *name, unsigned int flags,
+	 unsigned int value);
+
+#define ATRACE_COUNTER(name, value) \
+	meson_atrace(KERNEL_ATRACE_TAG, name, \
+		(1 << KERNEL_ATRACE_COUNTER), value)
+#define ATRACE_BEGIN(name) \
+	meson_atrace(KERNEL_ATRACE_TAG, name, \
+		(1 << KERNEL_ATRACE_BEGIN), 0)
+#define ATRACE_END() \
+	meson_atrace(KERNEL_ATRACE_TAG, "", \
+		(1 << KERNEL_ATRACE_END), 1)
+#define ATRACE_ASYNC_BEGIN(name, cookie) \
+	meson_atrace(KERNEL_ATRACE_TAG, name, \
+		(1 << KERNEL_ATRACE_ASYNC_BEGIN), cookie)
+#define ATRACE_ASYNC_END(name, cookie) \
+	meson_atrace(KERNEL_ATRACE_TAG, name, \
+		(1 << KERNEL_ATRACE_ASYNC_END), cookie)
+#else
+#define ATRACE_COUNTER(name, value)
+#define ATRACE_BEGIN(name)
+#define ATRACE_END(name)
+#define ATRACE_ASYNC_BEGIN(name, cookie)
+#define ATRACE_ASYNC_END(name, cookie)
+#endif
+
+#endif /* _TRACE_MESON_BASE_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff -Naur a/include/linux/amlogic/power_ctrl.h b/include/linux/amlogic/power_ctrl.h
--- a/include/linux/amlogic/power_ctrl.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/power_ctrl.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,48 @@
+/*
+ * include/linux/amlogic/power_ctrl.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _POWER_CTRL_H_
+#define _POWER_CTRL_H_
+#include <linux/types.h>
+
+#ifdef CONFIG_AMLOGIC_POWER
+bool is_support_power_ctrl(void);
+int power_ctrl_sleep(bool power_on, unsigned int shift);
+int power_ctrl_sleep_mask(bool power_on,
+			  unsigned int mask_val, unsigned int shift);
+int power_ctrl_iso(bool power_on, unsigned int shift);
+int power_ctrl_iso_mask(bool power_on,
+			unsigned int mask_val, unsigned int shift);
+int power_ctrl_mempd0(bool power_on, unsigned int mask_val, unsigned int shift);
+#else
+static inline int power_ctrl_sleep(bool power_on, unsigned int shift)
+{
+	return -EINVAL;
+}
+
+static inline int power_ctrl_iso(bool power_on, unsigned int shift)
+{
+	return -EINVAL;
+}
+
+static inline int power_ctrl_mempd0(bool power_on, unsigned int mask_val,
+                                    unsigned int shift)
+{
+	return -EINVAL;
+}
+#endif
+#endif /*_POWER_CTRL_H_*/
diff -Naur a/include/linux/amlogic/power_domain.h b/include/linux/amlogic/power_domain.h
--- a/include/linux/amlogic/power_domain.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/power_domain.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,27 @@
+/*
+ * include/linux/amlogic/power_domain.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#define PWR_ON	0
+#define PWR_OFF	1
+
+#ifdef CONFIG_AMLOGIC_POWER
+void power_domain_switch(int pwr_domain, bool pwr_switch);
+#else
+static inline void power_domain_switch(int pwr_domain, bool pwr_switch)
+{
+}
+#endif
diff -Naur a/include/linux/amlogic/reboot.h b/include/linux/amlogic/reboot.h
--- a/include/linux/amlogic/reboot.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/reboot.h	2022-06-06 14:41:46.045026500 +0800
@@ -0,0 +1,32 @@
+/*
+ * include/linux/amlogic/reboot.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/*******************************************************************/
+#define	MESON_COLD_REBOOT					0
+#define	MESON_NORMAL_BOOT					1
+#define	MESON_FACTORY_RESET_REBOOT			2
+#define	MESON_UPDATE_REBOOT					3
+#define	MESON_FASTBOOT_REBOOT				4
+#define	MESON_UBOOT_SUSPEND					5
+#define	MESON_HIBERNATE						6
+#define	MESON_BOOTLOADER_REBOOT				7
+#define	MESON_RPMBP_REBOOT					9
+#define MESON_QUIESCENT_REBOOT					10
+#define	MESON_CRASH_REBOOT					11
+#define	MESON_KERNEL_PANIC					12
+#define MESON_RECOVERY_QUIESCENT_REBOOT				14
+#define MESON_FFV_REBOOT					15
diff -Naur a/include/linux/amlogic/scpi_protocol.h b/include/linux/amlogic/scpi_protocol.h
--- a/include/linux/amlogic/scpi_protocol.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/scpi_protocol.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,141 @@
+/*
+ * include/linux/amlogic/scpi_protocol.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _SCPI_PROTOCOL_H_
+#define _SCPI_PROTOCOL_H_
+#include <linux/types.h>
+
+enum scpi_client_id {
+	SCPI_CL_NONE,
+	SCPI_CL_CLOCKS,
+	SCPI_CL_DVFS,
+	SCPI_CL_POWER,
+	SCPI_CL_THERMAL,
+	SCPI_CL_REMOTE,
+	SCPI_CL_LED_TIMER,
+	SCPI_MAX,
+};
+
+enum scpi_std_cmd {
+	SCPI_CMD_INVALID		= 0x00,
+	SCPI_CMD_SCPI_READY		= 0x01,
+	SCPI_CMD_SCPI_CAPABILITIES	= 0x02,
+	SCPI_CMD_EVENT			= 0x03,
+	SCPI_CMD_SET_CSS_PWR_STATE	= 0x04,
+	SCPI_CMD_GET_CSS_PWR_STATE	= 0x05,
+	SCPI_CMD_CFG_PWR_STATE_STAT	= 0x06,
+	SCPI_CMD_GET_PWR_STATE_STAT	= 0x07,
+	SCPI_CMD_SYS_PWR_STATE		= 0x08,
+	SCPI_CMD_L2_READY		= 0x09,
+	SCPI_CMD_SET_AP_TIMER		= 0x0a,
+	SCPI_CMD_CANCEL_AP_TIME		= 0x0b,
+	SCPI_CMD_DVFS_CAPABILITIES	= 0x0c,
+	SCPI_CMD_GET_DVFS_INFO		= 0x0d,
+	SCPI_CMD_SET_DVFS		= 0x0e,
+	SCPI_CMD_GET_DVFS		= 0x0f,
+	SCPI_CMD_GET_DVFS_STAT		= 0x10,
+	SCPI_CMD_SET_RTC		= 0x11,
+	SCPI_CMD_GET_RTC		= 0x12,
+	SCPI_CMD_CLOCK_CAPABILITIES	= 0x13,
+	SCPI_CMD_SET_CLOCK_INDEX	= 0x14,
+	SCPI_CMD_SET_CLOCK_VALUE	= 0x15,
+	SCPI_CMD_GET_CLOCK_VALUE	= 0x16,
+	SCPI_CMD_PSU_CAPABILITIES	= 0x17,
+	SCPI_CMD_SET_PSU		= 0x18,
+	SCPI_CMD_GET_PSU		= 0x19,
+	SCPI_CMD_SENSOR_CAPABILITIES	= 0x1a,
+	SCPI_CMD_SENSOR_INFO		= 0x1b,
+	SCPI_CMD_SENSOR_VALUE		= 0x1c,
+	SCPI_CMD_SENSOR_CFG_PERIODIC	= 0x1d,
+	SCPI_CMD_SENSOR_CFG_BOUNDS	= 0x1e,
+	SCPI_CMD_SENSOR_ASYNC_VALUE	= 0x1f,
+	SCPI_CMD_SET_USR_DATA = 0x20,
+	SCPI_CMD_OSCRING_VALUE = 0x43,
+	SCPI_CMD_WAKEUP_REASON_GET = 0x30,
+	SCPI_CMD_WAKEUP_REASON_CLR = 0X31,
+	SCPI_CMD_GET_ETHERNET_CALC = 0x32,
+	SCPI_CMD_GET_CPUINFO = 0x33,
+	SCPI_CMD_INIT_DSP = 0x34,
+
+	SCPI_CMD_GET_CEC1		= 0xB4,
+	SCPI_CMD_GET_CEC2		= 0xB5,
+	SCPI_CMD_SEND_DSP_DATA		= 0xB6,
+	SCPI_CMD_SET_CEC1		= 0xB7,
+	SCPI_CMD_SET_CEC2		= 0xB8,
+	SCPI_CMD_GET_CEC_REASON 	= 0xB9,
+	SCPI_CMD_SET_CEC_REASON 	= 0xBA,
+	SCPI_CMD_BL4_WAIT_UNLOCK	= 0xD6,
+	SCPI_CMD_BL4_SEND		= 0xD7,
+	SCPI_CMD_BL4_LISTEN		= 0xD8,
+	SCPI_CMD_COUNT
+};
+
+enum scpi_dsp_cmd {
+	SCPI_REQ_INVALID		= 0x00,
+	SCPI_REQ_COUNT
+};
+
+enum scpi_get_pfm_type {
+	SCPI_CPUINFO_CLUSTER0,
+	SCPI_CPUINFO_CLUSTER1,
+	SCPI_CPUINFO_VERSION,
+	SCPI_CPUINFO_SLT,
+	SCPI_CPUINFO_NUMS
+};
+
+struct scpi_opp_entry {
+	u32 freq_hz;
+	u32 volt_mv;
+} __packed;
+
+struct scpi_dvfs_info {
+	unsigned int count;
+	unsigned int latency; /* in usecs */
+	struct scpi_opp_entry *opp;
+} __packed;
+
+struct bl40_msg_buf {
+	int size;
+	char buf[512];
+} __packed;
+
+unsigned long scpi_clk_get_val(u16 clk_id);
+int scpi_clk_set_val(u16 clk_id, unsigned long rate);
+int scpi_dvfs_get_idx(u8 domain);
+int scpi_dvfs_set_idx(u8 domain, u8 idx);
+struct scpi_dvfs_info *scpi_dvfs_get_opps(u8 domain);
+int scpi_get_sensor(char *name);
+int scpi_get_sensor_value(u16 sensor, u32 *val);
+int scpi_send_usr_data(u32 client_id, u32 *val, u32 size);
+int scpi_get_vrtc(u32 *p_vrtc);
+int scpi_set_vrtc(u32 vrtc_val);
+int scpi_get_ring_value(unsigned char *val);
+int scpi_get_wakeup_reason(u32 *wakeup_reason);
+int scpi_clr_wakeup_reason(void);
+int scpi_get_cec_val(enum scpi_std_cmd index, u32 *p_cec);
+int scpi_set_cec_val(enum scpi_std_cmd index, u32 cec_data);
+u8  scpi_get_ethernet_calc(void);
+int scpi_get_cpuinfo(enum scpi_get_pfm_type type, u32 *freq, u32 *vol);
+int scpi_init_dsp_cfg0(u32 id, u32 addr, u32 cfg0);
+int scpi_unlock_bl40(void);
+int scpi_send_bl40(unsigned int cmd, struct bl40_msg_buf *bl40_buf);
+
+/*scpi dsp api*/
+int scpi_send_dsp_cmd(void *data, int size, bool to_dspa,
+		      int cmd, int sync, void *revdata, int revsize);
+int scpi_req_handle(void *p, u32 size, u32 cmd, int dspid);
+#endif /*_SCPI_PROTOCOL_H_*/
diff -Naur a/include/linux/amlogic/sd.h b/include/linux/amlogic/sd.h
--- a/include/linux/amlogic/sd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/sd.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,1869 @@
+/*
+ * include/linux/amlogic/sd.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_SD_H__
+#define __AML_SD_H__
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/mmc/host.h>
+/* #include <linux/earlysuspend.h> */
+#undef pr_fmt
+#define pr_fmt(fmt) "meson-mmc: " fmt
+
+#define EMMC_ERASE_TIMEOUT	(40*HZ)
+
+#define AML_FIXED_ADJ_MIN	5
+#define AML_FIXED_ADJ_MAX	6
+#define AML_FIXED_ADJ_STEP	4
+#define AML_MOVE_DELAY1(x)	\
+	((x << 0)|(x << 6)|(x << 12)|(x << 18)|(x << 24))
+#define AML_MOVE_DELAY2(x)	\
+	((x << 0)|(x << 6)|(x << 12)|(x << 24))
+#define NO_FIXED_ADJ_MID	(1 << 31)
+
+#define	 AML_ERROR_RETRY_COUNTER		 10
+#define	 AML_TIMEOUT_RETRY_COUNTER	   2
+#define AML_CALIBRATION
+#define AML_SDHC_MAGIC		"amlsdhc"
+#define AML_SDIO_MAGIC		"amlsdio"
+#define AML_SD_EMMC_MAGIC	"amlsd_emmc"
+#define SD_EMMC_MANUAL_CMD23
+#define MAX_TUNING_RETRY 4
+#define TUNING_NUM_PER_POINT 40
+#define ADJ_WIN_PRINT_MAXLEN 256
+#define CALI_PATTERN_OFFSET ((SZ_1M * (36 + 3)) / 512)
+/* #define AML_RESP_WR_EXT */
+/* pio to transfer data */
+#define CFG_SDEMMC_PIO		(1)
+
+#ifdef AML_CALIBRATION
+#define MAX_CALI_RETRY	3
+#define MAX_DELAY_CNT	16
+#define CALI_BLK_CNT	80
+#endif
+
+#define SD_EMMC_CLOCK 0x0
+#define SD_EMMC_DELAY 0x4
+#define SD_EMMC_ADJUST 0x8
+#define SD_EMMC_CALOUT 0x10
+#define SD_EMMC_START 0x40
+#define SD_EMMC_CFG 0x44
+#define SD_EMMC_STATUS 0x48
+#define SD_EMMC_IRQ_EN 0x4c
+#define SD_EMMC_CMD_RSP 0x5c
+#define SD_EMMC_CMD_RSP1 0x60
+#define SD_EMMC_CMD_RSP2 0x64
+#define SD_EMMC_CMD_RSP3 0x68
+
+#define SD_EMMC_CLOCK_V3 0x0
+#define SD_EMMC_DELAY1_V3 0x4
+#define SD_EMMC_DELAY2_V3 0x8
+#define SD_EMMC_ADJUST_V3 0xc
+#define SD_EMMC_ADJ_IDX_LOG 0x20
+#define SD_EMMC_CLKTEST_LOG	0x24
+#define SD_EMMC_CLKTEST_OUT	0x28
+#define SD_EMMC_EYETEST_LOG	0x2C
+#define SD_EMMC_EYETEST_OUT0 0x30
+#define SD_EMMC_EYETEST_OUT1 0x34
+#define SD_EMMC_INTF3	0x38
+
+#define SD_EMMC_DESC_OFF	0x200
+/* using SD_EMMC_CMD_RSP */
+#define SD_EMMC_RESP_SIZE	0x0
+#define SD_EMMC_DESC_SIZE	(0x200 - SD_EMMC_RESP_SIZE)
+#define SD_EMMC_RESP_OFF	(SD_EMMC_DESC_OFF + SD_EMMC_DESC_SIZE)
+
+#define SD_EMMC_PING_OFF	0x400
+#define SD_EMMC_PING_SIZE	0x200
+#define SD_EMMC_PONG_OFF	0x600
+#define SD_EMMC_PONE_SIZE	0x200
+/* join ping/pong as one */
+#define SD_EMMC_PIO_OFF		(SD_EMMC_PING_OFF)
+#define SD_EMMC_PIO_SIZE	(SD_EMMC_PING_SIZE + SD_EMMC_PONE_SIZE)
+
+#define   CLK_DIV_SHIFT 0
+#define   CLK_DIV_WIDTH 6
+#define   CLK_DIV_MASK 0x3f
+#define   CLK_DIV_MAX 63
+#define   CLK_SRC_SHIFT 6
+#define   CLK_SRC_WIDTH 2
+#define   CLK_SRC_MASK 0x3
+#define   CLK_SRC_XTAL_RATE 24000000
+#define   CLK_SRC_PLL_RATE 1000000000
+
+#define   CFG_BLK_LEN_SHIFT 4
+#define   CFG_BLK_LEN_MASK 0xf
+
+#define CMD_CFG_LENGTH_SHIFT 0
+#define CMD_CFG_LENGTH_MASK 0x1ff
+#define CMD_CFG_BLOCK_MODE BIT(9)
+#define CMD_CFG_DATA_IO BIT(18)
+#define CMD_CFG_DATA_WR BIT(19)
+#define CMD_CFG_DATA_NUM BIT(23)
+
+#define CMD_DATA_MASK (~0x3)
+
+struct aml_tuning_data {
+	const u8 *blk_pattern;
+	unsigned int blksz;
+};
+
+enum aml_mmc_waitfor {
+	XFER_INIT,			  /* 0 */
+	XFER_START,				/* 1 */
+	XFER_AFTER_START,		/* 2 */
+	XFER_IRQ_OCCUR,			/* 3 */
+	XFER_IRQ_TASKLET_CMD,	/* 4 */
+	XFER_IRQ_TASKLET_DATA,	/* 5 */
+	XFER_IRQ_TASKLET_BUSY,	/* 6 */
+	XFER_IRQ_UNKNOWN_IRQ,	/* 7 */
+	XFER_TIMER_TIMEOUT,		/* 8 */
+	XFER_TASKLET_CMD,		/* 9 */
+	XFER_TASKLET_DATA,		/* 10 */
+	XFER_TASKLET_BUSY,		/* 11 */
+	XFER_TIMEDOUT,			/* 12 */
+	XFER_FINISHED,			/* 13 */
+};
+
+enum aml_host_status { /* Host controller status */
+	HOST_INVALID = 0,	   /* 0, invalid value */
+	HOST_RX_FIFO_FULL = 1,  /* 1, start with 1 */
+	HOST_TX_FIFO_EMPTY,		/* 2 */
+	HOST_RSP_CRC_ERR,		/* 3 */
+	HOST_DAT_CRC_ERR,		/* 4 */
+	HOST_RSP_TIMEOUT_ERR,   /* 5 */
+	HOST_DAT_TIMEOUT_ERR,   /* 6 */
+	HOST_ERR_END,			/* 7, end of errors */
+	HOST_TASKLET_CMD,		/* 8 */
+	HOST_TASKLET_DATA,		/* 9 */
+};
+
+enum aml_host_bus_fsm { /* Host bus fsm status */
+	BUS_FSM_IDLE,			/* 0, idle */
+	BUS_FSM_SND_CMD,		/* 1, send cmd */
+	BUS_FSM_CMD_DONE,		/* 2, wait for cmd done */
+	BUS_FSM_RESP_START,		/* 3, resp start */
+	BUS_FSM_RESP_DONE,		/* 4, wait for resp done */
+	BUS_FSM_DATA_START,		/* 5, data start */
+	BUS_FSM_DATA_DONE,		/* 6, wait for data done */
+	BUS_FSM_DESC_WRITE_BACK,/* 7, wait for desc write back */
+	BUS_FSM_IRQ_SERVICE,	/* 8, wait for irq service */
+};
+
+enum aml_host_tuning_mode {
+	NONE_TUNING,
+	ADJ_TUNING_MODE,
+	AUTO_TUNING_MODE,
+	RX_PHASE_DELAY_TUNING_MODE,
+};
+
+struct cali_data {
+	u8 ln_delay[8];
+	u32 base_index[10];
+	u32 base_index_max;
+	u32 base_index_min;
+};
+
+struct cali_ctrl {
+	u8 line_x;
+	u8 cal_time;
+	u8 dly_tmp;
+	u8 max_index;
+};
+
+enum mmc_chip_e {
+	MMC_CHIP_M8B = 0x1B,
+	MMC_CHIP_GXBB = 0x1F,
+	MMC_CHIP_GXTVBB = 0x20,
+	MMC_CHIP_GXL = 0x21,
+	MMC_CHIP_GXM = 0x22,
+	MMC_CHIP_TXL = 0x23,
+	MMC_CHIP_TXLX = 0x24,
+	MMC_CHIP_AXG = 0x25,
+	MMC_CHIP_GXLX = 0x26,
+	MMC_CHIP_TXHD = 0x27,
+	MMC_CHIP_G12A = 0x28,
+	MMC_CHIP_G12B_A = 0x29,
+	MMC_CHIP_GXLX2 = 0x2a,
+	MMC_CHIP_TL1 = 0X2b,
+	MMC_CHIP_G12B = 0x29b,
+	MMC_CHIP_SM1 = 0X2C,
+	MMC_CHIP_TM2 = 0X2D,
+	MMC_CHIP_TM2_B = 0X2E,
+};
+
+struct mmc_phase {
+	unsigned int core_phase;
+	unsigned int tx_phase;
+	unsigned int rx_phase;
+	unsigned int tx_delay;
+};
+
+struct para_e {
+	struct mmc_phase init;
+	struct mmc_phase hs;
+	struct mmc_phase calc;
+	struct mmc_phase ddr;
+	struct mmc_phase hs2;
+	struct mmc_phase hs4;
+	struct mmc_phase sd_hs;
+	struct mmc_phase sdr104;
+};
+
+struct meson_mmc_data {
+	enum mmc_chip_e chip_type;
+	unsigned int port_a_base;
+	unsigned int port_b_base;
+	unsigned int port_c_base;
+	unsigned int pinmux_base;
+	unsigned int clksrc_base;
+	unsigned int ds_pin_poll;
+	unsigned int ds_pin_poll_en;
+	unsigned int ds_pin_poll_bit;
+	unsigned int latest_dat;
+	unsigned int tdma_f;
+	struct para_e sdmmc;
+};
+
+struct amlsd_host;
+struct sd_emmc_desc_info;
+
+struct clock_lay_t {
+	/* source clk, 24Mhz, 1Ghz */
+	unsigned int source;
+	/* core clk, Hz */
+	unsigned int core;
+	/* old core clk, Hz */
+	unsigned int old_core;
+	/* bus clk */
+	unsigned int sdclk;
+};
+
+/* todly in ns*/
+#define TODLY_MIN_NS	(2)
+#define TODLY_MAX_NS	(14)
+
+struct hs400_para {
+	unsigned int delay1;
+	unsigned int delay2;
+	unsigned int intf3;
+	unsigned int flag;
+};
+
+struct hs200_para {
+	unsigned int adjust;
+};
+
+struct hs_para {
+	unsigned int adjust;
+};
+
+struct aml_tuning_para {
+	unsigned int chip_id[4];
+	unsigned int magic;
+	unsigned int vddee;
+	struct hs400_para hs4[7];
+	struct hs200_para hs2;
+	struct hs_para hs;
+	unsigned int version;
+	unsigned int busmod;
+	unsigned int update;
+	int temperature;
+	long long checksum;
+};
+
+struct amlsd_platform {
+	struct amlsd_host *host;
+	struct mmc_host *mmc;
+	struct list_head sibling;
+	struct aml_tuning_para para;
+	u32 ocr_avail;
+	u32 port;
+#define	 PORT_SDIO_A	 0
+#define	 PORT_SDIO_B	 1
+#define	 PORT_SDIO_C	 2
+#define	 PORT_SDHC_A	 3
+#define	 PORT_SDHC_B	 4
+#define	 PORT_SDHC_C	 5
+
+#ifdef CONFIG_AMLOGIC_M8B_MMC
+	unsigned int width;
+	unsigned int tune_phase;	/* store tuning result */
+#endif
+	struct delayed_work cd_detect;
+	unsigned int caps;
+	unsigned int caps2;
+	unsigned int pm_caps;
+	unsigned int card_capacity;
+	unsigned int tx_phase;
+	unsigned int tx_delay;
+	unsigned int save_para;
+	unsigned int co_phase;
+	unsigned int f_min;
+	unsigned int f_max;
+	unsigned int clkc;
+	unsigned int clk2;
+	unsigned int clkc_w;
+	unsigned int ctrl;
+	unsigned int adj;
+	unsigned int dly1;
+	unsigned int dly2;
+	unsigned int intf3;
+	unsigned int win_start;
+	unsigned int irq_sdio_sleep;
+	unsigned int clock;
+	/* signalling voltage (1.8V or 3.3V) */
+	unsigned char signal_voltage;
+	struct clock_lay_t clk_lay;
+	int	bus_width;
+	int	bl_len;
+	int	stop_clk;
+
+	unsigned int low_burst;
+	struct mutex in_out_lock;
+	unsigned int irq_cd;
+	unsigned int gpio_cd;
+	unsigned int gpio_cd_level;
+	unsigned int gpio_cd_sta;
+	unsigned int gpio_power;
+	unsigned int power_level;
+	unsigned int calc_f;
+	unsigned int no_sduart;
+
+	unsigned int auto_clk_close;
+	unsigned int vol_switch;
+	unsigned int vol_switch_18;
+	unsigned int vol_switch_delay;
+	char pinname[32];
+	char dmode[8];
+	unsigned int gpio_ro;
+	unsigned int gpio_dat3;
+	unsigned int hw_reset;
+	unsigned int jtag_pin;
+	int is_sduart;
+	unsigned int card_in_delay;
+	bool is_in;
+	bool is_tuned;		/* if card has been tuning */
+	bool need_retuning;
+	bool rmpb_cmd_flag;
+	bool rpmb_valid_command;
+	/* we used this flag to filter
+	 * some unnecessary cmd before initialized flow
+	 */
+	/* has been initialized for the first time */
+	bool is_fir_init;
+	struct delayed_work	retuning;
+#ifdef AML_CALIBRATION
+	unsigned char caling;
+	unsigned char calout[20][20];
+#endif
+	unsigned int latest_dat;
+	u64 align[10];
+	int base_line;
+	unsigned int count;
+	unsigned int cmd_c;
+	unsigned int delay_cell;
+	/* int order; */
+	unsigned int rx_err;
+	/* 0:unknown, 1:mmc card(include eMMC), 2:sd card(include tSD),
+	 * 3:sdio device(ie:sdio-wifi), 4:SD combo (IO+mem) card,
+	 * 5:NON sdio device(means sd/mmc card), other:reserved
+	 */
+	unsigned int card_type;
+	struct cali_ctrl c_ctrl;
+	/* unknown */
+#define CARD_TYPE_UNKNOWN		0
+	/* MMC card */
+#define CARD_TYPE_MMC			1
+	/* SD card */
+#define CARD_TYPE_SD			2
+	/* SDIO card */
+#define CARD_TYPE_SDIO			3
+	/* SD combo (IO+mem) card */
+#define CARD_TYPE_SD_COMBO		4
+	/* NON sdio device (means SD/MMC card) */
+#define CARD_TYPE_NON_SDIO		5
+
+#define aml_card_type_unknown(c)	((c)->card_type == CARD_TYPE_UNKNOWN)
+#define aml_card_type_mmc(c)		((c)->card_type == CARD_TYPE_MMC)
+#define aml_card_type_sd(c)		 ((c)->card_type == CARD_TYPE_SD)
+#define aml_card_type_sdio(c)	   ((c)->card_type == CARD_TYPE_SDIO)
+#define aml_card_type_non_sdio(c)   ((c)->card_type == CARD_TYPE_NON_SDIO)
+
+	/* struct pinctrl *uart_ao_pinctrl; */
+	void (*irq_init)(struct amlsd_platform *pdata);
+
+	unsigned int max_blk_count;
+	unsigned int max_blk_size;
+	unsigned int max_req_size;
+	unsigned int max_seg_size;
+
+	/*for inand partition: struct mtd_partition, easy porting from nand*/
+	struct mtd_partition *parts;
+	unsigned int nr_parts;
+
+	struct resource *resource;
+	void (*xfer_pre)(struct amlsd_platform *pdata);
+	void (*xfer_post)(struct amlsd_platform *pdata);
+
+	int (*port_init)(struct amlsd_platform *pdata);
+	int (*cd)(struct amlsd_platform *pdata);
+	int (*ro)(struct amlsd_platform *pdata);
+	void (*pwr_pre)(struct amlsd_platform *pdata);
+	void (*pwr_on)(struct amlsd_platform *pdata);
+	void (*pwr_off)(struct amlsd_platform *pdata);
+
+};
+
+struct aml_emmc_adjust {
+	int adj_win_start;
+	int adj_win_len;
+	int adj_point;
+	int clk_div;
+};
+
+struct aml_emmc_rxclk {
+	int rxclk_win_start;
+	int rxclk_win_len;
+	int rxclk_rx_phase;
+	int rxclk_rx_delay;
+	int rxclk_point;
+};
+
+#define MUX_CLK_NUM_PARENTS 2
+struct amlsd_host {
+	/* back-link to device */
+	struct device *dev;
+	struct list_head sibling;
+	struct platform_device *pdev;
+	struct amlsd_platform *pdata;
+	struct mmc_host		*mmc;
+	struct mmc_request	*request;
+	struct meson_mmc_data *data;
+
+	struct mmc_command	*cmd;
+	u32 ocr_mask;
+	struct clk *core_clk;
+	struct clk_mux mux;
+	struct clk *mux_clk;
+	struct clk *mux_parent[MUX_CLK_NUM_PARENTS];
+	unsigned long mux_parent_rate[MUX_CLK_NUM_PARENTS];
+	struct clk_divider cfg_div;
+	struct clk *cfg_div_clk;
+#ifdef CONFIG_AMLOGIC_M8B_MMC
+	struct clk *div3_clk;
+#endif
+
+	struct resource		*mem;
+	struct sd_emmc_regs *sd_emmc_regs;
+	void __iomem		*base;
+	void __iomem		*pinmux_base;
+	void __iomem		*clksrc_base;
+	int			dma;
+	char *bn_buf;
+	dma_addr_t		bn_dma_buf;
+#ifdef AML_RESP_WR_EXT
+	u32 *resp_buf;
+	dma_addr_t resp_dma_buf;
+#endif
+	dma_addr_t		dma_gdesc; /* 0x200 */
+	dma_addr_t		dma_gping; /* 0x400 */
+	dma_addr_t		dma_gpong; /* 0x800 */
+	char is_tunning;
+	char cmd_retune;
+	char find_win;
+	char tuning_mode;
+	int gp0_enable;
+	unsigned int is_sduart;
+	unsigned int irq;
+	unsigned int irq_in;
+	unsigned int irq_out;
+	unsigned int f_max;
+	unsigned int f_max_w;
+	unsigned int f_min;
+	int	sdio_irqen;
+	unsigned int error_bak;
+	struct delayed_work	timeout;
+	struct class debug;
+
+	unsigned int send;
+	unsigned int ctrl;
+	unsigned int clkc;
+	unsigned int misc;
+	unsigned int ictl;
+	unsigned int ista;
+	unsigned int dma_addr;
+
+	unsigned long		clk_rate;
+
+	u8 *blk_test;
+	u8 *adj_win;
+	char *desc_buf;
+#ifdef CFG_SDEMMC_PIO
+	/* bounce buffer to accomplish 32bit apb access */
+	u8 *desc_bn;
+	/* pio buffer */
+	u8 *pio_buf;
+	dma_addr_t pio_dma_buf;
+#endif
+	dma_addr_t		desc_dma_addr;
+	unsigned int dma_sts;
+	unsigned int sg_cnt;
+	char *desc_cur;
+	unsigned int desc_cur_cnt;
+	char *desc_pre;
+	unsigned int desc_pre_cnt;
+	struct  mmc_request	*mrq;
+	struct  mmc_request	*mrq2;
+	spinlock_t	mrq_lock;
+	struct mutex	pinmux_lock;
+	struct completion   drv_completion;
+	int			cmd_is_stop;
+	enum aml_mmc_waitfor	xfer_step;
+	enum aml_mmc_waitfor	xfer_step_prev;
+
+	int	 port;
+	int	 locked;
+	bool	is_gated;
+	unsigned char sd_sdio_switch_volat_done;
+
+	int	 status; /* host status: xx_error/ok */
+	int init_flag;
+	int init_volt;
+
+	char	*msg_buf;
+#define MESSAGE_BUF_SIZE			512
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*debug_root;
+	struct dentry		*debug_state;
+	struct dentry		*debug_regs;
+#endif
+
+#ifdef CONFIG_CPU_FREQ
+	struct notifier_block	freq_transition;
+#endif
+
+	u32			opcode;
+	u32			arg;
+	u32		 cmd25_cnt;
+
+#ifdef CONFIG_MMC_AML_DEBUG
+	u32		 req_cnt;
+	u32		 trans_size;
+
+	u32		 reg_buf[16];
+#endif
+	u32		 time_req_sta; /* request start time */
+
+	struct pinctrl  *pinctrl;
+	char		pinctrl_name[30];
+	/* used for judging if there is a tsd/emmc */
+	int		 storage_flag;
+	/* bit[7-0]--minor version, bit[31-8]--major version */
+	int		 version;
+	int ctrl_ver;
+	unsigned long	clksrc_rate;
+	struct aml_emmc_adjust emmc_adj;
+	struct aml_emmc_rxclk emmc_rxclk;
+	u32 error_flag;
+	unsigned int reg_bak[20];
+	unsigned int resume_clock;
+	/* pre cmd op */
+	unsigned int (*pre_cmd_op)(struct amlsd_host *host,
+		struct mmc_request *mrq, struct sd_emmc_desc_info *desc);
+	/* post cmd op */
+	int (*post_cmd_op)(struct amlsd_host *host,
+		struct mmc_request *mrq);
+};
+
+/*-sdio-*/
+
+#define SDIO_ARGU	   (0x0)
+#define SDIO_SEND	   (0x4)
+#define SDIO_CONF	   (0x8)
+#define SDIO_IRQS	   (0xc)
+#define SDIO_IRQC	   (0x10)
+#define SDIO_MULT	   (0x14)
+#define SDIO_ADDR	   (0x18)
+#define SDIO_EXT		(0x1c)
+#define SDIO_CCTL	   (0x40)
+#define SDIO_CDAT	   (0x44)
+
+#define CLK_DIV		 (0x1f4)
+
+struct cmd_send {
+	u32 cmd_command:8; /*[7:0] Command Index*/
+	u32 cmd_response_bits:8;
+	/*[15:8]
+	 * 00 means no response
+	 * others: Response bit number
+	 * (cmd bits+response bits+crc bits-1)
+	 */
+	u32 response_do_not_have_crc7:1;
+	/*[16]
+	 * 0:Response need check CRC7,
+	 * 1: dont need check
+	 */
+	u32 response_have_data:1;
+	/*[17]
+	 * 0:Receiving Response without data,
+	 * 1:Receiving response with data
+	 */
+	u32 response_crc7_from_8:1;
+	/*[18]
+	 * 0:Normal CRC7, Calculating CRC7 will
+	 * be from bit0 of all response bits,
+	 * 1:Calculating CRC7 will be from
+	 * bit8 of all response bits
+	 */
+	u32 check_busy_on_dat0:1;
+	/*[19]
+	 * used for R1b response
+	 * 0: dont check busy on dat0,
+	 * 1:need check
+	 */
+	u32 cmd_send_data:1;
+	/*[20]
+	 * 0:This command is not for transmitting data,
+	 * 1:This command is for transmitting data
+	 */
+	u32 use_int_window:1;
+	/*[21]
+	 * 0:SDIO DAT1 interrupt window disabled, 1:Enabled
+	 */
+	u32 reserved:2;/*[23:22]*/
+	u32 repeat_package_times:8;
+	/*[31:24] Total packages to be sent*/
+};
+
+struct sdio_config {
+	u32 cmd_clk_divide:10;
+	/*[9:0] Clock rate setting,
+	 * Frequency of SD equals to Fsystem/((cmd_clk_divide+1)*2)
+	 */
+	u32 cmd_disable_crc:1;
+	/*[10]
+	 * 0:CRC employed, 1:dont send CRC during command being sent
+	 */
+	u32 cmd_out_at_posedge:1;
+	/*[11]
+	 * Command out at negedge normally, 1:at posedge
+	 */
+	u32 cmd_argument_bits:6;
+	/*[17:12] before CRC added, normally 39*/
+	u32 do_not_delay_data:1;
+	/*[18]
+	 *0:Delay one clock normally, 1:dont delay
+	 */
+	u32 data_latch_at_negedge:1;
+	/*[19]
+	 * 0:Data caught at posedge normally, 1:negedge
+	 */
+	u32 bus_width:1;
+	/*[20] 0:1bit, 1:4bit*/
+	u32 m_endian:2;
+	/*[22:21]
+	 * Change ENDIAN(bytes order) from DMA data (e.g. dma_din[31:0]).
+	 * (00: ENDIAN no change, data output equals to original dma_din[31:0];
+	 * 01: data output equals to {dma_din[23:16],dma_din[31:24],
+	 * dma_din[7:0],dma_din[15:8]};10: data output equals to
+	 * {dma_din[15:0],dma_din[31:16]};11: data output equals to
+	 * {dma_din[7:0],dma_din[15:8],dma_din[23:16],dma_din[31:24]})
+	 */
+	u32 sdio_write_nwr:6;
+	/*[28:23]
+	 * Number of clock cycles waiting before writing data
+	 */
+	u32 sdio_write_crc_ok_status:3;
+	/*[31:29] if CRC status
+	 * equals this register, sdio write can be consider as correct
+	 */
+};
+
+struct sdio_status_irq {
+	u32 sdio_status:4;
+	/*[3:0] Read Only
+	 * SDIO State Machine Current State, just for debug
+	 */
+	u32 sdio_cmd_busy:1;
+	/*[4] Read Only
+	 * SDIO Command Busy, 1:Busy State
+	 */
+	u32 sdio_response_crc7_ok:1;
+	/*[5] Read Only
+	 * SDIO Response CRC7 status, 1:OK
+	 */
+	u32 sdio_data_read_crc16_ok:1;
+	/*[6] Read Only
+	 * SDIO Data Read CRC16 status, 1:OK
+	 */
+	u32 sdio_data_write_crc16_ok:1;
+	/*[7] Read Only
+	 * SDIO Data Write CRC16 status, 1:OK
+	 */
+	u32 sdio_if_int:1;
+	/*[8] write 1 clear this int bit
+	 * SDIO DAT1 Interrupt Status
+	 */
+	u32 sdio_cmd_int:1;
+	/*[9] write 1 clear this int bit
+	 * Command Done Interrupt Status
+	 */
+	u32 sdio_soft_int:1;
+	/*[10] write 1 clear this int bit
+	 * Soft Interrupt Status
+	 */
+	u32 sdio_set_soft_int:1;
+	/*[11] write 1 to this bit
+	 * will set Soft Interrupt, read out is m_req_sdio, just for debug
+	 */
+	u32 sdio_status_info:4;
+	/*[15:12]
+	 * used for change information between ARC and Amrisc
+	 */
+	u32 sdio_timing_out_int:1;
+	/*[16] write 1 clear this int bit
+	 * Timeout Counter Interrupt Status
+	 */
+	u32 amrisc_timing_out_int_en:1;
+	/*[17]
+	 * Timeout Counter Interrupt Enable for AMRISC
+	 */
+	u32 arc_timing_out_int_en:1;
+	/*[18]
+	 * Timeout Counter Interrupt Enable for ARC/ARM
+	 */
+	u32 sdio_timing_out_count:13;
+	/*[31:19]
+	 * Timeout Counter Preload Setting and Present Status
+	 */
+};
+
+struct sdio_irq_config {
+	u32 amrisc_if_int_en:1;
+	/*[0]
+	 * 1:SDIO DAT1 Interrupt Enable for AMRISC
+	 */
+	u32 amrisc_cmd_int_en:1;
+	/*[1]
+	 * 1:Command Done Interrupt Enable for AMRISC
+	 */
+	u32 amrisc_soft_int_en:1;
+	/*[2]
+	 * 1:Soft Interrupt Enable for AMRISC
+	 */
+	u32 arc_if_int_en:1;
+	/*[3]
+	 * 1:SDIO DAT1 Interrupt Enable for ARM/ARC
+	 */
+	u32 arc_cmd_int_en:1;
+	/*[4]
+	 * 1:Command Done Interrupt Enable for ARM/ARC
+	 */
+	u32 arc_soft_int_en:1;
+	/*[5]
+	 * 1:Soft Interrupt Enable for ARM/ARC
+	 */
+	u32 sdio_if_int_config:2;
+	/*[7:6]
+	 * 00:sdio_if_interrupt window will reset after data Tx/Rx or command
+	 * done, others: only after command done
+	 */
+	u32 sdio_force_data:6;
+	/*[13:8]
+	 * Write operation: Data forced by software
+	 * Read operation: {CLK,CMD,DAT[3:0]}
+	 */
+	u32 sdio_force_enable:1;
+	/*[14] Software Force Enable
+	 * This is the software force mode, Software can directly
+	 * write to sdio 6 ports (cmd, clk, dat0..3) if force_output_en
+	 * is enabled. and hardware outputs will be bypassed.
+	 */
+	u32 soft_reset:1;
+	/*[15]
+	 * Write 1 Soft Reset, Don't need to clear it
+	 */
+	u32 sdio_force_output_en:6;
+	/*[21:16]
+	 * Force Data Output Enable,{CLK,CMD,DAT[3:0]}
+	 */
+	u32 disable_mem_halt:2;
+	/*[23:22] write and read
+	 * 23:Disable write memory halt, 22:Disable read memory halt
+	 */
+	u32 sdio_force_data_read:6;
+	/*[29:24] Read Only
+	 * Data read out which have been forced by software
+	 */
+	u32 force_halt:1;
+	/*[30] 1:Force halt SDIO by software
+	 * Halt in this sdio host controller means stop to transmit or
+	 * receive data from sd card. and then sd card clock will be shutdown.
+	 * Software can force to halt anytime, and hardware will automatically
+	 * halt the sdio when reading fifo is full or writing fifo is empty
+	 */
+	u32 halt_hole:1;
+	/*[31]
+	 * 0: SDIO halt for 8bit mode, 1:SDIO halt for 16bit mode
+	 */
+};
+
+struct sdio_mult_config {
+	u32 sdio_port_sel:2; /*[1:0] 0:sdio_a, 1:sdio_b, 2:sdio_c*/
+	u32 ms_enable:1; /*[2] 1:Memory Stick Enable*/
+	u32 ms_sclk_always:1; /*[3] 1: Always send ms_sclk*/
+	u32 stream_enable:1; /*[4] 1:Stream Enable*/
+	u32 stream_8_bits_mode:1; /*[5] Stream 8bits mode*/
+	u32 data_catch_level:2; /*[7:6] Level of data catch*/
+	u32 write_read_out_index:1;
+	/*[8] Write response index Enable
+	 * [31:16], [11:10], [7:0] is set only when
+	 * bit8 of this register is not set.
+	 * And other bits are set only when bit8
+	 * of this register is also set.
+	 */
+	u32 data_catch_readout_en:1; /*[9] Data catch readout Enable*/
+	u32 sdio_0_data_on_1:1; /*[10] 1:dat0 is on dat1*/
+	u32 sdio_1_data_swap01:1; /*[11] 1:dat1 and dat0 swapped*/
+	u32 response_read_index:4; /*[15:12] Index of internal read response*/
+	u32 data_catch_finish_point:12;
+	/*[27:16] If internal data
+	 * catch counter equals this register,
+	 *	it indicates data catching is finished
+	 */
+	u32 reserved:4; /*[31:28]*/
+};
+
+struct sdio_extension {
+	u32 cmd_argument_ext:16;
+	/*[15:0] for future use*/
+	u32 data_rw_number:14;
+	/*[29:16]
+	 * Data Read/Write Number in one packet, include CRC16 if has CRC16
+	 */
+	u32 data_rw_do_not_have_crc16:1;
+	/*[30]
+	 * 0:data Read/Write has crc16, 1:without crc16
+	 */
+	u32 crc_status_4line:1;
+	/*[31] 1:4Lines check CRC Status*/
+};
+
+struct sdio_reg {
+	u32 argument; /*2308*/
+	struct cmd_send send; /*2309*/
+	struct sdio_config config; /*230a*/
+	struct sdio_status_irq status; /*230b*/
+	struct sdio_irq_config irqc; /*230c*/
+	struct sdio_mult_config mult; /*230d*/
+	u32 m_addr; /*230e*/
+	struct sdio_extension ext;/*230f*/
+};
+
+/*-sdhc-*/
+
+#define SDHC_ARGU				(0x00)
+#define SDHC_SEND				(0x04)
+#define SDHC_CTRL				(0x08)
+#define SDHC_STAT				(0x0C)
+#define SDHC_CLKC				(0x10)
+#define SDHC_ADDR				(0x14)
+#define SDHC_PDMA				(0x18)
+#define SDHC_MISC				(0x1C)
+#define SDHC_DATA				(0x20)
+#define SDHC_ICTL				(0x24)
+#define SDHC_ISTA				(0x28)
+#define SDHC_SRST				(0x2C)
+#define SDHC_ESTA				(0x30)
+#define SDHC_ENHC				(0x34)
+#define SDHC_CLK2				(0x38)
+
+/* sdio cbus register */
+#define CBUS_SDIO_ARGU		(0x2308)
+#define CBUS_SDIO_SEND		(0x2309)
+#define CBUS_SDIO_CONF		(0x230a)
+#define CBUS_SDIO_IRQS		(0x230b)
+#define CBUS_SDIO_IRQC		(0x230c)
+#define CBUS_SDIO_MULT		(0x230d)
+#define CBUS_SDIO_ADDR		(0x230e)
+#define CBUS_SDIO_EXT		(0x230f)
+
+
+/* CBUS reg definition */
+#define	ISA_TIMERE			0x2655
+#define	HHI_GCLK_MPEG0		0x1050
+#define	ASSIST_POR_CONFIG	0x1f55
+
+#define PREG_PAD_GPIO0_EN_N 0x200c
+#define PREG_PAD_GPIO0_O	0x200d
+#define PREG_PAD_GPIO0_I	0x200e
+#define PREG_PAD_GPIO1_EN_N 0x200f
+#define PREG_PAD_GPIO1_O	0x2010
+#define PREG_PAD_GPIO1_I	0x2011
+#define PREG_PAD_GPIO2_EN_N 0x2012
+#define PREG_PAD_GPIO2_O	0x2013
+#define PREG_PAD_GPIO2_I	0x2014
+#define PREG_PAD_GPIO3_EN_N 0x2015
+#define PREG_PAD_GPIO3_O	0x2016
+#define PREG_PAD_GPIO3_I	0x2017
+#define PREG_PAD_GPIO4_EN_N 0x2018
+#define PREG_PAD_GPIO4_O	0x2019
+#define PREG_PAD_GPIO4_I	0x201a
+#define PREG_PAD_GPIO5_EN_N 0x201b
+#define PREG_PAD_GPIO5_O	0x201c
+#define PREG_PAD_GPIO5_I	0x201d
+
+#define	PERIPHS_PIN_MUX_0	0x202c
+#define	PERIPHS_PIN_MUX_1	0x202d
+#define	PERIPHS_PIN_MUX_2	0x202e
+#define	PERIPHS_PIN_MUX_3	0x202f
+#define	PERIPHS_PIN_MUX_4	0x2030
+#define	PERIPHS_PIN_MUX_5	0x2031
+#define	PERIPHS_PIN_MUX_6	0x2032
+#define	PERIPHS_PIN_MUX_7	0x2033
+#define	PERIPHS_PIN_MUX_8	0x2034
+#define	PERIPHS_PIN_MUX_9	0x2035
+
+/* interrupt definition */
+#define	INT_SDIO	(60-32)
+#define	INT_SDHC	(110-32)
+
+#define INT_GPIO_0	(96-32)
+#define INT_GPIO_1	(97-32)
+#define INT_GPIO_2	(98-32)
+#define INT_GPIO_3	(99-32)
+#define INT_GPIO_4	(100-32)
+#define INT_GPIO_5	(101-32)
+#define INT_GPIO_6	(102-32)
+#define INT_GPIO_7	(103-32)
+
+
+struct sdhc_send {
+	/*[5:0] command index*/
+	u32 cmd_index:6;
+	/*[6] 0:no resp 1:has resp*/
+	u32 cmd_has_resp:1;
+	/*[7] 0:no data 1:has data*/
+	u32 cmd_has_data:1;
+	/*[8] 0:48bit 1:136bit*/
+	u32 resp_len:1;
+	/*[9] 0:check crc7 1:don't check crc7*/
+	u32 resp_no_crc:1;
+	/*[10] 0:data rx, 1:data tx*/
+	u32 data_dir:1;
+	/*[11] 0:rx or tx, 1:data stop,ATTN:will give rx a softreset*/
+	u32 data_stop:1;
+	/*[12] 0: resp with no busy, 1:R1B*/
+	u32 r1b:1;
+	/*[15:13] reserved*/
+	u32 reserved:3;
+	/*[31:16] total package number for writing or reading*/
+	u32 total_pack:16;
+};
+
+struct sdhc_ctrl {
+	/*[1:0] 0:1bit, 1:4bits, 2:8bits, 3:reserved*/
+	u32 dat_type:2;
+	/*[2] 0:SDR mode, 1:Don't set it*/
+	u32 ddr_mode:1;
+	/*[3] 0:check sd write crc result, 1:disable tx crc check*/
+	u32 tx_crc_nocheck:1;
+	/*[12:4] 0:512Bytes, 1:1, 2:2, ..., 511:511Bytes*/
+	u32 pack_len:9;
+	/*[19:13] cmd or wcrc Receiving Timeout, default 64*/
+	u32 rx_timeout:7;
+	/*[23:20]Period between response/cmd and next cmd, default 8*/
+	u32 rx_period:4;
+	/*[26:24] Rx Endian Control*/
+	u32 rx_endian:3;
+	/*[27]0:Normal mode, 1: support data block gap
+	 *(need turn off clock gating)
+	 */
+	u32 sdio_irq_mode:1;
+	/*[28] Dat0 Interrupt selection,0:busy check after response,
+	 *1:any rising edge of dat0
+	 */
+	u32 dat0_irq_sel:1;
+	/*[31:29] Tx Endian Control*/
+	u32 tx_endian:3;
+};
+
+struct sdhc_stat {
+	/*[0] 0:Ready for command, 1:busy*/
+	u32 cmd_busy:1;
+	/*[4:1] DAT[3:0]*/
+	u32 dat3_0:4;
+	/*[5] CMD*/
+	u32 cmd:1;
+	/*[12:6] RxFIFO count*/
+	u32 rxfifo_cnt:7;
+	/*[19:13] TxFIFO count*/
+	u32 txfifo_cnt:7;
+	/*[23:20] DAT[7:4]*/
+	u32 dat7_4:4;
+	/*[31:24] Reserved*/
+	u32 reserved:8;
+};
+
+/*
+ * to avoid glitch issue,
+ * 1. clk_switch_on better be set after cfg_en be set to 1'b1
+ * 2. clk_switch_off shall be set before cfg_en be set to 1'b0
+ * 3. rx_clk/sd_clk phase diff please see SD_REGE_CLK2.
+ */
+struct sdhc_clkc {
+	/*[11:0] clk_div for TX_CLK 0: don't set it,1:div2, 2:div3, 3:div4 ...*/
+	u32 clk_div:12;
+	/*[12] TX_CLK 0:switch off, 1:switch on*/
+	u32 tx_clk_on:1;
+	/*[13] RX_CLK 0:switch off, 1:switch on*/
+	u32 rx_clk_on:1;
+	/*[14] SD_CLK 0:switch off, 1:switch on*/
+	u32 sd_clk_on:1;
+	/*[15] Clock Module Enable, Should set before bit[14:12] switch on,
+	 *	and after bit[14:12] switch off
+	 */
+	u32 mod_clk_on:1;
+	/*[17:16] 0:osc, 1:fclk_div4, 2:fclk_div3, 3:fclk_div5*/
+	u32 clk_src_sel:2;
+	/*[23:18] Reserved*/
+	u32 reserved:6;
+	/*[24] Clock JIC for clock gating control
+	 *1: will turn off clock gating
+	 */
+	u32 clk_jic:1;
+	/*[26:25] 00:Memory Power Up, 11:Memory Power Off*/
+	u32 mem_pwr_off:2;
+	/*[31:27] Reserved*/
+	u32 reserved2:5;
+};
+
+/*
+ * Note1: dma_urgent is just set when bandwidth is very tight
+ * Note2: pio_rdresp need to be combined with REG0_ARGU;
+ * For R0, when 0, reading REG0 will get the normal 32bit response;
+ * For R2, when 1, reading REG0 will get CID[31:0], when 2, get CID[63:32],
+ * and so on; 6 or 7, will get original command argument.
+ */
+struct sdhc_pdma {
+	/*[0] 0:PIO mode, 1:DMA mode*/
+	u32 dma_mode:1;
+	/*[3:1] 0:[39:8] 1:1st 32bits, 2:2nd ...,6 or 7:command argument*/
+	u32 pio_rdresp:3;
+	/*[4] 0:not urgent, 1:urgent*/
+	u32 dma_urgent:1;
+	/*[9:5] Number in one Write request burst(0:1,1:2...)*/
+	u32 wr_burst:5;
+	/*[14:10] Number in one Read request burst(0:1, 1:2...)*/
+	u32 rd_burst:5;
+	/*[21:15] RxFIFO threshold, >=rxth, will request write*/
+	u32 rxfifo_th:7;
+	/*[28:22] TxFIFO threshold, <=txth, will request read*/
+	u32 txfifo_th:7;
+	/*[30:29] [30]self-clear-flush,[29] mode: 0:hw, 1:sw*/
+	u32 rxfifo_manual_flush:2;
+	/*[31] self-clear-fill, recommand to write before sd send*/
+	u32 txfifo_fill:1;
+};
+
+struct sdhc_misc {
+	/*[3:0] reserved*/
+	u32 reserved:4;
+	/*[6:4] WCRC Error Pattern*/
+	u32 wcrc_err_patt:3;
+	/*[9:7] WCRC OK Pattern*/
+	u32 wcrc_ok_patt:3;
+	/*[15:10] reserved*/
+	u32 reserved1:6;
+	/*[21:16] Burst Number*/
+	u32 burst_num:6;
+	/*[27:22] Thread ID*/
+	u32 thread_id:6;
+	/*[28] 0:auto stop mode, 1:manual stop mode*/
+	u32 manual_stop:1;
+	/*[31:29] txstart_thres(if (txfifo_cnt/4)>
+	 *	(threshold*2), Tx will start)
+	 */
+	u32 txstart_thres:3;
+};
+
+struct sdhc_ictl {
+	/*[0] Response is received OK*/
+	u32 resp_ok:1;
+	/*[1] Response Timeout Error*/
+	u32 resp_timeout:1;
+	/*[2] Response CRC Error*/
+	u32 resp_err_crc:1;
+	/*[3] Response is received OK(always no self reset)*/
+	u32 resp_ok_noclear:1;
+	/*[4] One Package Data Completed ok*/
+	u32 data_1pack_ok:1;
+	/*[5] One Package Data Failed (Timeout Error)*/
+	u32 data_timeout:1;
+	/*[6] One Package Data Failed (CRC Error)*/
+	u32 data_err_crc:1;
+	/*[7] Data Transfer Completed ok*/
+	u32 data_xfer_ok:1;
+	/*[8] RxFIFO count > threshold*/
+	u32 rx_higher:1;
+	/*[9] TxFIFO count < threshold*/
+	u32 tx_lower:1;
+	/*[10] SDIO DAT1 Interrupt*/
+	u32 dat1_irq:1;
+	/*[11] DMA Done*/
+	u32 dma_done:1;
+	/*[12] RxFIFO Full*/
+	u32 rxfifo_full:1;
+	/*[13] TxFIFO Empty*/
+	u32 txfifo_empty:1;
+	/*[14] Additional SDIO DAT1 Interrupt*/
+	u32 addi_dat1_irq:1;
+	/*[15] reserved*/
+	u32 reserved:1;
+	/*[17:16] sdio dat1 interrupt mask windows
+	 *	clear delay control,0:2cycle 1:1cycles
+	 */
+	u32 dat1_irq_delay:2;
+	/*[31:18] reserved*/
+	u32 reserved1:14;
+};
+
+/*Note1: W1C is write one clear.*/
+struct sdhc_ista {
+	/*[0] Response is received OK (W1C)*/
+	u32 resp_ok:1;
+	/*[1] Response is received Failed (Timeout Error) (W1C)*/
+	u32 resp_timeout:1;
+	/*[2] Response is received Failed (CRC Error) (W1C)*/
+	u32 resp_err_crc:1;
+	/*[3] Response is Received OK (always no self reset)*/
+	u32 resp_ok_noclear:1;
+	/*[4] One Package Data Completed ok (W1C)*/
+	u32 data_1pack_ok:1;
+	/*[5] One Package Data Failed (Timeout Error) (W1C)*/
+	u32 data_timeout:1;
+	/*[6] One Package Data Failed (CRC Error) (W1C)*/
+	u32 data_err_crc:1;
+	/*[7] Data Transfer Completed ok (W1C)*/
+	u32 data_xfer_ok:1;
+	/*[8] RxFIFO count > threshold (W1C)*/
+	u32 rx_higher:1;
+	/*[9] TxFIFO count < threshold (W1C)*/
+	u32 tx_lower:1;
+	/*[10] SDIO DAT1 Interrupt (W1C)*/
+	u32 dat1_irq:1;
+	/*[11] DMA Done (W1C)*/
+	u32 dma_done:1;
+	/*[12] RxFIFO Full(W1C)*/
+	u32 rxfifo_full:1;
+	/*[13] TxFIFO Empty(W1C)*/
+	u32 txfifo_empty:1;
+	/*[14] Additional SDIO DAT1 Interrupt*/
+	u32 addi_dat1_irq:1;
+	/*[31:13] reserved*/
+	u32 reserved:17;
+};
+
+/*
+ * Note1: Soft reset for DPHY TX/RX needs programmer to set it
+ * and then clear it manually.
+ */
+struct sdhc_srst {
+	/*[0] Soft reset for MAIN CTRL(self clear)*/
+	u32 main_ctrl:1;
+	/*[1] Soft reset for RX FIFO(self clear)*/
+	u32 rxfifo:1;
+	/*[2] Soft reset for TX FIFO(self clear)*/
+	u32 txfifo:1;
+	/*[3] Soft reset for DPHY RX*/
+	u32 dphy_rx:1;
+	/*[4] Soft reset for DPHY TX*/
+	u32 dphy_tx:1;
+	/*[5] Soft reset for DMA IF(self clear)*/
+	u32 dma_if:1;
+	/*[31:6] reserved*/
+	u32 reserved:26;
+};
+
+struct  sdhc_enhc {
+	union  {
+		struct  {
+			/*[0] 0:Wrrsp Check in DMA Rx FSM 1:No Check in FSM*/
+			u32 wrrsp_mode:1;
+			/*[1] Rx Done without checking if Wrrsp count is 0*/
+			u32 chk_wrrsp:1;
+			/*[2] Rx Done without checking if DMA is IDLE*/
+			u32 chk_dma:1;
+			/*[5:3] debug only*/
+			u32 debug:3;
+			u32 reserved:2;
+			/*[15:8] SDIO IRQ Period Setting*/
+			u32 sdio_irq_period:8;
+			u32 reserved1:2;
+			/*[24:18] RXFIFO Full Threshold,default 60*/
+			u32 rxfifo_th:7;
+			/*[31:25] TXFIFO Empty Threshold,default 0*/
+			u32 txfifo_th:7;
+		}  meson8m2;
+		struct  {
+			/*[7:0] Data Rx Timeout Setting*/
+			u32 rx_timeout:8;
+			/*[15:8] SDIO IRQ Period Setting
+			 *(IRQ checking window length)
+			 */
+			u32 sdio_irq_period:8;
+			/*[16] No Read DMA Response Check*/
+			u32 dma_rd_resp:1;
+			/*[16] No Write DMA Response Check*/
+			u32 dma_wr_resp:1;
+			/*[24:18] RXFIFO Full Threshold,default 60*/
+			u32 rxfifo_th:7;
+			/*[31:25] TXFIFO Empty Threshold,default 0*/
+			u32 txfifo_th:7;
+		}  meson;
+	} reg;
+};
+
+struct sdhc_clk2 {
+	/*[11:0] rx_clk phase diff(default 0:no diff,
+	 *1:one input clock cycle ...)
+	 */
+	u32 rx_clk_phase:12;
+	/*[23:12] sd_clk phase diff(default 0:half(180 degree),
+	 *1:half+one input clock cycle, 2:half+2 input clock cycles, ...)
+	 */
+	u32 sd_clk_phase:12;
+	/*[31:24] reserved*/
+	u32 reserved:8;
+};
+
+#define SDHC_CLOCK_SRC_OSC			  0 /* 24MHz */
+#define SDHC_CLOCK_SRC_FCLK_DIV4		1
+#define SDHC_CLOCK_SRC_FCLK_DIV3		2
+#define SDHC_CLOCK_SRC_FCLK_DIV5		3
+#define SDHC_ISTA_W1C_ALL			   0x7fff
+#define SDHC_SRST_ALL				   0x3f
+#define SDHC_ICTL_ALL						0x7fff
+
+struct sd_emmc_regs {
+	u32 gclock;	 /* 0x00 */
+	u32 gdelay;	 /* 0x04 */
+	u32 gadjust;	/* 0x08 */
+	u32 reserved_0c;	   /* 0x0c */
+	u32 gcalout[4];	/* 0x10~0x1c */
+	u32 reserved_20[8];   /* 0x20~0x3c */
+	u32 gstart;	 /* 0x40 */
+	u32 gcfg;	   /* 0x44 */
+	u32 gstatus;	/* 0x48 */
+	u32 girq_en;	/* 0x4c */
+	u32 gcmd_cfg;   /* 0x50 */
+	u32 gcmd_arg;   /* 0x54 */
+	u32 gcmd_dat;   /* 0x58 */
+	u32 gcmd_rsp0;   /* 0x5c */
+	u32 gcmd_rsp1;  /* 0x60 */
+	u32 gcmd_rsp2;  /* 0x64 */
+	u32 gcmd_rsp3;  /* 0x68 */
+	u32 reserved_6c;	   /* 0x6c */
+	u32 gcurr_cfg;  /* 0x70 */
+	u32 gcurr_arg;  /* 0x74 */
+	u32 gcurr_dat;  /* 0x78 */
+	u32 gcurr_rsp;  /* 0x7c */
+	u32 gnext_cfg;  /* 0x80 */
+	u32 gnext_arg;  /* 0x84 */
+	u32 gnext_dat;  /* 0x88 */
+	u32 gnext_rsp;  /* 0x8c */
+	u32 grxd;	   /* 0x90 */
+	u32 gtxd;	   /* 0x94 */
+	u32 reserved_98[90];   /* 0x98~0x1fc */
+	u32 gdesc[128]; /* 0x200 */
+	u32 gping[128]; /* 0x400 */
+	u32 gpong[128]; /* 0x800 */
+};
+struct sd_emmc_regs_v3 {
+	u32 gclock;	 /* 0x00 */
+	u32 gdelay1;	 /* 0x04 */
+	u32 gdelay2;/*0x08*/
+	u32 gadjust;	/* 0x0c */
+	u32 gcalout[4];	/* 0x10~0x1c */
+	u32 adj_idx_log;/*20*/
+	u32 clktest_log;/*0x24*/
+	u32 clktest_out;/*0x28*/
+	u32 eyetest_log;/*0x2c*/
+	u32 eyetest_out0;/*0x30*/
+	u32 eyetest_out1;/*0x34*/
+	u32 intf3;/*0x38*/
+	u32 reserved3c;/*0x3c*/
+	u32 gstart;	 /* 0x40 */
+	u32 gcfg;	   /* 0x44 */
+	u32 gstatus;	/* 0x48 */
+	u32 girq_en;	/* 0x4c */
+	u32 gcmd_cfg;   /* 0x50 */
+	u32 gcmd_arg;   /* 0x54 */
+	u32 gcmd_dat;   /* 0x58 */
+	u32 gcmd_rsp0;   /* 0x5c */
+	u32 gcmd_rsp1;  /* 0x60 */
+	u32 gcmd_rsp2;  /* 0x64 */
+	u32 gcmd_rsp3;  /* 0x68 */
+	u32 reserved_6c;	   /* 0x6c */
+	u32 gcurr_cfg;  /* 0x70 */
+	u32 gcurr_arg;  /* 0x74 */
+	u32 gcurr_dat;  /* 0x78 */
+	u32 gcurr_rsp;  /* 0x7c */
+	u32 gnext_cfg;  /* 0x80 */
+	u32 gnext_arg;  /* 0x84 */
+	u32 gnext_dat;  /* 0x88 */
+	u32 gnext_rsp;  /* 0x8c */
+	u32 grxd;	   /* 0x90 */
+	u32 gtxd;	   /* 0x94 */
+	u32 reserved_98[90];   /* 0x98~0x1fc */
+	u32 gdesc[128]; /* 0x200 */
+	u32 gping[128]; /* 0x400 */
+	u32 gpong[128]; /* 0x800 */
+};
+struct sd_emmc_clock {
+	/*[5:0]	 Clock divider.
+	 *Frequency = clock source/cfg_div, Maximum divider 63.
+	 */
+	u32 div:6;
+	/*[7:6]	 Clock source, 0: Crystal 24MHz, 1: Fix PLL, 850MHz*/
+	u32 src:2;
+	/*[9:8]	 Core clock phase. 0: 0 phase,
+	 *1: 90 phase, 2: 180 phase, 3: 270 phase.
+	 */
+	u32 core_phase:2;
+	/*[11:10]   TX clock phase. 0: 0 phase,
+	 *1: 90 phase, 2: 180 phase, 3: 270 phase.
+	 */
+	u32 tx_phase:2;
+	/*[13:12]   RX clock phase. 0: 0 phase,
+	 *1: 90 phase, 2: 180 phase, 3: 270 phase.
+	 */
+	u32 rx_phase:2;
+	u32 reserved14:2;
+	/*[19:16]   TX clock delay line. 0: no delay,
+	 *n: delay n*200ps. Maximum delay 3ns.
+	 */
+	u32 tx_delay:4;
+	/*[23:20]   RX clock delay line. 0: no delay,
+	 *n: delay n*200ps. Maximum delay 3ns.
+	 */
+	u32 rx_delay:4;
+	/*[24]	  1: Keep clock always on.
+	 *0: Clock on/off controlled by activities.
+	 */
+	u32 always_on:1;
+	/*[25]	1: enable IRQ sdio when in sleep mode. */
+	u32 irq_sdio_sleep:1;
+	/*[26]	1: select DS as IRQ source during sleep.. */
+	u32 irq_sdio_sleep_ds:1;
+	u32 reserved27:5;
+};
+struct sd_emmc_clock_v3 {
+	/*[5:0]	 Clock divider.
+	 *Frequency = clock source/cfg_div, Maximum divider 63.
+	 */
+	u32 div:6;
+	/*[7:6]	 Clock source, 0: Crystal 24MHz, 1: Fix PLL, 850MHz*/
+	u32 src:2;
+	/*[9:8]	 Core clock phase. 0: 0 phase,
+	 *1: 90 phase, 2: 180 phase, 3: 270 phase.
+	 */
+	u32 core_phase:2;
+	/*[11:10]   TX clock phase. 0: 0 phase,
+	 *1: 90 phase, 2: 180 phase, 3: 270 phase.
+	 */
+	u32 tx_phase:2;
+	/*[13:12]   RX clock phase. 0: 0 phase,
+	 *1: 90 phase, 2: 180 phase, 3: 270 phase.
+	 */
+	u32 rx_phase:2;
+	u32 sram_pd:2;
+	/*[21:16]   TX clock delay line. 0: no delay,
+	 *n: delay n*200ps. Maximum delay 3ns.
+	 */
+	u32 tx_delay:6;
+	/*[27:22]   RX clock delay line. 0: no delay,
+	 *n: delay n*200ps. Maximum delay 3ns.
+	 */
+	u32 rx_delay:6;
+	/*[28]	  1: Keep clock always on.
+	 *0: Clock on/off controlled by activities.
+	 */
+	u32 always_on:1;
+	/*[29]	1: enable IRQ sdio when in sleep mode. */
+	u32 irq_sdio_sleep:1;
+	/*[30]	1: select DS as IRQ source during sleep.. */
+	u32 irq_sdio_sleep_ds:1;
+	u32 reserved31:1;
+};
+struct sd_emmc_delay {
+	u32 dat0:4;		 /*[3:0]	   Data 0 delay line. */
+	u32 dat1:4;		 /*[7:4]	   Data 1 delay line. */
+	u32 dat2:4;		 /*[11:8]	  Data 2 delay line. */
+	u32 dat3:4;		 /*[15:12]	 Data 3 delay line. */
+	u32 dat4:4;		 /*[19:16]	 Data 4 delay line. */
+	u32 dat5:4;		 /*[23:20]	 Data 5 delay line. */
+	u32 dat6:4;		 /*[27:24]	 Data 6 delay line. */
+	u32 dat7:4;		 /*[31:28]	 Data 7 delay line. */
+};
+struct sd_emmc_delay1_v3 {
+	u32 dat0:6;		 /*[5:0]	   Data 0 delay line. */
+	u32 dat1:6;		 /*[11:6]	   Data 1 delay line. */
+	u32 dat2:6;		 /*[17:12]	  Data 2 delay line. */
+	u32 dat3:6;		 /*[23:18]	 Data 3 delay line. */
+	u32 dat4:6;		 /*[29:24]	 Data 4 delay line. */
+	u32 spare:2;		 /*[31:30]	 Data 5 delay line. */
+};
+struct sd_emmc_delay2_v3 {
+	u32 dat5:6;		 /*[5:0]	   Data 0 delay line. */
+	u32 dat6:6;		 /*[11:6]	   Data 1 delay line. */
+	u32 dat7:6;		 /*[17:12]	  Data 2 delay line. */
+	u32 dat8:6;		 /*[23:18]	 Data 3 delay line. */
+	u32 dat9:6;		 /*[29:24]	 Data 4 delay line. */
+	u32 spare:2;		 /*[31:30]	 Data 5 delay line. */
+};
+struct sd_emmc_adjust {
+	/*[3:0]	   Command delay line. */
+	u32 cmd_delay:4;
+	/*[7:4]	   DS delay line. */
+	u32 ds_delay:4;
+	/*[11:8]	  Select one signal to be tested.*/
+	u32 cali_sel:4;
+	/*[12]		Enable calibration. */
+	u32 cali_enable:1;
+	/*[13]	   Adjust interface timing
+	 *by resampling the input signals.
+	 */
+	u32 adj_enable:1;
+	/*[14]	   1: test the rising edge.
+	 *0: test the falling edge.
+	 */
+	u32 cali_rise:1;
+	/*[15]	   1: Sampling the DAT based on DS in HS400 mode.
+	 *0: Sampling the DAT based on RXCLK.
+	 */
+	u32 ds_enable:1;
+	/*[21:16]	   Resample the input signals
+	 *when clock index==adj_delay.
+	 */
+	u32 adj_delay:6;
+	/*[22]	   1: Use cali_dut first falling edge to adjust
+	 *	the timing, set cali_enable to 1 to use this function.
+	 *0: no use adj auto.
+	 */
+	u32 adj_auto:1;
+	u32 reserved22:9;
+};
+struct sd_emmc_adjust_v3 {
+	u32 reserved8:8;
+	/*[11:8]	  Select one signal to be tested.*/
+	u32 cali_sel:4;
+	/*[12]		Enable calibration. */
+	u32 cali_enable:1;
+	/*[13]	   Adjust interface timing
+	 *by resampling the input signals.
+	 */
+	u32 adj_enable:1;
+	/*[14]	   1: test the rising edge.
+	 *0: test the falling edge.
+	 */
+	u32 cali_rise:1;
+	/*[15]	   1: Sampling the DAT based on DS in HS400 mode.
+	 *0: Sampling the DAT based on RXCLK.
+	 */
+	u32 ds_enable:1;
+	/*[21:16]	   Resample the input signals
+	 *when clock index==adj_delay.
+	 */
+	u32 adj_delay:6;
+	/*[22]	   1: Use cali_dut first falling edge to adjust
+	 *	the timing, set cali_enable to 1 to use this function.
+	 *0: no use adj auto.
+	 */
+	u32 adj_auto:1;
+	u32 reserved22:9;
+};
+struct sd_emmc_calout {
+	/*[5:0]	   Calibration reading.
+	 *The event happens at this index.
+	 */
+	u32 cali_idx:6;
+	u32 reserved6:1;
+	/*[7]		 The reading is valid. */
+	u32 cali_vld:1;
+	/*[15:8]	  Copied from BASE+0x8
+	 *[15:8] include cali_sel, cali_enable, adj_enable, cali_rise.
+	 */
+	u32 cali_setup:8;
+	u32 reserved16:16;
+};
+
+struct clktest_log {
+	u32 clktest_times:31;
+	u32 clktest_done:1;
+};
+
+struct clktest_out {
+	u32 clktest_out;
+};
+
+struct eyetest_log {
+	u32 eyetest_times:31;
+	u32 eyetest_done:1;
+};
+
+struct eyetest_out0 {
+	u32 eyetest_out0;
+};
+
+struct eyetest_out1 {
+	u32 eyetest_out1;
+};
+
+struct intf3 {
+	u32 clktest_exp:5;  /*[4:0]*/
+	u32 clktest_on_m:1; /*[5]*/
+	u32 eyetest_exp:5;  /*[10:6]*/
+	u32 eyetest_on:1;   /*[11]*/
+	u32 ds_sht_m:6;     /*[17:12]*/
+	u32 ds_sht_exp:4;   /*[21:18]*/
+	u32 sd_intf3:1;     /*[22]*/
+};
+
+struct sd_emmc_start {
+	/*[0]   1: Read descriptor from internal SRAM,
+	 *limited to 32 descriptors.
+	 */
+	u32 init:1;
+	/*[1]   1: Start command chain execution process. 0: Stop */
+	u32 busy:1;
+	/*[31:2] Descriptor address, the last 2 bits are 0,
+	 *4 bytes aligned.
+	 */
+	u32 addr:30;
+};
+struct sd_emmc_config {
+	/*[1:0]	 0: 1 bit, 1: 4 bits,
+	 *2: 8 bits, 3: 2 bits (not supported)
+	 */
+	u32 bus_width:2;
+	/*[2]	   1: DDR mode, 0: SDR mode */
+	u32 ddr:1;
+	/*[3]	   1: DDR access urgent, 0: DDR access normal. */
+	u32 dc_ugt:1;
+	/*[7:4]	 Block length 2^cfg_bl_len,
+	 *because internal buffer size is limited to 512 bytes,
+	 *the cfg_bl_len <=9.
+	 */
+	u32 bl_len:4;
+	/*[11:8]	Wait response till 2^cfg_resp_timeout core clock cycles.
+	 *Maximum 32768 core cycles.
+	 */
+	u32 resp_timeout:4;
+	/*[15:12]   Wait response-command,
+	 *command-command gap before next command,
+	 *2^cfg_rc_cc core clock cycles.
+	 */
+	u32 rc_cc:4;
+	/*[16]	  DDR mode only. The command and TXD start from rising edge.
+	 *Set 1 to start from falling edge.
+	 */
+	u32 out_fall:1;
+	/*[17]	  1: Enable SDIO data block gap interrupt period.
+	 *0: Disabled.
+	 */
+	u32 blk_gap_ip:1;
+	/*[18]	  Spare,  ??? need check*/
+	u32 spare:1;
+	/*[19]	  Use this descriptor
+	 *even if its owner bit is ???0????.
+	 */
+	u32 ignore_owner:1;
+	/*[20]	  Check data strobe in HS400.*/
+	u32 chk_ds:1;
+	/*[21]	  Hold CMD as output Low, eMMC boot mode.*/
+	u32 cmd_low:1;
+	/*[22]	  1: stop clock. 0: normal clock.*/
+	u32 stop_clk:1;
+	/*[23]	  1: when BUS is idle and no descriptor is available,
+	 *turn off clock, to save power.
+	 */
+	u32 auto_clk:1;
+	/*[24]	TXD add error test*/
+	u32 txd_add_err:1;
+	/*[25]	When TXD CRC error, host sends the block again.*/
+	u32 txd_retry:1;
+	/*[26]	1: Use DS pin as SDIO IRQ input,
+	 *0: Use DAT1 pin as SDIO IRQ input..
+	 */
+	u32 irq_ds:1;
+	u32 err_abort:1;
+	u32 revd:4;			/*[31:27]   reved*/
+};
+struct sd_emmc_status {
+	/*[7:0]	 RX data CRC error per wire, for multiple block read,
+	 *the CRC errors are ORed together.
+	 */
+	u32 rxd_err:8;
+	/*[8]	   TX data CRC error, for multiple block write,
+	 *any one of blocks CRC error.
+	 */
+	u32 txd_err:1;
+	/*[9]	   SD/eMMC controller doesn????t own descriptor.
+	 *The owner bit is set cfg_ignore_owner to ignore this error.
+	 */
+	u32 desc_err:1;
+	/*[10]	  Response CRC error.*/
+	u32 resp_err:1;
+	/*[11]	  No response received before time limit.
+	 *The timeout limit is set by cfg_resp_timeout.
+	 */
+	u32 resp_timeout:1;
+	/*[12]	  Descriptor execution time over time limit.
+	 *The timeout limit is set by descriptor itself.
+	 */
+	u32 desc_timeout:1;
+	/*[13]	  End of Chain IRQ, Normal IRQ. */
+	u32 end_of_chain:1;
+	/*[14]	  This descriptor requests an IRQ, Normal IRQ,
+	 *the descriptor chain execution keeps going on.
+	 */
+	u32 desc_irq:1;
+	/*[15]	  SDIO device uses DAT[1] to request IRQ. */
+	u32 irq_sdio:1;
+	/*[23:16]   Input data signals. */
+	u32 dat_i:8;
+	/*[24]	  nput response signal. */
+	u32 cmd_i:1;
+	/*[25]	  Input data strobe. */
+	u32 ds:1;
+	/*[29:26]   BUS fsm */
+	u32 bus_fsm:4;
+	/*[30]	  Descriptor write back process is done
+	 *and it is ready for CPU to read.
+	 */
+	u32 desc_wr_rdy:1;
+	/*[31]	  Core is busy,desc_busy or sd_emmc_irq
+	 *  or bus_fsm is not idle.
+	 */
+	u32 core_wr_rdy:1;
+};
+struct sd_emmc_irq_en {
+	/*[7:0]	 RX data CRC error per wire.*/
+	u32 rxd_err:8;
+	/*[8]	   TX data CRC error. */
+	u32 txd_err:1;
+	/*[9]	   SD/eMMC controller doesn????t own descriptor. */
+	u32 desc_err:1;
+	/*[10]	  Response CRC error.*/
+	u32 resp_err:1;
+	/*[11]	  No response received before time limit. */
+	u32 resp_timeout:1;
+	/*[12]	  Descriptor execution time over time limit. */
+	u32 desc_timeout:1;
+	/*[13]	  End of Chain IRQ. */
+	u32 end_of_chain:1;
+	/*[14]	  This descriptor requests an IRQ. */
+	u32 desc_irq:1;
+	/*[15]	  Enable sdio interrupt. */
+	u32 irq_sdio:1;
+	/*[31:16]   reved*/
+	u32 revd:16;
+};
+struct sd_emmc_data_info {
+	/*[9:0]	 Rxd words received from BUS. Txd words received from DDR.*/
+	u32 cnt:10;
+	/*[24:16]   Rxd Blocks received from BUS.
+	 *Txd blocks received from DDR.
+	 */
+	u32 blk:9;
+	/*[31:17]   Reved. */
+	u32 revd:30;
+};
+struct sd_emmc_card_info {
+	/*[9:0]	 Txd BUS cycle counter. */
+	u32 txd_cnt:10;
+	/*[24:16]   Txd BUS block counter.*/
+	u32 txd_blk:9;
+	/*[31:17]   Reved. */
+	u32 revd:30;
+};
+struct cmd_cfg {
+	u32 length:9;
+	u32 block_mode:1;
+	u32 r1b:1;
+	u32 end_of_chain:1;
+	u32 timeout:4;
+	u32 no_resp:1;
+	u32 no_cmd:1;
+	u32 data_io:1;
+	u32 data_wr:1;
+	u32 resp_nocrc:1;
+	u32 resp_128:1;
+	u32 resp_num:1;
+	u32 data_num:1;
+	u32 cmd_index:6;
+	u32 error:1;
+	u32 owner:1;
+};
+struct sd_emmc_desc_info {
+	u32 cmd_info;
+	u32 cmd_arg;
+	u32 data_addr;
+	u32 resp_addr;
+};
+#define HHI_NAND_CLK_CNTL					0x97
+#define SD_EMMC_MAX_DESC_MUN		512
+#define SD_EMMC_MAX_DESC_MUN_PIO		36
+#define SD_EMMC_REQ_DESC_MUN		4
+#define SD_EMMC_CLOCK_SRC_OSC		0 /* 24MHz */
+#define SD_EMMC_CLOCK_SRC_FCLK_DIV2	1 /* 1GHz */
+#define SD_EMMC_CLOCK_SRC_400MHZ	4
+#define SD_EMMC_CLOCK_SRC_MPLL		2 /* MPLL */
+#define SD_EMMC_CLOCK_SRC_DIFF_PLL	3
+#define SD_EMMC_IRQ_ALL			0x3fff
+#define SD_EMMC_RESP_SRAM_OFF		0
+/*#define SD_EMMC_DESC_SET_REG*/
+
+#define SD_EMMC_DESC_REG_CONF		0x4
+#define SD_EMMC_DESC_REG_IRQC		0xC
+#define SD_EMMC_DESC_RESP_STAT		0xfff80000
+#define SD_EMMC_IRQ_EN_ALL_INIT
+#define SD_EMMC_REQ_DMA_SGMAP
+/* #define SD_EMMC_CLK_CTRL*/
+/* #define SD_EMMC_DATA_TASKLET */
+#define STAT_POLL_TIMEOUT			0xfffff
+#define STAT_POLL_TIMEOUT			0xfffff
+
+#define MMC_RSP_136_NUM				4
+#define MMC_MAX_DEVICE				3
+#define MMC_TIMEOUT				5000
+
+/* #define pr_info(a...) */
+#define DBG_LINE_INFO() \
+{ \
+	pr_info("[%s] : %s\n", __func__, __FILE__); \
+}
+/* #define DBG_LINE_INFO() */
+/* #define dev_err(a,s) pr_info(KERN_INFO s); */
+/* fixme, those code should not be marco as vairous on chips */
+/* reg0 for BOOT */
+#define BOOT_POLL_UP	(0x3A << 2)
+#define BOOT_POLL_UP_EN (0x48 << 2)
+/* reg1 for GPIOC(card) */
+#define CARD_POLL_UP	(0x3B << 2)
+#define CARD_POLL_UP_EN (0x49 << 2)
+
+/* pinmux for sdcards, gpioC */
+#define PIN_MUX_REG6	(0xb6 << 2)
+#define PIN_MUX_REG9	(0xb9 << 2)
+
+#define AML_MMC_DISABLED_TIMEOUT	100
+#define AML_MMC_SLEEP_TIMEOUT		1000
+#define AML_MMC_OFF_TIMEOUT		8000
+
+#define SD_EMMC_BOUNCE_REQ_SIZE		(512*1024)
+#define SDHC_BOUNCE_REQ_SIZE		(512*1024)
+#define SDIO_BOUNCE_REQ_SIZE		(128*1024)
+#define MMC_TIMEOUT_MS			(20)
+
+#define MESON_SDIO_PORT_A 0
+#define MESON_SDIO_PORT_B 1
+#define MESON_SDIO_PORT_C 2
+#define MESON_SDIO_PORT_XC_A 3
+#define MESON_SDIO_PORT_XC_B 4
+#define MESON_SDIO_PORT_XC_C 5
+
+void aml_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq);
+int aml_sdhc_get_cd(struct mmc_host *mmc);
+extern void amlsd_init_debugfs(struct mmc_host *host);
+
+extern struct mmc_host *sdio_host;
+
+#define	 SPI_BOOT_FLAG			0
+#define	 NAND_BOOT_FLAG			1
+#define	 EMMC_BOOT_FLAG			2
+#define	 CARD_BOOT_FLAG			3
+#define	 SPI_NAND_FLAG			4
+#define	 SPI_EMMC_FLAG			5
+
+#define R_BOOT_DEVICE_FLAG  (aml_read_cbus(ASSIST_POR_CONFIG))
+
+
+#define POR_BOOT_VALUE ((((R_BOOT_DEVICE_FLAG>>9)&1)<<2)|\
+		((R_BOOT_DEVICE_FLAG>>6)&3)) /* {poc[9],poc[7:6]} */
+
+#define POR_NAND_BOOT() ((POR_BOOT_VALUE == 7) \
+		|| (POR_BOOT_VALUE == 6))
+#define POR_SPI_BOOT() ((POR_BOOT_VALUE == 5) || (POR_BOOT_VALUE == 4))
+/* #define POR_EMMC_BOOT() (POR_BOOT_VALUE == 3) */
+#define POR_EMMC_BOOT()	(POR_BOOT_VALUE == 3)
+
+#define POR_CARD_BOOT() (POR_BOOT_VALUE == 0)
+
+/* for external codec status, if using external codec,
+ *	jtag should not be set.
+ */
+extern int ext_codec;
+
+#ifndef CONFIG_MESON_TRUSTZONE
+/* P_AO_SECURE_REG1 is "Secure Register 1" in <M8-Secure-AHB-Registers.doc> */
+#define aml_jtag_gpioao()
+/*do{\
+ *	aml_clr_reg32_mask(P_AO_SECURE_REG1, ((1<<5) | (1<<9))); \
+ *	if(!ext_codec)\
+ *	aml_set_reg32_mask(P_AO_SECURE_REG1, ((1<<8) | (1<<1))); \
+ *}while(0)
+ */
+
+#define aml_jtag_sd()
+/*do{\
+ *	aml_clr_reg32_mask(P_AO_SECURE_REG1, ((1<<8) | (1<<1))); \
+ *	aml_set_reg32_mask(P_AO_SECURE_REG1, ((1<<5) | (1<<9))); \
+ *}while(0)
+ */
+#else
+/* Secure REG can only be accessed in Secure World if TrustZone enabled.*/
+#include <mach/meson-secure.h>
+#define aml_jtag_gpioao() \
+{ \
+	meson_secure_reg_write(P_AO_SECURE_REG1, \
+			meson_secure_reg_read(P_AO_SECURE_REG1) \
+			& (~((1<<5) | (1<<9)))); \
+}
+
+#define aml_jtag_sd() do {\
+	meson_secure_reg_write(P_AO_SECURE_REG1,\
+			meson_secure_reg_read(P_AO_SECURE_REG1)\
+			& (~(1<<8) | (1<<1))); \
+	meson_secure_reg_write(P_AO_SECURE_REG1,\
+			meson_secure_reg_read(P_AO_SECURE_REG1)\
+			| ((1<<5) | (1<<9))); \
+} while (0)
+#endif /* CONFIG_MESON_TRUSTZONE */
+
+#define aml_uart_pinctrl() do {\
+	\
+} while (0)
+
+#endif
+
diff -Naur a/include/linux/amlogic/secmon.h b/include/linux/amlogic/secmon.h
--- a/include/linux/amlogic/secmon.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/secmon.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __SEC_MON_H__
+#define __SEC_MON_H__
+
+void __iomem *get_secmon_sharemem_input_base(void);
+void __iomem *get_secmon_sharemem_output_base(void);
+long get_secmon_phy_input_base(void);
+long get_secmon_phy_output_base(void);
+
+void secmon_clear_cma_mmu(void);
+
+int within_secmon_region(unsigned long addr);
+void meson_sm_mutex_lock(void);
+void meson_sm_mutex_unlock(void);
+void __iomem *get_meson_sm_input_base(void);
+void __iomem *get_meson_sm_output_base(void);
+unsigned int get_secmon_sharemem_in_size(void);
+unsigned int get_secmon_sharemem_out_size(void);
+
+#endif
diff -Naur a/include/linux/amlogic/tee.h b/include/linux/amlogic/tee.h
--- a/include/linux/amlogic/tee.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/tee.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,89 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * include/linux/amlogic/tee.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __TEE_H__
+#define __TEE_H__
+
+/* memory align used by tee_protect_mem_by_type() */
+#define TEE_MEM_ALIGN_SIZE                                 0x10000
+
+/* memory type used by tee_protect_mem_by_type() */
+#define TEE_MEM_TYPE_STREAM_INPUT                          0x4
+#define TEE_MEM_TYPE_STREAM_OUTPUT                         0x5
+#define TEE_MEM_TYPE_GPU                                   0x6
+#define TEE_MEM_TYPE_VDIN                                  0x7
+#define TEE_MEM_TYPE_HCODEC                                0x8
+#define TEE_MEM_TYPE_GE2D                                  0x9
+#define TEE_MEM_TYPE_DEMUX                                 0xa
+#define TEE_MEM_TYPE_TCON                                  0xb
+#define TEE_MEM_TYPE_PCIE                                  0xc
+#define TEE_MEM_TYPE_FRC                                   0xd
+#define TEE_MEM_TYPE_KERNEL                                0xe
+#define TEE_MEM_TYPE_INVALID                               0xff
+
+/* device ID used by tee_config_device_state() */
+#define DMC_DEV_ID_GPU                                     1
+#define DMC_DEV_ID_HEVC                                    4
+#define DMC_DEV_ID_PARSER                                  7
+#define DMC_DEV_ID_VPU                                     8
+#define DMC_DEV_ID_VDIN                                    9
+#define DMC_DEV_ID_VDEC                                    13
+#define DMC_DEV_ID_HCODEC                                  14
+#define DMC_DEV_ID_GE2D                                    15
+#define DMC_DEV_ID_DI_PRE                                  16
+#define DMC_DEV_ID_DI_POST                                 17
+#define DMC_DEV_ID_GDC                                     18
+
+bool tee_enabled(void);
+int is_secload_get(void);
+int tee_load_video_fw(u32 index, u32 vdec);
+int tee_load_video_fw_swap(u32 index, u32 vdec, bool is_swap);
+u32 tee_protect_tvp_mem(u32 start, u32 size,
+			u32 *handle);
+void tee_unprotect_tvp_mem(u32 handle);
+u32 tee_protect_mem_by_type(u32 type,
+		u32 start, u32 size,
+		u32 *handle);
+void tee_unprotect_mem(u32 handle);
+
+int tee_config_device_state(int dev_id, int secure);
+
+void tee_demux_config_pipeline(int tsn_in, int tsn_out);
+
+int tee_demux_config_pad(int reg, int val);
+
+int tee_read_reg_bits(u32 reg, u32 *val, u32 offset, u32 length);
+
+int tee_write_reg_bits(u32 reg, u32 val, u32 offset, u32 length);
+
+u32 tee_protect_mem(u32 type, u32 level,
+		u32 start, u32 size, u32 *handle);
+
+int tee_check_in_mem(u32 pa, u32 size);
+
+int tee_check_out_mem(u32 pa, u32 size);
+
+int tee_vp9_prob_process(u32 cur_frame_type, u32 prev_frame_type,
+		u32 prob_status, u32 prob_addr);
+
+int tee_vp9_prob_malloc(u32 *prob_addr);
+
+int tee_vp9_prob_free(u32 prob_addr);
+
+#endif /* __TEE_H__ */
+
diff -Naur a/include/linux/amlogic/unifykey/key_manage.h b/include/linux/amlogic/unifykey/key_manage.h
--- a/include/linux/amlogic/unifykey/key_manage.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/unifykey/key_manage.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,29 @@
+/*
+ * include/linux/amlogic/unifykey/key_manage.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __KEYMANAGE1__
+#define __KEYMANAGE1__
+
+typedef int32_t (*store_key_ops)(uint8_t *buf,
+					uint32_t len, uint32_t *actual_length);
+
+void storage_ops_read(store_key_ops read);
+void storage_ops_write(store_key_ops write);
+
+void  *get_ukdev(void);
+
+#endif /*__KEYMANAGE1__*/
diff -Naur a/include/linux/amlogic/unifykey/security_key.h b/include/linux/amlogic/unifykey/security_key.h
--- a/include/linux/amlogic/unifykey/security_key.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/amlogic/unifykey/security_key.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,45 @@
+/*
+ * include/linux/amlogic/unifykey/security_key.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _AML_SECURITY_KEY_H_
+#define _AML_SECURITY_KEY_H_
+
+/* internal return value*/
+#define RET_OK		0
+#define RET_EFAIL	1	/*not found*/
+#define RET_EINVAL	2	/*name length*/
+#define RET_EMEM	3	/*no enough memory*/
+#define RET_EUND	0xff
+
+#define SMC_UNK		0xffffffff
+
+/* keyattr: 0: normal, 1: secure*/
+int32_t secure_storage_write(uint8_t *keyname, uint8_t *keybuf,
+			uint32_t keylen, uint32_t keyattr);
+int32_t secure_storage_read(uint8_t *keyname, uint8_t *keybuf,
+			uint32_t keylen, uint32_t *readlen);
+int32_t secure_storage_verify(uint8_t *keyname, uint8_t *hashbuf);
+int32_t secure_storage_query(uint8_t *keyname, uint32_t *retval);
+int32_t secure_storage_tell(uint8_t *keyname, uint32_t *retval);
+int32_t secure_storage_status(uint8_t *keyname, uint32_t *retval);
+void *secure_storage_getbuffer(uint32_t *size);
+void secure_storage_notifier_ex(uint32_t storagesize);
+void secure_storage_type(uint32_t is_emmc);
+int32_t secure_storage_set_enctype(uint32_t type);
+int32_t secure_storage_get_enctype(void);
+int32_t secure_storage_version(void);
+#endif
diff -Naur a/include/linux/libata.h b/include/linux/libata.h
--- a/include/linux/libata.h	2022-06-29 08:47:07.199383757 +0800
+++ b/include/linux/libata.h	2022-05-27 17:20:18.157934092 +0800
@@ -390,7 +390,7 @@
 	/* This should match the actual table size of
 	 * ata_eh_cmd_timeout_table in libata-eh.c.
 	 */
-	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 7,
+	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 6,
 
 	/* Horkage types. May be set by libata or controller on drives
 	   (some horkage may be drive/controller pair dependent */
diff -Naur a/include/linux/mmc/card.h b/include/linux/mmc/card.h
--- a/include/linux/mmc/card.h	2022-05-27 17:20:18.181934401 +0800
+++ b/include/linux/mmc/card.h	2022-05-31 11:56:48.097256115 +0800
@@ -310,6 +310,7 @@
 	struct dentry		*debugfs_root;
 	struct mmc_part	part[MMC_NUM_PHY_PARTITION]; /* physical partitions */
 	unsigned int    nr_parts;
+	unsigned int    key_stamp;
 
 	unsigned int		bouncesz;	/* Bounce buffer size */
 	struct workqueue_struct *complete_wq;	/* Private workqueue */
diff -Naur a/include/linux/mmc/emmc_partitions.h b/include/linux/mmc/emmc_partitions.h
--- a/include/linux/mmc/emmc_partitions.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/mmc/emmc_partitions.h	2022-05-31 11:56:48.097256115 +0800
@@ -0,0 +1,85 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _EMMC_PARTITIONS_H
+#define _EMMC_PARTITIONS_H
+
+#include<linux/genhd.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/core.h>
+
+/* #include <mach/register.h> */
+/* #include <mach/am_regs.h> */
+#define CONFIG_DTB_SIZE  (256 * 1024U)
+#define DTB_CELL_SIZE	(16 * 1024U)
+#define	STORE_CODE				1
+#define	STORE_CACHE				BIT(1)
+#define	STORE_DATA				BIT(2)
+
+#define     MAX_PART_NAME_LEN               16
+#define     MAX_MMC_PART_NUM                32
+
+/* MMC Partition Table */
+#define     MMC_PARTITIONS_MAGIC            "MPT"
+#define     MMC_RESERVED_NAME               "reserved"
+
+#define     SZ_1M                           0x00100000
+
+/* the size of bootloader partition */
+#define     MMC_BOOT_PARTITION_SIZE         (4 * SZ_1M)
+#define		MMC_TUNING_OFFSET               0X14400
+
+/* the size of reserve space behind bootloader partition */
+#define     MMC_BOOT_PARTITION_RESERVED     (32 * SZ_1M)
+
+#define     RESULT_OK                       0
+#define     RESULT_FAIL                     1
+#define     RESULT_UNSUP_HOST               2
+#define     RESULT_UNSUP_CARD               3
+
+struct partitions {
+	/* identifier string */
+	char name[MAX_PART_NAME_LEN];
+	/* partition size, byte unit */
+	u64 size;
+	/* offset within the master space, byte unit */
+	u64 offset;
+	/* master flags to mask out for this partition */
+	unsigned int mask_flags;
+};
+
+struct mmc_partitions_fmt {
+	char magic[4];
+	unsigned char version[12];
+	int part_num;
+	int checksum;
+	struct partitions partitions[MAX_MMC_PART_NUM];
+};
+
+/*#ifdef CONFIG_MMC_AML*/
+int aml_emmc_partition_ops(struct mmc_card *card, struct gendisk *disk);
+int add_fake_boot_partition(struct gendisk *disk, char *name, int idx);
+/*
+ *#else
+ *static inline int aml_emmc_partition_ops(struct mmc_card *card,
+ *					 struct gendisk *disk)
+ *{
+ *	return -1;
+ *}
+ *#endif
+ */
+unsigned int mmc_capacity(struct mmc_card *card);
+int mmc_read_internal(struct mmc_card *card,
+		      unsigned int dev_addr, unsigned int blocks, void *buf);
+int mmc_write_internal(struct mmc_card *card,
+		       unsigned int dev_addr, unsigned int blocks, void *buf);
+int get_reserve_partition_off_from_tbl(void);
+#endif
+
+extern struct mmc_partitions_fmt *pt_fmt;
+
diff -Naur a/include/linux/mmc/host.h b/include/linux/mmc/host.h
--- a/include/linux/mmc/host.h	2022-05-27 17:20:18.181934401 +0800
+++ b/include/linux/mmc/host.h	2022-05-31 11:56:48.097256115 +0800
@@ -286,6 +286,9 @@
 	u32			ocr_avail_sd;	/* SD-specific OCR */
 	u32			ocr_avail_mmc;	/* MMC-specific OCR */
 	struct wakeup_source	*ws;		/* Enable consume of uevents */
+#ifdef CONFIG_AMLOGIC_MODIFY
+	u8          first_init_flag;
+#endif
 	u32			max_current_330;
 	u32			max_current_300;
 	u32			max_current_180;
@@ -387,6 +390,9 @@
 	unsigned int		max_blk_size;	/* maximum size of one mmc block */
 	unsigned int		max_blk_count;	/* maximum number of blocks in one req */
 	unsigned int		max_busy_timeout; /* max busy timeout in ms */
+#ifdef CONFIG_AMLOGIC_MODIFY
+	unsigned int		capacity;
+#endif
 
 	/* private data */
 	spinlock_t		lock;		/* lock for claim and bus ops */
@@ -606,4 +612,8 @@
 int mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error);
 int mmc_abort_tuning(struct mmc_host *host, u32 opcode);
 
+#ifdef CONFIG_AMLOGIC_MODIFY
+int aml_read_tuning_para(struct mmc_host *mmc);
+#endif
+
 #endif /* LINUX_MMC_HOST_H */
diff -Naur a/include/linux/soc/amlogic/meson-canvas.h b/include/linux/soc/amlogic/meson-canvas.h
--- a/include/linux/soc/amlogic/meson-canvas.h	2022-05-27 17:20:18.225934968 +0800
+++ b/include/linux/soc/amlogic/meson-canvas.h	2022-05-31 11:56:48.097256115 +0800
@@ -39,6 +39,14 @@
 int meson_canvas_alloc(struct meson_canvas *canvas, u8 *canvas_index);
 
 /**
+ * meson_canvas_alloc_spec() - take ownership of a canvas
+ *
+ * @canvas: canvas provider instance retrieved from meson_canvas_get()
+ * @canvas_index: the specified canvas index
+ */
+int meson_canvas_alloc_spec(struct meson_canvas *canvas, u8 canvas_index);
+
+/**
  * meson_canvas_free() - remove ownership from a canvas
  *
  * @canvas: canvas provider instance retrieved from meson_canvas_get()
diff -Naur a/include/linux/usb/composite.h b/include/linux/usb/composite.h
--- a/include/linux/usb/composite.h	2022-05-27 17:20:18.241935174 +0800
+++ b/include/linux/usb/composite.h	2022-05-31 11:56:48.097256115 +0800
@@ -525,6 +525,8 @@
 extern int usb_string_ids_n(struct usb_composite_dev *c, unsigned n);
 
 extern void composite_disconnect(struct usb_gadget *gadget);
+extern void composite_reset(struct usb_gadget *gadget);
+
 extern int composite_setup(struct usb_gadget *gadget,
 		const struct usb_ctrlrequest *ctrl);
 extern void composite_suspend(struct usb_gadget *gadget);
@@ -590,6 +592,7 @@
 	struct config_group group;
 	struct list_head cfs_list;
 	struct usb_function_driver *fd;
+	struct usb_function *f;
 	int (*set_inst_name)(struct usb_function_instance *inst,
 			      const char *name);
 	void (*free_func_inst)(struct usb_function_instance *inst);
diff -Naur a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h
--- a/include/linux/usb/quirks.h	2022-05-27 17:20:18.241935174 +0800
+++ b/include/linux/usb/quirks.h	2022-05-31 11:56:48.097256115 +0800
@@ -72,4 +72,7 @@
 /* device has endpoints that should be ignored */
 #define USB_QUIRK_ENDPOINT_IGNORE		BIT(15)
 
+/* device can't support auto suspend function */
+#define USB_QUIRK_AUTO_SUSPEND			BIT(16)
+
 #endif /* __LINUX_USB_QUIRKS_H */
diff -Naur a/Kconfig b/Kconfig
--- a/Kconfig	2022-05-27 17:20:13.749877237 +0800
+++ b/Kconfig	2022-06-22 17:36:54.306837149 +0800
@@ -30,3 +30,5 @@
 source "lib/Kconfig.debug"
 
 source "Documentation/Kconfig"
+
+source "vendor/Kconfig"
diff -Naur a/kernel/dma/contiguous.c b/kernel/dma/contiguous.c
--- a/kernel/dma/contiguous.c	2022-05-27 17:20:18.377936928 +0800
+++ b/kernel/dma/contiguous.c	2022-05-31 11:56:48.097256115 +0800
@@ -262,6 +262,7 @@
 
 	return cma_alloc(dev_get_cma_area(dev), count, align, no_warn);
 }
+EXPORT_SYMBOL(dma_alloc_from_contiguous);
 
 /**
  * dma_release_from_contiguous() - release allocated pages
@@ -278,6 +279,7 @@
 {
 	return cma_release(dev_get_cma_area(dev), pages, count);
 }
+EXPORT_SYMBOL(dma_release_from_contiguous);
 
 static struct page *cma_alloc_aligned(struct cma *cma, size_t size, gfp_t gfp)
 {
diff -Naur a/Makefile b/Makefile
--- a/Makefile	2022-05-27 17:20:13.753877288 +0800
+++ b/Makefile	2022-06-22 23:09:26.871334703 +0800
@@ -653,6 +653,7 @@
 drivers-$(CONFIG_SAMPLES) += samples/
 drivers-y	+= net/ virt/
 libs-y		:= lib/
+vendor-y	:= vendor/
 endif # KBUILD_EXTMOD
 
 # The all: target is the default when no target is given on the
@@ -851,7 +852,7 @@
 endif
 
 endif # CONFIG_DEBUG_INFO
-
+KBUILD_CFLAGS += -Wno-unused-function
 KBUILD_CFLAGS += $(DEBUG_CFLAGS)
 export DEBUG_CFLAGS
 
@@ -945,7 +946,7 @@
 KBUILD_CFLAGS   += -Werror=date-time
 
 # enforce correct pointer usage
-KBUILD_CFLAGS   += $(call cc-option,-Werror=incompatible-pointer-types)
+#KBUILD_CFLAGS   += $(call cc-option,-Werror=incompatible-pointer-types)
 
 # Require designated initializers for all marked structures
 KBUILD_CFLAGS   += $(call cc-option,-Werror=designated-init)
@@ -1115,16 +1116,16 @@
 core-y		+= kernel/ certs/ mm/ fs/ ipc/ security/ crypto/ block/
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, \
-		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
+		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) $(vendor-y) \
 		     $(libs-y) $(libs-m)))
 
 vmlinux-alldirs	:= $(sort $(vmlinux-dirs) Documentation \
 		     $(patsubst %/,%,$(filter %/, $(core-) \
-			$(drivers-) $(libs-))))
+			$(drivers-) $(vendor-) $(libs-))))
 
 subdir-modorder := $(addsuffix modules.order,$(filter %/, \
 			$(core-y) $(core-m) $(libs-y) $(libs-m) \
-			$(drivers-y) $(drivers-m)))
+			$(drivers-y) $(vendor-y) $(drivers-m)))
 
 build-dirs	:= $(vmlinux-dirs)
 clean-dirs	:= $(vmlinux-alldirs)
@@ -1139,6 +1140,7 @@
 KBUILD_VMLINUX_LIBS := $(patsubst %/,%/lib.a, $(libs-y))
 endif
 KBUILD_VMLINUX_OBJS += $(patsubst %/,%/built-in.a, $(drivers-y))
+KBUILD_VMLINUX_OBJS += $(patsubst %/,%/built-in.a, $(vendor-y))
 
 export KBUILD_VMLINUX_OBJS KBUILD_VMLINUX_LIBS
 export KBUILD_LDS          := arch/$(SRCARCH)/kernel/vmlinux.lds
diff -Naur a/mm/Kconfig b/mm/Kconfig
--- a/mm/Kconfig	2022-07-04 18:32:52.121159105 +0800
+++ b/mm/Kconfig	2022-06-25 13:59:26.657088100 +0800
@@ -961,7 +961,6 @@
 config MEM_PURGEABLE
 	bool "Purgeable memory feature"
 	default n
-	depends on 64BIT
 	select ARCH_USES_HIGH_VMA_FLAGS
 	help
 	  Support purgeable pages for process
diff -Naur a/mm/vmscan.c b/mm/vmscan.c
--- a/mm/vmscan.c	2022-07-01 17:31:52.025722900 +0800
+++ b/mm/vmscan.c	2022-06-17 09:33:40.366370000 +0800
@@ -4362,10 +4362,8 @@
 {
 	struct mem_cgroup *memcg = NULL;
 	unsigned long nr = 0;
-#ifdef CONFIG_MEMCG
-	while (memcg = mem_cgroup_iter(NULL, memcg, NULL))
-#endif
-	{
+
+	while (memcg = mem_cgroup_iter(NULL, memcg, NULL)) {
 		struct lruvec *lruvec = mem_cgroup_lruvec(memcg, pgdata);
 
 		shrink_list(LRU_ACTIVE_PURGEABLE, -1, lruvec, sc);
diff -Naur a/net/ipv4/inet_hashtables.c b/net/ipv4/inet_hashtables.c
--- a/net/ipv4/inet_hashtables.c	2022-07-04 18:32:52.121159105 +0800
+++ b/net/ipv4/inet_hashtables.c	2022-06-15 15:15:55.636125159 +0800
@@ -711,18 +711,6 @@
 }
 EXPORT_SYMBOL_GPL(inet_unhash);
 
-/* RFC 6056 3.3.4.  Algorithm 4: Double-Hash Port Selection Algorithm
- * Note that we use 32bit integers (vs RFC 'short integers')
- * because 2^16 is not a multiple of num_ephemeral and this
- * property might be used by clever attacker.
- * RFC claims using TABLE_LENGTH=10 buckets gives an improvement, though
- * attacks were since demonstrated, thus we use 65536 instead to really
- * give more isolation and privacy, at the expense of 256kB of kernel
- * memory.
- */
-#define INET_TABLE_PERTURB_SHIFT 16
-static u32 table_perturb[1 << INET_TABLE_PERTURB_SHIFT];
-
 int __inet_hash_connect(struct inet_timewait_death_row *death_row,
 		struct sock *sk, u64 port_offset,
 		int (*check_established)(struct inet_timewait_death_row *,
@@ -736,8 +724,8 @@
 	struct inet_bind_bucket *tb;
 	u32 remaining, offset;
 	int ret, i, low, high;
+	static u32 hint;
 	int l3mdev;
-	u32 index;
 
 	if (port) {
 		head = &hinfo->bhash[inet_bhashfn(net, port,
@@ -764,10 +752,7 @@
 	if (likely(remaining > 1))
 		remaining &= ~1U;
 
-	net_get_random_once(table_perturb, sizeof(table_perturb));
-	index = hash_32(port_offset, INET_TABLE_PERTURB_SHIFT);
-
-	offset = READ_ONCE(table_perturb[index]) + port_offset;
+	offset = hint + port_offset;
 	offset %= remaining;
 	/* In first pass we try ports of @low parity.
 	 * inet_csk_get_port() does the opposite choice.
@@ -822,7 +807,7 @@
 	return -EADDRNOTAVAIL;
 
 ok:
-	WRITE_ONCE(table_perturb[index], READ_ONCE(table_perturb[index]) + i + 2);
+	hint += i + 2;
 
 	/* Head lock still held and bh's disabled */
 	inet_bind_hash(sk, tb, port);
diff -Naur a/net/nfc/netlink.c b/net/nfc/netlink.c
--- a/net/nfc/netlink.c	2022-06-25 17:56:10.483704524 +0800
+++ b/net/nfc/netlink.c	2022-05-27 17:20:18.613939971 +0800
@@ -1242,7 +1242,7 @@
 	struct sk_buff *msg;
 	void *hdr;
 
-	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);
+	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!msg)
 		return -ENOMEM;
 
@@ -1258,7 +1258,7 @@
 
 	genlmsg_end(msg, hdr);
 
-	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);
+	genlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);
 
 	return 0;
 
diff -Naur a/scripts/dtc/include-prefixes/arm64/amlogic/Makefile b/scripts/dtc/include-prefixes/arm64/amlogic/Makefile
--- a/scripts/dtc/include-prefixes/arm64/amlogic/Makefile	2022-05-27 17:20:14.013880643 +0800
+++ b/scripts/dtc/include-prefixes/arm64/amlogic/Makefile	2022-06-04 12:12:41.042068628 +0800
@@ -1,50 +1,2 @@
 # SPDX-License-Identifier: GPL-2.0
-dtb-$(CONFIG_ARCH_MESON) += meson-axg-s400.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12a-sei510.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12a-u200.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12a-x96-max.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-gtking.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-gtking-pro.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-a311d-khadas-vim3.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-s922x-khadas-vim3.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-odroid-n2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-odroid-n2-plus.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-g12b-ugoos-am6.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-kii-pro.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-nanopi-k2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-nexbox-a95x.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-odroidc2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-p200.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-p201.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-vega-s95-pro.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-vega-s95-meta.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-vega-s95-telos.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-wetek-hub.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxbb-wetek-play2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s805x-libretech-ac.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-hwacom-amazetv.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-khadas-vim.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-libretech-cc.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-libretech-cc-v2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-nexbox-a95x.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905x-p212.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-p230.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-p231.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-phicomm-n1.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-sml5442tw.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s805x-p241.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905w-p281.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905w-tx3-mini.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxl-s905d-libretech-pc.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-khadas-vim2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-nexbox-a1.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-q200.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-q201.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-rbox-pro.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-s912-libretech-pc.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-vega-s96.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-gxm-wetek-core2.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-sm1-sei610.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-sm1-khadas-vim3l.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-sm1-odroid-c4.dtb
-dtb-$(CONFIG_ARCH_MESON) += meson-a1-ad401.dtb
+dtb-$(CONFIG_ARCH_MESON) += meson-g12b-unionpi-tiger.dtb
\ No newline at end of file
diff -Naur a/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-a311d.dtsi b/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-a311d.dtsi
--- a/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-a311d.dtsi	2022-05-27 17:20:14.013880643 +0800
+++ b/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-a311d.dtsi	2022-05-31 11:56:47.693259679 +0800
@@ -11,26 +11,6 @@
 		compatible = "operating-points-v2";
 		opp-shared;
 
-		opp-100000000 {
-			opp-hz = /bits/ 64 <100000000>;
-			opp-microvolt = <731000>;
-		};
-
-		opp-250000000 {
-			opp-hz = /bits/ 64 <250000000>;
-			opp-microvolt = <731000>;
-		};
-
-		opp-500000000 {
-			opp-hz = /bits/ 64 <500000000>;
-			opp-microvolt = <731000>;
-		};
-
-		opp-667000000 {
-			opp-hz = /bits/ 64 <667000000>;
-			opp-microvolt = <731000>;
-		};
-
 		opp-1000000000 {
 			opp-hz = /bits/ 64 <1000000000>;
 			opp-microvolt = <761000>;
@@ -65,31 +45,21 @@
 			opp-hz = /bits/ 64 <1800000000>;
 			opp-microvolt = <1001000>;
 		};
-	};
-
-	cpub_opp_table_1: opp-table-1 {
-		compatible = "operating-points-v2";
-		opp-shared;
 
-		opp-100000000 {
-			opp-hz = /bits/ 64 <100000000>;
-			opp-microvolt = <731000>;
+		opp-1908000000 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <1022000>;
 		};
 
-		opp-250000000 {
-			opp-hz = /bits/ 64 <250000000>;
-			opp-microvolt = <731000>;
-		};
-
-		opp-500000000 {
-			opp-hz = /bits/ 64 <500000000>;
-			opp-microvolt = <731000>;
+		opp-2016000000 {
+			opp-hz = /bits/ 64 <2016000000>;
+			opp-microvolt = <1022000>;
 		};
+	};
 
-		opp-667000000 {
-			opp-hz = /bits/ 64 <667000000>;
-			opp-microvolt = <731000>;
-		};
+	cpub_opp_table_1: opp-table-1 {
+		compatible = "operating-points-v2";
+		opp-shared;
 
 		opp-1000000000 {
 			opp-hz = /bits/ 64 <1000000000>;
@@ -126,24 +96,34 @@
 			opp-microvolt = <831000>;
 		};
 
-                opp-1908000000 {
-                        opp-hz = /bits/ 64 <1908000000>;
-                        opp-microvolt = <861000>;
-                };
-
-                opp-2016000000 {
-                        opp-hz = /bits/ 64 <2016000000>;
-                        opp-microvolt = <911000>;
-                };
-
-                opp-2108000000 {
-                        opp-hz = /bits/ 64 <2108000000>;
-                        opp-microvolt = <951000>;
-                };
-
-                opp-2208000000 {
-                        opp-hz = /bits/ 64 <2208000000>;
-                        opp-microvolt = <1011000>;
-                };
+		opp-1908000000 {
+			opp-hz = /bits/ 64 <1908000000>;
+			opp-microvolt = <861000>;
+		};
+
+		opp-2016000000 {
+			opp-hz = /bits/ 64 <2016000000>;
+			opp-microvolt = <911000>;
+		};
+
+		opp-2108000000 {
+			opp-hz = /bits/ 64 <2108000000>;
+			opp-microvolt = <951000>;
+		};
+
+		opp-2208000000 {
+			opp-hz = /bits/ 64 <2208000000>;
+			opp-microvolt = <1011000>;
+		};
+
+		opp-2304000000 {
+			opp-hz = /bits/ 64 <2304000000>;
+			opp-microvolt = <1022000>;
+		};
+
+		opp-2400000000 {
+			opp-hz = /bits/ 64 <2400000000>;
+			opp-microvolt = <1022000>;
+		};
 	};
 };
diff -Naur a/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-unionpi-tiger.dts b/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-unionpi-tiger.dts
--- a/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-unionpi-tiger.dts	1970-01-01 08:00:00.000000000 +0800
+++ b/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-unionpi-tiger.dts	2022-07-04 13:57:46.707580803 +0800
@@ -0,0 +1,489 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (c) 2019 Christian Hewitt <christianshewitt@gmail.com>
+ */
+
+/dts-v1/;
+
+#include "meson-g12b-a311d.dtsi"
+#include "meson-unionpi-tiger.dtsi"
+#include "meson-g12b-unionpi-tiger.dtsi"
+
+/ {
+	model = "UnionPi Tiger";
+	compatible = "unionpi,tiger", "amlogic,a311d", "amlogic,g12b";
+	amlogic-dt-id = "g12b_w400_b";
+
+	reserved-memory {
+		galcore_reserved:linux,galcore {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x1000000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+		
+		isp_cma_reserved:linux,isp_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x10000000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+
+		adapt_cma_reserved:linux,adapt_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x03000000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+		
+		codec_mm_cma:linux,codec_mm_cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			/* ion_codec_mm max can alloc size 80M*/
+			size = <0x0 0x13400000>;
+			alignment = <0x0 0x400000>;
+			linux,contiguous-region;
+		};
+		
+		/* codec shared reserved */
+		codec_mm_reserved:linux,codec_mm_reserved {
+			compatible = "amlogic, codec-mm-reserved";
+			size = <0x0 0x0>;
+			alignment = <0x0 0x100000>;
+			//no-map;
+		};
+	};
+
+	cpu_version {
+		reg=<0x0 0xff800220 0x0 0x4>;
+	};
+	
+	canvas_legacy: canvas_legacy {
+		compatible = "amlogic, meson, canvas_legacy";
+		dev_name = "amlogic-canvas";
+		status = "okay";
+		amlogic,canvas = <&canvas>;
+	};
+	
+	media_clk {
+		compatible = "amlogic, media_clk";
+		status = "okay";
+		clocks = <&clkc CLKID_PARSER
+				&clkc CLKID_DEMUX
+				&clkc CLKID_AHB_ARB0
+				&clkc CLKID_DOS
+				&clkc CLKID_VDEC_MUX
+				&clkc CLKID_HCODEC_MUX
+				&clkc CLKID_HEVC_MUX
+				&clkc CLKID_HEVCF_MUX>;
+		clock-names = "parser_top",
+				"demux",
+				"ahbarb0",
+				"vdec",
+				"clk_vdec_mux",
+				"clk_hcodec_mux",
+				"clk_hevc_mux",
+				"clk_hevcb_mux";
+	};
+
+	codec_mm {
+		compatible = "amlogic, codec, mm";
+		memory-region = <&codec_mm_cma &codec_mm_reserved>;
+		dev_name = "codec_mm";
+		status = "okay";
+	};
+
+	codec_io: codec_io {
+		compatible = "amlogic, codec_io";
+		status = "okay";
+		#address-cells=<1>;
+		#size-cells=<1>;
+		ranges;
+		io_cbus_base{
+			reg = <0xffd00000 0x100000>;
+		};
+		io_dos_base{
+			reg = <0xff620000 0x10000>;
+		};
+		io_hiubus_base{
+			reg = <0xff63c000 0x2000>;
+		};
+		io_aobus_base{
+			reg = <0xff800000 0x10000>;
+		};
+		io_vcbus_base{
+			reg = <0xff900000 0x40000>;
+		};
+		io_dmc_base{
+			reg = <0xff638000 0x2000>;
+		};
+		io_efuse_base{
+			reg = <0xff630000 0x2000>;
+		};
+	};
+
+	vdec {
+		compatible = "amlogic, vdec";
+		dev_name = "vdec.0";
+		status = "okay";
+		interrupts = <0 3 1
+				0 23 1
+				0 32 1
+				0 43 1
+				0 44 1
+				0 45 1>;
+		interrupt-names = "vsync",
+				"demux",
+				"parser",
+				"mailbox_0",
+				"mailbox_1",
+				"mailbox_2";
+	};
+
+	amvenc_avc {
+		compatible = "amlogic, amvenc_avc";
+		dev_name = "amvenc_avc";
+		status = "okay";
+		interrupts = <0 45 1>;
+		interrupt-names = "mailbox_2";
+	};
+	
+	ge2d {
+		compatible = "amlogic, ge2d-g12a";
+		dev_name = "ge2d";
+		status = "okay";
+		interrupts = <GIC_SPI 146 IRQ_TYPE_EDGE_RISING>;
+		interrupt-names = "ge2d";
+		clocks = <&clkc CLKID_VAPB>,
+			<&clkc CLKID_G2D>,
+			<&clkc CLKID_VAPB>;
+		clock-names = "clk_vapb_0",
+			"clk_ge2d",
+			"clk_ge2d_gate";
+		reg = <0x0 0xff940000 0x0 0x10000>;
+		amlogic,canvas = <&canvas>;
+	};
+
+	galcore {
+		compatible = "amlogic, galcore";
+		dev_name = "galcore";
+		status = "okay";
+		clocks = <&clkc CLKID_NNA_AXI_CLK>,
+				<&clkc CLKID_NNA_CORE_CLK>;
+		clock-names = "cts_vipnanoq_axi_clk_composite",
+						"cts_vipnanoq_core_clk_composite";
+		interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "galcore";
+		reg = <0x0 0xff100000 0x0 0x800>,
+				<0x0 0xff000000 0x0 0x400000>,
+				<0x0 0xff63c10c 0x0 0x4>,
+				<0x0 0xff63c110 0x0 0x4>,
+				<0x0 0xffd01088 0x0 0x4>,
+				<0X0 0xff63c1c8 0X0 0x4>;
+		reg-names = "NN_REG","NN_SRAM","NN_MEM0",
+					"NN_MEM1","NN_RESET","NN_CLK";
+		nn_power_version = <2>;
+		nn_efuse = <0xff63003c 0x20>;
+
+		memory-region = <&galcore_reserved>;
+	};
+
+	cpu_iomap {
+		compatible = "amlogic, iomap";
+		#address-cells=<2>;
+		#size-cells=<2>;
+		ranges;
+		io_cbus_base {
+			reg = <0x0 0xffd00000 0x0 0x26000>;
+		};
+		io_apb_base {
+			reg = <0x0 0xffe01000 0x0 0x7f000>;
+		};
+		io_aobus_base {
+			reg = <0x0 0xff800000 0x0 0xb000>;
+		};
+		io_vapb_base {
+			reg = <0x0 0xff900000 0x0 0x50000>;
+		};
+		io_hiu_base {
+			reg = <0x0 0xff63c000 0x0 0x2000>;
+		};
+	};
+
+	aml_pm {
+		compatible = "amlogic, pm";
+		status = "okay";
+		device_name = "aml_pm";
+		debug_reg = <0xff8000a8>;
+		exit_reg = <0xff80023c>;
+	};
+
+	aml_reboot{
+		compatible = "amlogic, reboot";
+		sys_reset = <0x84000009>;
+		sys_poweroff = <0x84000008>;
+	};
+
+	bluetooth{
+		compatible = "amlogic, bt-dev";
+		dev_name = "bluetooth";
+		status = "okay";
+		gpio_en = <&gpio GPIOX_16 GPIO_ACTIVE_HIGH>;
+		gpio_hostwake = <&gpio GPIOX_19 GPIO_ACTIVE_HIGH>;
+	};
+
+	wifi{
+		compatible = "amlogic, wifi-dev";
+		dev_name = "wifi";
+		status = "okay";
+		power_on_pin = <&gpio_ao GPIOAO_5 GPIO_ACTIVE_HIGH>;
+	};
+
+	partitions: partitions{
+		parts = <14>;
+		part-0 = <&logo>;
+		part-1 = <&updater>;
+		part-2 = <&misc>;
+		part-3 = <&dto>;
+		part-4 = <&cri_data>;
+		part-5 = <&param>;
+		part-6 = <&boot>;
+		part-7 = <&rsv>;
+		part-8 = <&tee>;
+		part-9 = <&vendor>;
+		part-10 = <&odm>;
+		part-11 = <&system>;
+		part-12 = <&cache>;
+		part-13 = <&data>;
+
+		logo:logo{
+			pname = "logo";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+
+		updater:updater{
+			pname = "updater";
+			size = <0x0 0x1800000>;
+			mask = <1>;
+		};
+
+		misc:misc{
+			pname = "misc";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+
+		dto:dto{
+			pname = "dto";
+			size = <0x0 0x800000>;
+			mask = <1>;
+		};
+
+		cri_data:cri_data{
+			pname = "cri_data";
+			size = <0x0 0x800000>;
+			mask = <2>;
+		};
+
+		rsv:rsv{
+			pname = "rsv";
+			size = <0x0 0x1000000>;
+			mask = <1>;
+		};
+
+		param:param{
+			pname = "param";
+			size = <0x0 0x1000000>;
+			mask = <2>;
+		};
+
+		boot:boot{
+			pname = "boot";
+			size = <0x0 0x1000000>;
+			mask = <1>;
+		};
+
+		tee:tee{
+			pname = "tee";
+			size = <0x0 0x2000000>;
+			mask = <1>;
+		};
+
+		vendor:vendor{
+			pname = "vendor";
+			size = <0x0 0x20000000>;
+			mask = <1>;
+		};
+
+		odm:odm{
+			pname = "odm";
+			size = <0x0 0x10000000>;
+			mask = <1>;
+		};
+
+		system:system{
+			pname = "system";
+			size = <0x2 0x00000000>;
+			mask = <2>;
+		};
+
+		cache:cache{
+			pname = "cache";
+			size = <0x0 0x40000000>;
+			mask = <2>;
+		};
+
+		data:data{
+			pname = "data";
+			size = <0xffffffff 0xffffffff>;
+			mask = <4>;
+		};
+	};
+
+	unifykey{
+		compatible = "amlogic, unifykey";
+		status = "ok";
+		unifykey-num = <17>;
+		unifykey-index-0 = <&keysn_0>;
+		unifykey-index-1 = <&keysn_1>;
+		unifykey-index-2 = <&keysn_2>;
+		unifykey-index-3 = <&keysn_3>;
+		unifykey-index-4 = <&keysn_4>;
+		unifykey-index-5 = <&keysn_5>;
+		unifykey-index-6 = <&keysn_6>;
+		unifykey-index-7 = <&keysn_7>;
+		unifykey-index-8 = <&keysn_8>;
+		unifykey-index-9 = <&keysn_9>;
+		unifykey-index-10= <&keysn_10>;
+		unifykey-index-11= <&keysn_11>;
+		unifykey-index-12= <&keysn_12>;
+		unifykey-index-13= <&keysn_13>;
+		unifykey-index-14= <&keysn_14>;
+		unifykey-index-15= <&keysn_15>;
+		unifykey-index-16= <&keysn_16>;
+
+		keysn_0: key_0{
+			key-name = "usid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_1:key_1{
+			key-name = "mac";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_2:key_2{
+			key-name = "hdcp";
+			key-device = "secure";
+			key-type = "sha1";
+			key-permit = "read","write","del";
+		};
+		keysn_3:key_3{
+			key-name = "secure_boot_set";
+			key-device = "efuse";
+			key-permit = "write";
+		};
+		keysn_4:key_4{
+			key-name = "mac_bt";
+			key-device = "normal";
+			key-permit = "read","write","del";
+			key-type	= "mac";
+		};
+		keysn_5:key_5{
+			key-name = "mac_wifi";
+			key-device = "normal";
+			key-permit = "read","write","del";
+			key-type = "mac";
+		};
+		keysn_6:key_6{
+			key-name = "hdcp2_tx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_7:key_7{
+			key-name = "hdcp2_rx";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_8:key_8{
+			key-name = "widevinekeybox";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_9:key_9{
+			key-name = "deviceid";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+		keysn_10:key_10{
+			key-name = "hdcp22_fw_private";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_11:key_11{
+			key-name = "PlayReadykeybox25";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_12:key_12{
+			key-name = "prpubkeybox";// PlayReady
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_13:key_13{
+			key-name = "prprivkeybox";// PlayReady
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_14:key_14{
+			key-name = "netflix_mgkid";
+			key-device = "secure";
+			key-permit = "read","write","del";
+		};
+		keysn_15:key_15{
+				key-name = "eth_exphy_para";
+				key-device = "normal";
+				key-permit = "read","write","del";
+		};
+		keysn_16:key_16{
+			key-name = "um_factory_para";
+			key-device = "normal";
+			key-permit = "read","write","del";
+		};
+	};//End unifykey
+
+	sensor: sensor {
+			compatible = "soc, sensor";
+			status = "okay";
+			sensor-name = "imx219"; /*ov5647,imx290;os08a10;imx227;imx307;imx219*/
+			pinctrl-names="default";
+			clocks = <&clkc CLKID_24M>;
+			clock-names = "g12a_24m";
+	};
+
+	iq: iq {
+			compatible = "soc, iq";
+			status = "okay";
+			sensor-name = "imx219"; /*ov5647,imx290;os08a10;imx227;imx307;imx219*/
+	};
+};
+
+&isp {
+	status = "okay";
+	temper-line-offset = <0x1680>;
+	temper-buf-size = <12>;
+	temper-frame-num = <1>;
+	temper-frame-size = <0xBDD800>;
+	memory-region = <&isp_cma_reserved>;
+};
+
+&adapter {
+	status = "okay";
+	memory-region = <&adapt_cma_reserved>;
+};
diff -Naur a/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-unionpi-tiger.dtsi b/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-unionpi-tiger.dtsi
--- a/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-unionpi-tiger.dtsi	1970-01-01 08:00:00.000000000 +0800
+++ b/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12b-unionpi-tiger.dtsi	2022-05-31 11:56:47.693259679 +0800
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (c) 2019 Christian Hewitt <christianshewitt@gmail.com>
+ */
+
+/ {
+	vddcpu_a: regulator-vddcpu-a {
+		compatible = "pwm-regulator";
+
+		regulator-name = "VDDCPU_A";
+		regulator-min-microvolt = <721000>;
+		regulator-max-microvolt = <1022000>;
+		regulator-ramp-delay = <10>;
+
+		vin-supply = <&dc_in>;
+
+		pwms = <&pwm_ab 0 1250 0>;
+		pwm-dutycycle-range = <100 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vddcpu_b: regulator-vddcpu-b {
+		compatible = "pwm-regulator";
+
+		regulator-name = "VDDCPU_B";
+		regulator-min-microvolt = <721000>;
+		regulator-max-microvolt = <1022000>;
+		regulator-ramp-delay = <10>;
+
+		vin-supply = <&dc_in>;
+
+		pwms = <&pwm_AO_cd 1 1250 0>;
+		pwm-dutycycle-range = <100 0>;
+
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&vddcpu_b>;
+	operating-points-v2 = <&cpu_opp_table_0>;
+	clocks = <&clkc CLKID_CPU_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu1 {
+	cpu-supply = <&vddcpu_b>;
+	operating-points-v2 = <&cpu_opp_table_0>;
+	clocks = <&clkc CLKID_CPU_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu100 {
+	cpu-supply = <&vddcpu_a>;
+	operating-points-v2 = <&cpub_opp_table_1>;
+	clocks = <&clkc CLKID_CPUB_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu101 {
+	cpu-supply = <&vddcpu_a>;
+	operating-points-v2 = <&cpub_opp_table_1>;
+	clocks = <&clkc CLKID_CPUB_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu102 {
+	cpu-supply = <&vddcpu_a>;
+	operating-points-v2 = <&cpub_opp_table_1>;
+	clocks = <&clkc CLKID_CPUB_CLK>;
+	clock-latency = <50000>;
+};
+
+&cpu103 {
+	cpu-supply = <&vddcpu_a>;
+	operating-points-v2 = <&cpub_opp_table_1>;
+	clocks = <&clkc CLKID_CPUB_CLK>;
+	clock-latency = <50000>;
+};
+
+&pwm_ab {
+	pinctrl-0 = <&pwm_a_e_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin0";
+	status = "okay";
+};
+
+&pwm_AO_cd {
+	pinctrl-0 = <&pwm_ao_c_6_pins>, <&pwm_ao_d_e_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin1";
+	status = "okay";
+};
+
diff -Naur a/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12-common.dtsi b/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12-common.dtsi
--- a/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12-common.dtsi	2022-05-27 17:20:14.013880643 +0800
+++ b/scripts/dtc/include-prefixes/arm64/amlogic/meson-g12-common.dtsi	2022-06-18 13:48:23.734525427 +0800
@@ -17,6 +17,12 @@
 	#address-cells = <2>;
 	#size-cells = <2>;
 
+	aliases {
+		mmc0 = &sd_emmc_c; /* eMMC */
+		mmc1 = &sd_emmc_b; /* SD card */
+		mmc2 = &sd_emmc_a; /* SDIO */
+	};
+
 	chosen {
 		#address-cells = <2>;
 		#size-cells = <2>;
@@ -43,6 +49,10 @@
 		};
 	};
 
+	system-suspend {
+		compatible = "amlogic,meson-gx-pm";
+	};
+
 	efuse: efuse {
 		compatible = "amlogic,meson-gxbb-efuse";
 		clocks = <&clkc CLKID_EFUSE>;
@@ -55,10 +65,6 @@
 	gpu_opp_table: gpu-opp-table {
 		compatible = "operating-points-v2";
 
-		opp-124999998 {
-			opp-hz = /bits/ 64 <124999998>;
-			opp-microvolt = <800000>;
-		};
 		opp-249999996 {
 			opp-hz = /bits/ 64 <249999996>;
 			opp-microvolt = <800000>;
@@ -96,15 +102,19 @@
 		ranges;
 
 		/* 3 MiB reserved for ARM Trusted Firmware (BL31) */
-		secmon_reserved: secmon@5000000 {
-			reg = <0x0 0x05000000 0x0 0x300000>;
-			no-map;
+		secmon_reserved:linux,secmon {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 0x3400000>;
+			alignment = <0x0 0x400000>;
+			alloc-ranges = <0x0 0x05000000 0x0 0x3400000>;
+			clear-map;
 		};
 
 		linux,cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0x0 0x10000000>;
+			size = <0x0 0x38000000>;
 			alignment = <0x0 0x400000>;
 			linux,cma-default;
 		};
@@ -113,6 +123,16 @@
 	sm: secure-monitor {
 		compatible = "amlogic,meson-gxbb-sm";
 	};
+	
+	secmon {
+		compatible = "amlogic, secmon";
+		memory-region = <&secmon_reserved>;
+		in_base_func = <0x82000020>;
+		out_base_func = <0x82000021>;
+		inout_size_func = <0x8200002a>;
+		reserve_mem_size = <0x00300000>;
+		clear_range = <0x05100000 0x200000>;
+	};
 
 	soc {
 		compatible = "simple-bus";
@@ -224,6 +244,8 @@
 				      "timing-adjustment";
 			rx-fifo-depth = <4096>;
 			tx-fifo-depth = <2048>;
+			resets = <&reset RESET_ETHERNET>;
+			reset-names = "stmmaceth";
 			status = "disabled";
 
 			mdio0: mdio {
@@ -1681,12 +1703,31 @@
 								       <666666666>,
 								       <0>, /* Do Nothing */
 								       <0>, /* Do Nothing */
-								       <250000000>,
+								       <500000000>,
 								       <0>; /* Do Nothing */
 					};
+
+					mipi_analog_dphy: phy {
+						compatible = "amlogic,g12a-mipi-dphy-analog";
+						#phy-cells = <0>;
+						status = "disabled";
+					};
 				};
 			};
 
+			mipi_dphy: phy@44000 {
+				compatible = "amlogic,axg-mipi-dphy";
+				reg = <0x0 0x44000 0x0 0x2000>;
+				clocks = <&clkc CLKID_MIPI_DSI_PHY>;
+				clock-names = "pclk";
+				resets = <&reset RESET_MIPI_DSI_PHY>;
+				reset-names = "phy";
+				phys = <&mipi_analog_dphy>;
+				phy-names = "analog";
+				#phy-cells = <0>;
+				status = "disabled";
+			};
+
 			usb3_pcie_phy: phy@46000 {
 				compatible = "amlogic,g12a-usb3-pcie-phy";
 				reg = <0x0 0x46000 0x0 0x2000>;
@@ -1930,6 +1971,33 @@
 						};
 					};
 
+					uart_ao_b_1_pins: uart-ao-b-1 {
+						mux {
+							groups = "uart_ao_b_tx_2",
+								 "uart_ao_b_rx_3";
+							function = "uart_ao_b";
+							bias-disable;
+						};
+					};
+
+					uart_ao_b_2_pins: uart-ao-b-2 {
+						mux {
+							groups = "uart_ao_b_tx_8",
+								 "uart_ao_b_rx_9";
+							function = "uart_ao_b";
+							bias-disable;
+						};
+					};
+
+					uart_ao_b_cts_rts_pins: uart-ao-b-cts-rts {
+						mux {
+							groups = "uart_ao_b_cts",
+								 "uart_ao_b_rts";
+							function = "uart_ao_b";
+							bias-disable;
+						};
+					};
+
 					pwm_a_e_pins: pwm-a-e {
 						mux {
 							groups = "pwm_a_e";
@@ -2003,7 +2071,7 @@
 				};
 			};
 
-			vrtc: rtc@0a8 {
+			vrtc: rtc@a8 {
 				compatible = "amlogic,meson-vrtc";
 				reg = <0x0 0x000a8 0x0 0x4>;
 			};
@@ -2144,6 +2212,15 @@
 					remote-endpoint = <&hdmi_tx_in>;
 				};
 			};
+
+			/* DPI output port */
+			dpi_port: port@2 {
+				reg = <2>;
+
+				dpi_out: endpoint {
+					remote-endpoint = <&mipi_dsi_in>;
+				};
+			};
 		};
 
 		gic: interrupt-controller@ffc01000 {
@@ -2181,6 +2258,49 @@
 				amlogic,channel-interrupts = <64 65 66 67 68 69 70 71>;
 			};
 
+			mipi_dsi: mipi-dsi@7000 {
+				compatible = "amlogic,meson-g12a-dw-mipi-dsi";
+				reg = <0x0 0x7000 0x0 0x1000>;
+				resets = <&reset RESET_MIPI_DSI_HOST>;
+				reset-names = "top";
+				clocks = <&clkc CLKID_MIPI_DSI_HOST>,
+					 <&clkc CLKID_MIPI_DSI_PXCLK>;
+				clock-names = "pclk", "px_clk";
+				phys = <&mipi_dphy>;
+				phy-names = "dphy";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				status = "disabled";
+
+				assigned-clocks = <&clkc CLKID_MIPI_DSI_PXCLK_SEL>;
+				assigned-clock-parents = <&clkc CLKID_GP0_PLL>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					/* VPU VENC Input */
+					mipi_dsi_venc_port: port@0 {
+						reg = <0>;
+
+						mipi_dsi_in: endpoint {
+							remote-endpoint = <&dpi_out>;
+						};
+					};
+
+					/* DSI Output */
+					mipi_dsi_panel_port: port@1 {
+						reg = <1>;
+					};
+				};
+			};
+
+			watchdog: wdt@f0d0 {
+				compatible = "amlogic,meson-gxbb-wdt";
+				reg = <0x0 0xf0d0 0x0 0x10>;
+				clocks = <&xtal>;
+			};
+
 			spicc0: spi@13000 {
 				compatible = "amlogic,meson-g12a-spicc";
 				reg = <0x0 0x13000 0x0 0x44>;
@@ -2305,6 +2425,7 @@
 				clocks = <&xtal>, <&clkc CLKID_UART0>, <&xtal>;
 				clock-names = "xtal", "pclk", "baud";
 				status = "disabled";
+				fifo-size = <128>;
 			};
 		};
 
@@ -2400,6 +2521,62 @@
 			operating-points-v2 = <&gpu_opp_table>;
 			#cooling-cells = <2>;
 		};
+
+        isp_sc: isp-sc@ff655400 {
+                compatible = "amlogic, isp-sc";
+                reg = <0x0 0xff655400 0x0 0x00001000>;
+                reg-names = "isp_sc";
+                interrupts = <0 17 IRQ_TYPE_EDGE_RISING>;
+                interrupt-names = "isp_sc";
+        };
+
+        isp: isp@ff140000 {
+                compatible = "arm, isp";
+                reg = <0x0 0xff140000 0x0 0x00040000>;
+                reg-names = "ISP";
+                isp-efuse = <0xff630038 0x4000>;
+                interrupts = <0 142 4>;
+                interrupt-names = "ISP";
+                temper-buf-size = <24>;
+                clocks = <&clkc CLKID_MIPI_ISP_CLK_COMP>,
+                        <&clkc CLKID_MIPI_CSI_PHY_CLK0_COMP>;
+                clock-names = "cts_mipi_isp_clk_composite",
+                        "cts_mipi_csi_phy_clk0_composite";
+                link-device = <&isp_sc>;
+        };
+		
+		adapter: isp-adapter@ff650000 {
+			compatible = "amlogic, isp-adapter";
+			reg = <0x0 0xff650000 0x0 0x00006000>;
+			reg-names = "adapter";
+			interrupts = <0 179 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "adapter-irq";
+			mem_alloc = <48>;
+		};
+
+		phycsi: phy-csi@ff650000 {
+			compatible = "amlogic, phy-csi";
+			reg = <0x0 0xff650000 0x0 0x00002000>,
+					<0x0 0xff652000 0x0 0x00002000>,
+					<0x0 0xff63c300 0x0 0x00000100>,
+					<0x0 0xff654000 0x0 0x00000100>,
+					<0x0 0xff654400 0x0 0x00000100>;
+			reg-names = "csi2_phy0", "csi2_phy1", "aphy_reg",
+					"csi0_host", "csi1_host";
+			interrupts = <0 41 IRQ_TYPE_EDGE_RISING>,
+					<0 42 IRQ_TYPE_EDGE_RISING>,
+					<0 72 IRQ_TYPE_EDGE_RISING>,
+					<0 74 IRQ_TYPE_EDGE_RISING>,
+					<0 87 IRQ_TYPE_EDGE_RISING>,
+					<0 88 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "phy0-irq",
+					"phy1-irq",
+					"csi-host0-intr2",
+					"csi-host0-intr1",
+					"csi-host1-intr2",
+					"csi-host1-intr1";
+			link-device = <&adapter>;
+		};
 	};
 
 	timer {
@@ -2422,4 +2599,10 @@
 		#clock-cells = <0>;
 	};
 
+	osc8M: osc8M {
+		compatible = "fixed-clock";
+		clock-output-names = "osc8M";
+		clock-frequency = <8000000>;
+		#clock-cells = <0>;
+	};
 };
diff -Naur a/scripts/dtc/include-prefixes/arm64/amlogic/meson-unionpi-tiger.dtsi b/scripts/dtc/include-prefixes/arm64/amlogic/meson-unionpi-tiger.dtsi
--- a/scripts/dtc/include-prefixes/arm64/amlogic/meson-unionpi-tiger.dtsi	1970-01-01 08:00:00.000000000 +0800
+++ b/scripts/dtc/include-prefixes/arm64/amlogic/meson-unionpi-tiger.dtsi	2022-06-04 12:16:05.318220487 +0800
@@ -0,0 +1,805 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 BayLibre, SAS
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ * Copyright (c) 2019 Christian Hewitt <christianshewitt@gmail.com>
+ */
+
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/gpio/meson-g12a-gpio.h>
+#include <dt-bindings/sound/meson-g12a-toacodec.h>
+#include <dt-bindings/sound/meson-g12a-tohdmitx.h>
+#include <dt-bindings/clock/g12a-clkc.h>
+#include <dt-bindings/reset/amlogic,meson-g12a-reset.h>
+#include <dt-bindings/clock/axg-audio-clkc.h>
+
+/ {
+	aliases {
+		serial0 = &uart_AO;
+		serial1 = &uart_AO_B;
+		serial2 = &uart_A;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c2 = &i2c2;
+		i2c3 = &i2c3;
+		i2c4 = &i2c_AO;
+		ethernet0 = &ethmac;
+		rtc0 = &rtc;
+		rtc1 = &vrtc;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x0 0x0 0xf0000000>;
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <100>;
+
+		power-button {
+			label = "power";
+			linux,code = <KEY_POWER>;
+			gpios = <&gpio GPIOC_7 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		/* USB-OTG Switch GPIO */
+		usb-switch {
+			label = "usb_switch";
+			gpios = <&gpio GPIOX_7 GPIO_ACTIVE_LOW>;
+			default-state = "on";
+		};
+	};
+
+	emmc_pwrseq: emmc-pwrseq {
+		compatible = "mmc-pwrseq-emmc";
+		reset-gpios = <&gpio BOOT_12 GPIO_ACTIVE_LOW>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpio GPIOX_6 GPIO_ACTIVE_LOW>;
+	};
+
+	dc_in: regulator-dc_in {
+		compatible = "regulator-fixed";
+		regulator-name = "DC_IN";
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+		regulator-always-on;
+	};
+
+	vcc_5v: regulator-vcc_5v {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC_5V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_in>;
+
+		/* SY8113B */
+		gpio = <&gpio GPIOH_8 GPIO_OPEN_DRAIN>;
+		enable-active-high;
+	};
+
+	vsys_3v3: regulator-vsys_3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VSYS_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dc_in>;
+		regulator-always-on;
+	};
+
+	usb_pwr_en: regulator-usb-pwr-en {
+		compatible = "regulator-fixed";
+		regulator-name = "USB_PWR_EN";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc_5v>;
+		enable-active-high;
+	};
+
+	usb1_pow: regulator-usb1-pow {
+		compatible = "regulator-fixed";
+		regulator-name = "USB1_POW";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc_5v>;
+		enable-active-high;
+	};
+
+	vddao_3v3: regulator-vddao-3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDAO_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dc_in>;
+		regulator-always-on;
+	};
+
+	vddao_1v8: regulator-vddao_1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDAO_1V8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vddao_3v3>;
+		regulator-always-on;
+	};
+
+	usb_pwr: regulator-usb_pwr {
+		compatible = "regulator-fixed";
+		regulator-name = "USB_PWR";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc_5v>;
+		enable-active-high;
+	};
+
+	hdmi-connector {
+		compatible = "hdmi-connector";
+		type = "a";
+		status = "okay";
+
+		port {
+			hdmi_connector_in: endpoint {
+				remote-endpoint = <&hdmi_tx_tmds_out>;
+			};
+		};
+	};
+
+	spdif_dit: audio-codec-1 {
+		#sound-dai-cells = <0>;
+		compatible = "linux,spdif-dit";
+		status = "okay";
+		sound-name-prefix = "DIT";
+	};
+
+	sound {
+		compatible = "amlogic,axg-sound-card";
+		model = "UNIONPI-TIGER";
+		audio-widgets = "Line", "Lineout",
+				"Line", "Linein";
+		audio-aux-devs = <&tdmout_b>, <&tdmout_c>, 
+				<&tdmin_a>, <&tdmin_b>, <&tdmin_c>, <&tdmin_lb>;
+		audio-routing = "TDMOUT_B IN 0", "FRDDR_A OUT 1",
+				"TDMOUT_B IN 1", "FRDDR_B OUT 1",
+				"TDMOUT_B IN 2", "FRDDR_C OUT 1",
+				"TDM_B Playback", "TDMOUT_B OUT",
+				"TDMOUT_C IN 0", "FRDDR_A OUT 2",
+				"TDMOUT_C IN 1", "FRDDR_B OUT 2",
+				"TDMOUT_C IN 2", "FRDDR_C OUT 2",
+				"TDM_C Playback", "TDMOUT_C OUT",
+				/* for audio capture */
+				"TDMIN_A IN 1", "TDM_B Capture",
+				"TDMIN_B IN 1", "TDM_B Capture",
+				"TDMIN_C IN 1", "TDM_B Capture",
+				"TDMIN_A IN 2", "TDM_C Capture",
+				"TDMIN_B IN 2", "TDM_C Capture",
+				"TDMIN_C IN 2", "TDM_C Capture",
+				"TDMIN_A IN 4", "TDM_B Loopback",
+				"TDMIN_B IN 4", "TDM_B Loopback",
+				"TDMIN_C IN 4", "TDM_B Loopback",
+				"TDMIN_A IN 5", "TDM_C Loopback",
+				"TDMIN_B IN 5", "TDM_C Loopback",
+				"TDMIN_C IN 5", "TDM_C Loopback",
+				"TDMIN_LB IN 1", "TDM_B Capture",
+				"TDMIN_LB IN 2", "TDM_C Capture",
+				"TDMIN_LB IN 4", "TDM_B Loopback",
+				"TDMIN_LB IN 5", "TDM_C Loopback",
+				/* tdmin -> toddr */
+				"TODDR_A IN 0", "TDMIN_A OUT",
+				"TODDR_B IN 0", "TDMIN_A OUT",
+				"TODDR_C IN 0", "TDMIN_A OUT",
+				"TODDR_A IN 1", "TDMIN_B OUT",
+				"TODDR_B IN 1", "TDMIN_B OUT",
+				"TODDR_C IN 1", "TDMIN_B OUT",
+				"TODDR_A IN 2", "TDMIN_C OUT",
+				"TODDR_B IN 2", "TDMIN_C OUT",
+				"TODDR_C IN 2", "TDMIN_C OUT",
+				"TODDR_A IN 6", "TDMIN_LB OUT",
+				"TODDR_B IN 6", "TDMIN_LB OUT",
+				"TODDR_C IN 6", "TDMIN_LB OUT",
+				"Linein MIC1", "Linein",
+				"TDM_B Capture", "Linein AIFTX";
+
+		assigned-clocks = <&clkc CLKID_MPLL2>,
+					<&clkc CLKID_MPLL0>,
+					<&clkc CLKID_MPLL1>;
+		assigned-clock-parents = <0>, <0>, <0>;
+		assigned-clock-rates = <294912000>,
+					 	<270950400>,
+					 	<393216000>;
+		status = "okay";
+
+		dai-link-0 {
+			sound-dai = <&frddr_a>;
+		};
+
+		dai-link-1 {
+			sound-dai = <&frddr_b>;
+		};
+
+		dai-link-2 {
+			sound-dai = <&frddr_c>;
+		};
+
+		dai-link-3 {
+			sound-dai = <&toddr_a>;
+		};
+
+		dai-link-4 {
+			sound-dai = <&toddr_b>;
+		};
+
+		dai-link-5 {
+			sound-dai = <&toddr_c>;
+		};
+
+		/* 8ch hdmi interface */
+		dai-link-6 {
+			sound-dai = <&tdmif_b>;
+			dai-format = "i2s";
+			dai-tdm-slot-tx-mask-0 = <1 1>;
+			dai-tdm-slot-rx-mask-1 = <1 1>;
+			dai-tdm-slot-tx-mask-2 = <1 1>;
+			dai-tdm-slot-tx-mask-3 = <1 1>;
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&tohdmitx TOHDMITX_I2S_IN_B>;
+			};
+			
+			codec-1 {
+				sound-dai = <&toacodec TOACODEC_IN_B>;
+			};
+			
+			/* audio capture */
+			codec-2 {
+				sound-dai = <&nau8540>;
+			};
+		};
+
+		/* i2s jack output interface */
+		dai-link-7 {
+			sound-dai = <&tdmif_c>;
+			dai-format = "i2s";
+			dai-tdm-slot-tx-mask-0 = <1 1>;
+			mclk-fs = <256>;
+
+			codec-0 {
+				sound-dai = <&tohdmitx TOHDMITX_I2S_IN_C>;
+			};
+
+			codec-1 {
+				sound-dai = <&toacodec TOACODEC_IN_C>;
+			};
+		};
+		
+		/* hdmi glue */
+		dai-link-8 {
+			sound-dai = <&tohdmitx TOHDMITX_I2S_OUT>;
+
+			codec {
+				sound-dai = <&hdmi_tx>;
+			};
+		};
+
+		/* acodec glue */
+		dai-link-9 {
+			sound-dai = <&toacodec TOACODEC_OUT>;
+
+			codec {
+				sound-dai = <&acodec>;
+			};
+		};
+	};
+};
+
+&pdm {
+	status = "okay";
+};
+
+&acodec {
+	AVDD-supply = <&vddao_1v8>;
+	status = "okay";
+};
+
+&arb {
+	status = "okay";
+};
+
+&clkc_audio {
+	status = "okay";
+};
+
+&cec_AO {
+	pinctrl-0 = <&cec_ao_a_h_pins>;
+	pinctrl-names = "default";
+	status = "disabled";
+	hdmi-phandle = <&hdmi_tx>;
+};
+
+&cecb_AO {
+	pinctrl-0 = <&cec_ao_b_h_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+	hdmi-phandle = <&hdmi_tx>;
+};
+
+&ext_mdio {
+	external_phy: ethernet-phy@0 {
+		/* Realtek RTL8211F (0x001cc916) */
+		reg = <0>;
+		max-speed = <1000>;
+		reset-assert-us = <10000>;
+		reset-deassert-us = <80000>;
+		reset-gpios = <&gpio GPIOZ_15 (GPIO_ACTIVE_LOW | GPIO_OPEN_DRAIN)>;
+
+		interrupt-parent = <&gpio_intc>;
+		/* MAC_INTR on GPIOZ_14 */
+		interrupts = <26 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&ethmac {
+				pinctrl-0 = <&eth_pins>, <&eth_rgmii_pins>;
+				pinctrl-names = "default";
+				status = "okay";
+				phy-mode = "rgmii";
+				phy-handle = <&external_phy>;
+				amlogic,tx-delay-ns = <2>;
+};
+
+&frddr_a {
+	status = "okay";
+};
+
+&frddr_b {
+	status = "okay";
+};
+
+&frddr_c {
+	status = "okay";
+};
+
+&hdmi_tx {
+	status = "okay";
+	pinctrl-0 = <&hdmitx_hpd_pins>, <&hdmitx_ddc_pins>;
+	pinctrl-names = "default";
+	hdmi-supply = <&vcc_5v>;
+};
+
+&hdmi_tx_tmds_port {
+	hdmi_tx_tmds_out: endpoint {
+		remote-endpoint = <&hdmi_connector_in>;
+	};
+};
+
+&mipi_dsi {
+	status = "okay";
+	
+	assigned-clocks = <&clkc CLKID_GP0_PLL>,
+			  <&clkc CLKID_MIPI_DSI_PXCLK_SEL>,
+			  <&clkc CLKID_MIPI_DSI_PXCLK>;
+	assigned-clock-parents = <0>,
+				 <&clkc CLKID_GP0_PLL>,
+				 <0>;
+	assigned-clock-rates = <720000000>,
+			       <0>,
+			       <720000000>;
+
+	panel@0 {
+		status = "okay";
+		compatible = "chipone,icn6211";
+		power-supply = <&vddao_3v3>;
+		/*compatible = "waveshare,tl070hdv03ct";
+		power-supply = <&vcc_5v>;*/
+		reg = <0>;
+
+		port {
+			dsi_in_panel: endpoint {
+				remote-endpoint = <&dsi_out_panel>;
+			};
+		};
+	};
+};
+
+&mipi_analog_dphy {
+	status = "okay";
+};
+
+&mipi_dphy {
+	status = "okay";
+};
+
+&mipi_dsi_panel_port {
+	dsi_out_panel: endpoint {
+		remote-endpoint = <&dsi_in_panel>;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2_sck_x_pins>, <&i2c2_sda_x_pins>;
+	clock-frequency = <100000>; /* default 100k */
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names="default";
+	pinctrl-0 = <&i2c3_sck_a_pins>, <&i2c3_sda_a_pins>;
+	clock-frequency = <100000>; /* default 100k */
+
+	i2cmux@71 {
+		compatible = "nxp,pca9546";
+		reg = <0x71>;
+		status = "okay";
+		pinctrl-names = "default";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/*i2c and gpio_extension*/
+		i2c3a: i2c3@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0>;
+				status = "okay";
+		};
+
+		i2c3b: i2c3@1 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <1>;
+				status = "okay";
+		};
+
+		i2c3c: i2c3@2 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <2>;
+
+				pca9575b: gpio@21 {
+						compatible = "nxp,pca9575";
+						reg = <0x21>;
+						gpio-controller;
+						#gpio-cells = <0x02>;
+						status = "okay";
+						gpio-line-names = "WAKEUP_OUT", "PWR_ON_N", "WAKEUP_IN", "W_DISABLE_N",
+												"PMU_RSTIN_N", "9342_RST", "SEN-SYNC1", "", "MUTE",
+												"WIFI_LED", "CM_GPIO_1", "", "AMP_PWRDN", "POWER_LED",
+												"GPIO_18", "GPIO_17";
+				};
+
+				pca9575a: gpio@23 {
+						compatible = "nxp,pca9575";
+						reg = <0x23>;
+						gpio-controller;
+						#gpio-cells = <0x02>;
+						status = "okay";
+						gpio-line-names = "GPIO_01", "GPIO_02", "GPIO_03", "GPIO_04",
+												"GPIO_05", "GPIO_06", "GPIO_07", "GPIO_08", "GPIO_09",
+												"GPIO_10", "GPIO_11", "GPIO_12", "GPIO_13", "GPIO_14",
+												"GPIO_15", "GPIO_16";
+				};
+
+				es7243: es7243@11 {
+					compatible = "everest,es7243";
+					#sound-dai-cells = <0>;
+					reg = <0x11>;
+					status = "okay";
+				};
+
+				nau8540: nau8540@1c {
+						compatible = "nuvoton,nau8540";
+						#sound-dai-cells = <0>;
+						reg = <0x1c>;
+						sound-name-prefix = "Linein";
+						status = "okay";
+				};
+
+				tlv320dac3101: tlv320dac3101@18 {
+						compatible = "ti,tlv320dac3101";
+						#sound-dai-cells = <0>;
+						reg = <0x18>;
+						slot_number = <3>;
+						differential_pair = <1>;
+						status = "okay";
+				};
+
+				ft5406: ft5406@38 {
+						compatible = "edt,edt-ft5406";
+						reg = <0x38>;
+						touchscreen-size-x = < 800 >;
+						touchscreen-size-y = < 480 >;
+						touchscreen-inverted-x = < 1 >;
+						touchscreen-inverted-y = < 1 >;
+						status = "okay";
+				};
+
+				icn6211: icn6211@45 {
+						compatible = "chipone,icn6211-i2c";
+						status = "okay";
+						reg = <0x45>;
+				};
+
+				sensor-i2c@6c {
+					compatible = "arm, i2c-sensor";
+					reg = <0x6c>;
+					reg-names = "i2c-sensor";
+					slave-addr = <0x6c>;
+					reg-type = <2>;
+					reg-data-type = <1>;
+					link-device = <&phycsi>;
+				};
+		};
+
+		/*icm-20948*/
+		i2c3d: i2c3@3 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <3>;
+				status = "okay";
+		};
+	};
+};
+
+&i2c_AO {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c_ao_sck_pins>, <&i2c_ao_sda_pins>;
+	clock-frequency = <400000>;
+
+	rtc: rtc@51 {
+		compatible = "nxp,pcf8563";
+		reg = <0x51>;
+		status = "okay";
+		wakeup-source;
+	};
+};
+
+&pwm_ab {
+	status = "okay";
+};
+
+&pwm_AO_ab {
+	status = "okay";
+	pinctrl-0 = <&pwm_ao_a_pins>;
+	pinctrl-names = "default";
+	clocks = <&xtal>;
+	clock-names = "clkin0";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vddao_1v8>;
+};
+
+/* eMMC */
+&sd_emmc_c {
+	status = "okay";
+	compatible = "amlogic,meson-axg-mmc";
+	pinctrl-0 = <&emmc_ctrl_pins>, <&emmc_data_8b_pins>, <&emmc_ds_pins>;
+	pinctrl-1 = <&emmc_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <8>;
+	cap-mmc-highspeed;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	max-frequency = <200000000>;
+	disable-wp;
+
+	mmc-pwrseq = <&emmc_pwrseq>;
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&vddao_1v8>;
+};
+
+/* SD card */
+&sd_emmc_b {
+	status = "okay";
+	compatible = "amlogic,meson-axg-mmc";
+	pinctrl-0 = <&sdcard_c_pins>;
+	pinctrl-1 = <&sdcard_clk_gate_c_pins>;
+	pinctrl-names = "default", "clk-gate";
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	max-frequency = <50000000>;
+	disable-wp;
+
+	cd-gpios = <&gpio GPIOC_6 GPIO_ACTIVE_LOW>;
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&vddao_3v3>;
+};
+
+/* SDIO */
+&sd_emmc_a {
+	status = "okay";
+	pinctrl-0 = <&sdio_pins>;
+	pinctrl-1 = <&sdio_clk_gate_pins>;
+	pinctrl-names = "default", "clk-gate";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	bus-width = <4>;
+	cap-sd-highspeed;
+	sd-uhs-sdr104;
+	max-frequency = <167000000>;
+
+	non-removable;
+	disable-wp;
+
+	/* WiFi firmware requires power to be kept while in suspend */
+	keep-power-in-suspend;
+
+	mmc-pwrseq = <&sdio_pwrseq>;
+
+	vmmc-supply = <&vddao_3v3>;
+	vqmmc-supply = <&vddao_1v8>;
+};
+
+&tdmif_a {
+	status = "okay";
+};
+
+&tdmif_b {
+	pinctrl-0 = <&tdm_b_sclk_pins>, <&tdm_b_fs_pins>,
+				<&tdm_b_din0_pins>, <&tdm_b_din1_pins>, <&mclk0_a_pins>;
+	pinctrl-names = "default";
+	
+	assigned-clocks = <&clkc_audio AUD_CLKID_TDM_MCLK_PAD0>,
+						<&clkc_audio AUD_CLKID_TDM_SCLK_PAD1>,
+						<&clkc_audio AUD_CLKID_TDM_LRCLK_PAD1>;
+	assigned-clock-parents = <&clkc_audio AUD_CLKID_MST_B_MCLK>,
+						<&clkc_audio AUD_CLKID_MST_B_SCLK>,
+						<&clkc_audio AUD_CLKID_MST_B_LRCLK>;
+	assigned-clock-rates = <0>, <0>, <0>;
+
+	status = "okay";
+};
+
+&tdmif_c {
+	status = "okay";
+};
+
+&tdmin_a {
+	status = "okay";
+};
+
+&tdmin_b {
+	status = "okay";
+};
+
+&tdmin_lb {
+	status = "okay";
+};
+
+&tdmin_c {
+	status = "okay";
+};
+
+&tdmout_a {
+	status = "okay";
+};
+
+&tdmout_b {
+	status = "okay";
+};
+
+&tdmout_c {
+	status = "okay";
+};
+
+&toacodec {
+	status = "okay";
+};
+
+&tohdmitx {
+	status = "okay";
+};
+
+&toddr_a {
+	status = "okay";
+};
+
+&toddr_b {
+	status = "okay";
+};
+
+&toddr_c {
+	status = "okay";
+};
+
+&uart_AO {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_a_pins>;
+	pinctrl-names = "default";
+	xtal_tick_en = <2>;
+};
+
+&uart_AO_B {
+	status = "okay";
+	pinctrl-0 = <&uart_ao_b_2_pins>;
+	pinctrl-names = "default";
+};
+
+/* BT UART */
+&uart_A {
+	status = "okay";
+	pinctrl-0 = <&uart_a_pins>;
+	pinctrl-names = "default";
+};
+
+&dwc2 {
+	status = "okay";
+};
+
+&dwc3 {
+	status = "okay";
+};
+
+&usb2_phy0 {
+	status = "okay";
+	phy-supply = <&usb1_pow>;
+};
+
+&usb2_phy1 {
+	status = "okay";
+	phy-supply = <&usb1_pow>;
+};
+
+&usb3_pcie_phy {
+	status = "okay";
+	phy-supply = <&usb_pwr>;
+};
+
+&usb {
+	status = "okay";
+	dr_mode = "host";
+	vbus-supply = <&usb_pwr_en>;
+};
+
+&spicc0 {
+	status = "okay";
+	pinctrl-names = "default","gpio_periphs";
+	pinctrl-0 = <&spicc0_x_pins>;
+	pinctrl-1 = <&spicc0_ss0_x_pins>;
+	num_chipselect = <1>;
+	cs-gpios = <&gpio GPIOX_10 GPIO_ACTIVE_LOW>;
+
+	spidev@0 {
+		status = "okay";
+		compatible = "rohm,dh2228fv";
+		reg = <0>;
+		spi-max-frequency = <10000000>;
+	};
+};
+
+&spicc1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spicc1_pins>;
+	num_chipselect = <1>;
+	cs-gpios = <&gpio GPIOH_6 GPIO_ACTIVE_LOW>;
+
+	spidev@0 {
+		status = "okay";
+		compatible = "microchip,mcp2515";
+		reg = <0>;
+		clocks = <&osc8M>;
+		spi-max-frequency = <5000000>;
+		interrupt-parent = <&gpio_intc>;
+		interrupts = <66 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
diff -Naur a/scripts/dtc/include-prefixes/arm64/Makefile b/scripts/dtc/include-prefixes/arm64/Makefile
--- a/scripts/dtc/include-prefixes/arm64/Makefile	2022-05-27 17:20:14.009880591 +0800
+++ b/scripts/dtc/include-prefixes/arm64/Makefile	2022-05-31 11:56:47.697259643 +0800
@@ -30,3 +30,5 @@
 subdir-y += toshiba
 subdir-y += xilinx
 subdir-y += zte
+dtbs: $(addprefix $(obj)/, $(DTB_LIST))
+clean-files := dts/*.dtb *.dtb
diff -Naur a/scripts/dtc/include-prefixes/dt-bindings/clock/g12a-clkc.h b/scripts/dtc/include-prefixes/dt-bindings/clock/g12a-clkc.h
--- a/scripts/dtc/include-prefixes/dt-bindings/clock/g12a-clkc.h	2022-05-27 17:20:18.089933214 +0800
+++ b/scripts/dtc/include-prefixes/dt-bindings/clock/g12a-clkc.h	2022-05-31 11:56:48.093256151 +0800
@@ -147,5 +147,23 @@
 #define CLKID_SPICC1_SCLK			261
 #define CLKID_NNA_AXI_CLK			264
 #define CLKID_NNA_CORE_CLK			267
+#define CLKID_MIPI_DSI_PXCLK_SEL		269
+#define CLKID_MIPI_DSI_PXCLK			270
+#define CLKID_24M						271
+#define CLKID_MIPI_ISP_CLK_COMP			272
+#define CLKID_MIPI_CSI_PHY_CLK0_COMP	273
 
+#define CLKID_VDEC_P0_COMP				274
+#define CLKID_VDEC_P1_COMP				275
+#define CLKID_VDEC_MUX					276
+#define CLKID_HCODEC_P0_COMP			277
+#define CLKID_HCODEC_P1_COMP			278
+#define CLKID_HCODEC_MUX				279
+#define CLKID_HEVC_P0_COMP				280
+#define CLKID_HEVC_P1_COMP				281
+#define CLKID_HEVC_MUX					282
+#define CLKID_HEVCF_P0_COMP				283
+#define CLKID_HEVCF_P1_COMP				284
+#define CLKID_HEVCF_MUX					285
+	
 #endif /* __G12A_CLKC_H */
diff -Naur a/scripts/Makefile.lib b/scripts/Makefile.lib
--- a/scripts/Makefile.lib	2022-05-27 17:20:18.681940848 +0800
+++ b/scripts/Makefile.lib	2022-05-31 11:57:06.789097155 +0800
@@ -210,7 +210,9 @@
 
 ld_flags       = $(KBUILD_LDFLAGS) $(ldflags-y) $(LDFLAGS_$(@F))
 
-DTC_INCLUDE    := $(srctree)/scripts/dtc/include-prefixes
+DTC_INCLUDE    := $(srctree)/scripts/dtc/include-prefixes \
+		  $(objtree)/include/generated \
+		  $(srctree)/include/dt-bindings
 
 dtc_cpp_flags  = -Wp,-MMD,$(depfile).pre.tmp -nostdinc                    \
 		 $(addprefix -I,$(DTC_INCLUDE))                          \
@@ -316,7 +318,7 @@
 	$(call if_changed,dt_S_dtb)
 
 quiet_cmd_dtc = DTC     $@
-cmd_dtc = $(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
+cmd_dtc = mkdir -p $(dir $(dtc-tmp)); $(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
 	$(DTC) -O $(patsubst .%,%,$(suffix $@)) -o $@ -b 0 \
 		$(addprefix -i,$(dir $<) $(DTC_INCLUDE)) $(DTC_FLAGS) \
 		-d $(depfile).dtc.tmp $(dtc-tmp) ; \
diff -Naur a/sound/soc/codecs/nau8540.c b/sound/soc/codecs/nau8540.c
--- a/sound/soc/codecs/nau8540.c	2022-05-27 17:20:18.829942757 +0800
+++ b/sound/soc/codecs/nau8540.c	2022-05-31 11:57:06.789097155 +0800
@@ -756,7 +756,7 @@
 	 */
 	regmap_update_bits(regmap, NAU8540_REG_ADC_SAMPLE_RATE,
 		NAU8540_CH_SYNC | NAU8540_ADC_OSR_MASK,
-		NAU8540_CH_SYNC | NAU8540_ADC_OSR_64);
+		NAU8540_CH_SYNC | NAU8540_ADC_OSR_128);
 	/* PGA input mode selection */
 	regmap_update_bits(regmap, NAU8540_REG_FEPGA1,
 		NAU8540_FEPGA1_MODCH2_SHT | NAU8540_FEPGA1_MODCH1_SHT,
@@ -769,6 +769,17 @@
 		NAU8540_I2S_DO12_TRI, NAU8540_I2S_DO12_TRI);
 	regmap_update_bits(regmap, NAU8540_REG_PCM_CTRL2,
 		NAU8540_I2S_DO34_TRI, NAU8540_I2S_DO34_TRI);
+	/* Update 14th bit always out */
+	regmap_update_bits(nau8540->regmap, NAU8540_REG_PCM_CTRL1,
+		0x4000, 0X4000);
+	regmap_write(nau8540->regmap, NAU8540_REG_FEPGA3,0x1717);
+	regmap_write(nau8540->regmap, NAU8540_REG_DIGITAL_GAIN_CH1,0x0520);
+	regmap_write(nau8540->regmap, NAU8540_REG_DIGITAL_GAIN_CH2,0x0520);
+	regmap_write(nau8540->regmap, NAU8540_REG_DIGITAL_GAIN_CH3, 0x0520);
+	regmap_write(nau8540->regmap, NAU8540_REG_DIGITAL_GAIN_CH4, 0x0520);
+	regmap_write(nau8540->regmap, NAU8540_REG_DIGITAL_MUX,0x0000);
+	regmap_write(nau8540->regmap, NAU8540_REG_HPF_FILTER_CH12,0x1F1F);
+	regmap_write(nau8540->regmap, NAU8540_REG_HPF_FILTER_CH34,0x1F1F);
 }
 
 static int __maybe_unused nau8540_suspend(struct snd_soc_component *component)
diff -Naur a/sound/soc/Makefile b/sound/soc/Makefile
--- a/sound/soc/Makefile	2022-05-27 17:20:18.801942396 +0800
+++ b/sound/soc/Makefile	2022-06-18 17:43:11.719529135 +0800
@@ -37,7 +37,9 @@
 obj-$(CONFIG_SND_SOC)	+= img/
 obj-$(CONFIG_SND_SOC)	+= intel/
 obj-$(CONFIG_SND_SOC)	+= mediatek/
+ifeq ($(CONFIG_DRIVERS_HDF_AUDIO),)
 obj-$(CONFIG_SND_SOC)	+= meson/
+endif
 obj-$(CONFIG_SND_SOC)	+= mxs/
 obj-$(CONFIG_SND_SOC)	+= kirkwood/
 obj-$(CONFIG_SND_SOC)	+= pxa/
diff -Naur a/vendor/amlogic/battery/aml_battery.c b/vendor/amlogic/battery/aml_battery.c
--- a/vendor/amlogic/battery/aml_battery.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/battery/aml_battery.c	2022-06-27 21:51:16.307017964 +0800
@@ -0,0 +1,175 @@
+/*
+ * Battery driver for Amlogic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/power_supply.h>
+
+struct ac_data {
+	struct power_supply_desc psd;
+	struct power_supply *psy;
+};
+
+struct battery_data {
+	struct power_supply_desc psd;
+	struct power_supply *psy;
+};
+
+static enum power_supply_property ac_props[] = {
+	POWER_SUPPLY_PROP_ONLINE,
+};
+
+static enum power_supply_property battery_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_CHARGE_NOW,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CURRENT_AVG,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_AVG,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_TEMP_MIN,
+	POWER_SUPPLY_PROP_TEMP_MAX,
+};
+
+static int ac_get_property(struct power_supply *psy,
+	enum power_supply_property psp, union power_supply_propval *val)
+{
+	int ret = 0;
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_ONLINE:
+			val->intval = 1;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	return ret;
+}
+
+static int battery_get_property(struct power_supply *psy,
+	enum power_supply_property psp, union power_supply_propval *val)
+{
+	int ret = 0;
+
+	switch (psp) {
+		case POWER_SUPPLY_PROP_STATUS:
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+			break;
+		case POWER_SUPPLY_PROP_HEALTH:
+			val->intval = POWER_SUPPLY_HEALTH_GOOD;
+			break;
+		case POWER_SUPPLY_PROP_PRESENT:
+			val->intval = 0;
+			break;
+		case POWER_SUPPLY_PROP_CAPACITY:
+			val->intval = 100;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		case POWER_SUPPLY_PROP_CHARGE_FULL:
+			val->intval = 3000 * 1000;
+			break;
+		case POWER_SUPPLY_PROP_CHARGE_NOW:
+			val->intval = 3000 * 1000;
+			break;
+		case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		case POWER_SUPPLY_PROP_VOLTAGE_AVG:
+			val->intval = 4200 * 1000;
+			break;
+		case POWER_SUPPLY_PROP_TEMP:
+			val->intval = 25;
+			break;
+		case POWER_SUPPLY_PROP_TEMP_MIN:
+			val->intval = -40;
+			break;
+		case POWER_SUPPLY_PROP_TEMP_MAX:
+			val->intval = 100;
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_AVG:
+			val->intval = 4200 * 1000;
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_NOW:
+			val->intval = 100 * 1000;
+			break;
+		case POWER_SUPPLY_PROP_CURRENT_MAX:
+			val->intval = 3000000;
+			break;
+		case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+			val->intval = 5000000;
+			break;
+		case POWER_SUPPLY_PROP_TECHNOLOGY:
+			val->intval = POWER_SUPPLY_TECHNOLOGY_LIPO;
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+	}
+
+	return ret;
+}
+
+static struct ac_data ac_main = {
+	.psd = {
+		.name = "ac",
+		.type = POWER_SUPPLY_TYPE_MAINS,
+		.properties = ac_props,
+		.num_properties = ARRAY_SIZE(ac_props),
+		.get_property = ac_get_property,
+	},
+};
+
+static struct battery_data battery_main = {
+	.psd = {
+		.name = "battery",
+		.type = POWER_SUPPLY_TYPE_BATTERY,
+		.properties = battery_props,
+		.num_properties = ARRAY_SIZE(battery_props),
+		.get_property = battery_get_property,
+	},
+};
+
+static int __init aml_battery_init(void)
+{
+	ac_main.psy = power_supply_register(NULL, &ac_main.psd, NULL);
+	if (IS_ERR(ac_main.psy)) {
+		pr_debug("[%s] power_supply_register AC Fail !!\n", __func__);
+		return -1;
+	}
+
+	battery_main.psy = power_supply_register(NULL, &battery_main.psd, NULL);
+	if (IS_ERR(battery_main.psy)) {
+		pr_debug("[%s] power_supply_register Battery Fail !!\n",
+			__func__);
+		return -1;
+	}
+
+	pr_debug("power_supply_register AC/Battery Success !!\n");
+
+	return 0;
+}
+
+static void __exit aml_battery_exit(void)
+{
+	power_supply_unregister(battery_main.psy);
+}
+
+module_init(aml_battery_init);
+module_exit(aml_battery_exit);
+
+MODULE_AUTHOR("AlgoIdeas <yu19881234@163.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Battery driver for Amlogic");
\ No newline at end of file
diff -Naur a/vendor/amlogic/battery/Kconfig b/vendor/amlogic/battery/Kconfig
--- a/vendor/amlogic/battery/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/battery/Kconfig	2022-06-02 19:59:17.401116604 +0800
@@ -0,0 +1,5 @@
+config AMLOGIC_BATTERY
+	bool "Amlogic Battery support"
+	default y
+	help
+		select y to support amlogic battery
diff -Naur a/vendor/amlogic/battery/Makefile b/vendor/amlogic/battery/Makefile
--- a/vendor/amlogic/battery/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/battery/Makefile	2022-06-02 19:59:32.185446082 +0800
@@ -0,0 +1 @@
+obj-y += aml_battery.o
\ No newline at end of file
diff -Naur a/vendor/amlogic/bluetooth/bluesleep.c b/vendor/amlogic/bluetooth/bluesleep.c
--- a/vendor/amlogic/bluetooth/bluesleep.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/bluetooth/bluesleep.c	2022-05-31 11:56:47.705259573 +0800
@@ -0,0 +1,961 @@
+/*
+ * Date         Author           Comment
+ * -----------  --------------   --------------------------------
+ * 2006-Apr-28	Motorola	 The kernel module for running the Bluetooth(R)
+ *                               Sleep-Mode Protocol from the Host side
+ *  2006-Sep-08  Motorola        Added workqueue for handling sleep work.
+ *  2007-Jan-24  Motorola        Added mbm_handle_ioi() call to ISR.
+ *  2009-Aug-10  Motorola        Changed "add_timer" to "mod_timer" to solve
+ *                               race when flurry of queued work comes in.
+ */
+
+#define pr_fmt(fmt)	"Bluetooth: %s: " fmt, __func__
+
+#include <linux/module.h>	/* kernel module definitions */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/notifier.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/timer.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/irq.h>
+#include <linux/ioport.h>
+#include <linux/param.h>
+#include <linux/bitops.h>
+#include <linux/termios.h>
+#include <linux/wakelock_android.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/serial_core.h>
+
+#include <linux/of_irq.h>
+/* #include <linux/platform_data/msm_serial_hs.h> */
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h> /* event notifications */
+#include "../../bluetooth/hci_uart.h"
+#include "bluesleep.h"
+
+#define BT_SLEEP_DBG
+#ifndef BT_SLEEP_DBG
+#define BT_DBG(fmt, arg...)
+#endif
+/*
+ * Defines
+ */
+
+#define VERSION		"1.2"
+#define PROC_DIR	"bluetooth/sleep"
+#define BT_SLEEP "bluesleep"
+
+#define POLARITY_LOW 0
+#define POLARITY_HIGH 1
+
+#define BT_PORT_ID	0
+
+/* enable/disable wake-on-bluetooth */
+#define BT_ENABLE_IRQ_WAKE 0
+
+#define BT_BLUEDROID_SUPPORT 1
+
+enum {
+	DEBUG_USER_STATE = 1U << 0,
+	DEBUG_SUSPEND = 1U << 1,
+	DEBUG_BTWAKE = 1U << 2,
+	DEBUG_VERBOSE = 1U << 3,
+};
+
+static int debug_mask = DEBUG_USER_STATE;
+//module_param_named(debug_mask, debug_mask, int, S_IRUGO | S_IWUSR | S_IWGRP);
+module_param_named(debug_mask, debug_mask, int, 0664);
+
+struct bluesleep_info {
+	unsigned int host_wake;
+	unsigned int ext_wake;
+	unsigned int host_wake_irq;
+	struct uart_port *uport;
+	struct wake_lock wake_lock;
+	int irq_polarity;
+	int has_ext_wake;
+};
+
+/* work function */
+static void bluesleep_sleep_work(struct work_struct *work);
+
+/* work queue */
+DECLARE_DELAYED_WORK(sleep_workqueue, bluesleep_sleep_work);
+
+/* Macros for handling sleep work */
+#define bluesleep_rx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
+#define bluesleep_tx_busy()     schedule_delayed_work(&sleep_workqueue, 0)
+#define bluesleep_rx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
+#define bluesleep_tx_idle()     schedule_delayed_work(&sleep_workqueue, 0)
+
+/* 5 second timeout */
+#define TX_TIMER_INTERVAL  5
+
+/* state variable names and bit positions */
+#define BT_PROTO	0x01
+#define BT_TXDATA	0x02
+#define BT_ASLEEP	0x04
+#define BT_EXT_WAKE	0x08
+#define BT_SUSPEND	0x10
+
+#define PROC_BTWAKE	0
+#define PROC_HOSTWAKE	1
+#define PROC_PROTO	2
+#define PROC_ASLEEP	3
+#if BT_BLUEDROID_SUPPORT
+#define PROC_LPM	4
+#define PROC_BTWRITE	5
+#endif
+
+#if BT_BLUEDROID_SUPPORT
+static bool has_lpm_enabled;
+#else
+/* global pointer to a single hci device. */
+static struct hci_dev *bluesleep_hdev;
+#endif
+
+static struct platform_device *bluesleep_uart_dev;
+static struct bluesleep_info *bsi;
+static int bt_port_id = 1;
+
+/* module usage */
+static atomic_t open_count = ATOMIC_INIT(1);
+
+/*
+ * Local function prototypes
+ */
+#if !BT_BLUEDROID_SUPPORT
+static int bluesleep_hci_event(struct notifier_block *this,
+			unsigned long event, void *data);
+#endif
+static int bluesleep_start(void);
+static void bluesleep_stop(void);
+
+/*
+ * Global variables
+ */
+
+/** Global state flags */
+static unsigned long flags;
+
+/** Tasklet to respond to change in hostwake line */
+static struct tasklet_struct hostwake_task;
+
+/** Transmission timer */
+static void bluesleep_tx_timer_expire(unsigned long data);
+static DEFINE_TIMER(tx_timer, bluesleep_tx_timer_expire, 0, 0);
+
+/** Lock for state transitions */
+static spinlock_t rw_lock;
+
+#if !BT_BLUEDROID_SUPPORT
+/** Notifier block for HCI events */
+struct notifier_block hci_event_nblock = {
+	.notifier_call = bluesleep_hci_event,
+};
+#endif
+
+struct proc_dir_entry *bluetooth_dir, *sleep_dir;
+
+/*
+ * Local functions
+ */
+
+static void hsuart_power(int on)
+{
+}
+
+/**
+ * @return 1 if the Host can go to sleep, 0 otherwise.
+ */
+int bluesleep_can_sleep(void)
+{
+	/* check if WAKE_BT_GPIO and BT_WAKE_GPIO are both deasserted */
+	return (gpio_get_value(bsi->host_wake) != bsi->irq_polarity) &&
+		(test_bit(BT_EXT_WAKE, &flags)) &&
+		(bsi->uport != NULL);
+}
+
+void bluesleep_sleep_wakeup(void)
+{
+	if (test_bit(BT_ASLEEP, &flags)) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("waking up...\n");
+		wake_lock(&bsi->wake_lock);
+		/* Start the timer */
+		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
+		if (debug_mask & DEBUG_BTWAKE)
+			pr_info("BT WAKE: set to wake\n");
+		if (bsi->has_ext_wake == 1)
+			gpio_set_value(bsi->ext_wake, 1);
+		clear_bit(BT_EXT_WAKE, &flags);
+		clear_bit(BT_ASLEEP, &flags);
+		/*Activating UART */
+		hsuart_power(1);
+	}
+}
+
+/**
+ * @brief@  main sleep work handling function which update the flags
+ * and activate and deactivate UART ,check FIFO.
+ */
+static void bluesleep_sleep_work(struct work_struct *work)
+{
+	if (bluesleep_can_sleep()) {
+		/* already asleep, this is an error case */
+		if (test_bit(BT_ASLEEP, &flags)) {
+			if (debug_mask & DEBUG_SUSPEND)
+				pr_info("already asleep\n");
+			return;
+		}
+
+		if (bsi->uport->ops->tx_empty(bsi->uport)) {
+			if (debug_mask & DEBUG_SUSPEND)
+				pr_info("going to sleep...\n");
+			set_bit(BT_ASLEEP, &flags);
+			/*Deactivating UART */
+			hsuart_power(0);
+			/* UART clk is not turned off immediately. Release
+			 * wakelock after 500 ms.
+			 */
+			wake_lock_timeout(&bsi->wake_lock, HZ / 2);
+		} else {
+
+		  mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
+			return;
+		}
+	} else if (test_bit(BT_EXT_WAKE, &flags)
+			&& !test_bit(BT_ASLEEP, &flags)) {
+		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL * HZ));
+		if (debug_mask & DEBUG_BTWAKE)
+			pr_info("BT WAKE: set to wake\n");
+		if (bsi->has_ext_wake == 1)
+			gpio_set_value(bsi->ext_wake, 1);
+		clear_bit(BT_EXT_WAKE, &flags);
+	} else {
+		bluesleep_sleep_wakeup();
+	}
+}
+
+/**
+ * A tasklet function that runs in tasklet context and reads the value
+ * of the HOST_WAKE GPIO pin and further defer the work.
+ * @param data Not used.
+ */
+static void bluesleep_hostwake_task(unsigned long data)
+{
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("hostwake line change\n");
+
+	spin_lock(&rw_lock);
+	if (gpio_get_value(bsi->host_wake) == bsi->irq_polarity)
+		bluesleep_rx_busy();
+	else
+		bluesleep_rx_idle();
+
+	spin_unlock(&rw_lock);
+}
+
+/**
+ * Handles proper timer action when outgoing data is delivered to the
+ * HCI line discipline. Sets BT_TXDATA.
+ */
+static void bluesleep_outgoing_data(void)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&rw_lock, irq_flags);
+
+	/* log data passing by */
+	set_bit(BT_TXDATA, &flags);
+
+	spin_unlock_irqrestore(&rw_lock, irq_flags);
+
+	/* if the tx side is sleeping... */
+	if (test_bit(BT_EXT_WAKE, &flags)) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("tx was sleeping\n");
+		bluesleep_sleep_wakeup();
+	}
+}
+
+
+#if !BT_BLUEDROID_SUPPORT
+/**
+ * Handles HCI device events.
+ * @param this Not used.
+ * @param event The event that occurred.
+ * @param data The HCI device associated with the event.
+ * @return <code>NOTIFY_DONE</code>.
+ */
+static int bluesleep_hci_event(struct notifier_block *this,
+				unsigned long event, void *data)
+{
+	struct hci_dev *hdev = (struct hci_dev *) data;
+	struct hci_uart *hu;
+	struct uart_state *state;
+
+	if (!hdev)
+		return NOTIFY_DONE;
+
+	switch (event) {
+	case HCI_DEV_REG:
+		if (!bluesleep_hdev) {
+			bluesleep_hdev = hdev;
+			hu  = (struct hci_uart *) hdev->driver_data;
+			state = (struct uart_state *) hu->tty->driver_data;
+			bsi->uport = state->uart_port;
+			/* if bluetooth started, start bluesleep*/
+			bluesleep_start();
+		}
+		break;
+	case HCI_DEV_UNREG:
+		bluesleep_stop();
+		bluesleep_hdev = NULL;
+		bsi->uport = NULL;
+		/* if bluetooth stopped, stop bluesleep also */
+		break;
+	case HCI_DEV_WRITE:
+		bluesleep_outgoing_data();
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+#endif
+
+/**
+ * Handles transmission timer expiration.
+ * @param data Not used.
+ */
+static void bluesleep_tx_timer_expire(unsigned long data)
+{
+	unsigned long irq_flags;
+
+	if (debug_mask & DEBUG_VERBOSE)
+		pr_info("Tx timer expired\n");
+
+	spin_lock_irqsave(&rw_lock, irq_flags);
+
+	/* were we silent during the last timeout? */
+	if (!test_bit(BT_TXDATA, &flags)) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("Tx has been idle\n");
+		if (debug_mask & DEBUG_BTWAKE)
+			pr_info("BT WAKE: set to sleep\n");
+		if (bsi->has_ext_wake == 1)
+			gpio_set_value(bsi->ext_wake, 0);
+		set_bit(BT_EXT_WAKE, &flags);
+		bluesleep_tx_idle();
+	} else {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("Tx data during last period\n");
+		mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
+	}
+
+	/* clear the incoming data flag */
+	clear_bit(BT_TXDATA, &flags);
+
+	spin_unlock_irqrestore(&rw_lock, irq_flags);
+}
+
+/**
+ * Schedules a tasklet to run when receiving an interrupt on the
+ * <code>HOST_WAKE</code> GPIO pin.
+ * @param irq Not used.
+ * @param dev_id Not used.
+ */
+static irqreturn_t bluesleep_hostwake_isr(int irq, void *dev_id)
+{
+	/* schedule a tasklet to handle the change in the host wake line */
+	tasklet_schedule(&hostwake_task);
+	return IRQ_HANDLED;
+}
+
+/**
+ * Starts the Sleep-Mode Protocol on the Host.
+ * @return On success, 0. On error, -1, and <code>errno</code> is set
+ * appropriately.
+ */
+static int bluesleep_start(void)
+{
+	int retval;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&rw_lock, irq_flags);
+
+	if (test_bit(BT_PROTO, &flags)) {
+		spin_unlock_irqrestore(&rw_lock, irq_flags);
+		return 0;
+	}
+
+	spin_unlock_irqrestore(&rw_lock, irq_flags);
+
+	if (!atomic_dec_and_test(&open_count)) {
+		atomic_inc(&open_count);
+		return -EBUSY;
+	}
+
+	/* start the timer */
+
+	mod_timer(&tx_timer, jiffies + (TX_TIMER_INTERVAL*HZ));
+
+	/* assert BT_WAKE */
+	if (debug_mask & DEBUG_BTWAKE)
+		pr_info("BT WAKE: set to wake\n");
+	if (bsi->has_ext_wake == 1)
+		gpio_set_value(bsi->ext_wake, 1);
+	clear_bit(BT_EXT_WAKE, &flags);
+	retval = request_irq(bsi->host_wake_irq, bluesleep_hostwake_isr,
+		IRQF_DISABLED,
+		"bluetooth hostwake", NULL);
+	if (retval  < 0) {
+		BT_ERR("Couldn't acquire BT_HOST_WAKE IRQ");
+		goto fail;
+	}
+#if BT_ENABLE_IRQ_WAKE
+	retval = enable_irq_wake(bsi->host_wake_irq);
+	if (retval < 0) {
+		BT_ERR("Couldn't enable BT_HOST_WAKE as wakeup interrupt");
+		goto fail;
+	}
+#endif
+	set_bit(BT_PROTO, &flags);
+	wake_lock(&bsi->wake_lock);
+	return 0;
+
+fail:
+	del_timer(&tx_timer);
+	atomic_inc(&open_count);
+
+	return retval;
+}
+
+/**
+ * Stops the Sleep-Mode Protocol on the Host.
+ */
+static void bluesleep_stop(void)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&rw_lock, irq_flags);
+
+	if (!test_bit(BT_PROTO, &flags)) {
+		spin_unlock_irqrestore(&rw_lock, irq_flags);
+		return;
+	}
+
+	/* assert BT_WAKE */
+	if (debug_mask & DEBUG_BTWAKE)
+		pr_info("BT WAKE: set to wake\n");
+	if (bsi->has_ext_wake == 1)
+		gpio_set_value(bsi->ext_wake, 1);
+	clear_bit(BT_EXT_WAKE, &flags);
+	del_timer(&tx_timer);
+	clear_bit(BT_PROTO, &flags);
+
+	if (test_bit(BT_ASLEEP, &flags)) {
+		clear_bit(BT_ASLEEP, &flags);
+		spin_unlock_irqrestore(&rw_lock, irq_flags);
+		hsuart_power(1);
+	} else {
+		spin_unlock_irqrestore(&rw_lock, irq_flags);
+	}
+
+	atomic_inc(&open_count);
+
+#if BT_ENABLE_IRQ_WAKE
+	if (disable_irq_wake(bsi->host_wake_irq))
+		BT_ERR("Couldn't disable hostwake IRQ wakeup mode");
+#endif
+	free_irq(bsi->host_wake_irq, NULL);
+	wake_lock_timeout(&bsi->wake_lock, HZ / 2);
+}
+
+void bluesleep_setup_uart_port(struct platform_device *uart_dev)
+{
+	bluesleep_uart_dev = uart_dev;
+}
+
+static int bluesleep_populate_dt_pinfo(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int tmp;
+	const void *prop;
+
+	tmp = of_get_named_gpio(np, "bt_host_wake", 0);
+	if (tmp < 0) {
+		BT_ERR("couldn't find host_wake gpio");
+		return -ENODEV;
+	}
+	bsi->host_wake = tmp;
+
+	tmp = of_get_named_gpio(np, "bt_ext_wake", 0);
+	if (tmp < 0)
+		bsi->has_ext_wake = 0;
+	else
+		bsi->has_ext_wake = 1;
+
+	if (bsi->has_ext_wake)
+		bsi->ext_wake = tmp;
+
+	prop = of_get_property(np, "bt_port_id", NULL);
+	if (prop) {
+		bt_port_id = of_read_ulong(prop, 1);
+		BT_INFO("bt port id is %d\n", bt_port_id);
+	}
+
+	BT_INFO("bt_host_wake %d, bt_ext_wake %d",
+			bsi->host_wake,
+			bsi->ext_wake);
+	return 0;
+}
+
+static int bluesleep_populate_pinfo(struct platform_device *pdev)
+{
+	struct resource *res;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
+				"gpio_host_wake");
+	if (!res) {
+		BT_ERR("couldn't find host_wake gpio");
+		return -ENODEV;
+	}
+	bsi->host_wake = res->start;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_IO,
+				"gpio_ext_wake");
+	if (!res)
+		bsi->has_ext_wake = 0;
+	else
+		bsi->has_ext_wake = 1;
+
+	if (bsi->has_ext_wake)
+		bsi->ext_wake = res->start;
+
+	return 0;
+}
+
+static int bluesleep_probe(struct platform_device *pdev)
+{
+	/* struct resource *res; */
+	int ret;
+
+	bsi = kzalloc(sizeof(struct bluesleep_info), GFP_KERNEL);
+	if (!bsi)
+		return -ENOMEM;
+
+	if (pdev->dev.of_node) {
+		ret = bluesleep_populate_dt_pinfo(pdev);
+		if (ret < 0) {
+			BT_ERR("couldn't populate info from dt");
+			return ret;
+		}
+	} else {
+		ret = bluesleep_populate_pinfo(pdev);
+		if (ret < 0) {
+			BT_ERR("couldn't populate info");
+			return ret;
+		}
+	}
+
+	/* configure host_wake as input */
+	ret = gpio_request_one(bsi->host_wake, GPIOF_IN, "bt_host_wake");
+	if (ret < 0) {
+		BT_ERR("failed to configure input direction for GPIO %d err %d",
+				bsi->host_wake, ret);
+		goto free_bsi;
+	}
+
+	if (debug_mask & DEBUG_BTWAKE)
+		pr_info("BT WAKE: set to wake\n");
+	if (bsi->has_ext_wake) {
+		/* configure ext_wake as output mode*/
+		ret = gpio_request_one(bsi->ext_wake,
+				GPIOF_OUT_INIT_LOW, "bt_ext_wake");
+		if (ret < 0) {
+			BT_ERR("failed to config output");
+			BT_ERR("	for GPIO %d err %d",
+					bsi->ext_wake, ret);
+			goto free_bt_host_wake;
+		}
+	}
+	clear_bit(BT_EXT_WAKE, &flags);
+
+	bsi->host_wake_irq =
+		irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (bsi->host_wake_irq == 0) {
+		BT_ERR("couldn't find host_wake irq");
+		ret = -ENODEV;
+		goto free_bt_ext_wake;
+	}
+
+	gpio_for_irq(bsi->host_wake,
+				AML_GPIO_IRQ(bsi->host_wake_irq, FILTER_NUM7,
+				GPIO_IRQ_FALLING));
+
+	bsi->irq_polarity = POLARITY_LOW;/*low edge (falling edge)*/
+
+	wake_lock_init(&bsi->wake_lock,
+		WAKE_LOCK_SUSPEND, "bluesleep");
+	clear_bit(BT_SUSPEND, &flags);
+
+	BT_INFO("host_wake_irq %d, polarity %d",
+			bsi->host_wake_irq,
+			bsi->irq_polarity);
+
+	return 0;
+
+free_bt_ext_wake:
+	gpio_free(bsi->ext_wake);
+free_bt_host_wake:
+	gpio_free(bsi->host_wake);
+free_bsi:
+	kfree(bsi);
+	return ret;
+}
+
+static int bluesleep_remove(struct platform_device *pdev)
+{
+	gpio_free(bsi->host_wake);
+	gpio_free(bsi->ext_wake);
+	wake_lock_destroy(&bsi->wake_lock);
+	kfree(bsi);
+	return 0;
+}
+
+
+static int bluesleep_resume(struct platform_device *pdev)
+{
+	if (test_bit(BT_SUSPEND, &flags)) {
+		if (debug_mask & DEBUG_SUSPEND)
+			pr_info("bluesleep resuming...\n");
+		if ((bsi->uport != NULL) &&
+			(gpio_get_value(bsi->host_wake) == bsi->irq_polarity)) {
+			if (debug_mask & DEBUG_SUSPEND)
+				pr_info("bluesleep resume from BT event...\n");
+		}
+		clear_bit(BT_SUSPEND, &flags);
+	}
+	return 0;
+}
+
+static int bluesleep_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	if (debug_mask & DEBUG_SUSPEND)
+		pr_info("bluesleep suspending...\n");
+	set_bit(BT_SUSPEND, &flags);
+	return 0;
+}
+
+static const struct of_device_id bluesleep_match_table[] = {
+	{ .compatible = "amlogic, bluesleep" },
+	{}
+};
+
+static struct platform_driver bluesleep_driver = {
+	.probe = bluesleep_probe,
+	.remove = bluesleep_remove,
+	.suspend = bluesleep_suspend,
+	.resume = bluesleep_resume,
+	.driver = {
+		.name = "bluesleep",
+		.owner = THIS_MODULE,
+		.of_match_table = bluesleep_match_table,
+	},
+};
+
+static int bluesleep_proc_show(struct seq_file *m, void *v)
+{
+	switch ((long)m->private) {
+	case PROC_BTWAKE:
+		seq_printf(m, "btwake: %u\n", test_bit(BT_EXT_WAKE, &flags));
+		break;
+	case PROC_HOSTWAKE:
+		seq_printf(m, "hostwake: %u\n", gpio_get_value(bsi->host_wake));
+		break;
+	case PROC_PROTO:
+		seq_printf(m, "proto: %u\n",
+				test_bit(BT_PROTO, &flags) ? 1 : 0);
+		break;
+	case PROC_ASLEEP:
+		seq_printf(m, "asleep: %u\n",
+				test_bit(BT_ASLEEP, &flags) ? 1 : 0);
+		break;
+	case PROC_LPM:
+		seq_printf(m, "lpm: %u\n",
+				 has_lpm_enabled ? 1 : 0);
+		break;
+	case PROC_BTWRITE:
+		seq_printf(m, "lpm: %u\n",
+				test_bit(BT_TXDATA, &flags) ? 1 : 0);
+		break;
+
+	default:
+		return 0;
+	}
+	return 0;
+}
+
+static ssize_t bluesleep_proc_write(struct file *file, const char *buf,
+	size_t count, loff_t *pos)
+{
+	void *data = PDE_DATA(file_inode(file));
+	char lbuf[32];
+
+	if (count >= sizeof(lbuf))
+		count = sizeof(lbuf)-1;
+
+	if (copy_from_user(lbuf, buf, count))
+		return -EFAULT;
+	lbuf[count] = 0;
+
+	switch ((long)data) {
+	case PROC_BTWAKE:
+		if (lbuf[0] == '0') {
+			if (debug_mask & DEBUG_BTWAKE)
+				pr_info("BT WAKE: set to wake\n");
+			if (bsi->has_ext_wake == 1)
+				gpio_set_value(bsi->ext_wake, 1);
+			clear_bit(BT_EXT_WAKE, &flags);
+		} else if (buf[0] == '1') {
+			if (debug_mask & DEBUG_BTWAKE)
+				pr_info("BT WAKE: set to sleep\n");
+			if (bsi->has_ext_wake == 1)
+				gpio_set_value(bsi->ext_wake, 0);
+			set_bit(BT_EXT_WAKE, &flags);
+		}
+		break;
+	case PROC_PROTO:
+		if (lbuf[0] == '0')
+			bluesleep_stop();
+		else
+			bluesleep_start();
+		break;
+	case PROC_LPM:
+		if (lbuf[0] == '0') {
+			bluesleep_stop();
+			has_lpm_enabled = false;
+			bsi->uport = NULL;
+		} else {
+			if (!has_lpm_enabled) {
+				has_lpm_enabled = true;
+				bsi->uport = get_uart_port(bt_port_id);
+				if (bsi->uport)
+					bluesleep_start();
+				else
+					pr_info("bt port is null\n");
+			}
+		}
+		break;
+	case PROC_BTWRITE:
+		if (lbuf[0] != '0' && bsi->uport)
+			bluesleep_outgoing_data();
+		break;
+	default:
+		return 0;
+	}
+
+	return count;
+}
+
+static int bluesleep_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, bluesleep_proc_show, PDE_DATA(inode));
+}
+
+static const struct file_operations bluesleep_proc_readwrite_fops = {
+	.owner	= THIS_MODULE,
+	.open	= bluesleep_proc_open,
+	.read   = seq_read,
+	.write  = bluesleep_proc_write,
+	.release = single_release,
+};
+static const struct file_operations bluesleep_proc_read_fops = {
+	.owner	= THIS_MODULE,
+	.open	= bluesleep_proc_open,
+	.read   = seq_read,
+	.release = single_release,
+};
+
+/**
+ * Initializes the module.
+ * @return On success, 0. On error, -1, and <code>errno</code> is set
+ * appropriately.
+ */
+static int __init bluesleep_init(void)
+{
+	int retval;
+	struct proc_dir_entry *ent;
+
+	BT_INFO("BlueSleep Mode Driver Ver %s", VERSION);
+
+	retval = platform_driver_register(&bluesleep_driver);
+	if (retval)
+		return retval;
+
+	if (bsi == NULL)
+		return 0;
+
+#if !BT_BLUEDROID_SUPPORT
+	bluesleep_hdev = NULL;
+#endif
+
+	bluetooth_dir = proc_mkdir("bluetooth", NULL);
+	if (bluetooth_dir == NULL) {
+		BT_ERR("Unable to create /proc/bluetooth directory");
+		return -ENOMEM;
+	}
+
+	sleep_dir = proc_mkdir("sleep", bluetooth_dir);
+	if (sleep_dir == NULL) {
+		BT_ERR("Unable to create /proc/%s directory", PROC_DIR);
+		return -ENOMEM;
+	}
+
+	ent = proc_create_data("btwake", 0664,
+			sleep_dir, &bluesleep_proc_readwrite_fops,
+			(void *)PROC_BTWAKE);
+	if (ent == NULL) {
+		BT_ERR("Unable to create /proc/%s/btwake entry", PROC_DIR);
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	ent = proc_create_data("hostwake", 0444, sleep_dir,
+				&bluesleep_proc_read_fops,
+				(void *)PROC_HOSTWAKE);
+	if (ent == NULL) {
+		BT_ERR("Unable to create /proc/%s/hostwake entry", PROC_DIR);
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	ent = proc_create_data("proto", 0664,
+			sleep_dir, &bluesleep_proc_readwrite_fops,
+			(void *)PROC_PROTO);
+	if (ent == NULL) {
+		BT_ERR("Unable to create /proc/%s/proto entry", PROC_DIR);
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	ent = proc_create_data("asleep", 0444,
+			sleep_dir, &bluesleep_proc_read_fops,
+			(void *)PROC_ASLEEP);
+	if (ent == NULL) {
+		BT_ERR("Unable to create /proc/%s/asleep entry", PROC_DIR);
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+#if BT_BLUEDROID_SUPPORT
+	ent = proc_create_data("lpm", 0664,
+			sleep_dir, &bluesleep_proc_readwrite_fops,
+			(void *)PROC_LPM);
+	if (ent == NULL) {
+		BT_ERR("Unable to create /proc/%s/lpm entry", PROC_DIR);
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+	ent = proc_create_data("btwrite", 0664,
+			sleep_dir, &bluesleep_proc_readwrite_fops,
+			(void *)PROC_BTWRITE);
+	if (ent == NULL) {
+		BT_ERR("Unable to create /proc/%s/btwrite entry", PROC_DIR);
+		retval = -ENOMEM;
+		goto fail;
+	}
+
+#endif
+
+	flags = 0;
+
+	spin_lock_init(&rw_lock);
+
+	init_timer(&tx_timer);
+	tx_timer.function = bluesleep_tx_timer_expire;
+	tx_timer.data = 0;
+
+	tasklet_init(&hostwake_task, bluesleep_hostwake_task, 0);
+
+	if (debug_mask & DEBUG_BTWAKE)
+		pr_info("BT WAKE: set to wake\n");
+	if (bsi->has_ext_wake == 1)
+		gpio_set_value(bsi->ext_wake, 1);
+	clear_bit(BT_EXT_WAKE, &flags);
+#if !BT_BLUEDROID_SUPPORT
+	hci_register_notifier(&hci_event_nblock);
+#endif
+
+	return 0;
+
+fail:
+#if BT_BLUEDROID_SUPPORT
+	remove_proc_entry("btwrite", sleep_dir);
+	remove_proc_entry("lpm", sleep_dir);
+#endif
+	remove_proc_entry("asleep", sleep_dir);
+	remove_proc_entry("proto", sleep_dir);
+	remove_proc_entry("hostwake", sleep_dir);
+	remove_proc_entry("btwake", sleep_dir);
+	remove_proc_entry("sleep", bluetooth_dir);
+	remove_proc_entry("bluetooth", 0);
+	return retval;
+}
+
+/**
+ * Cleans up the module.
+ */
+static void __exit bluesleep_exit(void)
+{
+	if (bsi == NULL)
+		return;
+
+	if (bsi->has_ext_wake == 1)
+		gpio_set_value(bsi->ext_wake, 1);
+	clear_bit(BT_EXT_WAKE, &flags);
+	if (test_bit(BT_PROTO, &flags)) {
+		if (disable_irq_wake(bsi->host_wake_irq))
+			BT_ERR("Couldn't disable hostwake IRQ wakeup mode");
+		free_irq(bsi->host_wake_irq, NULL);
+		del_timer(&tx_timer);
+		if (test_bit(BT_ASLEEP, &flags))
+			hsuart_power(1);
+	}
+
+#if !BT_BLUEDROID_SUPPORT
+	hci_unregister_notifier(&hci_event_nblock);
+#endif
+	platform_driver_unregister(&bluesleep_driver);
+
+#if BT_BLUEDROID_SUPPORT
+	remove_proc_entry("btwrite", sleep_dir);
+	remove_proc_entry("lpm", sleep_dir);
+#endif
+	remove_proc_entry("asleep", sleep_dir);
+	remove_proc_entry("proto", sleep_dir);
+	remove_proc_entry("hostwake", sleep_dir);
+	remove_proc_entry("btwake", sleep_dir);
+	remove_proc_entry("sleep", bluetooth_dir);
+	remove_proc_entry("bluetooth", 0);
+}
+
+module_init(bluesleep_init);
+module_exit(bluesleep_exit);
+
+MODULE_DESCRIPTION("Bluetooth Sleep Mode Driver ver %s " VERSION);
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
diff -Naur a/vendor/amlogic/bluetooth/bluesleep.h b/vendor/amlogic/bluetooth/bluesleep.h
--- a/vendor/amlogic/bluetooth/bluesleep.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/bluetooth/bluesleep.h	2022-06-24 14:37:49.260765339 +0800
@@ -0,0 +1,22 @@
+/*
+ * vendor/amlogic/bluetooth/bluesleep.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _BLUESLEEP_H
+#define _BLUESLEEP_H
+#include <linux/serial_core.h>
+extern struct uart_port *get_uart_port(int id);
+#endif
diff -Naur a/vendor/amlogic/bluetooth/bt_device.c b/vendor/amlogic/bluetooth/bt_device.c
--- a/vendor/amlogic/bluetooth/bt_device.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/bluetooth/bt_device.c	2022-06-30 15:33:55.343687749 +0800
@@ -0,0 +1,440 @@
+/*
+ * Bluetooth  device tree and rfkill driver for Amlogic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <linux/rfkill.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/io.h>
+#include <linux/amlogic/bt_device.h>
+#include <linux/random.h>
+#include "../../drivers/gpio/gpiolib.h"
+
+#include <linux/interrupt.h>
+#include <linux/pm_wakeup.h>
+#include <linux/pm_wakeirq.h>
+
+#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+#include <linux/amlogic/pm.h>
+static struct early_suspend bt_early_suspend;
+#endif
+
+#define BT_RFKILL "bt_rfkill"
+
+char bt_addr[18] = "";
+static struct class *bt_addr_class;
+static int btpower_evt;
+static ssize_t bt_addr_show(struct class *cls,
+	struct class_attribute *attr, char *_buf)
+{
+	char local_addr[6];
+
+	if (!_buf)
+		return -EINVAL;
+
+	if (strlen(bt_addr) == 0) {
+		local_addr[0] = 0x22;
+		local_addr[1] = 0x22;
+		local_addr[2] = prandom_u32();
+		local_addr[3] = prandom_u32();
+		local_addr[4] = prandom_u32();
+		local_addr[5] = prandom_u32();
+		sprintf(bt_addr, "%02x:%02x:%02x:%02x:%02x:%02x",
+		local_addr[0], local_addr[1], local_addr[2],
+		local_addr[3], local_addr[4], local_addr[5]);
+	}
+
+	return sprintf(_buf, "%s\n", bt_addr);
+}
+static ssize_t bt_addr_store(struct class *cls,
+	struct class_attribute *attr, const char __user *buf, size_t count)
+{
+	int ret = -EINVAL;
+
+	if (!buf)
+		return ret;
+
+	snprintf(bt_addr, sizeof(bt_addr), "%s", buf);
+
+	if (bt_addr[strlen(bt_addr)-1] == '\n')
+		bt_addr[strlen(bt_addr)-1] = '\0';
+
+	pr_info("bt_addr=%s\n", bt_addr);
+	return count;
+}
+static CLASS_ATTR_RW(bt_addr);
+
+struct bt_device_runtime_data {
+	struct rfkill *bt_rfk;
+	struct bt_dev_data *pdata;
+};
+
+static void bt_device_off(struct bt_dev_data *pdata)
+{
+	if (pdata->power_down_disable == 0) {
+		if (pdata->power_off_flag > 0) {
+			if (pdata->gpio_reset > 0) {
+				if ((pdata->power_on_pin_OD)
+					 && (pdata->power_low_level)) {
+					gpio_direction_input(pdata->gpio_reset);
+				} else {
+					gpio_direction_output(pdata->gpio_reset,
+						pdata->power_low_level);
+				}
+			}
+			if (pdata->gpio_en > 0) {
+				if ((pdata->power_on_pin_OD)
+						&& (pdata->power_low_level)) {
+					gpio_direction_input(pdata->gpio_en);
+				} else {
+					gpio_direction_output(pdata->gpio_en, 0);
+				}
+			}
+			msleep(20);
+		}
+	}
+}
+
+static void bt_device_init(struct bt_dev_data *pdata)
+{
+	int tmp = 0;
+
+	if (pdata->gpio_reset > 0)
+		gpio_request(pdata->gpio_reset, BT_RFKILL);
+
+	if (pdata->gpio_en > 0){
+		gpio_request(pdata->gpio_en, BT_RFKILL);
+    }
+
+	if (pdata->gpio_hostwake > 0) {
+		gpio_request(pdata->gpio_hostwake, BT_RFKILL);
+		gpio_direction_output(pdata->gpio_hostwake, 1);
+	}
+
+	tmp = pdata->power_down_disable;
+	pdata->power_down_disable = 0;
+	bt_device_off(pdata);
+	pdata->power_down_disable = tmp;
+
+}
+
+static void bt_device_deinit(struct bt_dev_data *pdata)
+{
+	if (pdata->gpio_reset > 0)
+		gpio_free(pdata->gpio_reset);
+
+	if (pdata->gpio_en > 0)
+		gpio_free(pdata->gpio_en);
+
+	if (pdata->gpio_hostwake > 0)
+		gpio_free(pdata->gpio_hostwake);
+}
+
+static void bt_device_on(struct bt_dev_data *pdata)
+{
+	if (pdata->power_down_disable == 0) {
+		if (pdata->gpio_reset > 0) {
+			if ((pdata->power_on_pin_OD)
+					&& (pdata->power_low_level)) {
+				gpio_direction_input(pdata->gpio_reset);
+			} else {
+				gpio_direction_output(pdata->gpio_reset,
+						pdata->power_low_level);
+			}
+		}
+
+		if (pdata->gpio_en > 0) {
+			if ((pdata->power_on_pin_OD)
+					&& (pdata->power_low_level)) {
+				gpio_direction_input(pdata->gpio_en);
+			} else {
+				gpio_direction_output(pdata->gpio_en, 0);
+			}
+		}
+		msleep(200);
+	}
+
+	if (pdata->gpio_reset > 0) {
+
+		if ((pdata->power_on_pin_OD)
+			&& (!pdata->power_low_level)) {
+			gpio_direction_input(pdata->gpio_reset);
+		} else {
+			gpio_direction_output(pdata->gpio_reset,
+				!pdata->power_low_level);
+		}
+	}
+
+	if (pdata->gpio_en > 0) {
+		if ((pdata->power_on_pin_OD)
+			&& (!pdata->power_low_level)) {
+			gpio_direction_input(pdata->gpio_en);
+		} else {
+			gpio_direction_output(pdata->gpio_en, 1);
+		}
+	}
+	msleep(200);
+}
+
+static int bt_set_block(void *data, bool blocked)
+{
+	struct bt_dev_data *pdata = data;
+
+	if (!blocked) {
+		pr_info("BT: ON\n");
+		bt_device_on(pdata);
+	} else {
+		pr_info("BT: OFF\n");
+		bt_device_off(pdata);
+	}
+
+	return 0;
+}
+
+static const struct rfkill_ops bt_rfkill_ops = {
+	.set_block = bt_set_block,
+};
+
+#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+static void bt_earlysuspend(struct early_suspend *h)
+{
+
+}
+
+static void bt_lateresume(struct early_suspend *h)
+{
+}
+#endif
+
+static int bt_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+
+	return 0;
+}
+
+static int bt_resume(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static int bt_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	const void *prop;
+	struct rfkill *bt_rfk;
+	struct bt_dev_data *pdata = NULL;
+	struct bt_device_runtime_data *prdata;
+
+#ifdef CONFIG_OF
+	if (pdev && pdev->dev.of_node) {
+		const char *str;
+
+		pdata = kzalloc(sizeof(struct bt_dev_data), GFP_KERNEL);
+		ret = of_property_read_string(pdev->dev.of_node, "gpio_reset", &str);
+		if (ret) {
+			pr_warn("not get gpio_reset\n");
+			pdata->gpio_reset = 0;
+		} else {
+			pdata->gpio_reset = of_get_named_gpio_flags(pdev->dev.of_node, "gpio_reset", 0, NULL);
+		}
+
+		ret = of_property_read_string(pdev->dev.of_node, "gpio_en", &str);
+		if (ret) {
+			pr_warn("not get gpio_en\n");
+			pdata->gpio_en = 0;
+		} else {
+			pdata->gpio_en = of_get_named_gpio_flags(pdev->dev.of_node, "gpio_en", 0, NULL);
+		}
+		ret = of_property_read_string(pdev->dev.of_node, "gpio_hostwake", &str);
+		if (ret) {
+			pr_warn("not get gpio_hostwake\n");
+			pdata->gpio_hostwake = 0;
+		} else {
+			pdata->gpio_hostwake = of_get_named_gpio_flags(pdev->dev.of_node, "gpio_hostwake", 0, NULL);
+		}
+
+		prop = of_get_property(pdev->dev.of_node, "power_low_level", NULL);
+		if (prop) {
+			pr_info("power on valid level is low");
+			pdata->power_low_level = 1;
+		} else {
+			pr_info("power on valid level is high");
+			pdata->power_low_level = 0;
+			pdata->power_on_pin_OD = 0;
+		}
+
+		ret = of_property_read_u32(pdev->dev.of_node, "power_on_pin_OD", &pdata->power_on_pin_OD);
+		if (ret)
+			pdata->power_on_pin_OD = 0;
+		pr_info("bt: power_on_pin_OD = %d;\n", pdata->power_on_pin_OD);
+
+		ret = of_property_read_u32(pdev->dev.of_node, "power_off_flag", &pdata->power_off_flag);
+		if (ret)
+			pdata->power_off_flag = 1;/*bt poweroff*/
+		pr_info("bt: power_off_flag = %d;\n", pdata->power_off_flag);
+
+		ret = of_property_read_u32(pdev->dev.of_node, "power_down_disable", &pdata->power_down_disable);
+		if (ret)
+			pdata->power_down_disable = 0;
+		pr_info("bt: power down = %d;\n", pdata->power_down_disable);
+	} else if (pdev) {
+		pdata = (struct bt_dev_data *)(pdev->dev.platform_data);
+	} else {
+		ret = -ENOENT;
+		goto err_res;
+	}
+#else
+	pdata = (struct bt_dev_data *)(pdev->dev.platform_data);
+#endif
+	bt_addr_class = class_create(THIS_MODULE, "bt_addr");
+	ret = class_create_file(bt_addr_class, &class_attr_bt_addr);
+
+	bt_device_init(pdata);
+	if (pdata->power_down_disable == 1) {
+		pdata->power_down_disable = 0;
+		bt_device_on(pdata);
+		pdata->power_down_disable = 1;
+	}
+
+	bt_rfk = rfkill_alloc("bluetooth", &pdev->dev,
+		RFKILL_TYPE_BLUETOOTH,
+		&bt_rfkill_ops, pdata);
+
+	if (!bt_rfk) {
+		pr_info("rfk alloc fail\n");
+		ret = -ENOMEM;
+		goto err_rfk_alloc;
+	}
+
+	rfkill_init_sw_state(bt_rfk, false);
+	ret = rfkill_register(bt_rfk);
+	if (ret) {
+		pr_err("rfkill_register fail\n");
+		goto err_rfkill;
+	}
+
+	prdata = kmalloc(sizeof(struct bt_device_runtime_data), GFP_KERNEL);
+	if (!prdata)
+		goto err_rfkill;
+
+	prdata->bt_rfk = bt_rfk;
+	prdata->pdata = pdata;
+	platform_set_drvdata(pdev, prdata);
+
+#ifdef CONFIG_AMLOGIC_LEGACY_EARLY_SUSPEND
+	bt_early_suspend.level =
+		EARLY_SUSPEND_LEVEL_DISABLE_FB;
+	bt_early_suspend.suspend = bt_earlysuspend;
+	bt_early_suspend.resume = bt_lateresume;
+	bt_early_suspend.param = pdev;
+	register_early_suspend(&bt_early_suspend);
+#endif
+
+	return 0;
+
+err_rfkill:
+	rfkill_destroy(bt_rfk);
+err_rfk_alloc:
+	bt_device_deinit(pdata);
+err_res:
+	return ret;
+
+}
+
+static int bt_remove(struct platform_device *pdev)
+{
+	struct bt_device_runtime_data *prdata = platform_get_drvdata(pdev);
+	struct rfkill *rfk = NULL;
+	struct bt_dev_data *pdata = NULL;
+
+	platform_set_drvdata(pdev, NULL);
+
+	if (prdata) {
+		rfk = prdata->bt_rfk;
+		pdata = prdata->pdata;
+	}
+
+	if (pdata) {
+		bt_device_deinit(pdata);
+		kfree(pdata);
+	}
+
+	if (rfk) {
+		rfkill_unregister(rfk);
+		rfkill_destroy(rfk);
+	}
+	rfk = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id bt_dev_dt_match[] = {
+	{	.compatible = "amlogic, bt-dev",
+	},
+	{},
+};
+#else
+#define bt_dev_dt_match NULL
+#endif
+
+static struct platform_driver bt_driver = {
+	.driver		= {
+		.name	= "bluetooth",
+		.of_match_table = bt_dev_dt_match,
+	},
+	.probe = bt_probe,
+	.remove = bt_remove,
+	.suspend = bt_suspend,
+	.resume = bt_resume,
+};
+
+static int __init bt_init(void)
+{
+	pr_info("bt_init\n");
+	return platform_driver_register(&bt_driver);
+}
+
+static void __exit bt_exit(void)
+{
+	platform_driver_unregister(&bt_driver);
+}
+
+module_init(bt_init);
+module_exit(bt_exit);
+MODULE_DESCRIPTION("bt rfkill");
+MODULE_AUTHOR("");
+MODULE_LICENSE("GPL v2");
+
+/**************** bt mac *****************/
+static int __init mac_addr_set(char *line)
+{
+	if (line) {
+		pr_info("try to read bt mac from emmc key!\n");
+		strncpy(bt_addr, line, sizeof(bt_addr)-1);
+		bt_addr[sizeof(bt_addr)-1] = '\0';
+	}
+
+	return 1;
+}
+
+__setup("mac_bt=", mac_addr_set);
+
+
diff -Naur a/vendor/amlogic/bluetooth/Kconfig b/vendor/amlogic/bluetooth/Kconfig
--- a/vendor/amlogic/bluetooth/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/bluetooth/Kconfig	2022-06-06 09:23:20.004587331 +0800
@@ -0,0 +1,5 @@
+config AMLOGIC_BLUETOOTH
+    bool "Bluetooth Device support"
+    default n
+    help
+      Say Y here if you want to use the BT device.
diff -Naur a/vendor/amlogic/bluetooth/Makefile b/vendor/amlogic/bluetooth/Makefile
--- a/vendor/amlogic/bluetooth/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/bluetooth/Makefile	2022-05-31 11:56:47.709259537 +0800
@@ -0,0 +1 @@
+obj-y += bt_device.o
diff -Naur a/vendor/amlogic/canvas/canvas.c b/vendor/amlogic/canvas/canvas.c
--- a/vendor/amlogic/canvas/canvas.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/canvas/canvas.c	2022-06-30 15:17:45.712876428 +0800
@@ -0,0 +1,385 @@
+/*
+ * vendor/amlogic/media/common/canvas/canvas.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/major.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/irqflags.h>
+#include <linux/of_address.h>
+#include <linux/soc/amlogic/meson-canvas.h>
+
+#include <linux/amlogic/media/canvas/canvas.h>
+
+#define local_fiq_enable()      asm("msr        daifclr, #1" : : : "memory")
+#define local_fiq_disable()     asm("msr        daifset, #1" : : : "memory")
+
+#define NUM_CANVAS 256
+
+struct canvas_device_info {
+	const char *device_name;
+	spinlock_t lock;
+	struct canvas_s canvasPool[NUM_CANVAS];
+	struct meson_canvas *meson_canvas;
+};
+
+static struct canvas_device_info canvas_info;
+
+#define CANVAS_VALID(n) ((n) < NUM_CANVAS && canvas_info.canvasPool[n].used)
+
+#define canvas_lock(info, f, f2) do {\
+		spin_lock_irqsave(&info->lock, f);\
+		raw_local_save_flags(f2);\
+		local_fiq_disable();\
+	} while (0)
+
+#define canvas_unlock(info, f, f2) do {\
+		raw_local_irq_restore(f2);\
+		spin_unlock_irqrestore(&info->lock, f);\
+	} while (0)
+
+static void
+canvas_lut_data_build(ulong addr, u32 width, u32 height, u32 wrap, u32 blkmode,
+	u32 endian, u32 *data_l, u32 *data_h)
+{
+	/*
+	 *DMC_CAV_LUT_DATAL/DMC_CAV_LUT_DATAH
+	 *high 32bits of cavnas data which need to be configured
+	 *to canvas memory.
+	 *64bits CANVAS look up table
+	 *bit 61:58   Endian control.
+	 *bit 61:  1 : switch 2 64bits data inside 128bits boundary.
+	 *0 : no change.
+	 *bit 60:  1 : switch 2 32bits data inside 64bits data boundary.
+	 *0 : no change.
+	 *bit 59:  1 : switch 2 16bits data inside 32bits data boundary.
+	 *0 : no change.
+	 *bit 58:  1 : switch 2 8bits data  inside 16bits data bournday.
+	 *0 : no change.
+	 *bit 57:56.   Canvas block mode.  2 : 64x32, 1: 32x32;
+	 *0 : linear mode.
+	 *bit 55:      canvas Y direction wrap control.
+	 *1: wrap back in y.  0: not wrap back.
+	 *bit 54:      canvas X direction wrap control.
+	 *1: wrap back in X.  0: not wrap back.
+	 *bit 53:41.   canvas Hight.
+	 *bit 40:29.   canvas Width, unit: 8bytes. must in 32bytes boundary.
+	 *that means last 2 bits must be 0.
+	 *bit 28:0.    cavnas start address.   unit. 8 bytes. must be in
+	 *32bytes boundary. that means last 2bits must be 0.
+	 */
+
+#define CANVAS_ADDR_LMASK	0x1fffffff
+#define CANVAS_WIDTH_LMASK	0x7
+#define CANVAS_WADDR_LBIT	0
+#define CANVAS_WIDTH_LWID	3
+#define CANVAS_WIDTH_LBIT	29
+#define CANVAS_WIDTH_HBIT	0
+#define CANVAS_HEIGHT_HBIT	(41 - 32)
+#define CANVAS_WRAPX_HBIT	(54 - 32)
+#define CANVAS_WRAPY_HBIT	(55 - 32)
+#define CANVAS_BLKMODE_HBIT	(56 - 32)
+#define CANVAS_ENDIAN_HBIT	(58 - 32)
+#define CANVAS_HEIGHT_MASK	0x1fff
+#define CANVAS_HEIGHT_BIT	9
+
+	u32 addr_bits_l = ((addr + 7) >> 3 & CANVAS_ADDR_LMASK)
+		<< CANVAS_WADDR_LBIT;
+
+	u32 width_l = ((((width + 7) >> 3) & CANVAS_WIDTH_LMASK)
+		<< CANVAS_WIDTH_LBIT);
+
+	u32 width_h = ((((width + 7) >> 3) >> CANVAS_WIDTH_LWID)
+		<< CANVAS_WIDTH_HBIT);
+
+	u32 height_h = (height & CANVAS_HEIGHT_MASK)
+		<< CANVAS_HEIGHT_BIT;
+
+	u32 wrap_h = (wrap & (CANVAS_ADDR_WRAPX | CANVAS_ADDR_WRAPY));
+
+	u32 blkmod_h = (blkmode & CANVAS_BLKMODE_MASK)
+		<< CANVAS_BLKMODE_HBIT;
+
+	u32 switch_bits_ctl = (endian & 0xf)
+		<< CANVAS_ENDIAN_HBIT;
+
+	*data_l = addr_bits_l | width_l;
+	*data_h = width_h | height_h | wrap_h | blkmod_h | switch_bits_ctl;
+}
+
+static void canvas_config_locked(u32 index, struct canvas_s *p)
+{
+	struct canvas_device_info *info = &canvas_info;
+	u32 datal, datah;
+
+	canvas_lut_data_build(p->addr,
+			p->width,
+			p->height,
+			p->wrap,
+			p->blkmode,
+			p->endian, &datal, &datah);
+
+	meson_canvas_config(info->meson_canvas, (u8)index,
+			p->addr, p->width, p->height,
+			p->wrap, p->blkmode,
+			p->endian);
+
+	p->dataL = datal;
+	p->dataH = datah;
+}
+
+void canvas_config_ex(u32 index, ulong addr, u32 width, u32 height, u32 wrap,
+	u32 blkmode, u32 endian)
+{
+	struct canvas_device_info *info = &canvas_info;
+	struct canvas_s *canvas;
+	unsigned long flags, fiqflags;
+	if (!CANVAS_VALID(index))
+		return;
+
+	canvas_lock(info, flags, fiqflags);
+	canvas = &info->canvasPool[index];
+	canvas->addr = addr;
+	canvas->width = width;
+	canvas->height = height;
+	canvas->wrap = wrap;
+	canvas->blkmode = blkmode;
+	canvas->endian = endian;
+	canvas_config_locked(index, canvas);
+	canvas_unlock(info, flags, fiqflags);
+}
+EXPORT_SYMBOL(canvas_config_ex);
+
+void canvas_config_config(u32 index, struct canvas_config_s *cfg)
+{
+	canvas_config_ex(index, cfg->phy_addr,
+		cfg->width, cfg->height, CANVAS_ADDR_NOWRAP,
+		cfg->block_mode, cfg->endian);
+}
+EXPORT_SYMBOL(canvas_config_config);
+
+void canvas_config(u32 index, ulong addr, u32 width, u32 height, u32 wrap,
+	u32 blkmode)
+{
+	return canvas_config_ex(index, addr, width, height, wrap, blkmode, 0);
+}
+EXPORT_SYMBOL(canvas_config);
+
+void canvas_read(u32 index, struct canvas_s *p)
+{
+	struct canvas_device_info *info = &canvas_info;
+
+	if (CANVAS_VALID(index))
+		*p = info->canvasPool[index];
+}
+EXPORT_SYMBOL(canvas_read);
+
+void canvas_copy(u32 src, u32 dst)
+{
+	struct canvas_device_info *info = &canvas_info;
+	struct canvas_s *canvas_src = &info->canvasPool[src];
+	struct canvas_s *canvas_dst = &info->canvasPool[dst];
+	unsigned long flags, fiqflags;
+
+	if (!CANVAS_VALID(src) || !CANVAS_VALID(dst))
+		return;
+
+	canvas_lock(info, flags, fiqflags);
+	canvas_dst->addr = canvas_src->addr;
+	canvas_dst->width = canvas_src->width;
+	canvas_dst->height = canvas_src->height;
+	canvas_dst->wrap = canvas_src->wrap;
+	canvas_dst->blkmode = canvas_src->blkmode;
+	canvas_dst->endian = canvas_src->endian;
+	canvas_dst->dataH = canvas_src->dataH;
+	canvas_dst->dataL = canvas_src->dataL;
+	canvas_config_locked(dst, canvas_dst);
+	canvas_unlock(info, flags, fiqflags);
+}
+EXPORT_SYMBOL(canvas_copy);
+
+void canvas_update_addr(u32 index, u32 addr)
+{
+	struct canvas_device_info *info = &canvas_info;
+	struct canvas_s *canvas;
+	unsigned long flags, fiqflags;
+
+	if (!CANVAS_VALID(index))
+		return;
+	canvas = &info->canvasPool[index];
+
+	canvas_lock(info, flags, fiqflags);
+	canvas->addr = addr;
+	canvas_config_locked(index, canvas);
+	canvas_unlock(info, flags, fiqflags);
+
+	return;
+}
+EXPORT_SYMBOL(canvas_update_addr);
+
+unsigned int canvas_get_addr(u32 index)
+{
+	struct canvas_device_info *info = &canvas_info;
+
+	return info->canvasPool[index].addr;
+}
+EXPORT_SYMBOL(canvas_get_addr);
+
+unsigned int canvas_get_width(u32 index)
+{
+	struct canvas_device_info *info = &canvas_info;
+
+	if (!CANVAS_VALID(index))
+		return 0;
+
+	return info->canvasPool[index].width;
+}
+EXPORT_SYMBOL(canvas_get_width);
+
+unsigned int canvas_get_height(u32 index)
+{
+	struct canvas_device_info *info = &canvas_info;
+
+	if (!CANVAS_VALID(index))
+		return 0;
+
+	return info->canvasPool[index].height;
+}
+EXPORT_SYMBOL(canvas_get_height);
+
+
+static int alloc_canvas_range(struct canvas_device_info *info, uint8_t start, uint8_t end)
+{
+	uint8_t i, j;
+	for (i = start; i <= end; i++) {
+		if (meson_canvas_alloc_spec(info->meson_canvas, i)) {
+			// free before fail out.
+			for (j = start; j < i; j++) {
+				meson_canvas_free(info->meson_canvas, j);
+				info->canvasPool[j].used = 0;
+			}
+			return -1;
+		}
+		info->canvasPool[i].used = 1;
+	}
+
+	pr_info("Alloc Canvas: [%u, %u]\n", start, end);
+	
+	return 0;
+}
+
+static void free_canvas_range(struct canvas_device_info *info, uint8_t start, uint8_t end)
+{
+	uint8_t i;
+	for (i = start; i <= end; i++) {
+		meson_canvas_free(info->meson_canvas, i);
+		info->canvasPool[i].used = 0;
+	}
+}
+
+static int canvas_probe(struct platform_device *pdev)
+{
+	struct canvas_device_info *info = &canvas_info;
+	struct device *dev = &pdev->dev;
+	
+	memset(info, 0, sizeof(*info));
+
+	info->meson_canvas = meson_canvas_get(dev);
+	if (IS_ERR(info->meson_canvas)) {
+		dev_err(dev, "meson_canvas_get() failed. check your dts\n");
+		return -1;
+	}
+	
+	spin_lock_init(&info->lock);
+
+	// Pre-Alloc canvas for "VDec" : [0x78, 0xbf]
+	if (alloc_canvas_range(info, 0x78, 0xbf)) {
+		dev_err(dev, "alloc_canvas_range(0x78, 0xbf) failed\n");
+		return -EBUSY;
+	}
+	
+	// Pre-Alloc canvas for "VEnc" : [0xe4, 0xef]
+	if (alloc_canvas_range(info, 0xe4, 0xef)) {
+		dev_err(dev, "alloc_canvas_range(0xe4, 0xef) failed\n");
+		return -EBUSY;
+	}
+
+	dev_info(dev, "canvas_legacy probe success\n");
+	
+	return 0;
+}
+
+/* static int __devexit canvas_remove(struct platform_device *pdev) */
+static int canvas_remove(struct platform_device *pdev)
+{
+	struct canvas_device_info *info = &canvas_info;
+	struct device *dev = &pdev->dev;
+
+	// Free canvas
+	free_canvas_range(info, 0x78, 0xbf);
+	free_canvas_range(info, 0xe4, 0xef);
+	
+	dev_info(dev, "Canvas driver removed.\n");
+	
+	return 0;
+}
+
+static const struct of_device_id canvas_dt_match[] = {
+	{
+		.compatible = "amlogic, meson, canvas_legacy", 
+	},
+	{},
+};
+
+static struct platform_driver canvas_driver = {
+	.probe = canvas_probe,
+	.remove = canvas_remove,
+	.driver = {
+		.name = "amlogic-canvas-legacy",
+		.of_match_table = canvas_dt_match,
+	},
+};
+
+static int __init amcanvas_init(void)
+{
+	int r;
+	
+	r = platform_driver_register(&canvas_driver);
+	if (r) {
+			pr_err("Unable to register canvas driver\n");
+			return r;
+	}
+	pr_info("register canvas platform driver\n");
+	
+	return 0;
+}
+
+static void __exit amcanvas_exit(void)
+{
+}
+
+module_init(amcanvas_init);
+module_exit(amcanvas_exit);
+
+MODULE_DESCRIPTION("AMLOGIC Canvas management driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tim Yao <timyao@amlogic.com>");
diff -Naur a/vendor/amlogic/canvas/Kconfig b/vendor/amlogic/canvas/Kconfig
--- a/vendor/amlogic/canvas/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/canvas/Kconfig	2022-05-31 11:56:47.709259537 +0800
@@ -0,0 +1,13 @@
+#
+# Canvas management driver configuration
+#
+
+menu "Canvas management driver"
+
+config AMLOGIC_MEDIA_CANVAS
+	bool "Amlogic Canvas management driver"
+	default n
+	help
+		Select to enable Canvas management driver.
+
+endmenu
diff -Naur a/vendor/amlogic/canvas/Makefile b/vendor/amlogic/canvas/Makefile
--- a/vendor/amlogic/canvas/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/canvas/Makefile	2022-05-31 11:56:47.709259537 +0800
@@ -0,0 +1,5 @@
+#
+# Makefile for the Canvas management driver.
+#
+
+obj-$(CONFIG_AMLOGIC_MEDIA_CANVAS) += canvas.o
diff -Naur a/vendor/amlogic/codecs/es7243.c b/vendor/amlogic/codecs/es7243.c
--- a/vendor/amlogic/codecs/es7243.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/codecs/es7243.c	2022-05-31 11:57:06.789097100 +0800
@@ -0,0 +1,331 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <sound/soc.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include "es7243.h"
+
+struct es7243_reg {
+	u8 reg_index;
+	u8 reg_value;
+};
+
+struct es7243_priv {
+	struct clk *mclk;
+};
+
+static int count = 0;
+struct i2c_client *es7243_i2c_client[4];
+struct i2c_client *es724310_i2c_client;
+static struct es7243_reg init_mode[] = {
+	/* slave mode, software mode */
+	{ES7243_MODECFG_REG00, 0x01},
+};
+
+#define ES7243_INIT_NUM ARRAY_SIZE(init_mode)
+
+/* The Sequence for Startup  slave mode */
+static struct es7243_reg startup_mode[] = {
+	{ES7243_STATECTL_REG06, 0x18},
+	{ES7243_SDPFMT_REG01, 0x0c},
+	{ES7243_LRCDIV_REG02, 0x10},
+	{ES7243_BCKDIV_REG03, 0x04},
+	{ES7243_CLKDIV_REG04, 0x02},
+	{ES7243_MUTECTL_REG05, 0x1A},
+	{ES7243_ANACTL1_REG08, 0x43},//0x11
+	{ES7243_ANACTL0_REG07, 0x80},
+	{ES7243_ANACTL2_REG09, 0x00},
+	{ES7243_STMOSR_REG0D, 0xa0},
+	{ES7243_STATECTL_REG06, 0x00},
+	{ES7243_MUTECTL_REG05, 0x13},
+
+};
+#define ES7243_STARTUP_NUM ARRAY_SIZE(startup_mode)
+
+/* The sequence for Standby mode  */
+static struct es7243_reg standby_mode[] = {
+	{ES7243_STATECTL_REG06, 0x05},
+	/* Mute ADC  */
+	{ES7243_MUTECTL_REG05, 0x1B},
+	{ES7243_STATECTL_REG06, 0x5C},
+	/* {ES7243_ANACTL0_REG07, 0x3F}, */
+	/* {ES7243_ANACTL1_REG08, 0x4B}, */
+	{ES7243_ANACTL2_REG09, 0x9F},
+};
+#define ES7243_STANDBY_NUM ARRAY_SIZE(standby_mode)
+
+static int es7243_i2c_write(struct i2c_client *client, u8 reg, u8 value)
+{
+	u8 data[2];
+
+	data[0] = reg;
+	data[1] = value;
+
+	if (i2c_master_send(client, data, 2) == 2)
+		return 0;
+	else
+		return -EIO;
+}
+
+static int es7243_i2c_read(struct i2c_client *client, u8 reg)
+{
+	struct i2c_msg xfer[2];
+	u8 data;
+	int ret;
+
+	/* Write register */
+	xfer[0].addr = client->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = 1;
+	xfer[0].buf = &reg;
+	/* Read data */
+	xfer[1].addr = client->addr;
+	xfer[1].flags = I2C_M_RD;
+	xfer[1].len = 2;
+	xfer[1].buf = (u8 *)&data;
+
+	ret = i2c_transfer(client->adapter, xfer, 2);
+	if (ret != 2) {
+		dev_err(&client->dev, "i2c_transfer() returned %d\n", ret);
+		return 0;
+	}
+
+	return data;
+}
+
+int es7243_init_mode(struct i2c_client *client)
+{
+	int i = 0;
+	int err = 0;
+
+	for(i = 0; i < ES7243_INIT_NUM; i++) {
+		err = es7243_i2c_write(client, init_mode[i].reg_index,
+				init_mode[i].reg_value);
+		if(err != 0 )
+			dev_err(&client->dev, "i2c write 0x%0x failed\n",
+					init_mode[i].reg_index);
+	}
+	
+	return err;
+}
+
+int es7243_startup(struct i2c_client *client)
+{
+	int i = 0;
+	int err = 0;
+	printk("%s\n", __func__);
+	for(i = 0; i < ES7243_STARTUP_NUM; i++) {
+		err = es7243_i2c_write(client, startup_mode[i].reg_index,
+				startup_mode[i].reg_value);
+		if(err != 0 )
+			dev_err(&client->dev, "i2c write 0x%0x failed\n",
+					startup_mode[i].reg_index);
+	}
+	for(i = 0; i < 0xf; i++)
+		dev_info(&client->dev, "0x%0x -- 0x%0x\n",
+			 i, es7243_i2c_read(client, i));
+	mdelay(50);
+	return 0;
+}
+
+int es7243_start(void)
+{
+	int i = 0;
+	for(i = 0; i < count; i++)
+		es7243_startup(es7243_i2c_client[i]);
+	return 0;
+}
+
+EXPORT_SYMBOL(es7243_start);
+
+int es7243_init(void)
+{
+	int i = 0;
+	int err = 0;
+
+	for (i = 0; i < count; i++) {
+		err = es7243_init_mode(es7243_i2c_client[i]);
+		if (err == 0) {
+            dev_info(&es7243_i2c_client[i]->dev, "snd soc: es7243\n");
+        }
+    }
+
+	return 0;
+}
+
+EXPORT_SYMBOL(es7243_init);
+
+int es7243_set_standby(struct i2c_client *client)
+{
+	int i = 0;
+	int err = 0;
+
+	for(i = 0; i < ES7243_STANDBY_NUM; i++) {
+		err = es7243_i2c_write(client, standby_mode[i].reg_index,
+				standby_mode[i].reg_value);
+		if(err != 0 )
+			dev_err(&client->dev, "i2c write 0x%0x failed\n",
+					standby_mode[i].reg_index);
+	}
+	for(i = 0; i < 0xf; i++)
+		dev_info(&client->dev, "0x%0x -- 0x%0x\n",
+			 i, es7243_i2c_read(client, i));
+	return 0;
+}
+
+int es7243_standby(void)
+{
+	int i = 0;
+	for(i = 0; i < count; i++)
+		es7243_set_standby(es7243_i2c_client[i]);
+	return 0;
+}
+EXPORT_SYMBOL(es7243_standby);
+static const struct snd_soc_dapm_widget es7243_widgets[] = {
+		SND_SOC_DAPM_INPUT("RX"),
+		SND_SOC_DAPM_OUTPUT("TX"),
+};
+
+static const struct snd_soc_dapm_route es7243_routes[] = {
+	{ "Capture", NULL, "RX" },
+	{ "TX", NULL, "Playback" },
+};
+
+static int es7243_dai_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai){
+	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+	if(!playback){
+		es7243_start();
+	}
+
+	return 0;
+}
+
+static void es7243_dai_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai){
+	bool playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);
+	if(!playback){
+		es7243_standby();
+	}
+}
+
+static const struct snd_soc_dai_ops es7243_dai_ops = {
+	.startup   = es7243_dai_startup,
+	.shutdown  = es7243_dai_shutdown,
+};
+
+static struct snd_soc_dai_driver es7243_dai = {
+	.name = "es7243-mic-array",
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 8,
+		.rates = SNDRV_PCM_RATE_8000_96000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &es7243_dai_ops,
+};
+
+static const struct of_device_id of_es7243_match[] = {
+	{ .compatible = "everest,es7243"},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, of_es7243_match);
+
+static int es7243_probe(struct snd_soc_component *codec)
+{
+	es7243_init();
+	return 0;
+}
+
+static void es7243_remove(struct snd_soc_component *codec)
+{
+	return ;
+}
+
+static int es7243_i2c_remove(struct i2c_client *client)
+{
+	snd_soc_unregister_component(&client->dev);
+	return 0;
+}
+
+static struct snd_soc_component_driver es7243_component_driver = {
+	.probe =	es7243_probe,
+	.remove =	es7243_remove,
+	.dapm_widgets = es7243_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(es7243_widgets),
+	.dapm_routes = es7243_routes,
+	.num_dapm_routes = ARRAY_SIZE(es7243_routes),
+};
+
+static int es7243_i2c_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	const struct of_device_id *match;
+	struct device *dev = &client->dev;
+	int ret = 0;
+	struct es7243_priv *es7243;
+
+	es7243 = devm_kzalloc(&client->dev, sizeof(*es7243), GFP_KERNEL);
+	if (!es7243)
+		return -ENOMEM;
+	i2c_set_clientdata(client, es7243);
+
+	if (dev->of_node) {
+		match = of_match_device(of_es7243_match, dev);
+		if (!match) {
+			dev_err(dev, "Failed to find matching dt id\n");
+			return -EINVAL;
+		}
+	}
+
+	es7243_i2c_client[count] = client;
+	count++;
+	ret = snd_soc_register_component(&client->dev,
+			&es7243_component_driver,
+			&es7243_dai, 1);
+
+	return ret;
+}
+
+static const struct i2c_device_id es7243_id[] = {
+	{"es7243"},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, es7243_id);
+
+static struct i2c_driver es7243_driver = {
+	.driver         = {
+		.name   = "es7243",
+		.of_match_table = of_es7243_match,
+	},
+	.probe          = es7243_i2c_probe,
+	.remove         = es7243_i2c_remove,
+	.id_table       = es7243_id,
+};
+
+static int __init es7243_driver_init(void)
+{
+	return i2c_add_driver(&es7243_driver);
+}
+late_initcall_sync(es7243_driver_init);
+
+static void __exit es7243_driver_exit(void)
+{
+	return i2c_del_driver(&es7243_driver);
+}
+module_exit(es7243_driver_exit);
+
+
+MODULE_AUTHOR("AlgoIdeas <yu19881234@163.com>");
+MODULE_DESCRIPTION("ES7243 I2C Codec Driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/vendor/amlogic/codecs/es7243.h b/vendor/amlogic/codecs/es7243.h
--- a/vendor/amlogic/codecs/es7243.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/codecs/es7243.h	2022-05-31 11:57:06.789097100 +0800
@@ -0,0 +1,34 @@
+/*
+ * ALSA SoC ES7243 codec driver
+ *
+ * Author:      David Yang, <yangxiaohua@everest-semi.com>
+ *													or
+ *													<info@everest-semi.com>
+ * Copyright:   (C) 2017 Everest Semiconductor Co., Ltd
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _ES7243_H
+#define _ES7243_H
+
+/* Codec TLV320AIC23 */
+#define ES7243_MODECFG_REG00		0x00
+#define ES7243_SDPFMT_REG01		0x01
+#define ES7243_LRCDIV_REG02		0x02
+#define ES7243_BCKDIV_REG03		0x03
+#define ES7243_CLKDIV_REG04		0x04
+#define ES7243_MUTECTL_REG05		0x05
+#define ES7243_STATECTL_REG06			0x06
+#define ES7243_ANACTL0_REG07		0x07
+#define ES7243_ANACTL1_REG08		0x08
+#define ES7243_ANACTL2_REG09		0x09
+#define ES7243_ANACHARG_REG0A		0x0A
+#define ES7243_INISTATE_REG0B		0x0B
+#define ES7243_BIAS_REG0C		0x0C
+#define ES7243_STMOSR_REG0D		0x0D
+#define ES7243_CHIPID_REG0E		0x0E
+
+#endif /* _ES7243_H_ */
\ No newline at end of file
diff -Naur a/vendor/amlogic/codecs/Kconfig b/vendor/amlogic/codecs/Kconfig
--- a/vendor/amlogic/codecs/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/codecs/Kconfig	2022-06-30 17:25:19.016549738 +0800
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config SND_SOC_ES7243
+	tristate "Everest Semi ES7243 CODEC"
+	depends on I2C
diff -Naur a/vendor/amlogic/codecs/Makefile b/vendor/amlogic/codecs/Makefile
--- a/vendor/amlogic/codecs/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/codecs/Makefile	2022-06-30 17:27:14.915329125 +0800
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+snd-soc-es7243-objs := es7243.o
+obj-$(CONFIG_SND_SOC_ES7243)	+= snd-soc-es7243.o
diff -Naur a/vendor/amlogic/cpu_version/Kconfig b/vendor/amlogic/cpu_version/Kconfig
--- a/vendor/amlogic/cpu_version/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/cpu_version/Kconfig	2022-05-31 11:56:47.709259537 +0800
@@ -0,0 +1,26 @@
+menuconfig AMLOGIC_CPU_VERSION
+    bool "Amlogic cpu version support"
+    default n
+    help
+      This is the Amlogic CPU version interface driver
+
+if AMLOGIC_CPU_VERSION
+
+config	AMLOGIC_MESON64_VERSION
+	bool "Amlogic Meson64 cpu version"
+	default n
+	help
+	  say y to enable
+	  Amlogic gx-X
+	  cpu version driver
+	  .
+
+config	AMLOGIC_M8B_MESON32_VERSION
+	bool "Amlogic M8b Meson32 cpu version"
+	default n
+	help
+	  say y to enable
+	  Amlogic M8b
+	  cpu version driver
+
+endif
diff -Naur a/vendor/amlogic/cpu_version/Makefile b/vendor/amlogic/cpu_version/Makefile
--- a/vendor/amlogic/cpu_version/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/cpu_version/Makefile	2022-05-31 11:56:47.709259537 +0800
@@ -0,0 +1,2 @@
+obj-$(CONFIG_AMLOGIC_MESON64_VERSION)	+= meson64_cpu.o
+obj-$(CONFIG_AMLOGIC_M8B_MESON32_VERSION)	+= meson32_cpu.o
\ No newline at end of file
diff -Naur a/vendor/amlogic/cpu_version/meson32_cpu.c b/vendor/amlogic/cpu_version/meson32_cpu.c
--- a/vendor/amlogic/cpu_version/meson32_cpu.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/cpu_version/meson32_cpu.c	2022-06-24 14:37:49.436821008 +0800
@@ -0,0 +1,95 @@
+/*
+ * vendor/amlogic/cpu_version/meson32_cpu.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/meson-secure.h>
+
+#define IO_REGS_BASE		0xFE000000
+#define IO_BOOTROM_BASE	(IO_REGS_BASE + 0x010000) /*64K*/
+
+static int meson_cpu_version[MESON_CPU_VERSION_LVL_MAX+1];
+int __init meson_cpu_version_init(void)
+{
+	unsigned int version, ver;
+	struct device_node *cpu_version;
+	void __iomem  *assist_hw_rev0;
+	void __iomem  *assist_hw_rev1;
+	void __iomem  *assist_hw_rev2;
+	unsigned int  *version_map;
+
+	cpu_version = of_find_node_by_name(NULL, "cpu_version");
+	if (!cpu_version) {
+		pr_warn(" Not find cpu_version in dts. %s\n", __func__);
+		return 0;
+	}
+
+	assist_hw_rev0 = of_iomap(cpu_version, 0);
+	assist_hw_rev1 = of_iomap(cpu_version, 1);
+	assist_hw_rev2 = of_iomap(cpu_version, 2);
+
+	if (!assist_hw_rev0 || !assist_hw_rev1 || !assist_hw_rev2) {
+		pr_warn("%s: iomap failed: %p %p %p\n", __func__,
+			assist_hw_rev0, assist_hw_rev1, assist_hw_rev2);
+		return 0;
+	}
+
+	meson_cpu_version[MESON_CPU_VERSION_LVL_MAJOR] = readl(assist_hw_rev0);
+
+	if (meson_secure_enabled()) {
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MISC] =
+			meson_read_socrev1();
+	} else {
+		version_map = (unsigned int *)assist_hw_rev2;
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MISC] = version_map[1];
+	}
+
+	version = readl(assist_hw_rev1);
+	switch (version) {
+	case 0x11111111:
+		ver = 0xA;
+		break;
+	default:
+		ver = 0xB;
+		break;
+	}
+	meson_cpu_version[MESON_CPU_VERSION_LVL_MINOR] = ver;
+	pr_info("Meson chip version = Rev%X (%X:%X - %X:%X)\n", ver,
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MAJOR],
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MINOR],
+		meson_cpu_version[MESON_CPU_VERSION_LVL_PACK],
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MISC]
+		);
+	return 0;
+}
+EXPORT_SYMBOL(meson_cpu_version_init);
+
+int get_meson_cpu_version(int level)
+{
+	if (level >= 0 && level <= MESON_CPU_VERSION_LVL_MAX)
+		return meson_cpu_version[level];
+	return 0;
+}
+EXPORT_SYMBOL(get_meson_cpu_version);
+early_initcall(meson_cpu_version_init);
diff -Naur a/vendor/amlogic/cpu_version/meson64_cpu.c b/vendor/amlogic/cpu_version/meson64_cpu.c
--- a/vendor/amlogic/cpu_version/meson64_cpu.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/cpu_version/meson64_cpu.c	2022-06-24 14:37:49.458054143 +0800
@@ -0,0 +1,98 @@
+/*
+ * vendor/amlogic/cpu_version/meson64_cpu.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+static int meson_cpu_version[MESON_CPU_VERSION_LVL_MAX+1];
+void __iomem  *assist_hw_rev;
+
+int get_meson_cpu_version(int level)
+{
+	if (level >= 0 && level <= MESON_CPU_VERSION_LVL_MAX)
+		return meson_cpu_version[level];
+	return 0;
+}
+EXPORT_SYMBOL(get_meson_cpu_version);
+
+/*
+ * detect if a cpu id is big cpu
+ */
+int arch_big_cpu(int cpu)
+{
+	int type;
+	struct device_node *cpu_version;
+
+	cpu_version = of_find_node_by_name(NULL, "cpu_version");
+	if (cpu_version)
+		assist_hw_rev = of_iomap(cpu_version, 0);
+	else
+		return 0;
+
+	type = readl(assist_hw_rev) >> 24;
+	switch (type) {
+	case MESON_CPU_MAJOR_ID_GXM:	/* 0 ~ 3 is faster cpu for GXM */
+		if (cpu < 4)
+			return 1;
+
+	default:
+		return 0;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(arch_big_cpu);
+
+static unsigned int cpu_version_init;
+int __init meson_cpu_version_init(void)
+{
+	unsigned int ver;
+	struct device_node *cpu_version;
+
+	if (!cpu_version_init)
+		cpu_version_init = 1;
+	else
+		return 0;
+
+	cpu_version = of_find_node_by_name(NULL, "cpu_version");
+	if (cpu_version)
+		assist_hw_rev = of_iomap(cpu_version, 0);
+	else
+		return 0;
+
+	meson_cpu_version[MESON_CPU_VERSION_LVL_MAJOR] =
+		readl(assist_hw_rev) >> 24;
+
+	ver = (readl(assist_hw_rev) >> 8) & 0xff;
+
+	meson_cpu_version[MESON_CPU_VERSION_LVL_MINOR] = ver;
+	ver =  (readl(assist_hw_rev) >> 16) & 0xff;
+	meson_cpu_version[MESON_CPU_VERSION_LVL_PACK] = ver;
+	pr_info("Meson chip version = Rev%X (%X:%X - %X:%X)\n",
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MINOR],
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MAJOR],
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MINOR],
+		meson_cpu_version[MESON_CPU_VERSION_LVL_PACK],
+		meson_cpu_version[MESON_CPU_VERSION_LVL_MISC]
+		);
+	return 0;
+}
+early_initcall(meson_cpu_version_init);
diff -Naur a/vendor/amlogic/ge2d/bitblt.c b/vendor/amlogic/ge2d/bitblt.c
--- a/vendor/amlogic/ge2d/bitblt.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/bitblt.c	2022-06-24 14:37:49.483067496 +0800
@@ -0,0 +1,120 @@
+/*
+ * vendor/amlogic/media/common/ge2d/bitblt.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* Amlogic Headers */
+#include <linux/amlogic/media/ge2d/ge2d.h>
+
+static void _bitblt(struct ge2d_context_s *wq,
+			   int src_x, int src_y, int w, int h,
+			   int dst_x, int dst_y, int block)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + h - 1;
+
+	ge2d_cmd_cfg->dst_x_start = dst_x;
+	ge2d_cmd_cfg->dst_x_end   = dst_x + w - 1;
+	ge2d_cmd_cfg->dst_y_start = dst_y;
+	ge2d_cmd_cfg->dst_y_end   = dst_y + h - 1;
+
+	ge2d_cmd_cfg->sc_hsc_en = 0;
+	ge2d_cmd_cfg->sc_vsc_en = 0;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+	ge2d_cmd_cfg->hsc_div_en = 0;
+	ge2d_cmd_cfg->hsc_adv_num = 0;
+
+	ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->wait_done_flag   = block;
+
+	ge2d_wq_add_work(wq);
+}
+
+static void _bitblt_noalpha(struct ge2d_context_s *wq,
+				   int src_x, int src_y, int w, int h,
+				   int dst_x, int dst_y, int block)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+	if (dp_gen_cfg->alu_const_color != 0xff) {
+		dp_gen_cfg->alu_const_color = 0xff;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + h - 1;
+
+	ge2d_cmd_cfg->sc_hsc_en = 0;
+	ge2d_cmd_cfg->sc_vsc_en = 0;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+	ge2d_cmd_cfg->hsc_div_en = 0;
+	ge2d_cmd_cfg->hsc_adv_num = 0;
+
+	ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET;
+	ge2d_cmd_cfg->wait_done_flag   = block;
+
+	ge2d_wq_add_work(wq);
+}
+
+void bitblt(struct ge2d_context_s *wq,
+	    int src_x, int src_y, int w, int h,
+	    int dst_x, int dst_y)
+{
+	_bitblt(wq, src_x, src_y, w, h, dst_x, dst_y, 1);
+}
+EXPORT_SYMBOL(bitblt);
+
+void bitblt_noblk(struct ge2d_context_s *wq,
+		  int src_x, int src_y, int w, int h,
+		  int dst_x, int dst_y)
+{
+	_bitblt(wq, src_x, src_y, w, h, dst_x, dst_y, 0);
+}
+EXPORT_SYMBOL(bitblt_noblk);
+
+void bitblt_noalpha(struct ge2d_context_s *wq,
+		    int src_x, int src_y, int w, int h,
+		    int dst_x, int dst_y)
+{
+	_bitblt_noalpha(wq, src_x, src_y, w, h, dst_x, dst_y, 1);
+}
+EXPORT_SYMBOL(bitblt_noalpha);
+
+void bitblt_noalpha_noblk(struct ge2d_context_s *wq,
+			  int src_x, int src_y, int w, int h,
+			  int dst_x, int dst_y)
+{
+	_bitblt_noalpha(wq, src_x, src_y, w, h, dst_x, dst_y, 0);
+}
+EXPORT_SYMBOL(bitblt_noalpha_noblk);
diff -Naur a/vendor/amlogic/ge2d/blend.c b/vendor/amlogic/ge2d/blend.c
--- a/vendor/amlogic/ge2d/blend.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/blend.c	2022-06-24 14:37:49.506248515 +0800
@@ -0,0 +1,297 @@
+/*
+ * vendor/amlogic/media/common/ge2d/blend.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+/* Linux Headers */
+#include <linux/types.h>
+
+/* Amlogic Headers */
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/media/ge2d/ge2d.h>
+
+void blend(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + src_w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + src_h - 1;
+
+	ge2d_cmd_cfg->src2_x_start = src2_x;
+	ge2d_cmd_cfg->src2_x_end   = src2_x + src2_w - 1;
+	ge2d_cmd_cfg->src2_y_start = src2_y;
+	ge2d_cmd_cfg->src2_y_end   = src2_y + src2_h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + dst_w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + dst_h - 1;
+
+	/* if ((dst_w != src_w) || (dst_h != src_h)) { */
+	if (1) {
+		ge2d_cmd_cfg->sc_hsc_en = 1;
+		ge2d_cmd_cfg->sc_vsc_en = 1;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+		ge2d_cmd_cfg->hsc_div_en = 1;
+#ifdef CONFIG_GE2D_ADV_NUM
+		ge2d_cmd_cfg->hsc_adv_num =
+			((dst_w - 1) < 1024) ? (dst_w - 1) : 0;
+#else
+		ge2d_cmd_cfg->hsc_adv_num = 0;
+#endif
+	} else {
+		ge2d_cmd_cfg->sc_hsc_en = 0;
+		ge2d_cmd_cfg->sc_vsc_en = 0;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+		ge2d_cmd_cfg->hsc_div_en = 0;
+		ge2d_cmd_cfg->hsc_adv_num = 0;
+	}
+
+	ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
+	ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
+	ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
+	ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
+	ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
+
+	if (get_cpu_type() != MESON_CPU_MAJOR_ID_AXG) {
+		if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
+			ge2d_cmd_cfg->color_logic_op =
+				ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
+			ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+		}
+	}
+	ge2d_cmd_cfg->alpha_blend_mode = (op >> 8) & 0xff;
+	if (ge2d_cmd_cfg->alpha_blend_mode >= BLENDOP_LOGIC) {
+		ge2d_cmd_cfg->alpha_logic_op =
+			ge2d_cmd_cfg->alpha_blend_mode - BLENDOP_LOGIC;
+		ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	}
+
+	ge2d_cmd_cfg->wait_done_flag   = 1;
+
+	ge2d_wq_add_work(wq);
+}
+EXPORT_SYMBOL(blend);
+
+void blend_noblk(struct ge2d_context_s *wq,
+		 int src_x, int src_y, int src_w, int src_h,
+		 int src2_x, int src2_y, int src2_w, int src2_h,
+		 int dst_x, int dst_y, int dst_w, int dst_h,
+		 int op)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + src_w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + src_h - 1;
+
+	ge2d_cmd_cfg->src2_x_start = src2_x;
+	ge2d_cmd_cfg->src2_x_end   = src2_x + src2_w - 1;
+	ge2d_cmd_cfg->src2_y_start = src2_y;
+	ge2d_cmd_cfg->src2_y_end   = src2_y + src2_h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + dst_w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + dst_h - 1;
+
+	/* if ((dst_w != src_w) || (dst_h != src_h)) { */
+	if (1) {
+		ge2d_cmd_cfg->sc_hsc_en = 1;
+		ge2d_cmd_cfg->sc_vsc_en = 1;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+		ge2d_cmd_cfg->hsc_div_en = 1;
+#ifdef CONFIG_GE2D_ADV_NUM
+		ge2d_cmd_cfg->hsc_adv_num =
+			((dst_w - 1) < 1024) ? (dst_w - 1) : 0;
+#else
+		ge2d_cmd_cfg->hsc_adv_num = 0;
+#endif
+	} else {
+		ge2d_cmd_cfg->sc_hsc_en = 0;
+		ge2d_cmd_cfg->sc_vsc_en = 0;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+		ge2d_cmd_cfg->hsc_div_en = 0;
+		ge2d_cmd_cfg->hsc_adv_num = 0;
+	}
+
+	ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
+	ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
+	ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
+	ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
+	ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
+	if (get_cpu_type() != MESON_CPU_MAJOR_ID_AXG) {
+		if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
+			ge2d_cmd_cfg->color_logic_op =
+				ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
+			ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+		}
+	}
+	ge2d_cmd_cfg->alpha_blend_mode = (op >> 8) & 0xff;
+	if (ge2d_cmd_cfg->alpha_blend_mode >= BLENDOP_LOGIC) {
+		ge2d_cmd_cfg->alpha_logic_op =
+			ge2d_cmd_cfg->alpha_blend_mode - BLENDOP_LOGIC;
+		ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	}
+
+	ge2d_cmd_cfg->wait_done_flag = 0;
+
+	ge2d_wq_add_work(wq);
+}
+EXPORT_SYMBOL(blend_noblk);
+void blend_noalpha(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + src_w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + src_h - 1;
+
+	ge2d_cmd_cfg->src2_x_start = src2_x;
+	ge2d_cmd_cfg->src2_x_end   = src2_x + src2_w - 1;
+	ge2d_cmd_cfg->src2_y_start = src2_y;
+	ge2d_cmd_cfg->src2_y_end   = src2_y + src2_h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + dst_w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + dst_h - 1;
+
+	/* if ((dst_w != src_w) || (dst_h != src_h)) { */
+	if (1) {
+		ge2d_cmd_cfg->sc_hsc_en = 1;
+		ge2d_cmd_cfg->sc_vsc_en = 1;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+		ge2d_cmd_cfg->hsc_div_en = 1;
+#ifdef CONFIG_GE2D_ADV_NUM
+		ge2d_cmd_cfg->hsc_adv_num =
+			((dst_w - 1) < 1024) ? (dst_w - 1) : 0;
+#else
+		ge2d_cmd_cfg->hsc_adv_num = 0;
+#endif
+	} else {
+		ge2d_cmd_cfg->sc_hsc_en = 0;
+		ge2d_cmd_cfg->sc_vsc_en = 0;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+		ge2d_cmd_cfg->hsc_div_en = 0;
+		ge2d_cmd_cfg->hsc_adv_num = 0;
+	}
+
+	ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
+	ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
+	ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
+	ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
+	ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
+
+	if (get_cpu_type() != MESON_CPU_MAJOR_ID_AXG) {
+		if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
+			ge2d_cmd_cfg->color_logic_op =
+				ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
+			ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+		}
+	}
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET;
+
+	ge2d_cmd_cfg->wait_done_flag   = 1;
+
+	ge2d_wq_add_work(wq);
+}
+EXPORT_SYMBOL(blend_noalpha);
+
+
+void blend_noalpha_noblk(struct ge2d_context_s *wq,
+	   int src_x, int src_y, int src_w, int src_h,
+	   int src2_x, int src2_y, int src2_w, int src2_h,
+	   int dst_x, int dst_y, int dst_w, int dst_h,
+	   int op)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + src_w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + src_h - 1;
+
+	ge2d_cmd_cfg->src2_x_start = src2_x;
+	ge2d_cmd_cfg->src2_x_end   = src2_x + src2_w - 1;
+	ge2d_cmd_cfg->src2_y_start = src2_y;
+	ge2d_cmd_cfg->src2_y_end   = src2_y + src2_h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + dst_w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + dst_h - 1;
+
+	/* if ((dst_w != src_w) || (dst_h != src_h)) { */
+	if (1) {
+		ge2d_cmd_cfg->sc_hsc_en = 1;
+		ge2d_cmd_cfg->sc_vsc_en = 1;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+		ge2d_cmd_cfg->hsc_div_en = 1;
+#ifdef CONFIG_GE2D_ADV_NUM
+		ge2d_cmd_cfg->hsc_adv_num =
+			((dst_w - 1) < 1024) ? (dst_w - 1) : 0;
+#else
+		ge2d_cmd_cfg->hsc_adv_num = 0;
+#endif
+	} else {
+		ge2d_cmd_cfg->sc_hsc_en = 0;
+		ge2d_cmd_cfg->sc_vsc_en = 0;
+		ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+		ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+		ge2d_cmd_cfg->hsc_div_en = 0;
+		ge2d_cmd_cfg->hsc_adv_num = 0;
+	}
+
+	ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
+	ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
+	ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
+	ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
+	ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
+
+	if (get_cpu_type() != MESON_CPU_MAJOR_ID_AXG) {
+		if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
+			ge2d_cmd_cfg->color_logic_op =
+				ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
+			ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+		}
+	}
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET;
+
+	ge2d_cmd_cfg->wait_done_flag   = 0;
+
+	ge2d_wq_add_work(wq);
+}
+EXPORT_SYMBOL(blend_noalpha_noblk);
diff -Naur a/vendor/amlogic/ge2d/fillrect.c b/vendor/amlogic/ge2d/fillrect.c
--- a/vendor/amlogic/ge2d/fillrect.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/fillrect.c	2022-06-24 14:37:49.528700252 +0800
@@ -0,0 +1,74 @@
+/*
+ * vendor/amlogic/media/common/ge2d/fillrect.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* Amlogic Headers */
+#include <linux/amlogic/media/ge2d/ge2d.h>
+
+/* Local Headers */
+#include "ge2dgen.h"
+
+
+static void _fillrect(struct ge2d_context_s *wq,
+			     int x, int y, int w, int h,
+			     unsigned int color, int blk)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2dgen_src_color(wq, color);
+
+	ge2d_cmd_cfg->src1_x_start = x;
+	ge2d_cmd_cfg->src1_x_end   = x + w - 1;
+	ge2d_cmd_cfg->src1_y_start = y;
+	ge2d_cmd_cfg->src1_y_end   = y + h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = x;
+	ge2d_cmd_cfg->dst_x_end    = x + w - 1;
+	ge2d_cmd_cfg->dst_y_start  = y;
+	ge2d_cmd_cfg->dst_y_end    = y + h - 1;
+
+	ge2d_cmd_cfg->sc_hsc_en = 0;
+	ge2d_cmd_cfg->sc_vsc_en = 0;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+	ge2d_cmd_cfg->hsc_div_en = 0;
+	ge2d_cmd_cfg->hsc_adv_num = 0;
+
+	ge2d_cmd_cfg->src1_fill_color_en = 1;
+
+	ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->wait_done_flag   = 1;
+	ge2dgen_disable_matrix(wq);
+
+	ge2d_wq_add_work(wq);
+}
+
+void fillrect(struct ge2d_context_s *wq,
+	      int x, int y, int w, int h, unsigned int color)
+{
+	_fillrect(wq, x, y, w, h, color, 1);
+}
+EXPORT_SYMBOL(fillrect);
+
+void fillrect_noblk(struct ge2d_context_s *wq,
+		    int x, int y, int w, int h, unsigned int color)
+{
+	_fillrect(wq, x, y, w, h, color, 0);
+}
+EXPORT_SYMBOL(fillrect_noblk);
diff -Naur a/vendor/amlogic/ge2d/ge2d_dmabuf.c b/vendor/amlogic/ge2d/ge2d_dmabuf.c
--- a/vendor/amlogic/ge2d/ge2d_dmabuf.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_dmabuf.c	2022-06-24 14:37:49.642250255 +0800
@@ -0,0 +1,763 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_dmabuf.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/mm_types.h>
+#include <linux/mutex.h>
+#include <linux/dma-buf.h>
+#include <linux/scatterlist.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+#include <linux/dma-contiguous.h>
+#else
+#include <linux/iommu.h>
+#include <linux/dma-map-ops.h>
+#endif
+
+#include "ge2d_log.h"
+#include "ge2d_dmabuf.h"
+
+static void clear_dma_buffer(struct aml_dma_buffer *buffer, int index);
+
+static void *aml_mm_vmap(phys_addr_t phys, unsigned long size)
+{
+	u32 offset, npages;
+	struct page **pages = NULL;
+	pgprot_t pgprot = PAGE_KERNEL;
+	void *vaddr;
+	int i;
+
+	offset = offset_in_page(phys);
+	npages = DIV_ROUND_UP(size + offset, PAGE_SIZE);
+
+	pages = vmalloc(sizeof(struct page *) * npages);
+	if (!pages)
+		return NULL;
+	for (i = 0; i < npages; i++) {
+		pages[i] = phys_to_page(phys);
+		phys += PAGE_SIZE;
+	}
+	/* pgprot = pgprot_writecombine(PAGE_KERNEL); */
+
+	vaddr = vmap(pages, npages, VM_MAP, pgprot);
+	if (!vaddr) {
+		pr_err("vmaped fail, size: %d\n",
+			npages << PAGE_SHIFT);
+		vfree(pages);
+		return NULL;
+	}
+	vfree(pages);
+	ge2d_log_dbg("[HIGH-MEM-MAP] pa(%lx) to va(%p), size: %d\n",
+		(unsigned long)phys, vaddr, npages << PAGE_SHIFT);
+	return vaddr;
+}
+
+static void *aml_map_phyaddr_to_virt(dma_addr_t phys, unsigned long size)
+{
+	void *vaddr = NULL;
+
+	if (!PageHighMem(phys_to_page(phys)))
+		return phys_to_virt(phys);
+	vaddr = aml_mm_vmap(phys, size);
+	return vaddr;
+}
+
+/* dma free*/
+static void aml_dma_put(void *buf_priv)
+{
+	struct aml_dma_buf *buf = buf_priv;
+	struct page *cma_pages = NULL;
+	void *vaddr = (void *)(PAGE_MASK & (ulong)buf->vaddr);
+
+	if (!atomic_dec_and_test(&buf->refcount)) {
+		ge2d_log_dbg("ge2d aml_dma_put, refcont=%d\n",
+			atomic_read(&buf->refcount));
+		return;
+	}
+	cma_pages = phys_to_page(buf->dma_addr);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	if (is_vmalloc_or_module_addr(vaddr))
+#else
+	if (is_vmalloc_addr(vaddr))
+#endif
+		vunmap(vaddr);
+
+	if (!dma_release_from_contiguous(buf->dev, cma_pages,
+					 buf->size >> PAGE_SHIFT)) {
+		pr_err("failed to release cma buffer\n");
+	}
+	buf->vaddr = NULL;
+	clear_dma_buffer((struct aml_dma_buffer *)buf->priv, buf->index);
+	put_device(buf->dev);
+	ge2d_log_dbg("ge2d free:aml_dma_buf=0x%p,buf->index=%d\n",
+		buf, buf->index);
+	kfree(buf);
+}
+
+static void *aml_dma_alloc(struct device *dev, unsigned long attrs,
+			  unsigned long size, enum dma_data_direction dma_dir,
+			  gfp_t gfp_flags)
+{
+	struct aml_dma_buf *buf;
+	struct page *cma_pages = NULL;
+	dma_addr_t paddr = 0;
+
+	if (WARN_ON(!dev))
+		return (void *)(-EINVAL);
+
+	buf = kzalloc(sizeof(struct aml_dma_buf), GFP_KERNEL | gfp_flags);
+	if (!buf)
+		return NULL;
+
+	if (attrs)
+		buf->attrs = attrs;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+	cma_pages = dma_alloc_from_contiguous(dev,
+		size >> PAGE_SHIFT, 0);
+#else
+	cma_pages = dma_alloc_from_contiguous(dev,
+		size >> PAGE_SHIFT, 0, false);
+
+#endif
+	if (cma_pages) {
+		paddr = page_to_phys(cma_pages);
+	} else {
+		kfree(buf);
+		pr_err("failed to alloc cma pages.\n");
+		return NULL;
+	}
+	buf->vaddr = aml_map_phyaddr_to_virt(paddr, size);
+	buf->dev = get_device(dev);
+	buf->size = size;
+	buf->dma_dir = dma_dir;
+	buf->dma_addr = paddr;
+	atomic_inc(&buf->refcount);
+	ge2d_log_dbg("aml_dma_buf=0x%p, refcont=%d\n",
+		buf, atomic_read(&buf->refcount));
+
+	return buf;
+}
+
+static int aml_dma_mmap(void *buf_priv, struct vm_area_struct *vma)
+{
+	struct aml_dma_buf *buf = buf_priv;
+	unsigned long pfn = 0;
+	unsigned long vsize;
+	int ret = -1;
+
+	if (!buf || !vma) {
+		pr_err("No memory to map\n");
+		return -EINVAL;
+	}
+
+	vsize = vma->vm_end - vma->vm_start;
+
+	pfn = buf->dma_addr >> PAGE_SHIFT;
+	ret = remap_pfn_range(vma, vma->vm_start, pfn,
+		vsize, vma->vm_page_prot);
+	if (ret) {
+		pr_err("Remapping memory, error: %d\n", ret);
+		return ret;
+	}
+	vma->vm_flags |= VM_DONTEXPAND;
+	ge2d_log_dbg("mapped dma addr 0x%08lx at 0x%08lx, size %d\n",
+		(unsigned long)buf->dma_addr, vma->vm_start,
+		buf->size);
+	return 0;
+}
+
+/*********************************************/
+/*         DMABUF ops for exporters          */
+/*********************************************/
+struct aml_attachment {
+	struct sg_table sgt;
+	enum dma_data_direction dma_dir;
+};
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 10, 0)
+static int aml_dmabuf_ops_attach(struct dma_buf *dbuf, struct device *dev,
+	struct dma_buf_attachment *dbuf_attach)
+#else
+static int aml_dmabuf_ops_attach(struct dma_buf *dbuf,
+	struct dma_buf_attachment *dbuf_attach)
+#endif
+{
+	struct aml_attachment *attach;
+	struct aml_dma_buf *buf = dbuf->priv;
+	int num_pages = PAGE_ALIGN(buf->size) / PAGE_SIZE;
+	struct sg_table *sgt;
+	struct scatterlist *sg;
+	phys_addr_t phys = buf->dma_addr;
+	unsigned int i;
+	int ret;
+
+	attach = kzalloc(sizeof(*attach), GFP_KERNEL);
+	if (!attach)
+		return -ENOMEM;
+
+	sgt = &attach->sgt;
+	/* Copy the buf->base_sgt scatter list to the attachment, as we can't
+	 * map the same scatter list to multiple attachments at the same time.
+	 */
+	ret = sg_alloc_table(sgt, num_pages, GFP_KERNEL);
+	if (ret) {
+		kfree(attach);
+		return -ENOMEM;
+	}
+	for_each_sg(sgt->sgl, sg, sgt->nents, i) {
+		struct page *page = phys_to_page(phys);
+
+		sg_set_page(sg, page, PAGE_SIZE, 0);
+		phys += PAGE_SIZE;
+	}
+
+	attach->dma_dir = DMA_NONE;
+	dbuf_attach->priv = attach;
+
+	return 0;
+}
+
+static void aml_dmabuf_ops_detach(struct dma_buf *dbuf,
+	struct dma_buf_attachment *db_attach)
+{
+	struct aml_attachment *attach = db_attach->priv;
+	struct sg_table *sgt;
+
+	if (!attach)
+		return;
+
+	sgt = &attach->sgt;
+
+	/* release the scatterlist cache */
+	if (attach->dma_dir != DMA_NONE)
+		dma_unmap_sg(db_attach->dev, sgt->sgl, sgt->orig_nents,
+			attach->dma_dir);
+	sg_free_table(sgt);
+	kfree(attach);
+	db_attach->priv = NULL;
+
+}
+
+static struct sg_table *aml_dmabuf_ops_map(
+	struct dma_buf_attachment *db_attach, enum dma_data_direction dma_dir)
+{
+	struct aml_attachment *attach = db_attach->priv;
+	/* stealing dmabuf mutex to serialize map/unmap operations */
+	struct mutex *lock = &db_attach->dmabuf->lock;
+	struct sg_table *sgt;
+
+	mutex_lock(lock);
+
+	sgt = &attach->sgt;
+	/* return previously mapped sg table */
+	if (attach->dma_dir == dma_dir) {
+		mutex_unlock(lock);
+		return sgt;
+	}
+
+	/* release any previous cache */
+	if (attach->dma_dir != DMA_NONE) {
+		dma_unmap_sg(db_attach->dev, sgt->sgl, sgt->orig_nents,
+			attach->dma_dir);
+		attach->dma_dir = DMA_NONE;
+	}
+	/* mapping to the client with new direction */
+	sgt->nents = dma_map_sg(db_attach->dev, sgt->sgl, sgt->orig_nents,
+				dma_dir);
+	if (!sgt->nents) {
+		pr_err("failed to map scatterlist\n");
+		mutex_unlock(lock);
+		return (void *)(-EIO);
+	}
+
+	attach->dma_dir = dma_dir;
+
+	mutex_unlock(lock);
+	return sgt;
+}
+
+static void aml_dmabuf_ops_unmap(struct dma_buf_attachment *db_attach,
+	struct sg_table *sgt, enum dma_data_direction dma_dir)
+{
+	/* nothing to be done here */
+}
+
+static void aml_dmabuf_ops_release(struct dma_buf *dbuf)
+{
+	/* drop reference obtained in vb2_dc_get_dmabuf */
+	aml_dma_put(dbuf->priv);
+}
+
+static void *aml_dmabuf_ops_kmap(struct dma_buf *dbuf, unsigned long pgnum)
+{
+	struct aml_dma_buf *buf = dbuf->priv;
+
+	return buf->vaddr ? buf->vaddr + pgnum * PAGE_SIZE : NULL;
+}
+
+static void *aml_dmabuf_ops_vmap(struct dma_buf *dbuf)
+{
+	struct aml_dma_buf *buf = dbuf->priv;
+
+	return buf->vaddr;
+}
+
+static int aml_dmabuf_ops_mmap(struct dma_buf *dbuf,
+	struct vm_area_struct *vma)
+{
+	return aml_dma_mmap(dbuf->priv, vma);
+}
+
+static struct dma_buf_ops ge2d_dmabuf_ops = {
+	.attach = aml_dmabuf_ops_attach,
+	.detach = aml_dmabuf_ops_detach,
+	.map_dma_buf = aml_dmabuf_ops_map,
+	.unmap_dma_buf = aml_dmabuf_ops_unmap,
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 4, 125)
+	.kmap = aml_dmabuf_ops_kmap,
+	.kmap_atomic = aml_dmabuf_ops_kmap,
+#endif
+	.vmap = aml_dmabuf_ops_vmap,
+	.mmap = aml_dmabuf_ops_mmap,
+	.release = aml_dmabuf_ops_release,
+};
+
+static struct dma_buf *get_dmabuf(void *buf_priv, unsigned long flags)
+{
+	struct aml_dma_buf *buf = buf_priv;
+	struct dma_buf *dbuf;
+	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
+
+	exp_info.ops = &ge2d_dmabuf_ops;
+	exp_info.size = buf->size;
+	exp_info.flags = flags;
+	exp_info.priv = buf;
+	if (WARN_ON(!buf->vaddr))
+		return NULL;
+
+	dbuf = dma_buf_export(&exp_info);
+	if (IS_ERR(dbuf))
+		return NULL;
+
+	/* dmabuf keeps reference to vb2 buffer */
+	atomic_inc(&buf->refcount);
+	ge2d_log_dbg("get_dmabuf, refcount=%d\n",
+		atomic_read(&buf->refcount));
+	return dbuf;
+}
+
+/* ge2d dma-buf api.h*/
+static int find_empty_dma_buffer(struct aml_dma_buffer *buffer)
+{
+	int i;
+	int found = 0;
+
+	for (i = 0; i < AML_MAX_DMABUF; i++) {
+		if (buffer->gd_buffer[i].alloc)
+			continue;
+		else {
+			ge2d_log_dbg("find_empty_dma_buffer i=%d\n", i);
+			found = 1;
+			break;
+		}
+	}
+	if (found)
+		return i;
+	else
+		return -1;
+}
+
+static void clear_dma_buffer(struct aml_dma_buffer *buffer, int index)
+{
+	mutex_lock(&(buffer->lock));
+	buffer->gd_buffer[index].mem_priv = NULL;
+	buffer->gd_buffer[index].index = 0;
+	buffer->gd_buffer[index].alloc = 0;
+	mutex_unlock(&(buffer->lock));
+}
+
+void *ge2d_dma_buffer_create(void)
+{
+	int i;
+	struct aml_dma_buffer *buffer;
+
+	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+	if (!buffer)
+		return NULL;
+
+	mutex_init(&buffer->lock);
+	for (i = 0; i < AML_MAX_DMABUF; i++) {
+		buffer->gd_buffer[i].mem_priv = NULL;
+		buffer->gd_buffer[i].index = 0;
+		buffer->gd_buffer[i].alloc = 0;
+	}
+	return buffer;
+}
+
+void ge2d_dma_buffer_destroy(struct aml_dma_buffer *buffer)
+{
+	kfree(buffer);
+}
+
+int ge2d_dma_buffer_alloc(struct aml_dma_buffer *buffer,
+	struct device *dev,
+	struct ge2d_dmabuf_req_s *ge2d_req_buf)
+{
+	void *buf;
+	struct aml_dma_buf *dma_buf;
+	unsigned int size;
+	int index;
+
+	if (WARN_ON(!dev))
+		return (-EINVAL);
+	if (!ge2d_req_buf)
+		return (-EINVAL);
+	if (!buffer)
+		return (-EINVAL);
+
+	size = PAGE_ALIGN(ge2d_req_buf->len);
+	if (size == 0)
+		return (-EINVAL);
+	buf = aml_dma_alloc(dev, 0, size, ge2d_req_buf->dma_dir,
+		GFP_HIGHUSER | __GFP_ZERO);
+	if (!buf)
+		return (-ENOMEM);
+	mutex_lock(&(buffer->lock));
+	index = find_empty_dma_buffer(buffer);
+	if ((index < 0) || (index >= AML_MAX_DMABUF)) {
+		pr_err("no empty buffer found\n");
+		mutex_unlock(&(buffer->lock));
+		aml_dma_put(buf);
+		return (-ENOMEM);
+	}
+	((struct aml_dma_buf *)buf)->priv = buffer;
+	((struct aml_dma_buf *)buf)->index = index;
+	buffer->gd_buffer[index].mem_priv = buf;
+	buffer->gd_buffer[index].index = index;
+	buffer->gd_buffer[index].alloc = 1;
+	mutex_unlock(&(buffer->lock));
+	ge2d_req_buf->index = index;
+	dma_buf = (struct aml_dma_buf *)buf;
+	if (dma_buf->dma_dir == DMA_FROM_DEVICE)
+		dma_sync_single_for_cpu(dma_buf->dev,
+			dma_buf->dma_addr,
+			dma_buf->size, DMA_FROM_DEVICE);
+	return 0;
+}
+
+int ge2d_dma_buffer_free(struct aml_dma_buffer *buffer, int index)
+{
+	struct aml_dma_buf *buf;
+
+	if (!buffer)
+		return (-EINVAL);
+	if ((index < 0) || (index >= AML_MAX_DMABUF))
+		return (-EINVAL);
+
+	buf = buffer->gd_buffer[index].mem_priv;
+	if (!buf) {
+		pr_err("aml_dma_buf is null\n");
+		return (-EINVAL);
+	}
+	aml_dma_put(buf);
+	return 0;
+}
+
+int ge2d_dma_buffer_export(struct aml_dma_buffer *buffer,
+	struct ge2d_dmabuf_exp_s *ge2d_exp_buf)
+{
+	struct aml_dma_buf *buf;
+	struct dma_buf *dbuf;
+	int ret, index;
+	unsigned int flags;
+
+	if (!ge2d_exp_buf)
+		return (-EINVAL);
+	if (!buffer)
+		return (-EINVAL);
+
+	index = ge2d_exp_buf->index;
+	if ((index < 0) || (index >= AML_MAX_DMABUF))
+		return (-EINVAL);
+
+	flags = ge2d_exp_buf->flags;
+	buf = buffer->gd_buffer[index].mem_priv;
+	if (!buf) {
+		pr_err("aml_dma_buf is null\n");
+		return (-EINVAL);
+	}
+
+	dbuf = get_dmabuf(buf, flags & O_ACCMODE);
+	if (IS_ERR_OR_NULL(dbuf)) {
+		pr_err("failed to export buffer %d\n", index);
+		return -EINVAL;
+	}
+	ret = dma_buf_fd(dbuf, flags & ~O_ACCMODE);
+	if (ret < 0) {
+		pr_err("buffer %d, failed to export (%d)\n",
+			index, ret);
+		dma_buf_put(dbuf);
+		return ret;
+	}
+
+	ge2d_log_dbg("buffer %d,exported as %d descriptor\n",
+		index, ret);
+	buffer->gd_buffer[index].fd = ret;
+	buffer->gd_buffer[index].dbuf = dbuf;
+	ge2d_exp_buf->fd = ret;
+	return 0;
+}
+
+int ge2d_dma_buffer_map(struct aml_dma_cfg *cfg)
+{
+	long ret = -1;
+	int fd = -1;
+	struct dma_buf *dbuf = NULL;
+	struct dma_buf_attachment *d_att = NULL;
+	struct sg_table *sg = NULL;
+	void *vaddr = NULL;
+	struct device *dev = NULL;
+	enum dma_data_direction dir;
+
+	if (cfg == NULL || (cfg->fd < 0) || cfg->dev == NULL) {
+		pr_err("error input param");
+		return -EINVAL;
+	}
+	fd = cfg->fd;
+	dev = cfg->dev;
+	dir = cfg->dir;
+
+	dbuf = dma_buf_get(fd);
+	if (IS_ERR(dbuf)) {
+		pr_err("failed to get dma buffer");
+		return -EINVAL;
+	}
+
+	d_att = dma_buf_attach(dbuf, dev);
+	if (IS_ERR(d_att)) {
+		pr_err("failed to set dma attach");
+		goto attach_err;
+	}
+
+	sg = dma_buf_map_attachment(d_att, dir);
+	if (IS_ERR(sg)) {
+		pr_err("failed to get dma sg");
+		goto map_attach_err;
+	}
+
+	ret = dma_buf_begin_cpu_access(dbuf, dir);
+	if (ret != 0) {
+		pr_err("failed to access dma buff");
+		goto access_err;
+	}
+
+	vaddr = dma_buf_vmap(dbuf);
+	if (vaddr == NULL) {
+		pr_err("failed to vmap dma buf");
+		goto vmap_err;
+	}
+	cfg->dbuf = dbuf;
+	cfg->attach = d_att;
+	cfg->vaddr = vaddr;
+	cfg->sg = sg;
+	ge2d_log_dbg("%s, dbuf=0x%p\n", __func__, dbuf);
+	return ret;
+
+vmap_err:
+	dma_buf_end_cpu_access(dbuf, dir);
+
+access_err:
+	dma_buf_unmap_attachment(d_att, sg, dir);
+
+map_attach_err:
+	dma_buf_detach(dbuf, d_att);
+
+attach_err:
+	dma_buf_put(dbuf);
+
+	return ret;
+}
+
+static int ge2d_dma_buffer_get_phys_internal(struct aml_dma_buffer *buffer,
+	struct aml_dma_cfg *cfg, unsigned long *addr)
+{
+	int i = 0, ret = -1;
+	struct aml_dma_buf *dma_buf;
+	struct dma_buf *dbuf = NULL;
+
+	for (i = 0; i < AML_MAX_DMABUF; i++) {
+		if (buffer->gd_buffer[i].alloc) {
+			dbuf = dma_buf_get(cfg->fd);
+			if (IS_ERR(dbuf)) {
+				pr_err("%s: failed to get dma buffer,fd=%d, dbuf=%p\n",
+					__func__, cfg->fd, dbuf);
+				return -EINVAL;
+			}
+			dma_buf_put(dbuf);
+			if (dbuf == buffer->gd_buffer[i].dbuf) {
+				cfg->dbuf = dbuf;
+				dma_buf = buffer->gd_buffer[i].mem_priv;
+				*addr = dma_buf->dma_addr;
+				ret = 0;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+int ge2d_dma_buffer_get_phys(struct aml_dma_buffer *buffer,
+	struct aml_dma_cfg *cfg, unsigned long *addr)
+{
+	struct sg_table *sg_table;
+	struct page *page;
+	int ret = -1;
+
+	if (cfg == NULL || (cfg->fd < 0)) {
+		pr_err("error input param");
+		return -EINVAL;
+	}
+	ret = ge2d_dma_buffer_get_phys_internal(buffer, cfg, addr);
+	if (ret < 0) {
+		ret = ge2d_dma_buffer_map(cfg);
+		if (ret < 0) {
+			pr_err("gdc_dma_buffer_map failed\n");
+			return ret;
+		}
+		if (cfg->sg) {
+			sg_table = cfg->sg;
+			page = sg_page(sg_table->sgl);
+			*addr = PFN_PHYS(page_to_pfn(page));
+			ret = 0;
+		}
+	}
+	return ret;
+}
+
+int ge2d_dma_buffer_unmap_info(struct aml_dma_buffer *buffer,
+	struct aml_dma_cfg *cfg)
+{
+	int i, found = 0;
+
+	if (cfg == NULL || (cfg->fd < 0)) {
+		pr_err("error input param");
+		return -EINVAL;
+	}
+	for (i = 0; i < AML_MAX_DMABUF; i++) {
+		if (buffer->gd_buffer[i].alloc) {
+			if (cfg->dbuf == buffer->gd_buffer[i].dbuf) {
+				found = 1;
+				break;
+			}
+		}
+	}
+	if (!found)
+		ge2d_dma_buffer_unmap(cfg);
+	return 0;
+}
+
+void ge2d_dma_buffer_unmap(struct aml_dma_cfg *cfg)
+{
+	int fd = -1;
+	struct dma_buf *dbuf = NULL;
+	struct dma_buf_attachment *d_att = NULL;
+	struct sg_table *sg = NULL;
+	void *vaddr = NULL;
+	struct device *dev = NULL;
+	enum dma_data_direction dir;
+
+	if (cfg == NULL || (cfg->fd < 0) || cfg->dev == NULL
+			|| cfg->dbuf == NULL || cfg->vaddr == NULL
+			|| cfg->attach == NULL || cfg->sg == NULL) {
+		pr_err("Error input param");
+		return;
+	}
+	fd = cfg->fd;
+	dev = cfg->dev;
+	dir = cfg->dir;
+	dbuf = cfg->dbuf;
+	vaddr = cfg->vaddr;
+	d_att = cfg->attach;
+	sg = cfg->sg;
+
+	dma_buf_vunmap(dbuf, vaddr);
+
+	dma_buf_end_cpu_access(dbuf, dir);
+
+	dma_buf_unmap_attachment(d_att, sg, dir);
+
+	dma_buf_detach(dbuf, d_att);
+
+	dma_buf_put(dbuf);
+
+	ge2d_log_dbg("%s, dbuf=0x%p\n", __func__, dbuf);
+}
+
+void ge2d_dma_buffer_dma_flush(struct device *dev, int fd)
+{
+	struct dma_buf *dmabuf;
+	struct aml_dma_buf *buf;
+
+	ge2d_log_dbg("ge2d_dma_buffer_dma_flush fd=%d\n", fd);
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		pr_err("dma_buf_get failed\n");
+		return;
+	}
+	buf = dmabuf->priv;
+	if (!buf) {
+		pr_err("error input param");
+		return;
+	}
+	if ((buf->size > 0) && (buf->dev == dev))
+		dma_sync_single_for_device(buf->dev, buf->dma_addr,
+			buf->size, DMA_TO_DEVICE);
+	dma_buf_put(dmabuf);
+}
+
+void ge2d_dma_buffer_cache_flush(struct device *dev, int fd)
+{
+	struct dma_buf *dmabuf;
+	struct aml_dma_buf *buf;
+
+	ge2d_log_dbg("ge2d_dma_buffer_cache_flush fd=%d\n", fd);
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR(dmabuf)) {
+		pr_err("dma_buf_get failed\n");
+		return;
+	}
+	buf = dmabuf->priv;
+	if (!buf) {
+		pr_err("error input param");
+		return;
+	}
+	if ((buf->size > 0) && (buf->dev == dev))
+		dma_sync_single_for_cpu(buf->dev, buf->dma_addr,
+			buf->size, DMA_FROM_DEVICE);
+	dma_buf_put(dmabuf);
+}
+
+
diff -Naur a/vendor/amlogic/ge2d/ge2d_dmabuf.h b/vendor/amlogic/ge2d/ge2d_dmabuf.h
--- a/vendor/amlogic/ge2d/ge2d_dmabuf.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_dmabuf.h	2022-06-24 14:37:49.664974610 +0800
@@ -0,0 +1,85 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_dmabuf.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2D_DMABUF_H_
+#define _GE2D_DMABUF_H_
+
+#include <linux/mm_types.h>
+#include <linux/mutex.h>
+#include <linux/dma-buf.h>
+
+/* Amlogic Headers */
+#include <linux/amlogic/media/ge2d/ge2d.h>
+
+#define AML_MAX_DMABUF 32
+
+struct aml_dma_buf {
+	struct device		*dev;
+	void				*cookie;
+	void				*vaddr;
+	unsigned int		size;
+	enum dma_data_direction		dma_dir;
+	unsigned long		attrs;
+	unsigned int		index;
+	dma_addr_t			dma_addr;
+	atomic_t			refcount;
+	/* DMABUF related */
+	struct dma_buf_attachment	*db_attach;
+	void                *priv;
+};
+
+struct aml_dma_buf_priv {
+	void *mem_priv;
+	int index;
+	int fd;
+	unsigned int alloc;
+	struct dma_buf *dbuf;
+};
+
+struct aml_dma_buffer {
+	struct mutex lock;
+	struct aml_dma_buf_priv gd_buffer[AML_MAX_DMABUF];
+};
+
+struct aml_dma_cfg {
+	int fd;
+	void *dev;
+	void *vaddr;
+	struct dma_buf *dbuf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sg;
+	enum dma_data_direction dir;
+};
+
+
+void *ge2d_dma_buffer_create(void);
+void ge2d_dma_buffer_destroy(struct aml_dma_buffer *buffer);
+int ge2d_dma_buffer_alloc(struct aml_dma_buffer *buffer,
+	struct device *dev,
+	struct ge2d_dmabuf_req_s *ge2d_req_buf);
+int ge2d_dma_buffer_free(struct aml_dma_buffer *buffer, int index);
+int ge2d_dma_buffer_export(struct aml_dma_buffer *buffer,
+	struct ge2d_dmabuf_exp_s *ge2d_exp_buf);
+int ge2d_dma_buffer_map(struct aml_dma_cfg *cfg);
+void ge2d_dma_buffer_unmap(struct aml_dma_cfg *cfg);
+int ge2d_dma_buffer_get_phys(struct aml_dma_buffer *buffer,
+	struct aml_dma_cfg *cfg, unsigned long *addr);
+int ge2d_dma_buffer_unmap_info(struct aml_dma_buffer *buffer,
+	struct aml_dma_cfg *cfg);
+void ge2d_dma_buffer_dma_flush(struct device *dev, int fd);
+void ge2d_dma_buffer_cache_flush(struct device *dev, int fd);
+#endif
diff -Naur a/vendor/amlogic/ge2d/ge2dgen.c b/vendor/amlogic/ge2d/ge2dgen.c
--- a/vendor/amlogic/ge2d/ge2dgen.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2dgen.c	2022-06-24 14:37:49.583267498 +0800
@@ -0,0 +1,454 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2dgen.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* Amlogic Headers */
+#include <linux/amlogic/media/ge2d/ge2d.h>
+
+static inline void _set_src1_format(struct ge2d_src1_data_s *src1_data_cfg,
+				    struct ge2d_src1_gen_s *src1_gen_cfg,
+				    struct ge2d_dp_gen_s *dp_gen_cfg,
+				    unsigned int format_src,
+				    unsigned int format_dst)
+{
+	src1_data_cfg->format_all  = format_src;
+
+	src1_data_cfg->format      = (format_src >> 8) & 3;
+	src1_data_cfg->mode_8b_sel = (format_src >> 6) & 3;
+	src1_data_cfg->lut_en      = (format_src >> 5) & 1;
+	src1_data_cfg->sep_en      = (format_src >> 2) & 1;
+
+	src1_data_cfg->endian      = (format_src & GE2D_ENDIAN_MASK) >>
+				     GE2D_ENDIAN_SHIFT;
+	src1_data_cfg->color_map   = (format_src & GE2D_COLOR_MAP_MASK) >>
+				     GE2D_COLOR_MAP_SHIFT;
+
+
+	src1_gen_cfg->pic_struct   = (format_src >> 3) & 3;
+	src1_data_cfg->x_yc_ratio  = (format_src >> 1) & 1;
+	src1_data_cfg->y_yc_ratio  = (format_src >> 0) & 1;
+
+	if (format_src & GE2D_FORMAT_DEEP_COLOR)
+		src1_data_cfg->deep_color = 1;
+	else
+		src1_data_cfg->deep_color = 0;
+
+	if ((format_src & GE2D_MATRIX_CUSTOM) ||
+	    (format_dst & GE2D_MATRIX_CUSTOM)) {
+		dp_gen_cfg->use_matrix_default = MATRIX_CUSTOM;
+		dp_gen_cfg->conv_matrix_en = 1;
+		return;
+	}
+
+	if ((format_src & GE2D_FORMAT_YUV) &&
+	    ((format_dst & GE2D_FORMAT_YUV) == 0)) {
+		dp_gen_cfg->use_matrix_default =
+			(format_src & GE2D_FORMAT_FULL_RANGE) ?
+			MATRIX_FULL_RANGE_YCC_TO_RGB : MATRIX_YCC_TO_RGB;
+		dp_gen_cfg->conv_matrix_en = 1;
+	} else if (((format_src & GE2D_FORMAT_YUV) == 0) &&
+		   (format_dst & GE2D_FORMAT_YUV)) {
+		dp_gen_cfg->use_matrix_default =
+			(format_dst & GE2D_FORMAT_FULL_RANGE) ?
+			MATRIX_RGB_TO_FULL_RANGE_YCC : MATRIX_RGB_TO_YCC;
+		dp_gen_cfg->use_matrix_default |=
+			((format_dst & GE2D_FORMAT_BT_STANDARD) ?
+				MATRIX_BT_709 : MATRIX_BT_601);
+		dp_gen_cfg->conv_matrix_en = 1;
+	} else
+		dp_gen_cfg->conv_matrix_en = 0;
+}
+
+static inline void _set_src2_format(
+		struct ge2d_src2_dst_data_s *src2_dst_data_cfg,
+		struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg,
+		unsigned int format)
+{
+	src2_dst_data_cfg->src2_format_all  = format;
+
+	src2_dst_data_cfg->src2_format      = (format >> 8) & 3;
+	src2_dst_data_cfg->src2_endian      = (format & GE2D_ENDIAN_MASK) >>
+					      GE2D_ENDIAN_SHIFT;
+	src2_dst_data_cfg->src2_color_map   = (format & GE2D_COLOR_MAP_MASK) >>
+					      GE2D_COLOR_MAP_SHIFT;
+
+	src2_dst_data_cfg->src2_mode_8b_sel = (format >> 6) & 3;
+
+	src2_dst_gen_cfg->src2_pic_struct   = (format >> 3) & 3;
+}
+
+static inline void _set_dst_format(
+		struct ge2d_src2_dst_data_s *src2_dst_data_cfg,
+		struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg,
+		struct ge2d_dp_gen_s *dp_gen_cfg,
+		unsigned int format_src,
+		unsigned int format_dst)
+{
+	unsigned int y_yc_ratio;
+
+	src2_dst_data_cfg->dst_format_all = format_dst;
+	src2_dst_data_cfg->dst_format = (format_dst >> 8) & 3;
+	src2_dst_data_cfg->dst_endian = (format_dst & GE2D_ENDIAN_MASK) >>
+					GE2D_ENDIAN_SHIFT;
+	src2_dst_data_cfg->dst_color_map = (format_dst & GE2D_COLOR_MAP_MASK) >>
+					   GE2D_COLOR_MAP_SHIFT;
+
+	src2_dst_data_cfg->dst_mode_8b_sel = (format_dst >> 6) & 3;
+	src2_dst_gen_cfg->dst_pic_struct   = (format_dst >> 3) & 3;
+
+	y_yc_ratio = (format_dst >> 0) & 1;
+
+	/* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
+	/* for dest is nv21 or nv12 in m6. */
+	if ((format_dst & GE2D_FORMAT_YUV) &&
+	    ((src2_dst_data_cfg->dst_color_map | 1) == 15)) {
+		src2_dst_data_cfg->dst_format = 0;
+		src2_dst_data_cfg->dst_mode_8b_sel = 0;
+		src2_dst_data_cfg->dst2_pixel_byte_width = 1;
+		if (y_yc_ratio == 0)
+			src2_dst_data_cfg->dst2_discard_mode = 0xc;
+		else
+			src2_dst_data_cfg->dst2_discard_mode = 0xf;
+		src2_dst_data_cfg->dst2_enable = 1;
+		src2_dst_data_cfg->dst2_color_map =
+			src2_dst_data_cfg->dst_color_map - 5;
+	} else
+		src2_dst_data_cfg->dst2_enable = 0;
+	/* #endif */
+
+	if ((format_src & GE2D_MATRIX_CUSTOM) ||
+	    (format_dst & GE2D_MATRIX_CUSTOM)) {
+		dp_gen_cfg->use_matrix_default = MATRIX_CUSTOM;
+		dp_gen_cfg->conv_matrix_en = 1;
+		return;
+	}
+
+	if ((format_src & GE2D_FORMAT_YUV) &&
+	    ((format_dst & GE2D_FORMAT_YUV) == 0)) {
+		dp_gen_cfg->use_matrix_default =
+			(format_src & GE2D_FORMAT_FULL_RANGE) ?
+			MATRIX_FULL_RANGE_YCC_TO_RGB : MATRIX_YCC_TO_RGB;
+		dp_gen_cfg->conv_matrix_en = 1;
+	} else if (((format_src & GE2D_FORMAT_YUV) == 0) &&
+		   (format_dst & GE2D_FORMAT_YUV)) {
+		dp_gen_cfg->use_matrix_default =
+			(format_dst & GE2D_FORMAT_FULL_RANGE) ?
+			MATRIX_RGB_TO_FULL_RANGE_YCC : MATRIX_RGB_TO_YCC;
+		dp_gen_cfg->use_matrix_default |=
+			((format_dst & GE2D_FORMAT_BT_STANDARD) ?
+				MATRIX_BT_709 : MATRIX_BT_601);
+		dp_gen_cfg->conv_matrix_en = 1;
+	} else
+		dp_gen_cfg->conv_matrix_en = 0;
+}
+
+void ge2dgen_src(struct ge2d_context_s *wq,
+		unsigned int canvas_addr,
+		unsigned int format,
+		unsigned int phy_addr,
+		unsigned int stride)
+{
+	struct ge2d_src1_data_s *src1_data_cfg = ge2d_wq_get_src_data(wq);
+	struct ge2d_src1_gen_s *src1_gen_cfg = ge2d_wq_get_src_gen(wq);
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+	struct ge2d_src2_dst_data_s *src2_dst_data_cfg =
+		ge2d_wq_get_dst_data(wq);
+
+	if ((format != src1_data_cfg->format_all) ||
+	    (canvas_addr != src1_data_cfg->canaddr) ||
+		(phy_addr != src1_data_cfg->phy_addr) ||
+	    (stride != src1_data_cfg->stride)) {
+		src1_data_cfg->canaddr = canvas_addr;
+
+		_set_src1_format(src1_data_cfg, src1_gen_cfg, dp_gen_cfg,
+				 format, src2_dst_data_cfg->dst_format_all);
+		src1_data_cfg->phy_addr = phy_addr;
+		src1_data_cfg->stride = stride;
+		wq->config.update_flag |= UPDATE_SRC_DATA;
+		wq->config.update_flag |= UPDATE_SRC_GEN;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
+
+void ge2dgen_antiflicker(struct ge2d_context_s *wq, unsigned long enable)
+{
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+	enable = enable ? 1 : 0;
+
+	if (dp_gen_cfg->antiflick_en != enable) {
+		dp_gen_cfg->antiflick_en = enable;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
+void ge2dgen_post_release_src1buf(struct ge2d_context_s *wq,
+	unsigned int buffer)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_buffer = buffer;
+	ge2d_cmd_cfg->release_flag |= RELEASE_SRC1_BUFFER;
+}
+
+void ge2dgen_post_release_src1canvas(struct ge2d_context_s *wq)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->release_flag |= RELEASE_SRC1_CANVAS;
+}
+
+void ge2dgen_post_release_src2buf(struct ge2d_context_s *wq,
+	unsigned int buffer)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src2_buffer = buffer;
+	ge2d_cmd_cfg->release_flag |= RELEASE_SRC2_BUFFER;
+}
+
+void ge2dgen_post_release_src2canvas(struct ge2d_context_s *wq)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->release_flag |= RELEASE_SRC2_CANVAS;
+}
+
+void ge2dgen_cb(struct ge2d_context_s *wq,
+		int (*cmd_cb)(unsigned int), unsigned int param)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->cmd_cb = cmd_cb;
+	ge2d_cmd_cfg->cmd_cb_param = param;
+	ge2d_cmd_cfg->release_flag |= RELEASE_CB;
+}
+
+void ge2dgen_src2(struct ge2d_context_s *wq,
+		unsigned int canvas_addr,
+		unsigned int format,
+		unsigned int phy_addr,
+		unsigned int stride)
+{
+	struct ge2d_src2_dst_data_s *src2_dst_data_cfg =
+		ge2d_wq_get_dst_data(wq);
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+
+	if ((format != src2_dst_data_cfg->src2_format_all) ||
+	    (canvas_addr != src2_dst_data_cfg->src2_canaddr) ||
+		(phy_addr != src2_dst_data_cfg->src2_phyaddr) ||
+	    (stride != src2_dst_data_cfg->src2_stride)) {
+
+		src2_dst_data_cfg->src2_canaddr = canvas_addr;
+
+		_set_src2_format(src2_dst_data_cfg, src2_dst_gen_cfg, format);
+		src2_dst_data_cfg->src2_phyaddr = phy_addr;
+		src2_dst_data_cfg->src2_stride = stride;
+		wq->config.update_flag |= UPDATE_DST_DATA;
+		wq->config.update_flag |= UPDATE_DST_GEN;
+	}
+}
+
+void ge2dgen_dst(struct ge2d_context_s *wq,
+		 unsigned int canvas_addr,
+		 unsigned int format,
+		 unsigned int phy_addr,
+		 unsigned int stride)
+{
+	struct ge2d_src1_data_s *src1_data_cfg = ge2d_wq_get_src_data(wq);
+	struct ge2d_src2_dst_data_s *src2_dst_data_cfg =
+		ge2d_wq_get_dst_data(wq);
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+	if ((format != src2_dst_data_cfg->dst_format_all) ||
+	    (canvas_addr != src2_dst_data_cfg->dst_canaddr) ||
+	    (phy_addr != src2_dst_data_cfg->dst_phyaddr) ||
+	    (stride != src2_dst_data_cfg->dst_stride)) {
+		src2_dst_data_cfg->dst_canaddr = canvas_addr;
+
+		_set_dst_format(src2_dst_data_cfg, src2_dst_gen_cfg, dp_gen_cfg,
+				src1_data_cfg->format_all, format);
+		src2_dst_data_cfg->dst_phyaddr = phy_addr;
+		src2_dst_data_cfg->dst_stride = stride;
+		wq->config.update_flag |= UPDATE_DST_DATA;
+		wq->config.update_flag |= UPDATE_DST_GEN;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
+
+void ge2dgen_src_clip(struct ge2d_context_s *wq,
+		      int x, int y, int w, int h)
+{
+	struct ge2d_src1_gen_s *src1_gen_cfg = ge2d_wq_get_src_gen(wq);
+	/* adjust w->x_end h->y_end */
+	w = x + w - 1;
+	h = y + h - 1;
+	if (src1_gen_cfg->clipx_start != x ||
+			src1_gen_cfg->clipx_end   != w ||
+			src1_gen_cfg->clipy_start != y ||
+			src1_gen_cfg->clipy_end   != h) {
+		src1_gen_cfg->clipx_start = x;
+		src1_gen_cfg->clipx_end   = w;
+		src1_gen_cfg->clipy_start = y;
+		src1_gen_cfg->clipy_end   = h;
+		wq->config.update_flag |= UPDATE_SRC_GEN;
+	}
+}
+
+void ge2dgen_src2_clip(struct ge2d_context_s *wq,
+		       int x, int y, int w, int h)
+{
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+
+	/* adjust w->x_end h->y_end */
+	w = x + w - 1;
+	h = y + h - 1;
+	if (src2_dst_gen_cfg->src2_clipx_start != x ||
+	    src2_dst_gen_cfg->src2_clipx_end   != w ||
+	    src2_dst_gen_cfg->src2_clipy_start != y ||
+	    src2_dst_gen_cfg->src2_clipy_end   != h) {
+		src2_dst_gen_cfg->src2_clipx_start = x;
+		src2_dst_gen_cfg->src2_clipx_end   = w;
+		src2_dst_gen_cfg->src2_clipy_start = y;
+		src2_dst_gen_cfg->src2_clipy_end   = h;
+		wq->config.update_flag |= UPDATE_DST_GEN;
+	}
+}
+
+void ge2dgen_src_key(struct ge2d_context_s *wq,
+		     int en, int key, int keymask, int keymode)
+{
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+	if (dp_gen_cfg->src1_key_en != en ||
+			dp_gen_cfg->src1_key != key ||
+			dp_gen_cfg->src1_key_mask != keymask ||
+			dp_gen_cfg->src1_key_mode != keymode) {
+		dp_gen_cfg->src1_key_en = en & 0x1;
+		dp_gen_cfg->src1_key = key;
+		dp_gen_cfg->src1_key_mask = keymask;
+		dp_gen_cfg->src1_key_mode = keymode & 0x1;
+
+		dp_gen_cfg->src1_vsc_bank_length = 4;
+		dp_gen_cfg->src1_hsc_bank_length = 4;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
+EXPORT_SYMBOL(ge2dgen_src_key);
+
+void ge2dgent_src_gbalpha(struct ge2d_context_s *wq,
+			  unsigned char alpha1, unsigned char alpha2)
+{
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+#ifdef CONFIG_GE2D_SRC2
+	if ((dp_gen_cfg->src1_gb_alpha != alpha1)
+		|| (dp_gen_cfg->src2_gb_alpha != alpha2)) {
+		dp_gen_cfg->src1_gb_alpha = alpha1;
+		dp_gen_cfg->src2_gb_alpha = alpha2;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+#else
+	if (dp_gen_cfg->src1_gb_alpha != alpha1) {
+		dp_gen_cfg->src1_gb_alpha = alpha1;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+#endif
+}
+
+void ge2dgen_src_color(struct ge2d_context_s *wq,
+		       unsigned int color)
+{
+	struct ge2d_src1_data_s *src1_data_cfg = ge2d_wq_get_src_data(wq);
+
+	if (src1_data_cfg->def_color != color) {
+		src1_data_cfg->def_color = color;
+		wq->config.update_flag |= UPDATE_SRC_DATA;
+	}
+
+}
+
+void ge2dgen_rendering_dir(struct ge2d_context_s *wq,
+			   int src_x_dir, int src_y_dir,
+			   int dst_x_dir, int dst_y_dir,
+			   int dst_xy_swap)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_rev = src_x_dir;
+	ge2d_cmd_cfg->src1_y_rev = src_y_dir;
+	ge2d_cmd_cfg->dst_x_rev  = dst_x_dir;
+	ge2d_cmd_cfg->dst_y_rev  = dst_y_dir;
+	ge2d_cmd_cfg->dst_xy_swap  =  dst_xy_swap;
+}
+
+void ge2dgen_dst_clip(struct ge2d_context_s *wq,
+		      int x, int y, int w, int h, int mode)
+{
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+	/* adjust w->x_end h->y_end */
+	w = x + w - 1;
+	h = y + h - 1;
+	if (src2_dst_gen_cfg->dst_clipx_start != x ||
+	    src2_dst_gen_cfg->dst_clipx_end   != w ||
+	    src2_dst_gen_cfg->dst_clipy_start != y ||
+	    src2_dst_gen_cfg->dst_clipy_end   != h ||
+	    src2_dst_gen_cfg->dst_clip_mode   != mode) {
+		src2_dst_gen_cfg->dst_clipx_start = x;
+		src2_dst_gen_cfg->dst_clipx_end   = w;
+		src2_dst_gen_cfg->dst_clipy_start = y;
+		src2_dst_gen_cfg->dst_clipy_end   = h;
+		src2_dst_gen_cfg->dst_clip_mode   = mode;
+		wq->config.update_flag |= UPDATE_DST_GEN;
+	}
+}
+
+void ge2dgent_src2_clip(struct ge2d_context_s *wq,
+			int x, int y, int w, int h)
+{
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+	/* adjust w->x_end h->y_end */
+	w = x + w - 1;
+	h = y + h - 1;
+	if (src2_dst_gen_cfg->src2_clipx_start != x ||
+	    src2_dst_gen_cfg->src2_clipx_end   != w ||
+	    src2_dst_gen_cfg->src2_clipy_start != y ||
+	    src2_dst_gen_cfg->src2_clipy_end   != h) {
+		src2_dst_gen_cfg->src2_clipx_start = x;
+		src2_dst_gen_cfg->src2_clipx_end   = w;
+		src2_dst_gen_cfg->src2_clipy_start = y;
+		src2_dst_gen_cfg->src2_clipy_end   = h;
+		wq->config.update_flag |= UPDATE_DST_GEN;
+	}
+}
+
+void ge2dgen_const_color(struct ge2d_context_s *wq,
+			 unsigned int color)
+{
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+	if (dp_gen_cfg->alu_const_color != color) {
+		dp_gen_cfg->alu_const_color = color;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
+
+void ge2dgen_disable_matrix(struct ge2d_context_s *wq)
+{
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+	dp_gen_cfg->conv_matrix_en = 0;
+	wq->config.update_flag |= UPDATE_DP_GEN;
+}
diff -Naur a/vendor/amlogic/ge2d/ge2dgen.h b/vendor/amlogic/ge2d/ge2dgen.h
--- a/vendor/amlogic/ge2d/ge2dgen.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2dgen.h	2022-06-24 14:37:49.605999374 +0800
@@ -0,0 +1,89 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2dgen.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2DGEN_H_
+#define _GE2DGEN_H_
+
+void ge2dgen_src(struct ge2d_context_s *wq,
+		unsigned int canvas_addr,
+		unsigned int format,
+		unsigned int phy_addr,
+		unsigned int stride);
+
+void ge2dgen_post_release_src1buf(struct ge2d_context_s *wq,
+	unsigned int buffer);
+
+void ge2dgen_post_release_src1canvas(struct ge2d_context_s *wq);
+
+void ge2dgen_post_release_src2buf(struct ge2d_context_s *wq,
+	unsigned int buffer);
+
+void ge2dgen_post_release_src2canvas(struct ge2d_context_s *wq);
+
+void ge2dgen_src2(struct ge2d_context_s *wq,
+		unsigned int canvas_addr,
+		unsigned int format,
+		unsigned int phy_addr,
+		unsigned int stride);
+
+void ge2dgen_src2_clip(struct ge2d_context_s *wq,
+		       int x, int y, int w, int h);
+void ge2dgen_antiflicker(struct ge2d_context_s *wq, unsigned long enable);
+void ge2dgen_rendering_dir(struct ge2d_context_s *wq,
+			   int src1_xrev,
+			   int src1_yrev,
+			   int dst_xrev,
+			   int dst_yrev,
+			   int dst_xy_swap);
+
+void ge2dgen_dst(struct ge2d_context_s *wq,
+		unsigned int canvas_addr,
+		unsigned int format,
+		unsigned int phy_addr,
+		unsigned int stride);
+
+void ge2dgen_src_clip(struct ge2d_context_s *wq,
+		      int x, int y, int w, int h);
+
+void ge2dgen_src_key(struct ge2d_context_s *wq,
+		     int en, int key, int keymask, int keymode);
+
+void ge2dgent_src_gbalpha(struct ge2d_context_s *wq,
+			  unsigned char alpha1, unsigned char alpha2);
+
+void ge2dgen_src_color(struct ge2d_context_s *wq,
+		       unsigned int color);
+
+void ge2dgent_rendering_dir(struct ge2d_context_s *wq,
+			    int src_x_dir, int src_y_dir,
+			    int dst_x_dir, int dst_y_dir);
+
+
+void ge2dgen_dst_clip(struct ge2d_context_s *wq,
+		      int x, int y, int w, int h, int mode);
+
+void ge2dgent_src2_clip(struct ge2d_context_s *wq,
+			int x, int y, int w, int h);
+
+void ge2dgen_cb(struct ge2d_context_s *wq,
+		int (*cmd_cb)(unsigned int), unsigned int param);
+
+void ge2dgen_const_color(struct ge2d_context_s *wq,
+	unsigned int color);
+void ge2dgen_disable_matrix(struct ge2d_context_s *wq);
+#endif
+
diff -Naur a/vendor/amlogic/ge2d/ge2d_hw.c b/vendor/amlogic/ge2d/ge2d_hw.c
--- a/vendor/amlogic/ge2d/ge2d_hw.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_hw.c	2022-06-24 14:37:49.691432221 +0800
@@ -0,0 +1,1161 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_hw.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* Linux Headers */
+#include <linux/types.h>
+
+/* Amlogic Headers */
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/media/ge2d/ge2d.h>
+
+/* Local Headers */
+#include "ge2d_log.h"
+#include "ge2d_io.h"
+#include "ge2d_reg.h"
+
+#define GE2D_DST1_INDEX 0
+#define GE2D_SRC1_INDEX 1
+#define GE2D_SRC2_INDEX 2
+static int gaul_filter_used;
+static const  unsigned int filt_coef_gau1[] = { /* gau1+phase */
+	0x20402000,
+	0x203f2001,
+	0x203e2002,
+	0x203d2003,
+	0x203c2004,
+	0x203b2005,
+	0x203a2006,
+	0x20392007,
+	0x20382008,
+	0x20372009,
+	0x2036200a,
+	0x2035200b,
+	0x2034200c,
+	0x2033200d,
+	0x2032200e,
+	0x2031200f,
+	0x20302010,
+	0x202f2011,
+	0x202e2012,
+	0x202d2013,
+	0x202c2014,
+	0x202b2015,
+	0x202a2016,
+	0x20292017,
+	0x20282018,
+	0x20272019,
+	0x2026201a,
+	0x2025201b,
+	0x2024201c,
+	0x2023201d,
+	0x2022201e,
+	0x2021201f,
+	0x20202020
+};
+
+/* average, no phase, horizontal filter and vertical filter for top field */
+static const  unsigned int filt_coef_gau0[] = {
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020,
+	0x20202020
+};
+
+/* average, no phase, only for vertical filter of bot filed*/
+static const  unsigned int filt_coef_gau0_bot[] = {
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00,
+	0x2a2b2a00
+};
+
+static const  unsigned int filt_coef0[] = { /* bicubic */
+	0x00800000,
+	0x007f0100,
+	0xff7f0200,
+	0xfe7f0300,
+	0xfd7e0500,
+	0xfc7e0600,
+	0xfb7d0800,
+	0xfb7c0900,
+	0xfa7b0b00,
+	0xfa7a0dff,
+	0xf9790fff,
+	0xf97711ff,
+	0xf87613ff,
+	0xf87416fe,
+	0xf87218fe,
+	0xf8701afe,
+	0xf76f1dfd,
+	0xf76d1ffd,
+	0xf76b21fd,
+	0xf76824fd,
+	0xf76627fc,
+	0xf76429fc,
+	0xf7612cfc,
+	0xf75f2ffb,
+	0xf75d31fb,
+	0xf75a34fb,
+	0xf75837fa,
+	0xf7553afa,
+	0xf8523cfa,
+	0xf8503ff9,
+	0xf84d42f9,
+	0xf84a45f9,
+	0xf84848f8
+};
+
+static const    unsigned int filt_coef1[] = { /* 2 point bilinear */
+	0x00800000,
+	0x007e0200,
+	0x007c0400,
+	0x007a0600,
+	0x00780800,
+	0x00760a00,
+	0x00740c00,
+	0x00720e00,
+	0x00701000,
+	0x006e1200,
+	0x006c1400,
+	0x006a1600,
+	0x00681800,
+	0x00661a00,
+	0x00641c00,
+	0x00621e00,
+	0x00602000,
+	0x005e2200,
+	0x005c2400,
+	0x005a2600,
+	0x00582800,
+	0x00562a00,
+	0x00542c00,
+	0x00522e00,
+	0x00503000,
+	0x004e3200,
+	0x004c3400,
+	0x004a3600,
+	0x00483800,
+	0x00463a00,
+	0x00443c00,
+	0x00423e00,
+	0x00404000
+};
+
+static const    unsigned int filt_coef2[] = { /* 3 point triangle */
+	0x40400000,
+	0x3f400100,
+	0x3d410200,
+	0x3c410300,
+	0x3a420400,
+	0x39420500,
+	0x37430600,
+	0x36430700,
+	0x35430800,
+	0x33450800,
+	0x32450900,
+	0x31450a00,
+	0x30450b00,
+	0x2e460c00,
+	0x2d460d00,
+	0x2c470d00,
+	0x2b470e00,
+	0x29480f00,
+	0x28481000,
+	0x27481100,
+	0x26491100,
+	0x25491200,
+	0x24491300,
+	0x234a1300,
+	0x224a1400,
+	0x214a1500,
+	0x204a1600,
+	0x1f4b1600,
+	0x1e4b1700,
+	0x1d4b1800,
+	0x1c4c1800,
+	0x1b4c1900,
+	0x1a4c1a00
+};
+static const        unsigned int filt_coef3[] = { /* 3 point triangle */
+	0x20402000,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00,
+	0x00
+};
+
+void ge2d_canv_config(u32 index, u32 addr, u32 stride)
+{
+	ge2d_log_dbg("ge2d_canv_config:index=%d,addr=%x,stride=%d\n",
+		index, addr, stride);
+	if (index <= 2) {
+		ge2d_reg_write(GE2D_DST1_BADDR_CTRL + index * 2,
+			((addr + 7) >> 3));
+		ge2d_reg_write(GE2D_DST1_STRIDE_CTRL + index * 2,
+			((stride + 7) >> 3));
+	}
+}
+
+void ge2d_set_src1_data(struct ge2d_src1_data_s *cfg)
+{
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->urgent_en,  10, 1);
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->ddr_burst_size_y,  20, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->ddr_burst_size_cb, 18, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->ddr_burst_size_cr, 16, 2);
+
+	if (ge2d_meson_dev.canvas_status == 1) {
+		ge2d_canv_config(GE2D_SRC1_INDEX,
+			cfg->phy_addr,
+			cfg->stride);
+	} else {
+		ge2d_reg_write(GE2D_SRC1_CANVAS,
+				((cfg->canaddr & 0xff) << 24) |
+				(((cfg->canaddr >> 8) & 0xff) << 16) |
+				(((cfg->canaddr >> 16) & 0xff) << 8));
+	}
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0,
+			((cfg->x_yc_ratio << 1) | cfg->y_yc_ratio),
+			   10, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->sep_en, 0, 1);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->endian, 7, 1);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->color_map, 3, 4);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->format, 0, 2);
+	if (ge2d_meson_dev.deep_color == 1)
+		ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->deep_color, 2, 1);
+	if (ge2d_meson_dev.canvas_status  == 1) {
+		ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->mult_rounding, 18, 1);
+		ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->alpha_conv_mode0, 31, 1);
+		ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->alpha_conv_mode1, 10, 1);
+		ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->color_conv_mode0, 30, 1);
+		ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->color_conv_mode1, 26, 1);
+	}
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->mode_8b_sel, 5, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->lut_en, 3, 1);
+
+	ge2d_reg_write(GE2D_SRC1_DEF_COLOR, cfg->def_color);
+	if (cfg->x_yc_ratio)
+		/* horizontal formatter enable */
+		ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, 1, 18, 1);
+	else
+		/* horizontal formatter disable */
+		ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, 0, 18, 1);
+	if (cfg->y_yc_ratio)
+		/* vertical formatter enable */
+		ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, 1, 16, 1);
+	else
+		/* vertical formatter disable */
+		ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, 0, 16, 1);
+}
+
+void ge2d_set_src1_scale_coef(unsigned int v_filt_type,
+	unsigned int h_filt_type)
+{
+	int i;
+
+	/* write vert filter coefs */
+	ge2d_reg_write(GE2D_SCALE_COEF_IDX, 0x0000);
+	if ((v_filt_type == FILTER_TYPE_GAU0) ||
+		(v_filt_type == FILTER_TYPE_GAU0_BOT) ||
+		(v_filt_type == FILTER_TYPE_GAU1) ||
+		(h_filt_type == FILTER_TYPE_GAU0) ||
+		(h_filt_type == FILTER_TYPE_GAU0_BOT) ||
+		(h_filt_type == FILTER_TYPE_GAU1))
+		gaul_filter_used = 1;
+	else
+		gaul_filter_used = 0;
+	for (i = 0; i < 33; i++) {
+		if (v_filt_type == FILTER_TYPE_BICUBIC)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef0[i]);
+		else if (v_filt_type == FILTER_TYPE_BILINEAR)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef1[i]);
+		else if (v_filt_type == FILTER_TYPE_TRIANGLE)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef2[i]);
+		else if (v_filt_type == FILTER_TYPE_GAU0)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau0[i]);
+		else if (v_filt_type == FILTER_TYPE_GAU0_BOT)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau0_bot[i]);
+		else if (v_filt_type == FILTER_TYPE_GAU1)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau1[i]);
+		else {
+			/* TODO */
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef3[i]);
+		}
+	}
+
+	/* write horz filter coefs */
+	ge2d_reg_write(GE2D_SCALE_COEF_IDX, 0x0100);
+	for (i = 0; i < 33; i++) {
+		if (h_filt_type == FILTER_TYPE_BICUBIC)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef0[i]);
+		else if (h_filt_type == FILTER_TYPE_BILINEAR)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef1[i]);
+		else if (h_filt_type == FILTER_TYPE_TRIANGLE)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef2[i]);
+		else if (h_filt_type == FILTER_TYPE_GAU0)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau0[i]);
+		else if (h_filt_type == FILTER_TYPE_GAU0_BOT)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau0_bot[i]);
+		else if (h_filt_type == FILTER_TYPE_GAU1)
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef_gau1[i]);
+		else {
+			/* TODO */
+			ge2d_reg_write(GE2D_SCALE_COEF, filt_coef3[i]);
+		}
+	}
+
+}
+
+void ge2d_set_src1_gen(struct ge2d_src1_gen_s *cfg)
+{
+	ge2d_reg_write(GE2D_SRC1_CLIPX_START_END,
+			(cfg->clipx_start_ex << 31) |
+			(cfg->clipx_start << 16) |
+			(cfg->clipx_end_ex << 15) |
+			(cfg->clipx_end << 0)
+		       );
+
+	ge2d_reg_write(GE2D_SRC1_CLIPY_START_END,
+			(cfg->clipy_start_ex << 31) |
+			(cfg->clipy_start << 16) |
+			(cfg->clipy_end_ex << 15) |
+			(cfg->clipy_end << 0)
+		       );
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->pic_struct, 1, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, (cfg->fill_mode & 0x1), 4, 1);
+
+	ge2d_reg_set_bits(GE2D_SRC_OUTSIDE_ALPHA,
+			   ((cfg->fill_mode & 0x2) << 7) |
+			   cfg->outside_alpha, 0, 9);
+
+	ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, cfg->chfmt_rpt_pix, 19, 1);
+	ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, cfg->cvfmt_rpt_pix, 17, 1);
+}
+
+void ge2d_set_src2_dst_data(struct ge2d_src2_dst_data_s *cfg)
+{
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->urgent_en,  9, 1);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->ddr_burst_size, 22, 2);
+
+	if (ge2d_meson_dev.canvas_status == 1) {
+		ge2d_canv_config(GE2D_SRC2_INDEX,
+			cfg->src2_phyaddr,
+			cfg->src2_stride);
+		ge2d_canv_config(GE2D_DST1_INDEX,
+			cfg->dst_phyaddr,
+			cfg->dst_stride);
+	} else {
+		/* only for m6 and later chips. */
+		ge2d_reg_write(GE2D_SRC2_DST_CANVAS, (cfg->src2_canaddr << 8) |
+				((cfg->dst_canaddr & 0xff) << 0) |
+				((cfg->dst_canaddr & 0xff00) << 8)
+			       );
+	}
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->src2_endian, 15, 1);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->src2_color_map, 11, 4);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->src2_format, 8, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->dst_endian, 23, 1);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->dst_color_map, 19, 4);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2, cfg->dst_format, 16, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->src2_mode_8b_sel, 15, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->dst_mode_8b_sel, 24, 2);
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL3, cfg->dst2_pixel_byte_width, 16, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL3, cfg->dst2_color_map, 19, 4);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL3, cfg->dst2_discard_mode, 10, 4);
+	/* ge2d_reg_set_bits (GE2D_GEN_CTRL3, 1, 0, 1); */
+	ge2d_reg_set_bits(GE2D_GEN_CTRL3, cfg->dst2_enable, 8, 1);
+	ge2d_reg_write(GE2D_SRC2_DEF_COLOR, cfg->src2_def_color);
+}
+
+void ge2d_set_src2_dst_gen(struct ge2d_src2_dst_gen_s *cfg)
+{
+	ge2d_reg_write(GE2D_SRC2_CLIPX_START_END,
+			(cfg->src2_clipx_start << 16) |
+			(cfg->src2_clipx_end << 0)
+		       );
+
+	ge2d_reg_write(GE2D_SRC2_CLIPY_START_END,
+			(cfg->src2_clipy_start << 16) |
+			(cfg->src2_clipy_end << 0)
+		       );
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->src2_pic_struct, 12, 2);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, (cfg->src2_fill_mode & 0x1), 14, 1);
+
+	ge2d_reg_set_bits(GE2D_SRC_OUTSIDE_ALPHA,
+			   ((cfg->src2_fill_mode & 0x2) << 7) |
+			   cfg->src2_outside_alpha, 16, 9);
+
+	ge2d_reg_write(GE2D_DST_CLIPX_START_END,
+			(cfg->dst_clipx_start << 16) |
+			(cfg->dst_clipx_end << 0)
+		       );
+
+	ge2d_reg_write(GE2D_DST_CLIPY_START_END,
+			(cfg->dst_clipy_start << 16) |
+			(cfg->dst_clipy_end << 0)
+		       );
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0, cfg->dst_clip_mode,  23, 1);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->dst_pic_struct, 14, 2);
+}
+
+void ge2d_set_dp_gen(struct ge2d_config_s *config)
+{
+	struct ge2d_dp_gen_s *cfg = &config->dp_gen;
+
+	unsigned int antiflick_color_filter_n1[] = {0,   8,    16, 32};
+	unsigned int antiflick_color_filter_n2[] = {128, 112,  96, 64};
+	unsigned int antiflick_color_filter_n3[] = {0,   8,    16, 32};
+	unsigned int antiflick_color_filter_th[] = {8, 16, 64};
+	unsigned int antiflick_alpha_filter_n1[] = {0,    8,  16, 32};
+	unsigned int antiflick_alpha_filter_n2[] = {128, 112,  96, 64};
+	unsigned int antiflick_alpha_filter_n3[] = {0,    8,  16, 32};
+	unsigned int antiflick_alpha_filter_th[] = {8, 16, 64};
+
+	if (cfg->conv_matrix_en) {
+		cfg->antiflick_ycbcr_rgb_sel = 0; /* 0: yuv2rgb 1:rgb2rgb */
+		cfg->antiflick_cbcr_en = 1;
+		cfg->antiflick_r_coef = 0;
+		cfg->antiflick_g_coef = 0;
+		cfg->antiflick_b_coef = 0;
+	} else {
+		cfg->antiflick_ycbcr_rgb_sel = 1; /* 0: yuv2rgb 1:rgb2rgb */
+		cfg->antiflick_cbcr_en = 1;
+		cfg->antiflick_r_coef = 0x42;	/* 0.257 */
+		cfg->antiflick_g_coef = 0x81;	/* 0.504 */
+		cfg->antiflick_b_coef = 0x19;	/* 0.098 */
+	}
+	memcpy(cfg->antiflick_color_filter_n1, antiflick_color_filter_n1,
+	       4 * sizeof(unsigned int));
+	memcpy(cfg->antiflick_color_filter_n2, antiflick_color_filter_n2,
+	       4 * sizeof(unsigned int));
+	memcpy(cfg->antiflick_color_filter_n3, antiflick_color_filter_n3,
+	       4 * sizeof(unsigned int));
+	memcpy(cfg->antiflick_color_filter_th, antiflick_color_filter_th,
+	       3 * sizeof(unsigned int));
+	memcpy(cfg->antiflick_alpha_filter_n1, antiflick_alpha_filter_n1,
+	       4 * sizeof(unsigned int));
+	memcpy(cfg->antiflick_alpha_filter_n2, antiflick_alpha_filter_n2,
+	       4 * sizeof(unsigned int));
+	memcpy(cfg->antiflick_alpha_filter_n3, antiflick_alpha_filter_n3,
+	       4 * sizeof(unsigned int));
+	memcpy(cfg->antiflick_alpha_filter_th, antiflick_alpha_filter_th,
+	       3 * sizeof(unsigned int));
+	cfg->src1_vsc_bank_length = 4;
+	cfg->src1_hsc_bank_length = 4;
+	ge2d_reg_set_bits(GE2D_SC_MISC_CTRL,
+			   ((cfg->src1_hsc_rpt_ctrl << 9) |
+			    (cfg->src1_vsc_rpt_ctrl << 8) |
+			    (cfg->src1_vsc_phase0_always_en << 7) |
+			    (cfg->src1_vsc_bank_length << 4) |
+			    (cfg->src1_hsc_phase0_always_en << 3) |
+			    (cfg->src1_hsc_bank_length << 0)),  0, 10);
+
+	ge2d_reg_set_bits(GE2D_SC_MISC_CTRL,
+			((cfg->src1_vsc_nearest_en << 1) |
+			(cfg->src1_hsc_nearest_en << 0)), 29, 2);
+	if (cfg->antiflick_en == 1) {
+		/* Wr(GE2D_ANTIFLICK_CTRL0, 0x81000100); */
+		ge2d_reg_write(GE2D_ANTIFLICK_CTRL0, 0x80000000);
+		ge2d_reg_write(GE2D_ANTIFLICK_CTRL1,
+			(cfg->antiflick_ycbcr_rgb_sel << 25) |
+			(cfg->antiflick_cbcr_en << 24) |
+			((cfg->antiflick_r_coef & 0xff) << 16) |
+			((cfg->antiflick_g_coef & 0xff) << 8) |
+			((cfg->antiflick_b_coef & 0xff) << 0)
+			);
+
+		ge2d_reg_write(GE2D_ANTIFLICK_COLOR_FILT0,
+			((cfg->antiflick_color_filter_th[0] & 0xff) << 24) |
+			((cfg->antiflick_color_filter_n3[0] & 0xff) << 16) |
+			((cfg->antiflick_color_filter_n2[0] & 0xff) << 8) |
+			((cfg->antiflick_color_filter_n1[0] & 0xff) << 0)
+			);
+
+		ge2d_reg_write(GE2D_ANTIFLICK_COLOR_FILT1,
+			((cfg->antiflick_color_filter_th[1] & 0xff) << 24) |
+			((cfg->antiflick_color_filter_n3[1] & 0xff) << 16) |
+			((cfg->antiflick_color_filter_n2[1] & 0xff) << 8) |
+			((cfg->antiflick_color_filter_n1[1] & 0xff) << 0)
+			);
+
+		ge2d_reg_write(GE2D_ANTIFLICK_COLOR_FILT2,
+			((cfg->antiflick_color_filter_th[2] & 0xff) << 24) |
+			((cfg->antiflick_color_filter_n3[2] & 0xff) << 16) |
+			((cfg->antiflick_color_filter_n2[2] & 0xff) << 8) |
+			((cfg->antiflick_color_filter_n1[2] & 0xff) << 0)
+			);
+
+		ge2d_reg_write(GE2D_ANTIFLICK_COLOR_FILT3,
+			((cfg->antiflick_color_filter_n3[3] & 0xff) << 16) |
+			((cfg->antiflick_color_filter_n2[3] & 0xff) << 8) |
+			((cfg->antiflick_color_filter_n1[3] & 0xff) << 0)
+			);
+
+		ge2d_reg_write(GE2D_ANTIFLICK_ALPHA_FILT0,
+			((cfg->antiflick_alpha_filter_th[0] & 0xff) << 24) |
+			((cfg->antiflick_alpha_filter_n3[0] & 0xff) << 16) |
+			((cfg->antiflick_alpha_filter_n2[0] & 0xff) << 8) |
+			((cfg->antiflick_alpha_filter_n1[0] & 0xff) << 0)
+			);
+
+		ge2d_reg_write(GE2D_ANTIFLICK_ALPHA_FILT1,
+			((cfg->antiflick_alpha_filter_th[1] & 0xff) << 24) |
+			((cfg->antiflick_alpha_filter_n3[1] & 0xff) << 16) |
+			((cfg->antiflick_alpha_filter_n2[1] & 0xff) << 8) |
+			((cfg->antiflick_alpha_filter_n1[1] & 0xff) << 0)
+			);
+
+		ge2d_reg_write(GE2D_ANTIFLICK_ALPHA_FILT2,
+			((cfg->antiflick_alpha_filter_th[2] & 0xff) << 24) |
+			((cfg->antiflick_alpha_filter_n3[2] & 0xff) << 16) |
+			((cfg->antiflick_alpha_filter_n2[2] & 0xff) << 8) |
+			((cfg->antiflick_alpha_filter_n1[2] & 0xff) << 0)
+			);
+
+		ge2d_reg_write(GE2D_ANTIFLICK_ALPHA_FILT3,
+			((cfg->antiflick_alpha_filter_n3[3] & 0xff) << 16) |
+			((cfg->antiflick_alpha_filter_n2[3] & 0xff) << 8) |
+			((cfg->antiflick_alpha_filter_n1[3] & 0xff) << 0)
+			);
+	} else
+		ge2d_reg_set_bits(GE2D_ANTIFLICK_CTRL0, 0, 31, 1);
+
+	if (cfg->use_matrix_default & MATRIX_CUSTOM) {
+		struct ge2d_matrix_s *matrix = &config->matrix_custom;
+
+		ge2d_log_dbg("using matrix_custom\n");
+		cfg->matrix_coef[0] = matrix->coef0;
+		cfg->matrix_coef[1] = matrix->coef1;
+		cfg->matrix_coef[2] = matrix->coef2;
+		cfg->matrix_coef[3] = matrix->coef3;
+		cfg->matrix_coef[4] = matrix->coef4;
+		cfg->matrix_coef[5] = matrix->coef5;
+		cfg->matrix_coef[6] = matrix->coef6;
+		cfg->matrix_coef[7] = matrix->coef7;
+		cfg->matrix_coef[8] = matrix->coef8;
+		cfg->matrix_offset[0] = matrix->offset0;
+		cfg->matrix_offset[1] = matrix->offset1;
+		cfg->matrix_offset[2] = matrix->offset2;
+		cfg->matrix_sat_in_en = matrix->sat_in_en;
+
+		ge2d_reg_write(GE2D_MATRIX_PRE_OFFSET,
+			       (matrix->pre_offset0 << 20) |
+			       (matrix->pre_offset1 << 10) |
+			       matrix->pre_offset2);
+	} else {
+		if (cfg->use_matrix_default & MATRIX_YCC_TO_RGB) {
+			/* ycbcr(16-235) to rgb(0-255) */
+			cfg->matrix_coef[0] = 0x4a8;
+			cfg->matrix_coef[1] = 0;
+			cfg->matrix_coef[2] = 0x662;
+			cfg->matrix_coef[3] = 0x4a8;
+			cfg->matrix_coef[4] = 0x1e6f;
+			cfg->matrix_coef[5] = 0x1cbf;
+			cfg->matrix_coef[6] = 0x4a8;
+			cfg->matrix_coef[7] = 0x811;
+			cfg->matrix_coef[8] = 0x0;
+			cfg->matrix_offset[0] = 0;
+			cfg->matrix_offset[1] = 0;
+			cfg->matrix_offset[2] = 0;
+			cfg->matrix_sat_in_en = 1;
+			cfg->matrix_minus_16_ctrl = 0x4;
+			cfg->matrix_sign_ctrl = 0x3;
+		} else if (cfg->use_matrix_default & MATRIX_RGB_TO_YCC) {
+			if (cfg->use_matrix_default & MATRIX_BT_709) {
+				/* VDIN_MATRIX_RGB_YUV709 */
+				/* 0     0.183  0.614  0.062     16 */
+				/* 0    -0.101 -0.338  0.439    128 */
+				/* 0     0.439 -0.399 -0.04     128 */
+				cfg->matrix_coef[0] = 0xbb;
+				cfg->matrix_coef[1] = 0x275;
+				cfg->matrix_coef[2] = 0x3f;
+				cfg->matrix_coef[3] = 0x1f99;
+				cfg->matrix_coef[4] = 0x1ea6;
+				cfg->matrix_coef[5] = 0x1c2;
+				cfg->matrix_coef[6] = 0x1c2;
+				cfg->matrix_coef[7] = 0x1e67;
+				cfg->matrix_coef[8] = 0x1fd7;
+			} else {
+				/* rgb(0-255) to ycbcr(16-235) */
+				/* 0.257     0.504   0.098 */
+				/* -0.148    -0.291  0.439 */
+				/* 0.439     -0.368 -0.071 */
+				cfg->matrix_coef[0] = 0x107;
+				cfg->matrix_coef[1] = 0x204;
+				cfg->matrix_coef[2] = 0x64;
+				cfg->matrix_coef[3] = 0x1f68;
+				cfg->matrix_coef[4] = 0x1ed6;
+				cfg->matrix_coef[5] = 0x1c2;
+				cfg->matrix_coef[6] = 0x1c2;
+				cfg->matrix_coef[7] = 0x1e87;
+				cfg->matrix_coef[8] = 0x1fb7;
+			}
+			cfg->matrix_offset[0] = 16;
+			cfg->matrix_offset[1] = 128;
+			cfg->matrix_offset[2] = 128;
+			cfg->matrix_sat_in_en = 0;
+			cfg->matrix_minus_16_ctrl = 0;
+			cfg->matrix_sign_ctrl = 0;
+		} else if (cfg->use_matrix_default &
+			   MATRIX_FULL_RANGE_YCC_TO_RGB) {
+			/* ycbcr (0-255) to rgb(0-255) */
+			/* 1,     0,      1.402 */
+			/* 1, -0.34414,   -0.71414 */
+			/* 1, 1.772       0 */
+			cfg->matrix_coef[0] = 0x400;
+			cfg->matrix_coef[1] = 0;
+			cfg->matrix_coef[2] = 0x59c;
+			cfg->matrix_coef[3] = 0x400;
+			cfg->matrix_coef[4] = 0x1ea0;
+			cfg->matrix_coef[5] = 0x1d25;
+			cfg->matrix_coef[6] = 0x400;
+			cfg->matrix_coef[7] = 0x717;
+			cfg->matrix_coef[8] = 0;
+			cfg->matrix_offset[0] = 0;
+			cfg->matrix_offset[1] = 0;
+			cfg->matrix_offset[2] = 0;
+			cfg->matrix_sat_in_en = 0;
+			cfg->matrix_minus_16_ctrl = 0;
+			cfg->matrix_sign_ctrl = 0x3;
+		} else if (cfg->use_matrix_default &
+			   MATRIX_RGB_TO_FULL_RANGE_YCC) {
+			cfg->matrix_coef[0] = 0x132;
+			cfg->matrix_coef[1] = 0x259;
+			cfg->matrix_coef[2] = 0x75;
+			cfg->matrix_coef[3] = 0x1f53;
+			cfg->matrix_coef[4] = 0x1ead;
+			cfg->matrix_coef[5] = 0x200;
+			cfg->matrix_coef[6] = 0x200;
+			cfg->matrix_coef[7] = 0x1e53;
+			cfg->matrix_coef[8] = 0x1fad;
+			cfg->matrix_offset[0] = 0;
+			cfg->matrix_offset[1] = 128;
+			cfg->matrix_offset[2] = 128;
+			cfg->matrix_sat_in_en = 0;
+			cfg->matrix_minus_16_ctrl = 0;
+			cfg->matrix_sign_ctrl = 0;
+		}
+
+		if (cfg->matrix_minus_16_ctrl)
+			ge2d_reg_set_bits(GE2D_MATRIX_PRE_OFFSET, 0x1f0, 20, 9);
+		else
+			ge2d_reg_set_bits(GE2D_MATRIX_PRE_OFFSET, 0, 20, 9);
+
+		if (cfg->matrix_sign_ctrl & 3)
+			ge2d_reg_set_bits(GE2D_MATRIX_PRE_OFFSET,
+					  ((0x180 << 10) | 0x180), 0, 20);
+		else
+			ge2d_reg_set_bits(GE2D_MATRIX_PRE_OFFSET, 0, 0, 20);
+	}
+
+	ge2d_reg_write(GE2D_MATRIX_COEF00_01,
+			(cfg->matrix_coef[0] << 16) |
+			(cfg->matrix_coef[1] << 0)
+		       );
+
+	ge2d_reg_write(GE2D_MATRIX_COEF02_10,
+			(cfg->matrix_coef[2] << 16) |
+			(cfg->matrix_coef[3] << 0)
+		       );
+
+	ge2d_reg_write(GE2D_MATRIX_COEF11_12,
+			(cfg->matrix_coef[4] << 16) |
+			(cfg->matrix_coef[5] << 0)
+		       );
+
+	ge2d_reg_write(GE2D_MATRIX_COEF20_21,
+			(cfg->matrix_coef[6] << 16) |
+			(cfg->matrix_coef[7] << 0)
+		       );
+
+	ge2d_reg_write(GE2D_MATRIX_COEF22_CTRL,
+			(cfg->matrix_coef[8] << 16) |
+			(cfg->matrix_sat_in_en << 7) |
+#if 0
+			(cfg->matrix_minus_16_ctrl << 4) |
+			(cfg->matrix_sign_ctrl << 1) |
+#endif
+			(cfg->conv_matrix_en << 0)
+		       );
+
+	ge2d_reg_write(GE2D_MATRIX_OFFSET,
+			(cfg->matrix_offset[0] << 20) |
+			(cfg->matrix_offset[1] << 10) |
+			(cfg->matrix_offset[2] << 0)
+		       );
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->src1_gb_alpha, 0, 8);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL2,
+		cfg->src1_gb_alpha_en, 29, 1);
+#ifdef CONFIG_GE2D_SRC2
+	if (ge2d_meson_dev.src2_alp == 1) {
+		ge2d_reg_set_bits(GE2D_GEN_CTRL5, cfg->src2_gb_alpha, 0, 8);
+		ge2d_reg_set_bits(GE2D_GEN_CTRL5,
+			cfg->src2_gb_alpha_en, 8, 1);
+	}
+#endif
+	ge2d_reg_write(GE2D_ALU_CONST_COLOR, cfg->alu_const_color);
+	ge2d_reg_write(GE2D_SRC1_KEY, cfg->src1_key);
+	ge2d_reg_write(GE2D_SRC1_KEY_MASK, cfg->src1_key_mask);
+
+	ge2d_reg_write(GE2D_SRC2_KEY, cfg->src2_key);
+	ge2d_reg_write(GE2D_SRC2_KEY_MASK, cfg->src2_key_mask);
+
+	ge2d_reg_write(GE2D_DST_BITMASK, cfg->bitmask);
+
+	ge2d_reg_set_bits(GE2D_GEN_CTRL0,
+			   ((cfg->bytemask_only << 5) |
+			    (cfg->bitmask_en << 4) |
+			    (cfg->src2_key_en << 3) |
+			    (cfg->src2_key_mode << 2) |
+			    (cfg->src1_key_en << 1) |
+			    (cfg->src1_key_mode << 0)), 26, 6);
+}
+
+int ge2d_cmd_fifo_full(void)
+{
+	return ge2d_reg_read(GE2D_STATUS0) & (1 << 1);
+}
+
+void ge2d_set_cmd(struct ge2d_cmd_s *cfg)
+{
+	unsigned int widthi, heighti, tmp_widthi, tmp_heighti, widtho, heighto;
+	unsigned int multo;
+	unsigned int x_extra_bit_start = 0, x_extra_bit_end = 0;
+	unsigned int y_extra_bit_start = 0, y_extra_bit_end = 0;
+	unsigned int x_chr_phase = 0, y_chr_phase = 0;
+	unsigned int x_yc_ratio, y_yc_ratio;
+	int sc_prehsc_en, sc_prevsc_en;
+	int rate_w = 10, rate_h = 10;
+	/* expand src region with one line. */
+	unsigned int src1_y_end = cfg->src1_y_end + 1;
+
+	while ((ge2d_reg_read(GE2D_STATUS0) & (1 << 1)))
+		;
+
+	x_yc_ratio = ge2d_reg_get_bits(GE2D_GEN_CTRL0, 11, 1);
+	y_yc_ratio = ge2d_reg_get_bits(GE2D_GEN_CTRL0, 10, 1);
+
+	/* src:yuv , dst: rgb */
+	if ((cfg->src1_fmt & GE2D_FORMAT_YUV) &&
+		((cfg->dst_fmt & GE2D_FORMAT_YUV) == 0)) {
+		if (x_yc_ratio) {
+			if ((cfg->src1_x_rev + cfg->dst_x_rev) == 1) {
+				x_extra_bit_start = 3;
+				x_extra_bit_end   = 2;
+				x_chr_phase = 0x4c;
+			} else {
+				x_extra_bit_start = 2;
+				x_extra_bit_end   = 3;
+				x_chr_phase = 0xc4;
+			}
+		}
+		if (y_yc_ratio) {
+			if ((cfg->src1_y_rev + cfg->dst_y_rev) == 1) {
+				y_extra_bit_start = 3;
+				y_extra_bit_end   = 2;
+				y_chr_phase = 0x4c;
+			} else {
+				y_extra_bit_start = 2;
+				y_extra_bit_end   = 3;
+				y_chr_phase = 0xc4;
+			}
+		}
+	} else {
+		if (x_yc_ratio) {
+			if ((cfg->src1_x_rev + cfg->dst_x_rev) == 1) {
+				x_extra_bit_start = 3;
+				x_extra_bit_end   = 2;
+				x_chr_phase = 0x08;
+			} else {
+				x_extra_bit_start = 2;
+				x_extra_bit_end   = 3;
+				x_chr_phase = 0x08;
+			}
+		}
+
+		if (y_yc_ratio) {
+			if ((cfg->src1_y_rev + cfg->dst_y_rev) == 1) {
+				y_extra_bit_start = 3;
+				y_extra_bit_end   = 2;
+				y_chr_phase = 0x4c;
+			} else {
+				y_extra_bit_start = 2;
+				y_extra_bit_end   = 3;
+				y_chr_phase = 0x4c;
+			}
+		}
+	}
+	ge2d_reg_write(GE2D_SRC1_X_START_END,
+			(x_extra_bit_start << 30) |  /* x start extra */
+			((cfg->src1_x_start & 0x3fff) << 16) |
+			(x_extra_bit_end << 14) |    /* x end extra */
+			((cfg->src1_x_end & 0x3fff) << 0)
+		       );
+
+	ge2d_reg_write(GE2D_SRC1_Y_START_END,
+			(y_extra_bit_start << 30) |  /* y start extra */
+			((cfg->src1_y_start & 0x3fff) << 16) |
+			(y_extra_bit_end << 14) |    /* y end extra */
+			((src1_y_end & 0x3fff) << 0)
+		       );
+
+	ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, x_chr_phase, 8, 8);
+	ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, y_chr_phase, 0, 8);
+
+	if (((cfg->src1_x_end - cfg->src1_x_start) ==
+	     (cfg->dst_x_end - cfg->dst_x_start)) &&
+	    ((cfg->src1_y_end - cfg->src1_y_start) ==
+	     (cfg->dst_y_end - cfg->dst_y_start))) {
+		/* set chroma formatter repeat mode */
+		ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, 1, 19, 1);
+		ge2d_reg_set_bits(GE2D_SRC1_FMT_CTRL, 1, 17, 1);
+	}
+
+	ge2d_reg_write(GE2D_SRC2_X_START_END,
+			(cfg->src2_x_start << 16) |
+			(cfg->src2_x_end << 0)
+		       );
+
+	ge2d_reg_write(GE2D_SRC2_Y_START_END,
+			(cfg->src2_y_start << 16) |
+			(cfg->src2_y_end << 0)
+		       );
+
+	ge2d_reg_write(GE2D_DST_X_START_END,
+			(cfg->dst_x_start << 16) |
+			(cfg->dst_x_end << 0)
+		       );
+
+	ge2d_reg_write(GE2D_DST_Y_START_END,
+			(cfg->dst_y_start << 16) |
+			(cfg->dst_y_end << 0)
+		       );
+
+	widthi  = cfg->src1_x_end - cfg->src1_x_start + 1;
+	heighti = cfg->src1_y_end - cfg->src1_y_start + 1;
+
+	widtho  = cfg->dst_xy_swap ? (cfg->dst_y_end - cfg->dst_y_start + 1) :
+		  (cfg->dst_x_end - cfg->dst_x_start + 1);
+	heighto = cfg->dst_xy_swap ? (cfg->dst_x_end - cfg->dst_x_start + 1) :
+		  (cfg->dst_y_end - cfg->dst_y_start + 1);
+
+	sc_prehsc_en = (widthi > widtho * 2) ? 1 : 0;
+	sc_prevsc_en = (heighti > heighto * 2) ? 1 : 0;
+
+	tmp_widthi  = sc_prehsc_en ? ((widthi + 1) >> 1) : widthi;
+	tmp_heighti = sc_prevsc_en ? ((heighti + 1) >> 1) : heighti;
+
+	if (cfg->hsc_phase_step == 0)
+		cfg->hsc_phase_step = ((tmp_widthi << 18) / widtho) <<
+				      6; /* width no more than 8192 */
+
+	if (cfg->vsc_phase_step == 0)
+		cfg->vsc_phase_step = ((tmp_heighti << 18) / heighto) <<
+				      6;/* height no more than 8192 */
+
+	if ((cfg->sc_hsc_en) && (cfg->hsc_div_en)) {
+		cfg->hsc_div_length = (124 << 24) / cfg->hsc_phase_step;
+
+		multo = cfg->hsc_phase_step * cfg->hsc_div_length;
+		cfg->hsc_adv_num   = multo >> 24;
+		cfg->hsc_adv_phase = multo & 0xffffff;
+	}
+
+	if (!gaul_filter_used) {
+		rate_w = (widtho * 10) / widthi;
+		rate_h = (heighto * 10) / heighti;
+		if (rate_h == 10) {
+			/* not scaler case */
+			cfg->vsc_ini_phase = 0;
+			ge2d_reg_set_bits(GE2D_SC_MISC_CTRL,
+				((0 << 1) | (0 << 0)), 8, 2);
+		} else if (rate_h < 10) {
+			/* scaler down case */
+			cfg->sc_vsc_en = 1;
+			cfg->vsc_rpt_l0_num = 1;
+			if (rate_h != 0)
+				cfg->vsc_ini_phase =
+					0x5000000/rate_h - 0x800000;
+			else
+				cfg->vsc_ini_phase = 0x5000000;
+		} else {
+			/* scaler up case */
+			cfg->sc_vsc_en = 1;
+			cfg->vsc_rpt_l0_num = 2;
+			cfg->vsc_ini_phase =
+				0x800000 + 0x5000000/rate_h;
+		}
+
+		if (rate_w == 10) {
+			/* not scaler case */
+			cfg->hsc_ini_phase = 0;
+			ge2d_reg_set_bits(GE2D_SC_MISC_CTRL,
+				((0 << 1) | (0 << 0)), 8, 2);
+		} else if (rate_w < 10) {
+			/* scaler down case */
+			cfg->sc_hsc_en = 1;
+			cfg->hsc_rpt_p0_num = 1;
+			if (rate_w != 0)
+				cfg->hsc_ini_phase =
+					0x5000000/rate_w - 0x800000;
+			else
+				cfg->hsc_ini_phase = 0x5000000;
+		} else {
+			/* scaler up case */
+			cfg->sc_hsc_en = 1;
+			cfg->hsc_rpt_p0_num = 2;
+			cfg->hsc_ini_phase =
+				0x800000 + 0x5000000/rate_w;
+		}
+		/* expand src1/src2 color with 1 */
+		ge2d_reg_set_bits(GE2D_GEN_CTRL2, 1, 27, 1);
+		ge2d_reg_set_bits(GE2D_GEN_CTRL2, 1, 25, 1);
+	}
+	ge2d_log_dbg("rate_w=%d,rate_h=%d\n", rate_w, rate_h);
+	ge2d_reg_set_bits(GE2D_SC_MISC_CTRL,
+			   ((cfg->hsc_div_en << 17) |
+			    (cfg->hsc_div_length << 4) |
+			    (sc_prehsc_en << 3) |
+			    (sc_prevsc_en << 2) |
+			    (cfg->sc_vsc_en << 1) |
+			    (cfg->sc_hsc_en << 0)), 11, 18);
+
+	ge2d_reg_write(GE2D_HSC_START_PHASE_STEP, cfg->hsc_phase_step);
+
+	ge2d_reg_write(GE2D_HSC_PHASE_SLOPE, cfg->hsc_phase_slope);
+
+#ifdef CONFIG_GE2D_ADV_NUM
+	ge2d_reg_write(GE2D_HSC_ADV_CTRL,
+			(cfg->hsc_adv_num << 24) |
+			(cfg->hsc_adv_phase << 0)
+		       );
+	if (cfg->hsc_adv_num > 255)
+		cfg->hsc_adv_num = cfg->hsc_adv_num >> 8;
+	else
+		cfg->hsc_adv_num = 0;
+	ge2d_reg_write(GE2D_HSC_INI_CTRL,
+			(cfg->hsc_rpt_p0_num << 29) |
+			(cfg->hsc_adv_num << 24) |
+			((cfg->hsc_ini_phase & 0xffffff) << 0)
+		       );
+#else
+	ge2d_reg_write(GE2D_HSC_ADV_CTRL,
+			(cfg->hsc_adv_num << 24) |
+			(cfg->hsc_adv_phase << 0)
+		       );
+	ge2d_reg_write(GE2D_HSC_INI_CTRL,
+			(cfg->hsc_rpt_p0_num << 29) |
+			((cfg->hsc_ini_phase & 0xffffff) << 0)
+		       );
+#endif
+
+	ge2d_reg_write(GE2D_VSC_START_PHASE_STEP, cfg->vsc_phase_step);
+
+	ge2d_reg_write(GE2D_VSC_PHASE_SLOPE, cfg->vsc_phase_slope);
+
+	ge2d_reg_write(GE2D_VSC_INI_CTRL,
+			(cfg->vsc_rpt_l0_num << 29) |
+			(cfg->vsc_ini_phase << 0)
+		       );
+#ifdef CONFIG_GE2D_SRC2
+	if (ge2d_meson_dev.src2_alp == 1)
+		ge2d_reg_write(GE2D_ALU_OP_CTRL,
+				(cfg->src2_cmult_ad << 27) |
+				(cfg->src1_cmult_asel << 25) |
+				(cfg->src2_cmult_asel << 23) |
+				(cfg->color_blend_mode << 20) |
+				(cfg->color_src_blend_factor << 16) |
+				(((cfg->color_blend_mode == 5) ?
+				cfg->color_logic_op :
+				  cfg->color_dst_blend_factor) << 12) |
+				(cfg->alpha_blend_mode << 8) |
+				(cfg->alpha_src_blend_factor << 4) |
+				(((cfg->alpha_blend_mode == 5) ?
+				cfg->alpha_logic_op :
+				  cfg->alpha_dst_blend_factor) << 0)
+			       );
+	else
+#endif
+		ge2d_reg_write(GE2D_ALU_OP_CTRL,
+			(cfg->src1_cmult_asel << 25) |
+			(cfg->src2_cmult_asel << 24) |
+			(cfg->color_blend_mode << 20) |
+			(cfg->color_src_blend_factor << 16) |
+			(((cfg->color_blend_mode == 5) ? cfg->color_logic_op :
+			  cfg->color_dst_blend_factor) << 12) |
+			(cfg->alpha_blend_mode << 8) |
+			(cfg->alpha_src_blend_factor << 4) |
+			(((cfg->alpha_blend_mode == 5) ? cfg->alpha_logic_op :
+			  cfg->alpha_dst_blend_factor) << 0)
+		       );
+
+	/* if true, disable bug fix about the dp_out_done/
+	 * scale_out_done(test1823) hang issue when
+	 * scaling down ratio is high.
+	 */
+	if (ge2d_meson_dev.hang_flag == 1)
+		ge2d_reg_set_bits(GE2D_GEN_CTRL4, cfg->hang_flag, 0, 1);
+	ge2d_reg_write(GE2D_CMD_CTRL,
+			(cfg->src2_fill_color_en << 9) |
+			(cfg->src1_fill_color_en << 8) |
+			(cfg->dst_xy_swap << 7) |
+			(cfg->dst_x_rev << 6) |
+			(cfg->dst_y_rev << 5) |
+			(cfg->src2_x_rev << 4) |
+			(cfg->src2_y_rev << 3) |
+			(cfg->src1_x_rev << 2) |
+			(cfg->src1_y_rev << 1) |
+			1  << 0 /* start cmd */
+		       );
+	cfg->release_flag |= START_FLAG;
+}
+
+void ge2d_wait_done(void)
+{
+	while (ge2d_reg_read(GE2D_STATUS0) & 1)
+		;
+}
+
+bool ge2d_is_busy(void)
+{
+	if (ge2d_reg_read(GE2D_STATUS0) & 1)
+		return true;
+	else
+		return false;
+}
+
+void ge2d_soft_rst(void)
+{
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, 1, 31, 1);
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, 0, 31, 1);
+}
+
+void ge2d_set_gen(struct ge2d_gen_s *cfg)
+{
+	ge2d_reg_set_bits(GE2D_GEN_CTRL1, cfg->interrupt_ctrl, 24, 2);
+
+	ge2d_reg_write(GE2D_DP_ONOFF_CTRL,
+			(cfg->dp_onoff_mode << 31) |
+			(cfg->dp_on_cnt << 16) |
+			(cfg->vfmt_onoff_en << 15) |
+			(cfg->dp_off_cnt << 0)
+		       );
+	if (ge2d_meson_dev.fifo == 1) {
+		ge2d_reg_set_bits(GE2D_GEN_CTRL4,
+			(cfg->fifo_size << 26) |
+			(cfg->fifo_size << 24) |
+			(cfg->fifo_size << 22) |
+			(cfg->fifo_size << 20) |
+			(cfg->burst_ctrl << 18) |
+			(cfg->burst_ctrl << 16),
+		       16, 12);
+	}
+}
+
diff -Naur a/vendor/amlogic/ge2d/ge2d_io.h b/vendor/amlogic/ge2d/ge2d_io.h
--- a/vendor/amlogic/ge2d/ge2d_io.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_io.h	2022-06-24 14:37:49.714608731 +0800
@@ -0,0 +1,191 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_io.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2D_IO_H_
+#define _GE2D_IO_H_
+
+#include <linux/io.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/power_ctrl.h>
+#include <linux/amlogic/power_domain.h>
+
+#include "ge2d_log.h"
+
+#define GE2DBUS_REG_ADDR(reg) (((reg - 0x1800) << 2))
+#define GE2D_PWR_DOMAIN       19
+
+extern unsigned int ge2d_dump_reg_cnt;
+extern unsigned int ge2d_dump_reg_enable;
+extern void __iomem *ge2d_reg_map;
+
+struct reg_map_s {
+	unsigned int phy_addr;
+	unsigned int size;
+	void __iomem *vir_addr;
+	int flag;
+};
+
+static struct reg_map_s reg_map = {
+	.phy_addr = 0xd0160000,
+	.size = 0x10000,
+};
+
+static int check_map_flag(unsigned int addr)
+{
+	int ret = 0;
+
+	if (reg_map.flag)
+		return 1;
+
+	if (ge2d_reg_map) {
+		reg_map.vir_addr = ge2d_reg_map;
+		reg_map.flag = 1;
+		ret = 1;
+	} else {
+		reg_map.vir_addr = ioremap(reg_map.phy_addr, reg_map.size);
+		if (!reg_map.vir_addr) {
+			pr_info("failed map phy: 0x%x\n", addr);
+			ret = 0;
+		} else {
+			reg_map.flag = 1;
+			ge2d_log_dbg("mapped phy: 0x%x\n", reg_map.phy_addr);
+			ret = 1;
+		}
+	}
+	return ret;
+}
+
+static uint32_t ge2d_reg_read(unsigned int reg)
+{
+	unsigned int addr = 0;
+	unsigned int val = 0;
+
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXBB)
+		return (uint32_t)aml_read_cbus(reg);
+
+	addr = GE2DBUS_REG_ADDR(reg);
+	if (check_map_flag(addr))
+		val = readl(reg_map.vir_addr + addr);
+
+	ge2d_log_dbg2("read(0x%x)=0x%x\n", reg_map.phy_addr + addr, val);
+
+	return val;
+}
+
+static void ge2d_reg_write(unsigned int reg, unsigned int val)
+{
+	unsigned int addr = 0;
+
+	if (get_cpu_type() < MESON_CPU_MAJOR_ID_GXBB) {
+		aml_write_cbus(reg, val);
+		return;
+	}
+
+	addr = GE2DBUS_REG_ADDR(reg);
+	if (check_map_flag(addr)) {
+		writel(val, reg_map.vir_addr + addr);
+		/* ret = readl(reg_map.vir_addr + addr); */
+	}
+	if (ge2d_dump_reg_enable && (ge2d_dump_reg_cnt > 0)) {
+		ge2d_log_info("write(0x%x) = 0x%x\n",
+				reg, val);
+		ge2d_dump_reg_cnt--;
+	}
+}
+
+static inline uint32_t ge2d_vcbus_read(uint32_t reg)
+{
+	return (uint32_t)aml_read_vcbus(reg);
+};
+
+static inline uint32_t ge2d_reg_get_bits(uint32_t reg,
+		const uint32_t start,
+		const uint32_t len)
+{
+	uint32_t val;
+
+	val = (ge2d_reg_read(reg) >> (start)) & ((1L << (len)) - 1);
+	return val;
+}
+
+static inline void ge2d_reg_set_bits(uint32_t reg,
+				      const uint32_t value,
+				      const uint32_t start,
+				      const uint32_t len)
+{
+	ge2d_reg_write(reg, ((ge2d_reg_read(reg) &
+			       ~(((1L << (len)) - 1) << (start))) |
+			      (((value) & ((1L << (len)) - 1)) << (start))));
+}
+
+static void ge2d_hiu_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len)
+{
+	aml_write_hiubus(_reg, ((aml_read_hiubus(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+static void ge2d_ao_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len)
+{
+	aml_write_aobus(_reg, ((aml_read_aobus(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+static void ge2d_c_setb(unsigned int _reg, unsigned int _value,
+		unsigned int _start, unsigned int _len)
+{
+	aml_write_cbus(_reg, ((aml_read_cbus(_reg) &
+			~(((1L << (_len))-1) << (_start))) |
+			(((_value)&((1L<<(_len))-1)) << (_start))));
+}
+
+static inline void ge2d_set_pwr_tbl_bits(unsigned int table_type,
+			unsigned int reg, unsigned int val,
+			unsigned int start, unsigned int len)
+{
+	switch (table_type) {
+	case CBUS_BASE:
+		ge2d_c_setb(reg, val, start, len);
+	break;
+	case AOBUS_BASE:
+		ge2d_ao_setb(reg, val, start, len);
+	break;
+	case HIUBUS_BASE:
+		ge2d_hiu_setb(reg, val, start, len);
+	break;
+	case GEN_PWR_SLEEP0:
+		power_ctrl_sleep(val ? 0 : 1, start);
+	break;
+	case GEN_PWR_ISO0:
+		power_ctrl_iso(val ? 0 : 1, start);
+	break;
+	case MEM_PD_REG0:
+		power_ctrl_mempd0(val ? 0 : 1, 0xFF, start);
+	break;
+	case PWR_DOMAIN_CTRL:
+		power_domain_switch(GE2D_PWR_DOMAIN, val);
+	break;
+	default:
+		ge2d_log_err("unsupported bus type\n");
+	break;
+	}
+}
+#endif
diff -Naur a/vendor/amlogic/ge2d/ge2d_log.h b/vendor/amlogic/ge2d/ge2d_log.h
--- a/vendor/amlogic/ge2d/ge2d_log.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_log.h	2022-06-24 14:37:49.735290506 +0800
@@ -0,0 +1,52 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_log.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2D_LOG_H_
+#define _GE2D_LOG_H_
+
+#include <stdarg.h>
+#include <linux/printk.h>
+
+#define GE2D_LOG_TAG "[GE2D]"
+#define GE2D_LOG_LEVEL_NULL 0
+#define GE2D_LOG_LEVEL_DEBUG 1
+#define GE2D_LOG_LEVEL_DEBUG2 2
+
+extern unsigned int ge2d_log_level;
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#define ge2d_log_info(fmt, ...) \
+	pr_info(fmt, ##__VA_ARGS__)
+
+#define ge2d_log_err(fmt, ...) \
+	pr_err(fmt, ##__VA_ARGS__)
+
+#define ge2d_log_dbg(fmt, ...) \
+	do { \
+		if (ge2d_log_level >= GE2D_LOG_LEVEL_DEBUG) { \
+			pr_info(fmt, ##__VA_ARGS__); \
+		} \
+	} while (0)
+
+#define ge2d_log_dbg2(fmt, ...) \
+	do { \
+		if (ge2d_log_level >= GE2D_LOG_LEVEL_DEBUG2) { \
+			pr_info(fmt, ##__VA_ARGS__); \
+		} \
+	} while (0)
+
+#endif
diff -Naur a/vendor/amlogic/ge2d/ge2d_main.c b/vendor/amlogic/ge2d/ge2d_main.c
--- a/vendor/amlogic/ge2d/ge2d_main.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_main.c	2022-06-24 14:37:49.764406249 +0800
@@ -0,0 +1,1404 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_main.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* Linux Headers */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/fb.h>
+#include <linux/list.h>
+#include <linux/uaccess.h>
+#include <linux/sysfs.h>
+#include <linux/spinlock.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/of_address.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/reset.h>
+#include <linux/clk.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+/* Amlogic Headers */
+#include <linux/amlogic/media/ge2d/ge2d.h>
+#include <linux/amlogic/media/ge2d/ge2d_cmd.h>
+#ifdef CONFIG_AMLOGIC_VPU
+#include <linux/amlogic/media/vpu/vpu.h>
+#endif
+#include <linux/amlogic/cpu_version.h>
+#ifdef CONFIG_AMLOGIC_ION
+#include <meson_ion.h>
+#endif
+/* Local Headers */
+#include "ge2dgen.h"
+#include "ge2d_log.h"
+#include "ge2d_wq.h"
+#include "ge2d_dmabuf.h"
+
+#define GE2D_CLASS_NAME "ge2d"
+#define MAX_GE2D_CLK 500000000
+#define HHI_MEM_PD_REG0 0x40
+#define RESET2_LEVEL    0x422
+#define GE2D_POWER_DOMAIN_CTRL
+
+struct ge2d_device_s {
+	char name[20];
+	atomic_t open_count;
+	int major;
+	unsigned int dbg_enable;
+	struct class *cla;
+	struct device *dev;
+};
+
+void __iomem *ge2d_reg_map;
+static struct ge2d_device_s ge2d_device;
+static DEFINE_MUTEX(ge2d_mutex);
+unsigned int ge2d_log_level;
+unsigned int ge2d_dump_reg_enable;
+unsigned int ge2d_dump_reg_cnt;
+#ifdef CONFIG_AMLOGIC_ION
+struct ion_client *ge2d_ion_client;
+#endif
+
+struct ge2d_device_data_s ge2d_meson_dev;
+
+static int init_ge2d_device(void);
+static int remove_ge2d_device(void);
+static int ge2d_open(struct inode *inode, struct file *file);
+static long ge2d_ioctl(struct file *filp, unsigned int cmd,
+		       unsigned long args);
+#ifdef CONFIG_COMPAT
+static long ge2d_compat_ioctl(struct file *filp, unsigned int cmd,
+			      unsigned long args);
+#endif
+static int ge2d_release(struct inode *inode, struct file *file);
+static ssize_t log_level_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf);
+static ssize_t log_level_store(struct class *cla,
+			       struct class_attribute *attr,
+			       const char *buf, size_t count);
+static ssize_t dump_reg_enable_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf);
+static ssize_t dump_reg_enable_store(struct class *cla,
+				 struct class_attribute *attr,
+				 const char *buf, size_t count);
+static ssize_t dump_reg_cnt_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf);
+static ssize_t dump_reg_cnt_store(struct class *cla,
+			       struct class_attribute *attr,
+			       const char *buf, size_t count);
+
+
+static const struct file_operations ge2d_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ge2d_open,
+	.unlocked_ioctl = ge2d_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = ge2d_compat_ioctl,
+#endif
+	.release	= ge2d_release,
+};
+
+static CLASS_ATTR_RO(work_queue_status);
+static CLASS_ATTR_RO(free_queue_status);
+static CLASS_ATTR_RW(log_level);
+static CLASS_ATTR_RW(dump_reg_enable);
+static CLASS_ATTR_RW(dump_reg_cnt);
+
+static struct attribute *ge2d_class_attrs[] = {
+	&class_attr_work_queue_status.attr,
+	&class_attr_free_queue_status.attr,
+	&class_attr_log_level.attr,
+	&class_attr_dump_reg_enable.attr,
+	&class_attr_dump_reg_cnt.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(ge2d_class);
+
+static struct class ge2d_class = {
+	.name = GE2D_CLASS_NAME,
+	.class_groups = ge2d_class_groups,
+};
+
+static ssize_t dump_reg_enable_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf)
+{
+	return snprintf(buf, 40, "%d\n", ge2d_dump_reg_enable);
+}
+
+static ssize_t dump_reg_enable_store(struct class *cla,
+			       struct class_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int res = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &res);
+	if (ret) {
+		ge2d_log_err("kstrtoint err\n");
+		return -EINVAL;
+	}
+
+	ge2d_log_info("ge2d dump_reg_enbale: %d->%d\n",
+		ge2d_dump_reg_enable, res);
+	ge2d_dump_reg_enable = res;
+
+	return count;
+}
+
+static ssize_t dump_reg_cnt_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf)
+{
+	return snprintf(buf, 40, "%d\n", ge2d_dump_reg_cnt);
+}
+
+static ssize_t dump_reg_cnt_store(struct class *cla,
+			       struct class_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int res = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &res);
+	if (ret) {
+		ge2d_log_err("kstrtoint err\n");
+		return -EINVAL;
+	}
+
+	ge2d_log_info("ge2d dump_reg: %d->%d\n", ge2d_dump_reg_cnt, res);
+	ge2d_dump_reg_cnt = res;
+	return count;
+}
+
+static ssize_t log_level_show(struct class *cla,
+			      struct class_attribute *attr,
+			      char *buf)
+{
+	return snprintf(buf, 40, "%d\n", ge2d_log_level);
+}
+
+static ssize_t log_level_store(struct class *cla,
+			       struct class_attribute *attr,
+			       const char *buf, size_t count)
+{
+	int res = 0;
+	int ret = 0;
+
+	ret = kstrtoint(buf, 0, &res);
+	if (ret) {
+		ge2d_log_err("kstrtoint err\n");
+		return -EINVAL;
+	}
+
+	ge2d_log_info("ge2d log_level: %d->%d\n", ge2d_log_level, res);
+	ge2d_log_level = res;
+
+	return count;
+}
+
+static int ge2d_open(struct inode *inode, struct file *file)
+{
+	struct ge2d_context_s *context = NULL;
+
+	/* we create one ge2d workqueue for this file handler. */
+	context = create_ge2d_work_queue();
+	if (!context) {
+		ge2d_log_err("can't create work queue\n");
+		return -1;
+	}
+	file->private_data = context;
+	atomic_inc(&ge2d_device.open_count);
+
+	return 0;
+}
+
+static int ge2d_ioctl_config_ex_mem(struct ge2d_context_s *context,
+	unsigned int cmd, unsigned long args)
+{
+	struct config_para_ex_memtype_s *ge2d_config_ex_mem;
+	struct config_ge2d_para_ex_s ge2d_para_config;
+	int ret = 0;
+#ifdef CONFIG_COMPAT
+	struct compat_config_para_ex_memtype_s __user *uf_ex_mem;
+	struct compat_config_ge2d_para_ex_s __user *uf_ge2d_para;
+	int r = 0;
+	int i, j;
+#endif
+	void __user *argp = (void __user *)args;
+
+	memset(&ge2d_para_config, 0, sizeof(struct config_ge2d_para_ex_s));
+	switch (cmd) {
+	case GE2D_CONFIG_EX_MEM:
+		ret = copy_from_user(&ge2d_para_config, argp,
+			sizeof(struct config_ge2d_para_ex_s));
+		ge2d_config_ex_mem = &(ge2d_para_config.para_config_memtype);
+		ret = ge2d_context_config_ex_mem(context, ge2d_config_ex_mem);
+		break;
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG_EX32_MEM:
+		uf_ge2d_para = (struct compat_config_ge2d_para_ex_s *)argp;
+		r |= get_user(ge2d_para_config.para_config_memtype.ge2d_magic,
+			&uf_ge2d_para->para_config_memtype.ge2d_magic);
+		ge2d_config_ex_mem = &(ge2d_para_config.para_config_memtype);
+
+		if (ge2d_para_config.para_config_memtype.ge2d_magic
+			== sizeof(struct compat_config_para_ex_memtype_s)) {
+			struct config_para_ex_ion_s *pge2d_config_ex;
+
+			uf_ex_mem =
+				(struct compat_config_para_ex_memtype_s *)argp;
+			pge2d_config_ex =
+				&(ge2d_config_ex_mem->_ge2d_config_ex);
+			r = copy_from_user(
+				&pge2d_config_ex->src_para,
+				&uf_ex_mem->_ge2d_config_ex.src_para,
+				sizeof(struct src_dst_para_ex_s));
+			r |= copy_from_user(
+				&pge2d_config_ex->src2_para,
+				&uf_ex_mem->_ge2d_config_ex.src2_para,
+				sizeof(struct src_dst_para_ex_s));
+			r |= copy_from_user(
+				&pge2d_config_ex->dst_para,
+				&uf_ex_mem->_ge2d_config_ex.dst_para,
+				sizeof(struct src_dst_para_ex_s));
+			r |= copy_from_user(&pge2d_config_ex->src_key,
+				&uf_ex_mem->_ge2d_config_ex.src_key,
+				sizeof(struct src_key_ctrl_s));
+			r |= copy_from_user(&pge2d_config_ex->src2_key,
+				&uf_ex_mem->_ge2d_config_ex.src2_key,
+				sizeof(struct src_key_ctrl_s));
+
+			r |= get_user(pge2d_config_ex->src1_cmult_asel,
+				&uf_ex_mem->_ge2d_config_ex.src1_cmult_asel);
+			r |= get_user(pge2d_config_ex->src2_cmult_asel,
+				&uf_ex_mem->_ge2d_config_ex.src2_cmult_asel);
+			r |= get_user(pge2d_config_ex->alu_const_color,
+				&uf_ex_mem->_ge2d_config_ex.alu_const_color);
+			r |= get_user(pge2d_config_ex->src1_gb_alpha_en,
+				&uf_ex_mem->_ge2d_config_ex.src1_gb_alpha_en);
+			r |= get_user(pge2d_config_ex->src1_gb_alpha,
+				&uf_ex_mem->_ge2d_config_ex.src1_gb_alpha);
+#ifdef CONFIG_GE2D_SRC2
+			r |= get_user(pge2d_config_ex->src2_gb_alpha_en,
+				&uf_ex_mem->_ge2d_config_ex.src2_gb_alpha_en);
+			r |= get_user(pge2d_config_ex->src2_gb_alpha,
+				&uf_ex_mem->_ge2d_config_ex.src2_gb_alpha);
+#endif
+			r |= get_user(pge2d_config_ex->op_mode,
+				&uf_ex_mem->_ge2d_config_ex.op_mode);
+			r |= get_user(pge2d_config_ex->bitmask_en,
+				&uf_ex_mem->_ge2d_config_ex.bitmask_en);
+			r |= get_user(pge2d_config_ex->bytemask_only,
+				&uf_ex_mem->_ge2d_config_ex.bytemask_only);
+			r |= get_user(pge2d_config_ex->bitmask,
+				&uf_ex_mem->_ge2d_config_ex.bitmask);
+			r |= get_user(pge2d_config_ex->dst_xy_swap,
+				&uf_ex_mem->_ge2d_config_ex.dst_xy_swap);
+			r |= get_user(pge2d_config_ex->hf_init_phase,
+				&uf_ex_mem->_ge2d_config_ex.hf_init_phase);
+			r |= get_user(pge2d_config_ex->hf_rpt_num,
+				&uf_ex_mem->_ge2d_config_ex.hf_rpt_num);
+			r |= get_user(pge2d_config_ex->hsc_start_phase_step,
+				&uf_ex_mem->_ge2d_config_ex
+				.hsc_start_phase_step);
+			r |= get_user(pge2d_config_ex->hsc_phase_slope,
+				&uf_ex_mem->_ge2d_config_ex.hsc_phase_slope);
+			r |= get_user(pge2d_config_ex->vf_init_phase,
+				&uf_ex_mem->_ge2d_config_ex.vf_init_phase);
+			r |= get_user(pge2d_config_ex->vf_rpt_num,
+				&uf_ex_mem->_ge2d_config_ex.vf_rpt_num);
+			r |= get_user(pge2d_config_ex->vsc_start_phase_step,
+				&uf_ex_mem->_ge2d_config_ex
+				.vsc_start_phase_step);
+			r |= get_user(pge2d_config_ex->vsc_phase_slope,
+				&uf_ex_mem->_ge2d_config_ex.vsc_phase_slope);
+			r |= get_user(
+				pge2d_config_ex->src1_vsc_phase0_always_en,
+				&uf_ex_mem->_ge2d_config_ex
+				.src1_vsc_phase0_always_en);
+			r |= get_user(
+				pge2d_config_ex->src1_hsc_phase0_always_en,
+				&uf_ex_mem->_ge2d_config_ex
+				.src1_hsc_phase0_always_en);
+			r |= get_user(
+				pge2d_config_ex->src1_hsc_rpt_ctrl,
+				&uf_ex_mem->_ge2d_config_ex.src1_hsc_rpt_ctrl);
+			r |= get_user(
+				pge2d_config_ex->src1_vsc_rpt_ctrl,
+				&uf_ex_mem->_ge2d_config_ex.src1_vsc_rpt_ctrl);
+
+			for (i = 0; i < 4; i++) {
+				struct config_planes_ion_s *psrc_planes;
+
+				psrc_planes =
+					&pge2d_config_ex->src_planes[i];
+				r |= get_user(psrc_planes->addr,
+					&uf_ex_mem->_ge2d_config_ex
+					.src_planes[i].addr);
+				r |= get_user(psrc_planes->w,
+					&uf_ex_mem->_ge2d_config_ex
+					.src_planes[i].w);
+				r |= get_user(psrc_planes->h,
+					&uf_ex_mem->_ge2d_config_ex
+					.src_planes[i].h);
+				r |= get_user(psrc_planes->shared_fd,
+					&uf_ex_mem->_ge2d_config_ex
+					.src_planes[i].shared_fd);
+			}
+
+			for (i = 0; i < 4; i++) {
+				struct config_planes_ion_s *psrc2_planes;
+
+				psrc2_planes =
+					&pge2d_config_ex->src2_planes[i];
+				r |= get_user(psrc2_planes->addr,
+					&uf_ex_mem->_ge2d_config_ex
+					.src2_planes[i].addr);
+				r |= get_user(psrc2_planes->w,
+					&uf_ex_mem->_ge2d_config_ex
+					.src2_planes[i].w);
+				r |= get_user(psrc2_planes->h,
+					&uf_ex_mem->_ge2d_config_ex
+					.src2_planes[i].h);
+				r |= get_user(psrc2_planes->shared_fd,
+					&uf_ex_mem->_ge2d_config_ex
+					.src2_planes[i].shared_fd);
+			}
+
+			for (j = 0; j < 4; j++) {
+				struct config_planes_ion_s *pdst_planes;
+
+				pdst_planes =
+					&pge2d_config_ex->dst_planes[j];
+				r |= get_user(pdst_planes->addr,
+					&uf_ex_mem->_ge2d_config_ex
+					.dst_planes[j].addr);
+				r |= get_user(pdst_planes->w,
+					&uf_ex_mem->_ge2d_config_ex
+					.dst_planes[j].w);
+				r |= get_user(pdst_planes->h,
+					&uf_ex_mem->_ge2d_config_ex
+					.dst_planes[j].h);
+				r |= get_user(pdst_planes->shared_fd,
+					&uf_ex_mem->_ge2d_config_ex
+					.dst_planes[j].shared_fd);
+			}
+
+			r |= get_user(ge2d_config_ex_mem->src1_mem_alloc_type,
+				&uf_ex_mem->src1_mem_alloc_type);
+			r |= get_user(ge2d_config_ex_mem->src2_mem_alloc_type,
+				&uf_ex_mem->src2_mem_alloc_type);
+			r |= get_user(ge2d_config_ex_mem->dst_mem_alloc_type,
+				&uf_ex_mem->dst_mem_alloc_type);
+
+		}
+		if (r) {
+			pr_err("GE2D_CONFIG_EX32 get parameter failed .\n");
+			return -EFAULT;
+		}
+		ret = ge2d_context_config_ex_mem(context, ge2d_config_ex_mem);
+		break;
+#endif
+	}
+	return ret;
+}
+
+static long ge2d_ioctl(struct file *filp, unsigned int cmd, unsigned long args)
+{
+	struct ge2d_context_s *context = NULL;
+	struct config_para_s ge2d_config;
+	struct ge2d_para_s para;
+	struct config_para_ex_s ge2d_config_ex;
+	struct config_para_ex_ion_s ge2d_config_ex_ion;
+	struct ge2d_dmabuf_req_s ge2d_req_buf;
+	struct ge2d_dmabuf_exp_s ge2d_exp_buf;
+	int ret = 0;
+#ifdef CONFIG_COMPAT
+	struct compat_config_para_s __user *uf;
+	struct compat_config_para_ex_s __user *uf_ex;
+	struct compat_config_para_ex_ion_s __user *uf_ex_ion;
+	int r = 0;
+	int i, j;
+#endif
+	int cap_mask = 0;
+	int index = 0, dma_fd;
+	void __user *argp = (void __user *)args;
+
+	context = (struct ge2d_context_s *)filp->private_data;
+	memset(&ge2d_config, 0, sizeof(struct config_para_s));
+	memset(&ge2d_config_ex, 0, sizeof(struct config_para_ex_s));
+	memset(&ge2d_config_ex_ion, 0, sizeof(struct config_para_ex_ion_s));
+	memset(&ge2d_req_buf, 0, sizeof(struct ge2d_dmabuf_req_s));
+	memset(&ge2d_exp_buf, 0, sizeof(struct ge2d_dmabuf_exp_s));
+#ifdef CONFIG_AMLOGIC_MEDIA_GE2D_MORE_SECURITY
+	switch (cmd) {
+	case GE2D_CONFIG:
+	case GE2D_CONFIG32:
+	case GE2D_CONFIG_EX:
+	case GE2D_CONFIG_EX32:
+		pr_err("ioctl not support.\n");
+		return -EINVAL;
+	}
+#endif
+	switch (cmd) {
+	case GE2D_GET_CAP:
+		cap_mask = ge2d_meson_dev.src2_alp & 0x1;
+		put_user(cap_mask, (int __user *)argp);
+		break;
+	case GE2D_CONFIG:
+	case GE2D_SRCCOLORKEY:
+		ret = copy_from_user(&ge2d_config,
+				argp, sizeof(struct config_para_s));
+		break;
+#ifdef CONFIG_COMPAT
+	case GE2D_SRCCOLORKEY32:
+		uf = (struct compat_config_para_s *)argp;
+		r = get_user(ge2d_config.src_dst_type, &uf->src_dst_type);
+		r |= get_user(ge2d_config.alu_const_color,
+			&uf->alu_const_color);
+		r |= get_user(ge2d_config.src_format, &uf->src_format);
+		r |= get_user(ge2d_config.dst_format, &uf->dst_format);
+		for (i = 0; i < 4; i++) {
+			r |= get_user(ge2d_config.src_planes[i].addr,
+				&uf->src_planes[i].addr);
+			r |= get_user(ge2d_config.src_planes[i].w,
+				&uf->src_planes[i].w);
+			r |= get_user(ge2d_config.src_planes[i].h,
+				&uf->src_planes[i].h);
+		}
+		for (j = 0; j < 4; j++) {
+			r |= get_user(ge2d_config.dst_planes[j].addr,
+				&uf->dst_planes[j].addr);
+			r |= get_user(ge2d_config.dst_planes[j].w,
+				&uf->dst_planes[j].w);
+			r |= get_user(ge2d_config.dst_planes[j].h,
+				&uf->dst_planes[j].h);
+		}
+		r |= copy_from_user(&ge2d_config.src_key, &uf->src_key,
+			sizeof(struct src_key_ctrl_s));
+		if (r) {
+			pr_err("GE2D_SRCCOLORKEY32 get parameter failed .\n");
+			return -EFAULT;
+			}
+		break;
+#endif
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG32:
+		uf = (struct compat_config_para_s *)argp;
+		r = get_user(ge2d_config.src_dst_type, &uf->src_dst_type);
+		r |= get_user(ge2d_config.alu_const_color,
+			&uf->alu_const_color);
+		r |= get_user(ge2d_config.src_format, &uf->src_format);
+		r |= get_user(ge2d_config.dst_format, &uf->dst_format);
+		for (i = 0; i < 4; i++) {
+			r |= get_user(ge2d_config.src_planes[i].addr,
+				&uf->src_planes[i].addr);
+			r |= get_user(ge2d_config.src_planes[i].w,
+				&uf->src_planes[i].w);
+			r |= get_user(ge2d_config.src_planes[i].h,
+				&uf->src_planes[i].h);
+		}
+		for (j = 0; j < 4; j++) {
+			r |= get_user(ge2d_config.dst_planes[j].addr,
+				&uf->dst_planes[j].addr);
+			r |= get_user(ge2d_config.dst_planes[j].w,
+				&uf->dst_planes[j].w);
+			r |= get_user(ge2d_config.dst_planes[j].h,
+				&uf->dst_planes[j].h);
+		}
+		r |= copy_from_user(&ge2d_config.src_key, &uf->src_key,
+			sizeof(struct src_key_ctrl_s));
+		if (r) {
+			pr_err("GE2D_CONFIG32 get parameter failed .\n");
+			return -EFAULT;
+		}
+
+		break;
+#endif
+	case GE2D_CONFIG_EX:
+		ret = copy_from_user(&ge2d_config_ex, argp,
+				sizeof(struct config_para_ex_s));
+		break;
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG_EX32:
+		uf_ex = (struct compat_config_para_ex_s *)argp;
+		r = copy_from_user(&ge2d_config_ex.src_para, &uf_ex->src_para,
+			sizeof(struct src_dst_para_ex_s));
+		r |= copy_from_user(&ge2d_config_ex.src2_para,
+			&uf_ex->src2_para,
+			sizeof(struct src_dst_para_ex_s));
+		r |= copy_from_user(&ge2d_config_ex.dst_para, &uf_ex->dst_para,
+			sizeof(struct src_dst_para_ex_s));
+
+		r |= copy_from_user(&ge2d_config_ex.src_key, &uf_ex->src_key,
+			sizeof(struct src_key_ctrl_s));
+		r |= copy_from_user(&ge2d_config_ex.src2_key, &uf_ex->src2_key,
+			sizeof(struct src_key_ctrl_s));
+
+		r |= get_user(ge2d_config_ex.alu_const_color,
+			&uf_ex->alu_const_color);
+		r |= get_user(ge2d_config_ex.src1_gb_alpha,
+			&uf_ex->src1_gb_alpha);
+		r |= get_user(ge2d_config_ex.op_mode, &uf_ex->op_mode);
+		r |= get_user(ge2d_config_ex.bitmask_en, &uf_ex->bitmask_en);
+		r |= get_user(ge2d_config_ex.bytemask_only,
+			&uf_ex->bytemask_only);
+		r |= get_user(ge2d_config_ex.bitmask, &uf_ex->bitmask);
+		r |= get_user(ge2d_config_ex.dst_xy_swap, &uf_ex->dst_xy_swap);
+		r |= get_user(ge2d_config_ex.hf_init_phase,
+			&uf_ex->hf_init_phase);
+		r |= get_user(ge2d_config_ex.hf_rpt_num, &uf_ex->hf_rpt_num);
+		r |= get_user(ge2d_config_ex.hsc_start_phase_step,
+			&uf_ex->hsc_start_phase_step);
+		r |= get_user(ge2d_config_ex.hsc_phase_slope,
+			&uf_ex->hsc_phase_slope);
+		r |= get_user(ge2d_config_ex.vf_init_phase,
+			&uf_ex->vf_init_phase);
+		r |= get_user(ge2d_config_ex.vf_rpt_num, &uf_ex->vf_rpt_num);
+		r |= get_user(ge2d_config_ex.vsc_start_phase_step,
+			&uf_ex->vsc_start_phase_step);
+		r |= get_user(ge2d_config_ex.vsc_phase_slope,
+			&uf_ex->vsc_phase_slope);
+		r |= get_user(ge2d_config_ex.src1_vsc_phase0_always_en,
+			&uf_ex->src1_vsc_phase0_always_en);
+		r |= get_user(ge2d_config_ex.src1_hsc_phase0_always_en,
+			&uf_ex->src1_hsc_phase0_always_en);
+		r |= get_user(ge2d_config_ex.src1_hsc_rpt_ctrl,
+			&uf_ex->src1_hsc_rpt_ctrl);
+		r |= get_user(ge2d_config_ex.src1_vsc_rpt_ctrl,
+			&uf_ex->src1_vsc_rpt_ctrl);
+
+		for (i = 0; i < 4; i++) {
+			r |= get_user(ge2d_config_ex.src_planes[i].addr,
+				&uf_ex->src_planes[i].addr);
+			r |= get_user(ge2d_config_ex.src_planes[i].w,
+				&uf_ex->src_planes[i].w);
+			r |= get_user(ge2d_config_ex.src_planes[i].h,
+				&uf_ex->src_planes[i].h);
+		}
+
+		for (i = 0; i < 4; i++) {
+			r |= get_user(ge2d_config_ex.src2_planes[i].addr,
+				&uf_ex->src2_planes[i].addr);
+			r |= get_user(ge2d_config_ex.src2_planes[i].w,
+				&uf_ex->src2_planes[i].w);
+			r |= get_user(ge2d_config_ex.src2_planes[i].h,
+				&uf_ex->src2_planes[i].h);
+		}
+
+		for (j = 0; j < 4; j++) {
+			r |= get_user(ge2d_config_ex.dst_planes[j].addr,
+				&uf_ex->dst_planes[j].addr);
+			r |= get_user(ge2d_config_ex.dst_planes[j].w,
+				&uf_ex->dst_planes[j].w);
+			r |= get_user(ge2d_config_ex.dst_planes[j].h,
+				&uf_ex->dst_planes[j].h);
+		}
+
+		if (r) {
+			pr_err("GE2D_CONFIG_EX32 get parameter failed .\n");
+			return -EFAULT;
+			}
+		break;
+#endif
+		case GE2D_CONFIG_EX_ION:
+			ret = copy_from_user(&ge2d_config_ex_ion, argp,
+					sizeof(struct config_para_ex_ion_s));
+			break;
+#ifdef CONFIG_COMPAT
+		case GE2D_CONFIG_EX32_ION:
+			uf_ex_ion = (struct compat_config_para_ex_ion_s *)argp;
+			r = copy_from_user(
+				&ge2d_config_ex_ion.src_para,
+				&uf_ex_ion->src_para,
+				sizeof(struct src_dst_para_ex_s));
+			r |= copy_from_user(
+				&ge2d_config_ex_ion.src2_para,
+				&uf_ex_ion->src2_para,
+				sizeof(struct src_dst_para_ex_s));
+			r |= copy_from_user(
+				&ge2d_config_ex_ion.dst_para,
+				&uf_ex_ion->dst_para,
+				sizeof(struct src_dst_para_ex_s));
+
+			r |= copy_from_user(&ge2d_config_ex_ion.src_key,
+				&uf_ex_ion->src_key,
+				sizeof(struct src_key_ctrl_s));
+			r |= copy_from_user(&ge2d_config_ex_ion.src2_key,
+				&uf_ex_ion->src2_key,
+				sizeof(struct src_key_ctrl_s));
+
+			r |= get_user(ge2d_config_ex_ion.src1_cmult_asel,
+				&uf_ex_ion->src1_cmult_asel);
+			r |= get_user(ge2d_config_ex_ion.src2_cmult_asel,
+				&uf_ex_ion->src2_cmult_asel);
+			r |= get_user(ge2d_config_ex_ion.alu_const_color,
+				&uf_ex_ion->alu_const_color);
+			r |= get_user(ge2d_config_ex_ion.src1_gb_alpha_en,
+				&uf_ex_ion->src1_gb_alpha_en);
+			r |= get_user(ge2d_config_ex_ion.src1_gb_alpha,
+				&uf_ex_ion->src1_gb_alpha);
+#ifdef CONFIG_GE2D_SRC2
+			r |= get_user(ge2d_config_ex_ion.src2_gb_alpha_en,
+				&uf_ex_ion->src2_gb_alpha_en);
+			r |= get_user(ge2d_config_ex_ion.src2_gb_alpha,
+				&uf_ex_ion->src2_gb_alpha);
+#endif
+			r |= get_user(ge2d_config_ex_ion.op_mode,
+				&uf_ex_ion->op_mode);
+			r |= get_user(ge2d_config_ex_ion.bitmask_en,
+				&uf_ex_ion->bitmask_en);
+			r |= get_user(ge2d_config_ex_ion.bytemask_only,
+				&uf_ex_ion->bytemask_only);
+			r |= get_user(ge2d_config_ex_ion.bitmask,
+				&uf_ex_ion->bitmask);
+			r |= get_user(ge2d_config_ex_ion.dst_xy_swap,
+				&uf_ex_ion->dst_xy_swap);
+			r |= get_user(ge2d_config_ex_ion.hf_init_phase,
+				&uf_ex_ion->hf_init_phase);
+			r |= get_user(ge2d_config_ex_ion.hf_rpt_num,
+				&uf_ex_ion->hf_rpt_num);
+			r |= get_user(ge2d_config_ex_ion.hsc_start_phase_step,
+				&uf_ex_ion->hsc_start_phase_step);
+			r |= get_user(ge2d_config_ex_ion.hsc_phase_slope,
+				&uf_ex_ion->hsc_phase_slope);
+			r |= get_user(ge2d_config_ex_ion.vf_init_phase,
+				&uf_ex_ion->vf_init_phase);
+			r |= get_user(ge2d_config_ex_ion.vf_rpt_num,
+				&uf_ex_ion->vf_rpt_num);
+			r |= get_user(ge2d_config_ex_ion.vsc_start_phase_step,
+				&uf_ex_ion->vsc_start_phase_step);
+			r |= get_user(ge2d_config_ex_ion.vsc_phase_slope,
+				&uf_ex_ion->vsc_phase_slope);
+			r |= get_user(
+				ge2d_config_ex_ion.src1_vsc_phase0_always_en,
+				&uf_ex_ion->src1_vsc_phase0_always_en);
+			r |= get_user(
+				ge2d_config_ex_ion.src1_hsc_phase0_always_en,
+				&uf_ex_ion->src1_hsc_phase0_always_en);
+			r |= get_user(
+				ge2d_config_ex_ion.src1_hsc_rpt_ctrl,
+				&uf_ex_ion->src1_hsc_rpt_ctrl);
+			r |= get_user(
+				ge2d_config_ex_ion.src1_vsc_rpt_ctrl,
+				&uf_ex_ion->src1_vsc_rpt_ctrl);
+
+			for (i = 0; i < 4; i++) {
+				struct config_planes_ion_s *psrc_planes;
+
+				psrc_planes =
+					&ge2d_config_ex_ion.src_planes[i];
+				r |= get_user(psrc_planes->addr,
+					&uf_ex_ion->src_planes[i].addr);
+				r |= get_user(psrc_planes->w,
+					&uf_ex_ion->src_planes[i].w);
+				r |= get_user(psrc_planes->h,
+					&uf_ex_ion->src_planes[i].h);
+				r |= get_user(psrc_planes->shared_fd,
+					&uf_ex_ion->src_planes[i].shared_fd);
+			}
+
+			for (i = 0; i < 4; i++) {
+				struct config_planes_ion_s *psrc2_planes;
+
+				psrc2_planes =
+					&ge2d_config_ex_ion.src2_planes[i];
+				r |= get_user(psrc2_planes->addr,
+					&uf_ex_ion->src2_planes[i].addr);
+				r |= get_user(psrc2_planes->w,
+					&uf_ex_ion->src2_planes[i].w);
+				r |= get_user(psrc2_planes->h,
+					&uf_ex_ion->src2_planes[i].h);
+				r |= get_user(psrc2_planes->shared_fd,
+					&uf_ex_ion->src2_planes[i].shared_fd);
+			}
+
+			for (j = 0; j < 4; j++) {
+				struct config_planes_ion_s *pdst_planes;
+
+				pdst_planes =
+					&ge2d_config_ex_ion.dst_planes[j];
+				r |= get_user(pdst_planes->addr,
+					&uf_ex_ion->dst_planes[j].addr);
+				r |= get_user(pdst_planes->w,
+					&uf_ex_ion->dst_planes[j].w);
+				r |= get_user(pdst_planes->h,
+					&uf_ex_ion->dst_planes[j].h);
+				r |= get_user(pdst_planes->shared_fd,
+					&uf_ex_ion->dst_planes[j].shared_fd);
+			}
+			if (r) {
+				pr_err("GE2D_CONFIG_EX32 get parameter failed .\n");
+				return -EFAULT;
+				}
+			break;
+#endif
+	case GE2D_SET_COEF:
+	case GE2D_ANTIFLICKER_ENABLE:
+		break;
+	case GE2D_REQUEST_BUFF:
+		ret = copy_from_user(&ge2d_req_buf, argp,
+			sizeof(struct ge2d_dmabuf_req_s));
+		if (ret < 0) {
+			pr_err("Error user param\n");
+			return -EINVAL;
+		}
+		break;
+	case GE2D_EXP_BUFF:
+		ret = copy_from_user(&ge2d_exp_buf, argp,
+			sizeof(struct ge2d_dmabuf_exp_s));
+		if (ret < 0) {
+			pr_err("Error user param\n");
+			return -EINVAL;
+		}
+		break;
+	case GE2D_FREE_BUFF:
+		ret = copy_from_user(&index, argp,
+			sizeof(int));
+		if (ret < 0) {
+			pr_err("Error user param\n");
+			return -EINVAL;
+		}
+		break;
+	case GE2D_SYNC_DEVICE:
+	case GE2D_SYNC_CPU:
+		ret = copy_from_user(&dma_fd, argp,
+			sizeof(int));
+		if (ret < 0) {
+			pr_err("Error user param\n");
+			return -EINVAL;
+		}
+		break;
+	case GE2D_CONFIG_OLD:
+	case GE2D_CONFIG_EX_OLD:
+	case GE2D_SRCCOLORKEY_OLD:
+		pr_err("ioctl not support yed.\n");
+		return -EINVAL;
+	default:
+		ret = copy_from_user(&para, argp, sizeof(struct ge2d_para_s));
+		break;
+
+	}
+
+	switch (cmd) {
+	case GE2D_CONFIG:
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG32:
+#endif
+		ret = ge2d_context_config(context, &ge2d_config);
+		break;
+	case GE2D_CONFIG_EX:
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG_EX32:
+#endif
+		ret = ge2d_context_config_ex(context, &ge2d_config_ex);
+		break;
+	case GE2D_CONFIG_EX_ION:
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG_EX32_ION:
+#endif
+		ret = ge2d_context_config_ex_ion(context, &ge2d_config_ex_ion);
+		break;
+	case GE2D_CONFIG_EX_MEM:
+#ifdef CONFIG_COMPAT
+	case GE2D_CONFIG_EX32_MEM:
+#endif
+		ret = ge2d_ioctl_config_ex_mem(context, cmd, args);
+		break;
+	case GE2D_SET_COEF:
+		ge2d_wq_set_scale_coef(context, args & 0xff, args >> 16);
+		break;
+	case GE2D_ANTIFLICKER_ENABLE:
+		ge2d_antiflicker_enable(context, args);
+		break;
+	case GE2D_SRCCOLORKEY:
+#ifdef CONFIG_COMPAT
+	case GE2D_SRCCOLORKEY32:
+#endif
+		ge2d_log_dbg("src colorkey...,key_enable=0x%x,key_color=0x%x,key_mask=0x%x,key_mode=0x%x\n",
+			     ge2d_config.src_key.key_enable,
+			     ge2d_config.src_key.key_color,
+			     ge2d_config.src_key.key_mask,
+			     ge2d_config.src_key.key_mode);
+
+		ge2dgen_src_key(context, ge2d_config.src_key.key_enable,
+				ge2d_config.src_key.key_color,
+				ge2d_config.src_key.key_mask,
+				ge2d_config.src_key.key_mode); /* RGBA MODE */
+		break;
+	case GE2D_FILLRECTANGLE:
+		ge2d_log_dbg("fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x\n",
+			     para.src1_rect.x, para.src1_rect.y,
+			     para.src1_rect.w, para.src1_rect.h,
+			     para.color);
+
+		fillrect(context,
+			 para.src1_rect.x, para.src1_rect.y,
+			 para.src1_rect.w, para.src1_rect.h,
+			 para.color);
+		break;
+	case GE2D_FILLRECTANGLE_NOBLOCK:
+		ge2d_log_dbg("fill rect noblk\t");
+		ge2d_log_dbg("x=%d,y=%d,w=%d,h=%d,color=0x%x\n",
+			     para.src1_rect.x, para.src1_rect.y,
+			     para.src1_rect.w, para.src1_rect.h,
+			     para.color);
+
+		fillrect_noblk(context,
+			       para.src1_rect.x, para.src1_rect.y,
+			       para.src1_rect.w, para.src1_rect.h,
+			       para.color);
+		break;
+	case GE2D_STRETCHBLIT:
+		/* stretch blit */
+		ge2d_log_dbg("stretchblt\t");
+		ge2d_log_dbg("x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\n",
+			     para.src1_rect.x, para.src1_rect.y,
+			     para.src1_rect.w, para.src1_rect.h,
+			     para.dst_rect.w, para.dst_rect.h);
+
+		stretchblt(context,
+			   para.src1_rect.x, para.src1_rect.y,
+			   para.src1_rect.w, para.src1_rect.h,
+			   para.dst_rect.x,  para.dst_rect.y,
+			   para.dst_rect.w,  para.dst_rect.h);
+		break;
+	case GE2D_STRETCHBLIT_NOBLOCK:
+		/* stretch blit */
+		ge2d_log_dbg("stretchblt noblk\t");
+		ge2d_log_dbg("x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\n",
+			     para.src1_rect.x, para.src1_rect.y,
+			     para.src1_rect.w, para.src1_rect.h,
+			     para.dst_rect.w, para.dst_rect.h);
+
+		stretchblt_noblk(context,
+				 para.src1_rect.x, para.src1_rect.y,
+				 para.src1_rect.w, para.src1_rect.h,
+				 para.dst_rect.x,  para.dst_rect.y,
+				 para.dst_rect.w,  para.dst_rect.h);
+		break;
+	case GE2D_BLIT:
+		/* bitblt */
+		ge2d_log_dbg("blit...\n");
+		bitblt(context,
+		       para.src1_rect.x, para.src1_rect.y,
+		       para.src1_rect.w, para.src1_rect.h,
+		       para.dst_rect.x, para.dst_rect.y);
+		break;
+	case GE2D_BLIT_NOBLOCK:
+		/* bitblt */
+		ge2d_log_dbg("blit...,noblk\n");
+		bitblt_noblk(context,
+			     para.src1_rect.x, para.src1_rect.y,
+			     para.src1_rect.w, para.src1_rect.h,
+			     para.dst_rect.x, para.dst_rect.y);
+		break;
+	case GE2D_BLEND:
+		ge2d_log_dbg("blend ...\n");
+		blend(context,
+		      para.src1_rect.x, para.src1_rect.y,
+		      para.src1_rect.w, para.src1_rect.h,
+		      para.src2_rect.x, para.src2_rect.y,
+		      para.src2_rect.w, para.src2_rect.h,
+		      para.dst_rect.x, para.dst_rect.y,
+		      para.dst_rect.w, para.dst_rect.h,
+		      para.op);
+		break;
+	case GE2D_BLEND_NOBLOCK:
+		ge2d_log_dbg("blend ...,noblk\n");
+		blend_noblk(context,
+			    para.src1_rect.x, para.src1_rect.y,
+			    para.src1_rect.w, para.src1_rect.h,
+			    para.src2_rect.x, para.src2_rect.y,
+			    para.src2_rect.w, para.src2_rect.h,
+			    para.dst_rect.x, para.dst_rect.y,
+			    para.dst_rect.w, para.dst_rect.h,
+			    para.op);
+		break;
+	case GE2D_BLEND_NOALPHA:
+		ge2d_log_dbg("blend_noalpha ...\n");
+		blend_noalpha(context,
+			  para.src1_rect.x, para.src1_rect.y,
+			  para.src1_rect.w, para.src1_rect.h,
+			  para.src2_rect.x, para.src2_rect.y,
+			  para.src2_rect.w, para.src2_rect.h,
+			  para.dst_rect.x, para.dst_rect.y,
+			  para.dst_rect.w, para.dst_rect.h,
+			  para.op);
+			break;
+	case GE2D_BLEND_NOALPHA_NOBLOCK:
+		ge2d_log_dbg("blend_noalpha ...,noblk\n");
+		blend_noalpha_noblk(context,
+				para.src1_rect.x, para.src1_rect.y,
+				para.src1_rect.w, para.src1_rect.h,
+				para.src2_rect.x, para.src2_rect.y,
+				para.src2_rect.w, para.src2_rect.h,
+				para.dst_rect.x, para.dst_rect.y,
+				para.dst_rect.w, para.dst_rect.h,
+				para.op);
+		break;
+	case GE2D_BLIT_NOALPHA:
+		/* bitblt_noalpha */
+		ge2d_log_dbg("blit_noalpha...\n");
+		bitblt_noalpha(context,
+			       para.src1_rect.x, para.src1_rect.y,
+			       para.src1_rect.w, para.src1_rect.h,
+			       para.dst_rect.x, para.dst_rect.y);
+		break;
+	case GE2D_BLIT_NOALPHA_NOBLOCK:
+		/* bitblt_noalpha */
+		ge2d_log_dbg("blit_noalpha...,noblk\n");
+		bitblt_noalpha_noblk(context,
+				     para.src1_rect.x, para.src1_rect.y,
+				     para.src1_rect.w, para.src1_rect.h,
+				     para.dst_rect.x, para.dst_rect.y);
+		break;
+	case GE2D_STRETCHBLIT_NOALPHA:
+		/* stretch blit */
+		ge2d_log_dbg("stretchblt_noalpha\t");
+		ge2d_log_dbg("x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\n",
+			     para.src1_rect.x, para.src1_rect.y,
+			     para.src1_rect.w, para.src1_rect.h,
+			     para.dst_rect.w, para.dst_rect.h);
+
+		stretchblt_noalpha(context,
+				   para.src1_rect.x, para.src1_rect.y,
+				   para.src1_rect.w, para.src1_rect.h,
+				   para.dst_rect.x,  para.dst_rect.y,
+				   para.dst_rect.w,  para.dst_rect.h);
+		break;
+	case GE2D_STRETCHBLIT_NOALPHA_NOBLOCK:
+		/* stretch blit */
+		ge2d_log_dbg("stretchblt_noalpha_noblk\t");
+		ge2d_log_dbg("x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\n",
+			     para.src1_rect.x, para.src1_rect.y,
+			     para.src1_rect.w, para.src1_rect.h,
+			     para.dst_rect.w, para.dst_rect.h);
+
+		stretchblt_noalpha_noblk(context,
+					 para.src1_rect.x, para.src1_rect.y,
+					 para.src1_rect.w, para.src1_rect.h,
+					 para.dst_rect.x,  para.dst_rect.y,
+					 para.dst_rect.w,  para.dst_rect.h);
+		break;
+	case GE2D_REQUEST_BUFF:
+		ret = ge2d_buffer_alloc(&ge2d_req_buf);
+		if (ret == 0)
+			ret = copy_to_user(argp, &ge2d_req_buf,
+				sizeof(struct ge2d_dmabuf_req_s));
+		break;
+	case GE2D_EXP_BUFF:
+		ret = ge2d_buffer_export(&ge2d_exp_buf);
+		if (ret == 0)
+			ret = copy_to_user(argp, &ge2d_exp_buf,
+				sizeof(struct ge2d_dmabuf_exp_s));
+		break;
+	case GE2D_FREE_BUFF:
+		ret = ge2d_buffer_free(index);
+		break;
+	case GE2D_SYNC_DEVICE:
+		ge2d_buffer_dma_flush(dma_fd);
+		break;
+	case GE2D_SYNC_CPU:
+		ge2d_buffer_cache_flush(dma_fd);
+		break;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long ge2d_compat_ioctl(struct file *filp,
+			      unsigned int cmd, unsigned long args)
+{
+	unsigned long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = ge2d_ioctl(filp, cmd, args);
+
+	return ret;
+}
+#endif
+
+static int ge2d_release(struct inode *inode, struct file *file)
+{
+	struct ge2d_context_s *context = NULL;
+
+	context = (struct ge2d_context_s *)file->private_data;
+	if (context && (destroy_ge2d_work_queue(context) == 0)) {
+		atomic_dec(&ge2d_device.open_count);
+		return 0;
+	}
+	ge2d_log_dbg("release one ge2d device\n");
+	return -1;
+}
+
+#ifndef GE2D_POWER_DOMAIN_CTRL
+static struct ge2d_ctrl_s default_poweron_ctrl[] = {
+			/* power up ge2d */
+			{GEN_PWR_SLEEP0, AO_RTI_GEN_PWR_SLEEP0, 0, 19, 1, 0},
+			/* Power up memory */
+			{MEM_PD_REG0, HHI_MEM_PD_REG0, 0, 18, 8, 100},
+			/* reset */
+			{CBUS_BASE, RESET2_LEVEL, 0, 6, 1, 0},
+			/* remove isolation */
+			{GEN_PWR_ISO0, AO_RTI_GEN_PWR_ISO0, 0, 19, 1, 0},
+			/* pull up reset */
+			{CBUS_BASE, RESET2_LEVEL, 1, 6, 1, 0}
+		};
+static struct ge2d_ctrl_s default_poweroff_ctrl[] = {
+			/* reset */
+			{CBUS_BASE, RESET2_LEVEL, 0, 6, 1, 0},
+			/* add isolation */
+			{GEN_PWR_ISO0, AO_RTI_GEN_PWR_ISO0, 1, 19, 1, 0},
+			/* Power down memory */
+			{MEM_PD_REG0, HHI_MEM_PD_REG0, 0xFF, 18, 8, 0},
+			/* power down ge2d */
+			{GEN_PWR_SLEEP0, AO_RTI_GEN_PWR_SLEEP0, 1, 19, 1, 0}
+		};
+
+struct ge2d_power_table_s default_poweron_table = {5, default_poweron_ctrl};
+struct ge2d_power_table_s default_poweroff_table = {4, default_poweroff_ctrl};
+#else
+static struct ge2d_ctrl_s default_poweron_ctrl[] = {
+			/* power on */
+			{PWR_DOMAIN_CTRL, 0, 0, 0, 0, 0},
+		};
+static struct ge2d_ctrl_s default_poweroff_ctrl[] = {
+			/* power off */
+			{PWR_DOMAIN_CTRL, 0, 1, 0, 0, 0},
+		};
+
+struct ge2d_power_table_s default_poweron_table = {1, default_poweron_ctrl};
+struct ge2d_power_table_s default_poweroff_table = {1, default_poweroff_ctrl};
+#endif
+
+static struct ge2d_device_data_s ge2d_gxl = {
+	.ge2d_rate = 400000000,
+	.src2_alp = 0,
+	.canvas_status = 0,
+	.deep_color = 0,
+	.hang_flag = 0,
+	.fifo = 0,
+	.has_self_pwr = 0,
+};
+
+static struct ge2d_device_data_s ge2d_gxm = {
+	.ge2d_rate = 400000000,
+	.src2_alp = 0,
+	.canvas_status = 0,
+	.deep_color = 0,
+	.hang_flag = 0,
+	.fifo = 0,
+	.has_self_pwr = 0,
+};
+
+static struct ge2d_device_data_s ge2d_txl = {
+	.ge2d_rate = 400000000,
+	.src2_alp = 0,
+	.canvas_status = 0,
+	.deep_color = 1,
+	.hang_flag = 0,
+	.fifo = 0,
+	.has_self_pwr = 0,
+};
+
+static struct ge2d_device_data_s ge2d_txlx = {
+	.ge2d_rate = 400000000,
+	.src2_alp = 0,
+	.canvas_status = 0,
+	.deep_color = 1,
+	.hang_flag = 1,
+	.fifo = 1,
+	.has_self_pwr = 0,
+};
+
+static struct ge2d_device_data_s ge2d_axg = {
+	.ge2d_rate = 400000000,
+	.src2_alp = 0,
+	.canvas_status = 1,
+	.deep_color = 1,
+	.hang_flag = 1,
+	.fifo = 1,
+	.has_self_pwr = 0,
+};
+
+static struct ge2d_device_data_s ge2d_g12a = {
+	.ge2d_rate = 500000000,
+	.src2_alp = 1,
+	.canvas_status = 0,
+	.deep_color = 1,
+	.hang_flag = 1,
+	.fifo = 1,
+	.has_self_pwr = 0,
+};
+
+static struct ge2d_device_data_s ge2d_sm1 = {
+	.ge2d_rate = 500000000,
+	.src2_alp = 1,
+	.canvas_status = 0,
+	.deep_color = 1,
+	.hang_flag = 1,
+	.fifo = 1,
+	.has_self_pwr = 1,
+	.poweron_table = &default_poweron_table,
+	.poweroff_table = &default_poweroff_table,
+};
+
+static const struct of_device_id ge2d_dt_match[] = {
+	{
+		.compatible = "amlogic, ge2d-gxl",
+		.data = &ge2d_gxl,
+	},
+	{
+		.compatible = "amlogic, ge2d-gxm",
+		.data = &ge2d_gxm,
+	},
+	{
+		.compatible = "amlogic, ge2d-txl",
+		.data = &ge2d_txl,
+	},
+	{
+		.compatible = "amlogic, ge2d-txlx",
+		.data = &ge2d_txlx,
+	},
+	{
+		.compatible = "amlogic, ge2d-axg",
+		.data = &ge2d_axg,
+	},
+	{
+		.compatible = "amlogic, ge2d-g12a",
+		.data = &ge2d_g12a,
+	},
+	{
+		.compatible = "amlogic, ge2d-sm1",
+		.data = &ge2d_sm1,
+	},
+	{},
+};
+
+static int ge2d_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	int irq = 0;
+	struct clk *clk_gate;
+	struct clk *clk_vapb0;
+	struct clk *clk;
+	struct resource res;
+
+	init_ge2d_device();
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+		struct ge2d_device_data_s *ge2d_meson;
+		struct device_node *of_node = pdev->dev.of_node;
+
+		match = of_match_node(ge2d_dt_match, of_node);
+		if (match) {
+			ge2d_meson = (struct ge2d_device_data_s *)match->data;
+			if (ge2d_meson)
+				memcpy(&ge2d_meson_dev, ge2d_meson,
+					sizeof(struct ge2d_device_data_s));
+			else {
+				pr_err("%s data NOT match\n", __func__);
+				return -ENODEV;
+			}
+		} else {
+				pr_err("%s NOT match\n", __func__);
+				return -ENODEV;
+		}
+	}
+	/* get interrupt resource */
+	irq = platform_get_irq_byname(pdev, "ge2d");
+	if (irq == -ENXIO) {
+		ge2d_log_err("get ge2d irq resource error\n");
+		ret = -ENXIO;
+		goto failed1;
+	}
+
+	clk_gate = devm_clk_get(&pdev->dev, "clk_ge2d_gate");
+	if (IS_ERR(clk_gate)) {
+		ge2d_log_err("cannot get clock\n");
+		clk_gate = NULL;
+		ret = -ENOENT;
+		goto failed1;
+	}
+	ge2d_log_info("clock source clk_ge2d_gate %px\n", clk_gate);
+	clk_prepare_enable(clk_gate);
+
+	clk = devm_clk_get(&pdev->dev, "clk_ge2d");
+	if (IS_ERR(clk)) {
+		ge2d_log_err("cannot get clock\n");
+		clk = NULL;
+		ret = -ENOENT;
+		goto failed1;
+	}
+	ge2d_log_info("clock clk_ge2d source %px\n", clk);
+	clk_prepare_enable(clk);
+
+	clk_vapb0 = devm_clk_get(&pdev->dev, "clk_vapb_0");
+	if (PTR_ERR(clk_vapb0) != -ENOENT) {
+		int vapb_rate = 0, vpu_rate = 0;
+
+		if (!IS_ERR(clk_vapb0)) {
+			ge2d_log_info("clock source clk_vapb_0 %px\n",
+				clk_vapb0);
+			vapb_rate =  ge2d_meson_dev.ge2d_rate;
+			#ifdef CONFIG_AMLOGIC_VPU
+			vpu_rate = get_vpu_clk();
+			ge2d_log_info(
+				"ge2d init clock is %d HZ, VPU clock is %d HZ\n",
+				vapb_rate, vpu_rate);
+
+			if (vpu_rate >= ge2d_meson_dev.ge2d_rate)
+				vapb_rate = ge2d_meson_dev.ge2d_rate;
+			else if (vpu_rate == 333330000)
+				vapb_rate = 333333333;
+			else if (vpu_rate == 166660000)
+				vapb_rate = 166666667;
+			else if (vapb_rate > vpu_rate)
+				vapb_rate = vpu_rate;
+			#endif
+			ge2d_log_info("ready to set vapb0: %d Hz\n", vapb_rate);
+			clk_set_rate(clk_vapb0, vapb_rate);
+			clk_prepare_enable(clk_vapb0);
+			vapb_rate = clk_get_rate(clk_vapb0);
+			ge2d_log_info("ge2d clock is %d MHZ\n",
+				vapb_rate/1000000);
+		}
+	}
+	ret = of_address_to_resource(pdev->dev.of_node, 0, &res);
+	if (ret == 0) {
+		ge2d_log_info("find address resource\n");
+		if (res.start != 0) {
+			ge2d_reg_map =
+				ioremap(res.start, resource_size(&res));
+			if (ge2d_reg_map) {
+				ge2d_log_info("map io source 0x%px,size=%d to 0x%px\n",
+					(void *)res.start,
+					(int)resource_size(&res),
+					ge2d_reg_map);
+			}
+		} else {
+			ge2d_reg_map = 0;
+			ge2d_log_info("ignore io source start %p,size=%d\n",
+			(void *)res.start, (int)resource_size(&res));
+		}
+	}
+	ret = of_reserved_mem_device_init(&(pdev->dev));
+	if (ret < 0)
+		ge2d_log_info("reserved mem is not used\n");
+
+	ret = ge2d_wq_init(pdev, irq, clk_gate);
+
+	clk_disable_unprepare(clk_gate);
+
+#ifdef CONFIG_AMLOGIC_ION
+	if (!ge2d_ion_client)
+		ge2d_ion_client = meson_ion_client_create(-1, "meson-ge2d");
+#endif
+failed1:
+	return ret;
+}
+
+static int ge2d_remove(struct platform_device *pdev)
+{
+	ge2d_log_info("%s\n", __func__);
+	ge2d_wq_deinit();
+	remove_ge2d_device();
+	return 0;
+}
+
+static struct platform_driver ge2d_driver = {
+	.probe      = ge2d_probe,
+	.remove     = ge2d_remove,
+	.driver     = {
+		.name = "ge2d",
+		.of_match_table = ge2d_dt_match,
+	}
+};
+
+static int init_ge2d_device(void)
+{
+	int  ret = 0;
+
+	strcpy(ge2d_device.name, "ge2d");
+	ret = register_chrdev(0, ge2d_device.name, &ge2d_fops);
+	if (ret <= 0) {
+		ge2d_log_err("register ge2d device error\n");
+		return  ret;
+	}
+	ge2d_device.major = ret;
+	ge2d_device.dbg_enable = 0;
+	ge2d_log_info("ge2d_dev major:%d\n", ret);
+	ret = class_register(&ge2d_class);
+	if (ret < 0) {
+		ge2d_log_err("error create ge2d class\n");
+		return ret;
+	}
+	ge2d_device.cla = &ge2d_class;
+	ge2d_device.dev = device_create(ge2d_device.cla,
+					NULL, MKDEV(ge2d_device.major,
+					0), NULL, ge2d_device.name);
+	if (IS_ERR(ge2d_device.dev)) {
+		ge2d_log_err("create ge2d device error\n");
+		class_unregister(ge2d_device.cla);
+		return -1;
+	}
+	return ret;
+}
+
+static int remove_ge2d_device(void)
+{
+	if (!ge2d_device.cla)
+		return 0;
+
+	if (ge2d_device.dev)
+		device_destroy(ge2d_device.cla, MKDEV(ge2d_device.major, 0));
+	class_unregister(ge2d_device.cla);
+	unregister_chrdev(ge2d_device.major, ge2d_device.name);
+
+	return  0;
+}
+
+static int __init ge2d_init_module(void)
+{
+	ge2d_log_info("%s\n", __func__);
+	if (platform_driver_register(&ge2d_driver)) {
+		ge2d_log_err("failed to register ge2d driver!\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static void __exit ge2d_remove_module(void)
+{
+	platform_driver_unregister(&ge2d_driver);
+	ge2d_log_info("%s\n", __func__);
+}
+
+module_init(ge2d_init_module);
+module_exit(ge2d_remove_module);
+
+MODULE_LICENSE("GPL");
diff -Naur a/vendor/amlogic/ge2d/ge2d_reg.h b/vendor/amlogic/ge2d/ge2d_reg.h
--- a/vendor/amlogic/ge2d/ge2d_reg.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_reg.h	2022-06-24 14:37:49.791691734 +0800
@@ -0,0 +1,104 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_reg.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2D_REG_H_
+#define _GE2D_REG_H_
+
+#define GE2D_GEN_CTRL0 0x18a0
+#define GE2D_GEN_CTRL1 0x18a1
+#define GE2D_GEN_CTRL2 0x18a2
+#define GE2D_CMD_CTRL 0x18a3
+#define GE2D_STATUS0 0x18a4
+#define GE2D_STATUS1 0x18a5
+#define GE2D_SRC1_DEF_COLOR 0x18a6
+#define GE2D_SRC1_CLIPX_START_END 0x18a7
+#define GE2D_SRC1_CLIPY_START_END 0x18a8
+#define GE2D_SRC1_CANVAS 0x18a9
+#define GE2D_SRC1_X_START_END 0x18aa
+#define GE2D_SRC1_Y_START_END 0x18ab
+#define GE2D_SRC1_LUT_ADDR 0x18ac
+#define GE2D_SRC1_LUT_DAT 0x18ad
+#define GE2D_SRC1_FMT_CTRL 0x18ae
+#define GE2D_SRC2_DEF_COLOR 0x18af
+#define GE2D_SRC2_CLIPX_START_END 0x18b0
+#define GE2D_SRC2_CLIPY_START_END 0x18b1
+#define GE2D_SRC2_X_START_END 0x18b2
+#define GE2D_SRC2_Y_START_END 0x18b3
+#define GE2D_DST_CLIPX_START_END 0x18b4
+#define GE2D_DST_CLIPY_START_END 0x18b5
+#define GE2D_DST_X_START_END 0x18b6
+#define GE2D_DST_Y_START_END 0x18b7
+#define GE2D_SRC2_DST_CANVAS 0x18b8
+#define GE2D_VSC_START_PHASE_STEP 0x18b9
+#define GE2D_VSC_PHASE_SLOPE 0x18ba
+#define GE2D_VSC_INI_CTRL 0x18bb
+#define GE2D_HSC_START_PHASE_STEP 0x18bc
+#define GE2D_HSC_PHASE_SLOPE 0x18bd
+#define GE2D_HSC_INI_CTRL 0x18be
+#define GE2D_HSC_ADV_CTRL 0x18bf
+#define GE2D_SC_MISC_CTRL 0x18c0
+#define GE2D_VSC_NRND_POINT 0x18c1
+#define GE2D_VSC_NRND_PHASE 0x18c2
+#define GE2D_HSC_NRND_POINT 0x18c3
+#define GE2D_HSC_NRND_PHASE 0x18c4
+#define GE2D_MATRIX_PRE_OFFSET 0x18c5
+#define GE2D_MATRIX_COEF00_01 0x18c6
+#define GE2D_MATRIX_COEF02_10 0x18c7
+#define GE2D_MATRIX_COEF11_12 0x18c8
+#define GE2D_MATRIX_COEF20_21 0x18c9
+#define GE2D_MATRIX_COEF22_CTRL 0x18ca
+#define GE2D_MATRIX_OFFSET 0x18cb
+#define GE2D_ALU_OP_CTRL 0x18cc
+#define GE2D_ALU_CONST_COLOR 0x18cd
+#define GE2D_SRC1_KEY 0x18ce
+#define GE2D_SRC1_KEY_MASK 0x18cf
+#define GE2D_SRC2_KEY 0x18d0
+#define GE2D_SRC2_KEY_MASK 0x18d1
+#define GE2D_DST_BITMASK 0x18d2
+#define GE2D_DP_ONOFF_CTRL 0x18d3
+#define GE2D_SCALE_COEF_IDX 0x18d4
+#define GE2D_SCALE_COEF 0x18d5
+#define GE2D_SRC_OUTSIDE_ALPHA 0x18d6
+#define GE2D_ANTIFLICK_CTRL0 0x18d8
+#define GE2D_ANTIFLICK_CTRL1 0x18d9
+#define GE2D_ANTIFLICK_COLOR_FILT0 0x18da
+#define GE2D_ANTIFLICK_COLOR_FILT1 0x18db
+#define GE2D_ANTIFLICK_COLOR_FILT2 0x18dc
+#define GE2D_ANTIFLICK_COLOR_FILT3 0x18dd
+#define GE2D_ANTIFLICK_ALPHA_FILT0 0x18de
+#define GE2D_ANTIFLICK_ALPHA_FILT1 0x18df
+#define GE2D_ANTIFLICK_ALPHA_FILT2 0x18e0
+#define GE2D_ANTIFLICK_ALPHA_FILT3 0x18e1
+#define GE2D_SRC1_RANGE_MAP_Y_CTRL 0x18e3
+#define GE2D_SRC1_RANGE_MAP_CB_CTRL 0x18e4
+#define GE2D_SRC1_RANGE_MAP_CR_CTRL 0x18e5
+#define GE2D_ARB_BURST_NUM 0x18e6
+#define GE2D_TID_TOKEN 0x18e7
+#define GE2D_GEN_CTRL3 0x18e8
+#define GE2D_STATUS2 0x18e9
+#define GE2D_GEN_CTRL4 0x18ea
+#define GE2D_DST1_BADDR_CTRL  0x18f1
+#define GE2D_DST1_STRIDE_CTRL 0x18f2
+#define GE2D_SRC1_BADDR_CTRL  0x18f3
+#define GE2D_SRC1_STRIDE_CTRL 0x18f4
+#define GE2D_SRC2_BADDR_CTRL  0x18f5
+#define GE2D_SRC2_STRIDE_CTRL 0x18f6
+#define GE2D_GEN_CTRL5  0x18f1
+
+#define VIU_OSD1_BLK0_CFG_W0 0x1a1b
+
+#endif
diff -Naur a/vendor/amlogic/ge2d/ge2d_wq.c b/vendor/amlogic/ge2d/ge2d_wq.c
--- a/vendor/amlogic/ge2d/ge2d_wq.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_wq.c	2022-06-24 14:37:49.831094403 +0800
@@ -0,0 +1,2708 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_wq.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/kthread.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/reset.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+
+/* Amlogic Headers */
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/media/ge2d/ge2d.h>
+#include <linux/platform_device.h>
+#ifdef CONFIG_AMLOGIC_ION
+#include <meson_ion.h>
+#endif
+
+/* Local Headers */
+#include "ge2dgen.h"
+#include "ge2d_log.h"
+#include "ge2d_io.h"
+#include "ge2d_reg.h"
+#include "ge2d_wq.h"
+#include "ge2d_dmabuf.h"
+
+#ifdef CONFIG_AMLOGIC_MEDIA_FB
+#include "osd_io.h"
+#include "osd_hw.h"
+#endif
+
+#define CANVAS_ADDR_NOWRAP      0x00
+#define CANVAS_ADDR_WRAPX       0x01
+#define CANVAS_ADDR_WRAPY       0x02
+#define CANVAS_BLKMODE_MASK     3
+#define CANVAS_BLKMODE_BIT      24
+#define CANVAS_BLKMODE_LINEAR   0x00
+#define CANVAS_BLKMODE_32X32    0x01
+#define CANVAS_BLKMODE_64X32    0x02s
+
+#define OSD1_CANVAS_INDEX 0x40
+#define OSD2_CANVAS_INDEX 0x43
+#define OSD3_CANVAS_INDEX 0x41
+#define OSD4_CANVAS_INDEX 0x42
+#define ALLOC_CANVAS_INDEX 0x44
+
+static struct ge2d_manager_s ge2d_manager;
+static int ge2d_irq = -ENXIO;
+static struct clk *ge2d_clk;
+
+static const int bpp_type_lut[] = {
+#ifdef CONFIG_AMLOGIC_MEDIA_FB
+	/* 16bit */
+	COLOR_INDEX_16_655,	/* 0 */
+	COLOR_INDEX_16_844,	/* 1 */
+	COLOR_INDEX_16_6442,	/* 2 */
+	COLOR_INDEX_16_4444_R,	/* 3 */
+	COLOR_INDEX_16_565,		/* 4 */
+	COLOR_INDEX_16_4444_A,	/* 5 */
+	COLOR_INDEX_16_1555_A,	/* 6 */
+	COLOR_INDEX_16_4642_R,	/* 7 */
+	/* 24bit */
+	COLOR_INDEX_24_RGB,	/* 0 */
+	COLOR_INDEX_24_5658,	/* 1 */
+	COLOR_INDEX_24_8565,	/* 2 */
+	COLOR_INDEX_24_6666_R,	/* 3 */
+	COLOR_INDEX_24_6666_A,	/* 4 */
+	COLOR_INDEX_24_888_B,	/* 5 */
+	0,
+	0,
+	/* 32bit */
+	COLOR_INDEX_32_RGBA,	/* 0 */
+	COLOR_INDEX_32_ARGB,	/* 1 */
+	COLOR_INDEX_32_ABGR,	/* 2 */
+	COLOR_INDEX_32_BGRA,	/* 3 */
+	0, 0, 0, 0
+#endif
+};
+
+static const int default_ge2d_color_lut[] = {
+	0,
+	0,
+	0,/* BPP_TYPE_02_PAL4    = 2, */
+	0,
+	0,/* BPP_TYPE_04_PAL16   = 4, */
+	0,
+	0,
+	0,
+	0,/* BPP_TYPE_08_PAL256=8, */
+	GE2D_FORMAT_S16_RGB_655,/* BPP_TYPE_16_655 =9, */
+	GE2D_FORMAT_S16_RGB_844,/* BPP_TYPE_16_844 =10, */
+	GE2D_FORMAT_S16_RGBA_6442,/* BPP_TYPE_16_6442 =11 , */
+	GE2D_FORMAT_S16_RGBA_4444,/* BPP_TYPE_16_4444_R = 12, */
+	GE2D_FORMAT_S16_RGBA_4642,/* BPP_TYPE_16_4642_R = 13, */
+	GE2D_FORMAT_S16_ARGB_1555,/* BPP_TYPE_16_1555_A=14, */
+	GE2D_FORMAT_S16_ARGB_4444,/* BPP_TYPE_16_4444_A = 15, */
+	GE2D_FORMAT_S16_RGB_565,/* BPP_TYPE_16_565 =16, */
+	0,
+	0,
+	GE2D_FORMAT_S24_ARGB_6666,/* BPP_TYPE_24_6666_A=19, */
+	GE2D_FORMAT_S24_RGBA_6666,/* BPP_TYPE_24_6666_R=20, */
+	GE2D_FORMAT_S24_ARGB_8565,/* BPP_TYPE_24_8565 =21, */
+	GE2D_FORMAT_S24_RGBA_5658,/* BPP_TYPE_24_5658 = 22, */
+	GE2D_FORMAT_S24_BGR,/* BPP_TYPE_24_888_B = 23, */
+	GE2D_FORMAT_S24_RGB,/* BPP_TYPE_24_RGB = 24, */
+	0,
+	0,
+	0,
+	0,
+	GE2D_FORMAT_S32_BGRA,/* BPP_TYPE_32_BGRA=29, */
+	GE2D_FORMAT_S32_ABGR,/* BPP_TYPE_32_ABGR = 30, */
+	GE2D_FORMAT_S32_RGBA,/* BPP_TYPE_32_RGBA=31, */
+	GE2D_FORMAT_S32_ARGB,/* BPP_TYPE_32_ARGB=32, */
+};
+
+static int ge2d_buffer_get_phys(struct aml_dma_cfg *cfg,
+	unsigned long *addr);
+static int ge2d_buffer_unmap(struct aml_dma_cfg *cfg);
+
+static void ge2d_pre_init(void)
+{
+	struct ge2d_gen_s ge2d_gen_cfg;
+
+	ge2d_gen_cfg.interrupt_ctrl = 0x02;
+	ge2d_gen_cfg.dp_on_cnt       = 0;
+	ge2d_gen_cfg.dp_off_cnt      = 0;
+	ge2d_gen_cfg.dp_onoff_mode   = 0;
+	ge2d_gen_cfg.vfmt_onoff_en   = 0;
+	/*  fifo size control, 00: 512, 01: 256, 10: 128 11: 96 */
+	ge2d_gen_cfg.fifo_size = 0;
+	/* fifo burst control, 00: 24x64, 01: 32x64
+	 * 10: 48x64, 11:64x64
+	 */
+	ge2d_gen_cfg.burst_ctrl = 0;
+	ge2d_set_gen(&ge2d_gen_cfg);
+}
+
+static int ge2d_clk_config(bool enable)
+{
+	if (ge2d_clk == NULL)
+		return -1;
+	if (enable)
+		clk_prepare_enable(ge2d_clk);
+	else
+		clk_disable_unprepare(ge2d_clk);
+
+	return 0;
+}
+
+void ge2d_pwr_config(bool enable)
+{
+	int i, table_size;
+	struct ge2d_ctrl_s tmp;
+	struct ge2d_ctrl_s *power_table;
+
+	if (ge2d_meson_dev.has_self_pwr) {
+		if (enable) {
+			power_table = ge2d_meson_dev.poweron_table->power_table;
+			table_size = ge2d_meson_dev.poweron_table->table_size;
+		} else {
+			power_table =
+				ge2d_meson_dev.poweroff_table->power_table;
+			table_size = ge2d_meson_dev.poweroff_table->table_size;
+		}
+
+		for (i = 0; i < table_size; i++) {
+			tmp = power_table[i];
+			ge2d_set_pwr_tbl_bits(tmp.table_type, tmp.reg, tmp.val,
+					tmp.start, tmp.len);
+			if (tmp.udelay > 0)
+				udelay(tmp.udelay);
+		}
+	}
+
+	ge2d_clk_config(enable);
+
+	if (enable) {
+		ge2d_soft_rst();
+		ge2d_pre_init();
+	}
+}
+
+static int get_queue_member_count(struct list_head *head)
+{
+	int member_count = 0;
+
+	struct ge2d_queue_item_s *pitem;
+
+	list_for_each_entry(pitem, head, list) {
+		member_count++;
+		if (member_count > MAX_GE2D_CMD) /* error has occurred */
+			break;
+	}
+
+	return member_count;
+}
+
+ssize_t work_queue_status_show(struct class *cla, struct class_attribute *attr,
+			       char *buf)
+{
+	struct ge2d_context_s *wq = ge2d_manager.current_wq;
+
+	if (wq == 0)
+		return 0;
+	return snprintf(buf, 40, "cmd count in queue:%d\n",
+			get_queue_member_count(&wq->work_queue));
+}
+
+ssize_t free_queue_status_show(struct class *cla, struct class_attribute *attr,
+			       char *buf)
+{
+	struct ge2d_context_s *wq = ge2d_manager.current_wq;
+
+	if (wq == 0)
+		return 0;
+	return snprintf(buf, 40, "free space :%d\n",
+			get_queue_member_count(&wq->free_queue));
+}
+
+static inline  int  work_queue_no_space(struct ge2d_context_s *queue)
+{
+	return  list_empty(&queue->free_queue);
+}
+
+static void ge2d_dump_cmd(struct ge2d_cmd_s *cfg)
+{
+	ge2d_log_dbg("src1_x_start=%d,src1_y_start=%d\n",
+		cfg->src1_x_start, cfg->src1_y_start);
+	ge2d_log_dbg("src1_x_end=%d,src1_y_end=%d\n",
+		cfg->src1_x_end, cfg->src1_y_end);
+	ge2d_log_dbg("src1_x_rev=%d,src1_y_rev=%d\n",
+		cfg->src1_x_rev, cfg->src1_y_rev);
+	ge2d_log_dbg("src1_fill_color_en=%d\n",
+		cfg->src1_fill_color_en);
+
+	ge2d_log_dbg("src2_x_start=%d,src2_y_start=%d\n",
+		cfg->src2_x_start, cfg->src2_y_start);
+	ge2d_log_dbg("src2_x_end=%d,src2_y_end=%d\n",
+		cfg->src2_x_end, cfg->src2_y_end);
+	ge2d_log_dbg("src2_x_rev=%d,src2_y_rev=%d\n",
+		cfg->src2_x_rev, cfg->src2_y_rev);
+	ge2d_log_dbg("src2_fill_color_en=%d\n",
+		cfg->src2_fill_color_en);
+
+	ge2d_log_dbg("dst_x_start=%d,dst_y_start=%d\n",
+		cfg->dst_x_start, cfg->dst_y_start);
+	ge2d_log_dbg("dst_x_end=%d,dst_y_end=%d\n",
+		cfg->dst_x_end, cfg->dst_y_end);
+	ge2d_log_dbg("dst_x_rev=%d,dst_y_rev=%d\n",
+		cfg->dst_x_rev, cfg->dst_y_rev);
+	ge2d_log_dbg("dst_xy_swap=%d\n",
+		cfg->dst_xy_swap);
+
+	ge2d_log_dbg("color_blend_mode=0x%x\n",
+		cfg->color_blend_mode);
+	ge2d_log_dbg("color_src_blend_factor=0x%x\n",
+		cfg->color_src_blend_factor);
+	ge2d_log_dbg("color_dst_blend_factor=0x%x\n",
+		cfg->color_dst_blend_factor);
+	ge2d_log_dbg("color_logic_op=0x%x\n",
+		cfg->color_logic_op);
+	ge2d_log_dbg("alpha_blend_mode=0x%x\n",
+		cfg->alpha_blend_mode);
+	ge2d_log_dbg("alpha_src_blend_factor=0x%x\n",
+		cfg->alpha_src_blend_factor);
+	ge2d_log_dbg("alpha_src_blend_factor=0x%x\n",
+		cfg->alpha_dst_blend_factor);
+	ge2d_log_dbg("alpha_logic_op=0x%x\n",
+		cfg->alpha_logic_op);
+
+	ge2d_log_dbg("sc_prehsc_en=%d\n", cfg->sc_prehsc_en);
+	ge2d_log_dbg("sc_prevsc_en=%d\n", cfg->sc_prevsc_en);
+	ge2d_log_dbg("sc_hsc_en=%d\n", cfg->sc_hsc_en);
+	ge2d_log_dbg("sc_vsc_en=%d\n", cfg->sc_vsc_en);
+	ge2d_log_dbg("vsc_phase_step=%d\n", cfg->vsc_phase_step);
+	ge2d_log_dbg("vsc_phase_slope=%d\n", cfg->vsc_phase_slope);
+	ge2d_log_dbg("vsc_rpt_l0_num=%d\n", cfg->vsc_rpt_l0_num);
+	ge2d_log_dbg("vsc_ini_phase=%d\n", cfg->vsc_ini_phase);
+	ge2d_log_dbg("hsc_phase_step=%d\n", cfg->hsc_phase_step);
+	ge2d_log_dbg("hsc_phase_slope=%d\n", cfg->hsc_phase_slope);
+	ge2d_log_dbg("hsc_rpt_p0_num=%d\n", cfg->hsc_rpt_p0_num);
+	ge2d_log_dbg("hsc_ini_phase=%d\n", cfg->hsc_ini_phase);
+	ge2d_log_dbg("hsc_div_en=%d\n", cfg->hsc_div_en);
+	ge2d_log_dbg("hsc_div_length=%d\n", cfg->hsc_div_length);
+	ge2d_log_dbg("hsc_adv_num=%d\n", cfg->hsc_adv_num);
+	ge2d_log_dbg("hsc_adv_phase=%d\n", cfg->hsc_adv_phase);
+	ge2d_log_dbg("src1_cmult_asel=%d\n", cfg->src1_cmult_asel);
+	ge2d_log_dbg("src2_cmult_asel=%d\n", cfg->src2_cmult_asel);
+
+	ge2d_log_dbg("GE2D_STATUS0=0x%x\n", ge2d_reg_read(GE2D_STATUS0));
+	ge2d_log_dbg("GE2D_STATUS1=0x%x\n", ge2d_reg_read(GE2D_STATUS1));
+}
+
+static void ge2d_set_canvas(struct ge2d_config_s *cfg)
+{
+	int i;
+	uint32_t index_src = 0, index_src2 = 0, index_dst = 0;
+    uint8_t canvas_index = 0;
+	int canvas_set = 0;
+	
+	for (i = 0; i < MAX_PLANE; i++) {
+		if (cfg->src_canvas_cfg[i].canvas_used) {
+            canvas_index = ge2d_manager.alloced_canvas_index[i];
+            meson_canvas_config(ge2d_manager.canvas, canvas_index, 
+                cfg->src_canvas_cfg[i].phys_addr,
+                cfg->src_canvas_cfg[i].stride,
+                cfg->src_canvas_cfg[i].height,
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR, 0);
+            
+            index_src |= canvas_index << (8 * i);
+			cfg->src_canvas_cfg[i].canvas_used = 0;
+			ge2d_log_dbg("src canvas: addr(%lx),stride(%d),height(%d)",
+				cfg->src_canvas_cfg[i].phys_addr,
+				cfg->src_canvas_cfg[i].stride,
+				cfg->src_canvas_cfg[i].height);
+			canvas_set = 1;
+		}
+	}
+	if (canvas_set) {
+		cfg->src1_data.canaddr = index_src;
+		ge2d_log_dbg("src canvas_index:%x\n", index_src);
+		canvas_set = 0;
+	}
+	for (i = 0; i < MAX_PLANE; i++) {
+		if (cfg->src2_canvas_cfg[i].canvas_used) {
+            canvas_index = ge2d_manager.alloced_canvas_index[MAX_PLANE+i];
+            meson_canvas_config(ge2d_manager.canvas, canvas_index, 
+                cfg->src2_canvas_cfg[i].phys_addr,
+                cfg->src2_canvas_cfg[i].stride,
+                cfg->src2_canvas_cfg[i].height,
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR, 0);
+
+            index_src2 |= canvas_index << (8 * i);
+			cfg->src2_canvas_cfg[i].canvas_used = 0;
+			ge2d_log_dbg("src2 canvas: addr(%lx),stride(%d),height(%d)",
+				cfg->src2_canvas_cfg[i].phys_addr,
+				cfg->src2_canvas_cfg[i].stride,
+				cfg->src2_canvas_cfg[i].height);
+			canvas_set = 1;
+		}
+	}
+	if (canvas_set) {
+		cfg->src2_dst_data.src2_canaddr = index_src2;
+		ge2d_log_dbg("src2 canvas_index:%x\n", index_src2);
+		canvas_set = 0;
+	}
+
+	for (i = 0; i < MAX_PLANE; i++) {
+		if (cfg->dst_canvas_cfg[i].canvas_used) {
+			canvas_index = ge2d_manager.alloced_canvas_index[MAX_PLANE*2+i];
+            meson_canvas_config(ge2d_manager.canvas, canvas_index, 
+                cfg->dst_canvas_cfg[i].phys_addr,
+                cfg->dst_canvas_cfg[i].stride,
+                cfg->dst_canvas_cfg[i].height,
+                CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR, 0);
+
+            index_dst |= canvas_index << (8 * i);
+			cfg->dst_canvas_cfg[i].canvas_used = 0;
+			ge2d_log_dbg("dst canvas: addr(%lx),stride(%d),height(%d)",
+				cfg->dst_canvas_cfg[i].phys_addr,
+				cfg->dst_canvas_cfg[i].stride,
+				cfg->dst_canvas_cfg[i].height);
+			canvas_set = 1;
+		}
+	}
+	if (canvas_set) {
+		cfg->src2_dst_data.dst_canaddr = index_dst;
+		ge2d_log_dbg("dst canvas_index:%x\n", index_dst);
+	}
+}
+
+
+static int ge2d_process_work_queue(struct ge2d_context_s *wq)
+{
+	struct ge2d_config_s *cfg;
+	struct ge2d_queue_item_s *pitem;
+	unsigned int  mask = 0x1;
+	struct list_head  *head = &wq->work_queue, *pos;
+	int ret = 0, i = 0;
+	unsigned int block_mode;
+	int timeout = 0;
+	if (wq->ge2d_request_exit)
+		goto exit;
+	ge2d_manager.ge2d_state = GE2D_STATE_RUNNING;
+	pos = head->next;
+	if (pos != head) { /* current work queue not empty. */
+		if (wq != ge2d_manager.last_wq) { /* maybe */
+			/* modify the first item . */
+			pitem = (struct ge2d_queue_item_s *)pos;
+			if (pitem)
+				pitem->config.update_flag = UPDATE_ALL;
+			else {
+				ge2d_log_err("can't get pitem\n");
+				ret = -1;
+				goto  exit;
+			}
+		} else
+			/* modify the first item . */
+			pitem = (struct ge2d_queue_item_s *)pos;
+
+	} else {
+		ret = -1;
+		goto  exit;
+	}
+
+	do {
+		cfg = &pitem->config;
+		ge2d_set_canvas(cfg);
+		mask = 0x1;
+		while (cfg->update_flag && mask <= UPDATE_SCALE_COEF) {
+			/* we do not change */
+			switch (cfg->update_flag & mask) {
+			case UPDATE_SRC_DATA:
+				ge2d_set_src1_data(&cfg->src1_data);
+				break;
+			case UPDATE_SRC_GEN:
+				ge2d_set_src1_gen(&cfg->src1_gen);
+				break;
+			case UPDATE_DST_DATA:
+				ge2d_set_src2_dst_data(&cfg->src2_dst_data);
+				break;
+			case UPDATE_DST_GEN:
+				ge2d_set_src2_dst_gen(&cfg->src2_dst_gen);
+				break;
+			case UPDATE_DP_GEN:
+				ge2d_set_dp_gen(cfg);
+				break;
+			case UPDATE_SCALE_COEF:
+				ge2d_set_src1_scale_coef(cfg->v_scale_coef_type,
+						cfg->h_scale_coef_type);
+				break;
+			}
+
+			cfg->update_flag &= ~mask;
+			mask = mask << 1;
+
+		}
+		pitem->cmd.hang_flag = 1;
+		ge2d_set_cmd(&pitem->cmd);/* set START_FLAG in this func. */
+		/* remove item */
+		block_mode = pitem->cmd.wait_done_flag;
+		/* spin_lock(&wq->lock); */
+		/* pos=pos->next; */
+		/* list_move_tail(&pitem->list,&wq->free_queue); */
+		/* spin_unlock(&wq->lock); */
+
+		while (ge2d_is_busy()) {
+			timeout = wait_event_interruptible_timeout(
+					ge2d_manager.event.cmd_complete,
+					!ge2d_is_busy(),
+					msecs_to_jiffies(1000));
+			if (timeout == 0) {
+				ge2d_log_err("ge2d timeout!!!\n");
+				ge2d_dump_cmd(&pitem->cmd);
+				ge2d_soft_rst();
+				break;
+			}
+		}
+		/* if block mode (cmd) */
+		if (block_mode) {
+			pitem->cmd.wait_done_flag = 0;
+			wake_up_interruptible(&wq->cmd_complete);
+		}
+		spin_lock(&wq->lock);
+		pos = pos->next;
+		list_move_tail(&pitem->list, &wq->free_queue);
+		spin_unlock(&wq->lock);
+		/* if dma buf detach it */
+		for (i = 0; i < MAX_PLANE; i++) {
+			if (pitem->config.src_dma_cfg[i].dma_used) {
+				ge2d_buffer_unmap((struct aml_dma_cfg *
+					)pitem->config.src_dma_cfg[i].dma_cfg);
+				pitem->config.src_dma_cfg[i].dma_used = 0;
+				kfree(pitem->config.src_dma_cfg[i].dma_cfg);
+			}
+			if (pitem->config.src2_dma_cfg[i].dma_used) {
+				ge2d_buffer_unmap((struct aml_dma_cfg *
+					)pitem->config.src2_dma_cfg[i].dma_cfg);
+				pitem->config.src2_dma_cfg[i].dma_used = 0;
+				kfree(pitem->config.src2_dma_cfg[i].dma_cfg);
+			}
+			if (pitem->config.dst_dma_cfg[i].dma_used) {
+				ge2d_buffer_unmap((struct aml_dma_cfg *
+					)pitem->config.dst_dma_cfg[i].dma_cfg);
+				pitem->config.dst_dma_cfg[i].dma_used = 0;
+				kfree(pitem->config.dst_dma_cfg[i].dma_cfg);
+			}
+		}
+		pitem = (struct ge2d_queue_item_s *)pos;
+	} while (pos != head);
+	ge2d_manager.last_wq = wq;
+exit:
+	if (wq->ge2d_request_exit)
+		complete(&ge2d_manager.event.process_complete);
+	ge2d_manager.ge2d_state = GE2D_STATE_IDLE;
+	return ret;
+}
+
+static irqreturn_t ge2d_wq_handle(int irq_number, void *para)
+{
+	wake_up(&ge2d_manager.event.cmd_complete);
+	return IRQ_HANDLED;
+}
+
+static void update_canvas_cfg(struct ge2d_canvas_cfg_s *canvas_cfg,
+	unsigned long phys_addr,
+	unsigned int stride,
+	unsigned int height)
+{
+	canvas_cfg->canvas_used = 1;
+	canvas_cfg->phys_addr = phys_addr;
+	canvas_cfg->stride = stride;
+	canvas_cfg->height = height;
+}
+
+struct ge2d_canvas_cfg_s *ge2d_wq_get_canvas_cfg(struct ge2d_context_s *wq,
+					   unsigned int data_type,
+					   unsigned int plane_id)
+{
+	struct ge2d_canvas_cfg_s *canvas_cfg = NULL;
+
+	switch (data_type) {
+	case AML_GE2D_SRC:
+		canvas_cfg = &wq->config.src_canvas_cfg[plane_id];
+		break;
+	case AML_GE2D_SRC2:
+		canvas_cfg = &wq->config.src2_canvas_cfg[plane_id];
+		break;
+	case AML_GE2D_DST:
+		canvas_cfg = &wq->config.dst_canvas_cfg[plane_id];
+		break;
+	default:
+		ge2d_log_err("wrong data_type\n");
+		break;
+	}
+	return canvas_cfg;
+}
+
+struct ge2d_dma_cfg_s *ge2d_wq_get_dma_cfg(struct ge2d_context_s *wq,
+					   unsigned int data_type,
+					   unsigned int plane_id)
+{
+	struct ge2d_dma_cfg_s *dma_cfg = NULL;
+
+	switch (data_type) {
+	case AML_GE2D_SRC:
+		dma_cfg = &wq->config.src_dma_cfg[plane_id];
+		break;
+	case AML_GE2D_SRC2:
+		dma_cfg = &wq->config.src2_dma_cfg[plane_id];
+		break;
+	case AML_GE2D_DST:
+		dma_cfg = &wq->config.dst_dma_cfg[plane_id];
+		break;
+	default:
+		ge2d_log_err("wrong data_type\n");
+		break;
+	}
+
+	return dma_cfg;
+}
+
+struct ge2d_src1_data_s *ge2d_wq_get_src_data(struct ge2d_context_s *wq)
+{
+	return &wq->config.src1_data;
+}
+
+struct ge2d_src1_gen_s *ge2d_wq_get_src_gen(struct ge2d_context_s *wq)
+{
+	return &wq->config.src1_gen;
+}
+
+struct ge2d_src2_dst_data_s *ge2d_wq_get_dst_data(struct ge2d_context_s *wq)
+{
+	return &wq->config.src2_dst_data;
+}
+
+struct ge2d_src2_dst_gen_s *ge2d_wq_get_dst_gen(struct ge2d_context_s *wq)
+{
+	return &wq->config.src2_dst_gen;
+}
+
+struct ge2d_dp_gen_s *ge2d_wq_get_dp_gen(struct ge2d_context_s *wq)
+{
+	return &wq->config.dp_gen;
+}
+
+struct ge2d_cmd_s *ge2d_wq_get_cmd(struct ge2d_context_s *wq)
+{
+	return &wq->cmd;
+}
+
+void ge2d_wq_set_scale_coef(struct ge2d_context_s *wq,
+			    unsigned int v_scale_coef_type,
+			    unsigned int h_scale_coef_type)
+{
+
+	if (wq) {
+		wq->config.v_scale_coef_type = v_scale_coef_type;
+		wq->config.h_scale_coef_type = h_scale_coef_type;
+		wq->config.update_flag |= UPDATE_SCALE_COEF;
+	}
+}
+
+int ge2d_wq_add_work(struct ge2d_context_s *wq)
+{
+
+	struct ge2d_queue_item_s  *pitem;
+
+	ge2d_log_dbg("add new work @@%s:%d\n", __func__, __LINE__);
+	if (work_queue_no_space(wq)) {
+		ge2d_log_dbg("work queue no space\n");
+		/* we should wait for queue empty at this point. */
+		#if 0
+		while (work_queue_no_space(wq))
+			interruptible_sleep_on_timeout(
+					&ge2d_manager.event.cmd_complete, 3);
+		#endif
+		return -1;
+	}
+
+	pitem = list_entry(wq->free_queue.next, struct ge2d_queue_item_s, list);
+	if (IS_ERR(pitem))
+		goto error;
+	memcpy(&pitem->cmd, &wq->cmd, sizeof(struct ge2d_cmd_s));
+	memset(&wq->cmd, 0, sizeof(struct ge2d_cmd_s));
+	memcpy(&pitem->config, &wq->config, sizeof(struct ge2d_config_s));
+	wq->config.update_flag = 0; /* reset config set flag */
+	spin_lock(&wq->lock);
+	list_move_tail(&pitem->list, &wq->work_queue);
+	spin_unlock(&wq->lock);
+	ge2d_log_dbg("add new work ok\n");
+	/* only read not need lock */
+	if (ge2d_manager.event.cmd_in_sem.count == 0)
+		up(&ge2d_manager.event.cmd_in_sem);/* new cmd come in */
+	/* add block mode   if() */
+	if (pitem->cmd.wait_done_flag) {
+		wait_event_interruptible(wq->cmd_complete,
+				pitem->cmd.wait_done_flag == 0);
+		/* interruptible_sleep_on(&wq->cmd_complete); */
+	}
+	return 0;
+error:
+	return -1;
+}
+
+static inline struct ge2d_context_s *get_next_work_queue(
+		struct ge2d_manager_s *manager)
+{
+	struct ge2d_context_s *pcontext;
+
+	spin_lock(&ge2d_manager.event.sem_lock);
+	list_for_each_entry(pcontext, &manager->process_queue, list) {
+		/* not lock maybe delay to next time. */
+		if (!list_empty(&pcontext->work_queue)) {
+			/* move head . */
+			list_move(&manager->process_queue, &pcontext->list);
+			spin_unlock(&ge2d_manager.event.sem_lock);
+			return pcontext;
+		}
+	}
+	spin_unlock(&ge2d_manager.event.sem_lock);
+	return NULL;
+}
+
+static int ge2d_monitor_thread(void *data)
+{
+	int ret;
+	struct ge2d_manager_s *manager = (struct ge2d_manager_s *)data;
+
+	ge2d_log_info("ge2d workqueue monitor start\n");
+	/* setup current_wq here. */
+	while (ge2d_manager.process_queue_state != GE2D_PROCESS_QUEUE_STOP) {
+		ret = down_interruptible(&manager->event.cmd_in_sem);
+		ge2d_pwr_config(true);
+		while ((manager->current_wq =
+				get_next_work_queue(manager)) != NULL)
+			ge2d_process_work_queue(manager->current_wq);
+		if (!ge2d_dump_reg_enable)
+			ge2d_pwr_config(false);
+	}
+	ge2d_log_info("exit ge2d_monitor_thread\n");
+	return 0;
+}
+
+static int ge2d_start_monitor(void)
+{
+	int ret = 0;
+
+	ge2d_log_info("ge2d start monitor\n");
+	ge2d_manager.process_queue_state = GE2D_PROCESS_QUEUE_START;
+	ge2d_manager.ge2d_thread = kthread_run(ge2d_monitor_thread,
+					       &ge2d_manager,
+					       "ge2d_monitor");
+	if (IS_ERR(ge2d_manager.ge2d_thread)) {
+		ret = PTR_ERR(ge2d_manager.ge2d_thread);
+		ge2d_log_err("ge2d failed to start kthread (%d)\n", ret);
+	}
+	return ret;
+}
+
+static int ge2d_stop_monitor(void)
+{
+	ge2d_log_info("stop ge2d monitor thread\n");
+	if (ge2d_manager.ge2d_thread) {
+		ge2d_manager.process_queue_state = GE2D_PROCESS_QUEUE_STOP;
+		up(&ge2d_manager.event.cmd_in_sem);
+		kthread_stop(ge2d_manager.ge2d_thread);
+		ge2d_manager.ge2d_thread = NULL;
+	}
+	return  0;
+}
+
+static inline int bpp(unsigned int format)
+{
+	switch (format & GE2D_BPP_MASK) {
+	case GE2D_BPP_8BIT:
+		return 8;
+	case GE2D_BPP_16BIT:
+		return 16;
+	case GE2D_BPP_24BIT:
+		if ((GE2D_COLOR_MAP_NV21 == (format & GE2D_COLOR_MAP_NV21)) ||
+			(GE2D_COLOR_MAP_NV12 == (format & GE2D_COLOR_MAP_NV12)))
+			return 8;
+		return 24;
+	case GE2D_BPP_32BIT:
+	default:
+		return 32;
+	}
+}
+
+static int build_ge2d_config(struct ge2d_context_s *context,
+				  struct config_para_s *cfg,
+			      struct src_dst_para_s *src,
+			      struct src_dst_para_s *dst)
+{
+	struct ge2d_canvas_cfg_s *canvas_cfg = NULL;
+	int i;
+
+	if (src) {
+		src->xres = cfg->src_planes[0].w;
+		src->yres = cfg->src_planes[0].h;
+		src->ge2d_color_index = cfg->src_format;
+		src->bpp = bpp(cfg->src_format);
+		for (i = 0; i < MAX_PLANE; i++) {
+			if (cfg->src_planes[0].addr) {
+				if (ge2d_meson_dev.canvas_status == 1) {
+					if (i == 0) {
+						src->canvas_index = 0;
+						src->phy_addr =
+							cfg->src_planes[0].addr;
+						src->stride =
+							cfg->src_planes[0].w *
+							src->bpp / 8;
+					} else {
+						ge2d_log_info("not support src_planes>1\n");
+					}
+				} else {
+					src->canvas_index = 0;
+					canvas_cfg = ge2d_wq_get_canvas_cfg
+						(context, AML_GE2D_SRC, i);
+					if (!canvas_cfg)
+						return -1;
+					update_canvas_cfg(canvas_cfg,
+						cfg->src_planes[i].addr,
+						cfg->src_planes[i].w *
+						src->bpp / 8,
+						cfg->src_planes[i].h);
+				}
+			}
+		}
+	}
+	if (dst) {
+		dst->xres = cfg->dst_planes[0].w;
+		dst->yres = cfg->dst_planes[0].h;
+		dst->ge2d_color_index = cfg->dst_format;
+		dst->bpp = bpp(cfg->dst_format);
+		for (i = 0; i < MAX_PLANE; i++) {
+			if (cfg->dst_planes[i].addr) {
+				if (ge2d_meson_dev.canvas_status == 1) {
+					if (i == 0) {
+						dst->canvas_index = 0;
+						dst->phy_addr =
+							cfg->dst_planes[0].addr;
+						dst->stride =
+							cfg->dst_planes[0].w *
+							dst->bpp / 8;
+					} else {
+						ge2d_log_info("not support dst_planes>1\n");
+					}
+				} else {
+					dst->canvas_index = 0;
+					canvas_cfg = ge2d_wq_get_canvas_cfg
+						(context, AML_GE2D_DST, i);
+					if (!canvas_cfg)
+						return -1;
+					update_canvas_cfg(canvas_cfg,
+						cfg->dst_planes[i].addr,
+						cfg->dst_planes[i].w *
+						dst->bpp / 8,
+						cfg->dst_planes[i].h);
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+static int setup_display_property(struct src_dst_para_s *src_dst, int index)
+{
+#if 0
+#define REG_OFFSET (0x20)
+#ifdef CONFIG_AMLOGIC_MEDIA_CANVAS
+	struct canvas_s	canvas;
+#endif
+	u32 cs_width = 0, cs_height = 0, cs_addr = 0;
+	unsigned	int	data32;
+	unsigned	int	bpp;
+	unsigned int	block_mode[] = {2, 4, 8, 16, 16, 32, 0, 24,
+					0, 0, 0, 0, 0, 0, 0, 0};
+
+	src_dst->canvas_index = index;
+	if (ge2d_meson_dev.canvas_status == 0) {
+#ifdef CONFIG_AMLOGIC_MEDIA_CANVAS
+		canvas_read(index, &canvas);
+		cs_width = canvas.width;
+		cs_height = canvas.height;
+#else
+		cs_width = 0;
+		cs_height = 0;
+#endif
+	}
+	index = (index == OSD1_CANVAS_INDEX ? 0 : 1);
+	ge2d_log_dbg("osd%d ", index);
+#ifdef CONFIG_AMLOGIC_MEDIA_FB
+	data32 = VSYNCOSD_RD_MPEG_REG(
+		VIU_OSD1_BLK0_CFG_W0 + REG_OFFSET * index);
+	src_dst->canvas_index = (data32 >> 16) & 0xff;
+	if (ge2d_meson_dev.canvas_status == 1) {
+		src_dst->canvas_index = 0;
+		osd_get_info(index, &cs_addr,
+			&cs_width, &cs_height);
+		src_dst->phy_addr = cs_addr;
+		src_dst->stride = cs_width;
+	}
+#ifdef CONFIG_AMLOGIC_MEDIA_CANVAS
+	else {
+		canvas_read(src_dst->canvas_index, &canvas);
+		cs_width = canvas.width;
+		cs_height = canvas.height;
+	}
+#endif
+#else
+	data32 = 0;
+#endif
+	index = (data32 >> 8) & 0xf;
+	bpp = block_mode[index]; /* OSD_BLK_MODE[8..11] */
+	ge2d_log_dbg("%d bpp\n", bpp);
+
+	if (bpp < 16)
+		return -1;
+
+	src_dst->bpp = bpp;
+	src_dst->xres = cs_width / (bpp >> 3);
+	src_dst->yres = cs_height;
+	if (index == 3) /* yuv422 32bit for two pixel. */
+		src_dst->ge2d_color_index =	GE2D_FORMAT_S16_YUV422;
+	else { /* for block mode=4,5,7 */
+		/* color mode [2..5] */
+		index = bpp - 16 + ((data32 >> 2) & 0xf);
+		index = bpp_type_lut[index]; /* get color mode */
+		/* get matched ge2d color mode. */
+		src_dst->ge2d_color_index = default_ge2d_color_lut[index];
+
+		if (src_dst->xres <= 0 ||
+			src_dst->yres <= 0 ||
+			src_dst->ge2d_color_index == 0)
+			return -2;
+	}
+#endif
+	return 0;
+
+}
+
+int ge2d_antiflicker_enable(struct ge2d_context_s *context,
+		unsigned long enable)
+{
+	/*
+	 * antiflicker used in cvbs mode, if antiflicker is enabled,
+	 * it represent that we want this feature be enabled for all ge2d work
+	 */
+	struct ge2d_context_s *pcontext;
+
+	spin_lock(&ge2d_manager.event.sem_lock);
+	list_for_each_entry(pcontext, &ge2d_manager.process_queue, list) {
+		ge2dgen_antiflicker(pcontext, enable);
+	}
+	spin_unlock(&ge2d_manager.event.sem_lock);
+
+	return 0;
+}
+
+int ge2d_context_config(struct ge2d_context_s *context,
+		struct config_para_s *ge2d_config)
+{
+	struct src_dst_para_s src, dst, tmp;
+	int type = ge2d_config->src_dst_type;
+
+	ge2d_log_dbg(" ge2d init\n");
+	memset(&src, 0, sizeof(struct src_dst_para_s));
+	memset(&dst, 0, sizeof(struct src_dst_para_s));
+	/* setup src and dst */
+	switch (type) {
+	case OSD0_OSD0:
+	case OSD0_OSD1:
+	case OSD1_OSD0:
+	case ALLOC_OSD0:
+		if (setup_display_property(&src, OSD1_CANVAS_INDEX) < 0)
+			return -1;
+		break;
+	default:
+		break;
+	}
+	switch (type) {
+	case OSD0_OSD1:
+	case OSD1_OSD1:
+	case OSD1_OSD0:
+	case ALLOC_OSD1:
+		if (setup_display_property(&dst, OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		break;
+	case ALLOC_ALLOC:
+	default:
+		break;
+	}
+	ge2d_log_dbg("OSD ge2d type %d\n", type);
+	switch (type) {
+	case OSD0_OSD0:
+		dst = src;
+		break;
+	case OSD0_OSD1:
+		break;
+	case OSD1_OSD1:
+		src = dst;
+		break;
+	case OSD1_OSD0:
+		tmp = src;
+		src = dst;
+		dst = tmp;
+		break;
+	case ALLOC_OSD0:
+		dst = src;
+		build_ge2d_config(context, ge2d_config, &src, NULL);
+		break;
+	case ALLOC_OSD1:
+		build_ge2d_config(context, ge2d_config, &src, NULL);
+		break;
+	case ALLOC_ALLOC:
+		build_ge2d_config(context, ge2d_config, &src, &dst);
+		break;
+	}
+	if (src.bpp < 16 || dst.bpp < 16)
+		ge2d_log_dbg("src dst bpp type, src=%d,dst=%d\n",
+				src.bpp, dst.bpp);
+
+	/* next will config regs */
+	ge2d_log_dbg("ge2d src.xres %d src.yres %d, dst.xres %d dst.yres %d\n",
+		     src.xres, src.yres, dst.xres, dst.yres);
+	ge2d_log_dbg("src_format: 0x%x, dst_format: 0x%x\n",
+		     src.ge2d_color_index, dst.ge2d_color_index);
+
+	ge2dgen_src(context, src.canvas_index,
+		src.ge2d_color_index,
+		src.phy_addr,
+		src.stride);
+	ge2dgen_src_clip(context,
+			 0, 0, src.xres, src.yres);
+	ge2dgen_src2(context, dst.canvas_index,
+		dst.ge2d_color_index,
+		dst.phy_addr,
+		dst.stride);
+	ge2dgen_src2_clip(context,
+			  0, 0,  dst.xres, dst.yres);
+	ge2dgen_const_color(context, ge2d_config->alu_const_color);
+	ge2dgen_dst(context, dst.canvas_index,
+		dst.ge2d_color_index,
+		dst.phy_addr,
+		dst.stride);
+	ge2dgen_dst_clip(context,
+			 0, 0, dst.xres, dst.yres, DST_CLIP_MODE_INSIDE);
+	return  0;
+
+}
+
+static int build_ge2d_addr_config(
+			struct config_planes_s *plane,
+			unsigned int format,
+			unsigned int *addr,
+			unsigned int *stride
+			)
+{
+	int ret = -1;
+	int bpp_value = bpp(format);
+
+	bpp_value /= 8;
+	ge2d_log_dbg("build_ge2d_addr_config bpp_value=%d\n",
+		bpp_value);
+	if (plane) {
+		if (plane[0].addr) {
+			*addr = plane[0].addr;
+			*stride = plane[0].w * bpp_value;
+			ret = 0;
+		}
+		/* not support multi-src_planes */
+		if ((plane[1].addr) ||
+			(plane[2].addr) ||
+			(plane[3].addr)) {
+			ge2d_log_info("ge2d not support NV21 mode\n");
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+static int build_ge2d_addr_config_ion(
+			struct config_planes_ion_s *plane,
+			unsigned int format,
+			unsigned int *addr,
+			unsigned int *stride
+			)
+{
+	int ret = -1;
+	int bpp_value = bpp(format);
+	unsigned long addr_temp = 0;
+
+	bpp_value /= 8;
+	ge2d_log_dbg("build_ge2d_addr_config_ion bpp_value=%d\n",
+		bpp_value);
+	if (plane) {
+		if (plane[0].shared_fd) {
+#ifdef CONFIG_AMLOGIC_ION
+			size_t len = 0;
+
+			ret = meson_ion_share_fd_to_phys(ge2d_ion_client,
+				plane[0].shared_fd, &addr_temp, &len);
+			if (ret != 0)
+				return ret;
+#else
+			return ret;
+#endif
+		}
+		plane[0].addr += addr_temp;
+		if (plane[0].addr) {
+			*addr = plane[0].addr;
+			*stride = plane[0].w * bpp_value;
+			ret = 0;
+		}
+		/* not support multi-src_planes */
+		if ((plane[1].addr) ||
+			(plane[2].addr) ||
+			(plane[3].addr)) {
+			ge2d_log_info("ge2d not support NV21 mode\n");
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+static int build_ge2d_addr_config_dma(
+			struct ge2d_context_s *context,
+			struct config_planes_ion_s *plane,
+			unsigned int format,
+			unsigned int *addr,
+			unsigned int *stride,
+			unsigned int dir,
+			unsigned int data_type
+			)
+{
+	int ret = -1;
+	int bpp_value = bpp(format);
+	unsigned long addr_temp = 0;
+
+	bpp_value /= 8;
+	ge2d_log_dbg("build_ge2d_addr_config_ion bpp_value=%d\n",
+		bpp_value);
+	if (plane) {
+		if (plane[0].shared_fd) {
+			struct ge2d_dma_cfg_s *cfg = NULL;
+			struct aml_dma_cfg *dma_cfg = NULL;
+
+			cfg = ge2d_wq_get_dma_cfg(context, data_type, 0);
+			if (!cfg)
+				return -1;
+			cfg->dma_used = 1;
+			dma_cfg = kzalloc(sizeof(*dma_cfg), GFP_KERNEL);
+			dma_cfg->fd = plane[0].shared_fd;
+			dma_cfg->dev = &(ge2d_manager.pdev->dev);
+			dma_cfg->dir = dir;
+			cfg->dma_cfg = dma_cfg;
+			ret = ge2d_buffer_get_phys(dma_cfg, &addr_temp);
+			if (ret != 0)
+				return ret;
+		}
+		plane[0].addr += addr_temp;
+		if (plane[0].addr) {
+			*addr = plane[0].addr;
+			*stride = plane[0].w * bpp_value;
+			ret = 0;
+		}
+		/* not support multi-src_planes */
+		if ((plane[1].addr) ||
+			(plane[2].addr) ||
+			(plane[3].addr)) {
+			ge2d_log_info("ge2d not support NV21 mode\n");
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+static int build_ge2d_config_ex(struct ge2d_context_s *context,
+				struct config_planes_s *plane,
+				unsigned int format,
+				unsigned int data_type)
+{
+	struct ge2d_canvas_cfg_s *canvas_cfg = NULL;
+	int bpp_value = bpp(format);
+	int ret = -1, i = 0;
+
+	bpp_value /= 8;
+	if (plane) {
+		for (i = 0; i < MAX_PLANE; i++) {
+			if (plane[i].addr) {
+				canvas_cfg = ge2d_wq_get_canvas_cfg(context,
+					data_type, i);
+				if (!canvas_cfg)
+					return -1;
+				update_canvas_cfg(canvas_cfg,
+					plane[i].addr,
+					plane[i].w * bpp_value,
+					plane[i].h);
+				ret = 0;
+			}
+		}
+	}
+	return ret;
+}
+
+
+static int build_ge2d_config_ex_ion(struct ge2d_context_s *context,
+				struct config_planes_ion_s *plane,
+				unsigned int format,
+				unsigned int data_type)
+{
+	struct ge2d_canvas_cfg_s *canvas_cfg = NULL;
+	int bpp_value = bpp(format);
+	int ret = -1, i;
+	int canvas_set = 0;
+	unsigned long addr;
+	size_t len;
+
+	bpp_value /= 8;
+	if (plane) {
+		for (i = 0; i < MAX_PLANE; i++) {
+			/* multi-src_planes */
+			canvas_set = 0;
+			if (plane[i].shared_fd) {
+#ifdef CONFIG_AMLOGIC_ION
+			ret = meson_ion_share_fd_to_phys(ge2d_ion_client,
+				plane[i].shared_fd, &addr, &len);
+			if (ret != 0)
+				return ret;
+#else
+				return ret;
+#endif
+				plane[i].addr = addr;
+				canvas_set = 1;
+			} else if (plane[i].addr) {
+				plane[i].addr += plane[0].addr;
+				canvas_set = 1;
+			}
+			if (canvas_set) {
+				canvas_cfg = ge2d_wq_get_canvas_cfg(context,
+					data_type, i);
+				if (!canvas_cfg)
+					return -1;
+				update_canvas_cfg(canvas_cfg,
+					plane[i].addr,
+					plane[i].w * bpp_value,
+					plane[i].h);
+				canvas_set = 0;
+				ret = 0;
+			}
+		}
+	}
+	return ret;
+}
+
+static int build_ge2d_config_ex_dma(struct ge2d_context_s *context,
+				struct config_planes_ion_s *plane,
+				unsigned int format,
+				unsigned int dir,
+				unsigned int data_type)
+{
+	struct ge2d_canvas_cfg_s *canvas_cfg = NULL;
+	int bpp_value = bpp(format);
+	int ret = -1, i;
+	int canvas_set = 0;
+	unsigned long addr;
+
+	bpp_value /= 8;
+	if (plane) {
+		for (i = 0; i < MAX_PLANE; i++) {
+			/* multi-src_planes */
+			canvas_set = 0;
+			if (plane[i].shared_fd) {
+				struct ge2d_dma_cfg_s *cfg = NULL;
+				struct aml_dma_cfg *dma_cfg = NULL;
+
+				cfg = ge2d_wq_get_dma_cfg(context,
+					data_type, i);
+				if (!cfg)
+					return -1;
+				cfg->dma_used = 1;
+				dma_cfg = kzalloc(sizeof(*dma_cfg), GFP_KERNEL);
+				if (!dma_cfg)
+					return ret;
+				dma_cfg->fd = plane[i].shared_fd;
+				dma_cfg->dev = &(ge2d_manager.pdev->dev);
+				dma_cfg->dir = dir;
+				cfg->dma_cfg = dma_cfg;
+				ret = ge2d_buffer_get_phys(dma_cfg, &addr);
+				if (ret != 0)
+					return ret;
+				plane[i].addr = addr;
+				canvas_set = 1;
+			} else if (plane[i].addr) {
+				plane[i].addr += plane[0].addr;
+				canvas_set = 1;
+			}
+			if (canvas_set) {
+				canvas_cfg = ge2d_wq_get_canvas_cfg(context,
+					data_type, i);
+				if (!canvas_cfg)
+					return -1;
+				update_canvas_cfg(canvas_cfg,
+					plane[i].addr,
+					plane[i].w * bpp_value,
+					plane[i].h);
+				canvas_set = 0;
+			}
+		}
+	}
+	return ret;
+}
+
+int ge2d_context_config_ex(struct ge2d_context_s *context,
+			   struct config_para_ex_s *ge2d_config)
+{
+	struct src_dst_para_s  tmp;
+	struct ge2d_src1_gen_s *src1_gen_cfg;
+	struct ge2d_src2_dst_data_s *src2_dst_data_cfg;
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg;
+	struct ge2d_dp_gen_s *dp_gen_cfg;
+	struct ge2d_cmd_s *ge2d_cmd_cfg;
+	int top, left, width, height;
+	unsigned int src_addr = 0, src2_addr = 0, dst_addr = 0;
+	unsigned int src_stride = 0, src2_stride = 0, dst_stride = 0;
+
+	/* setup src and dst */
+	switch (ge2d_config->src_para.mem_type) {
+	case CANVAS_OSD0:
+	case CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->src_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->src_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src_para.format = tmp.ge2d_color_index;
+		src_addr = tmp.phy_addr;
+		src_stride = tmp.stride;
+		ge2d_log_dbg("ge2d: src1-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->src_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->src_para.format);
+
+		top = ge2d_config->src_para.top;
+		left = ge2d_config->src_para.left;
+		width = ge2d_config->src_para.width;
+		height = ge2d_config->src_para.height;
+		if ((left + width > tmp.xres) ||
+		    (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d src error: out of range\n");
+			return -1;
+		}
+		ge2d_config->src_para.width = tmp.xres;
+		ge2d_config->src_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			src_addr,
+			src_stride,
+			ge2d_config->src_para.format);
+		break;
+	case CANVAS_ALLOC:
+		top = ge2d_config->src_para.top;
+		left = ge2d_config->src_para.left;
+		width = ge2d_config->src_para.width;
+		height = ge2d_config->src_para.height;
+		if ((left + width > ge2d_config->src_planes[0].w)
+		    || (top + height > ge2d_config->src_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: src alloc, out of range\n");
+			return -1;
+		}
+		if (ge2d_meson_dev.canvas_status == 1) {
+			if (build_ge2d_addr_config(
+				&ge2d_config->src_planes[0],
+				ge2d_config->src_para.format,
+				&src_addr,
+				&src_stride) < 0)
+				return -1;
+			ge2d_log_dbg("ge2d alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+				src_addr,
+				src_stride,
+				ge2d_config->src_para.format);
+		} else {
+			if (build_ge2d_config_ex(context,
+				&ge2d_config->src_planes[0],
+				ge2d_config->src_para.format,
+				AML_GE2D_SRC) < 0)
+				return -1;
+			ge2d_config->src_para.canvas_index = 0;
+			ge2d_log_dbg("ge2d src alloc,format:0x%x\n",
+				ge2d_config->src_para.format);
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (ge2d_config->src2_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->src2_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->src2_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src2_para.format = tmp.ge2d_color_index;
+		src2_addr = tmp.phy_addr;
+		src2_stride = tmp.stride;
+		ge2d_log_dbg("ge2d: src2-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->src2_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->src2_para.format);
+
+		top = ge2d_config->src2_para.top;
+		left = ge2d_config->src2_para.left;
+		width = ge2d_config->src2_para.width;
+		height = ge2d_config->src2_para.height;
+		if ((left + width > tmp.xres) || (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d error: src2: osd%d, out of range\n",
+				ge2d_config->src2_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		ge2d_config->src2_para.width = tmp.xres;
+		ge2d_config->src2_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			src2_addr,
+			src_stride,
+			ge2d_config->src2_para.format);
+		break;
+	case  CANVAS_ALLOC:
+		top = ge2d_config->src2_para.top;
+		left = ge2d_config->src2_para.left;
+		width = ge2d_config->src2_para.width;
+		height = ge2d_config->src2_para.height;
+		if ((left + width > ge2d_config->src2_planes[0].w)
+		    || (top + height > ge2d_config->src2_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: src2: alloc, out of range\n");
+			return -1;
+		}
+		if (ge2d_config->src2_planes[0].addr ==
+				ge2d_config->src_planes[0].addr) {
+			ge2d_config->src2_para.canvas_index =
+				ge2d_config->src_para.canvas_index;
+			src2_addr = src_addr;
+			src2_stride = src_stride;
+		} else {
+			if (ge2d_meson_dev.canvas_status == 1) {
+				if (build_ge2d_addr_config(
+					&ge2d_config->src2_planes[0],
+					ge2d_config->src2_para.format,
+					&src2_addr,
+					&src2_stride) < 0)
+					return -1;
+				ge2d_log_dbg("ge2d alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+					src2_addr,
+					src2_stride,
+					ge2d_config->src2_para.format);
+			} else {
+				if (build_ge2d_config_ex(context,
+					&ge2d_config->src2_planes[0],
+					ge2d_config->src2_para.format,
+					AML_GE2D_SRC2) < 0)
+					return -1;
+				ge2d_config->src2_para.canvas_index = 0;
+				ge2d_log_dbg("ge2d src2 alloc,format:0x%x\n",
+					ge2d_config->src2_para.format);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (ge2d_config->dst_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->dst_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->dst_para.canvas_index = tmp.canvas_index;
+		ge2d_config->dst_para.format = tmp.ge2d_color_index;
+		dst_addr = tmp.phy_addr;
+		dst_stride = tmp.stride;
+
+		ge2d_log_dbg("ge2d: dst-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->dst_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->dst_para.format);
+
+		top = ge2d_config->dst_para.top;
+		left = ge2d_config->dst_para.left;
+		width = ge2d_config->dst_para.width;
+		height = ge2d_config->dst_para.height;
+		if ((left + width > tmp.xres) || (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d error: dst: osd%d, out of range\n",
+				ge2d_config->dst_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		ge2d_config->dst_para.width = tmp.xres;
+		ge2d_config->dst_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			dst_addr,
+			dst_stride,
+			ge2d_config->dst_para.format);
+		break;
+	case  CANVAS_ALLOC:
+		top = ge2d_config->dst_para.top;
+		left = ge2d_config->dst_para.left;
+		width = ge2d_config->dst_para.width;
+		height = ge2d_config->dst_para.height;
+		if ((left + width > ge2d_config->dst_planes[0].w)
+		    || (top + height > ge2d_config->dst_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: dst: alloc, out of range\n");
+			return -1;
+		}
+		if (ge2d_config->dst_planes[0].addr ==
+				ge2d_config->src_planes[0].addr) {
+			ge2d_config->dst_para.canvas_index =
+				ge2d_config->src_para.canvas_index;
+			dst_addr = src_addr;
+			dst_stride = src_stride;
+		}
+		else if (ge2d_config->dst_planes[0].addr ==
+				ge2d_config->src2_planes[0].addr) {
+			ge2d_config->dst_para.canvas_index =
+				ge2d_config->src2_para.canvas_index;
+			dst_addr = src2_addr;
+			dst_stride = src2_stride;
+		} else {
+			if (ge2d_meson_dev.canvas_status == 1) {
+				if (build_ge2d_addr_config(
+					&ge2d_config->dst_planes[0],
+					ge2d_config->dst_para.format,
+					&dst_addr,
+					&dst_stride) < 0)
+					return -1;
+				ge2d_log_dbg("ge2d alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+					dst_addr,
+					dst_stride,
+					ge2d_config->dst_para.format);
+			} else {
+				if (build_ge2d_config_ex(context,
+					&ge2d_config->dst_planes[0],
+					ge2d_config->dst_para.format,
+					AML_GE2D_DST) < 0)
+					return -1;
+				ge2d_config->dst_para.canvas_index = 0;
+				ge2d_log_dbg("ge2d: dst alloc,format:0x%x\n",
+					ge2d_config->dst_para.format);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	ge2dgen_rendering_dir(context, ge2d_config->src_para.x_rev,
+			      ge2d_config->src_para.y_rev,
+			      ge2d_config->dst_para.x_rev,
+			      ge2d_config->dst_para.y_rev,
+			      ge2d_config->dst_xy_swap);
+	ge2dgen_const_color(context, ge2d_config->alu_const_color);
+
+	ge2dgen_src(context, ge2d_config->src_para.canvas_index,
+		    ge2d_config->src_para.format,
+		    src_addr,
+		    src_stride);
+	ge2dgen_src_clip(context, ge2d_config->src_para.left,
+			ge2d_config->src_para.top,
+			ge2d_config->src_para.width,
+			ge2d_config->src_para.height);
+	ge2dgen_src_key(context, ge2d_config->src_key.key_enable,
+			ge2d_config->src_key.key_color,
+			ge2d_config->src_key.key_mask,
+			ge2d_config->src_key.key_mode);
+#ifdef CONFIG_GE2D_SRC2
+	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha,
+		ge2d_config->src2_gb_alpha);
+#else
+	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha, 0);
+#endif
+	ge2dgen_src_color(context, ge2d_config->src_para.color);
+
+	ge2dgen_src2(context, ge2d_config->src2_para.canvas_index,
+		     ge2d_config->src2_para.format,
+		     src2_addr,
+		     src2_stride);
+	ge2dgen_src2_clip(context, ge2d_config->src2_para.left,
+			  ge2d_config->src2_para.top,
+			  ge2d_config->src2_para.width,
+			  ge2d_config->src2_para.height);
+
+	ge2dgen_dst(context, ge2d_config->dst_para.canvas_index,
+		    ge2d_config->dst_para.format,
+		    dst_addr,
+		    dst_stride);
+	ge2dgen_dst_clip(context, ge2d_config->dst_para.left,
+			 ge2d_config->dst_para.top,
+			 ge2d_config->dst_para.width,
+			 ge2d_config->dst_para.height,
+			 DST_CLIP_MODE_INSIDE);
+
+	src1_gen_cfg = ge2d_wq_get_src_gen(context);
+	src1_gen_cfg->fill_mode = ge2d_config->src_para.fill_mode;
+	src1_gen_cfg->chfmt_rpt_pix = 0;
+	src1_gen_cfg->cvfmt_rpt_pix = 0;
+	/* src1_gen_cfg->clipx_start_ex = 0; */
+	/* src1_gen_cfg->clipx_end_ex = 1; */
+	/* src1_gen_cfg->clipy_start_ex = 1; */
+	/* src1_gen_cfg->clipy_end_ex = 1; */
+
+	src2_dst_data_cfg = ge2d_wq_get_dst_data(context);
+	src2_dst_data_cfg->src2_def_color = ge2d_config->src2_para.color;
+
+	src2_dst_gen_cfg = ge2d_wq_get_dst_gen(context);
+	src2_dst_gen_cfg->src2_fill_mode = ge2d_config->src2_para.fill_mode;
+
+	dp_gen_cfg = ge2d_wq_get_dp_gen(context);
+
+	dp_gen_cfg->src1_vsc_phase0_always_en =
+		ge2d_config->src1_hsc_phase0_always_en;
+	dp_gen_cfg->src1_hsc_phase0_always_en =
+		ge2d_config->src1_vsc_phase0_always_en;
+	if ((context->config.v_scale_coef_type == FILTER_TYPE_GAU0) ||
+		(context->config.v_scale_coef_type == FILTER_TYPE_GAU0_BOT) ||
+		(context->config.v_scale_coef_type == FILTER_TYPE_GAU1) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU0) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU0_BOT) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU1)) {
+		/* 1bit, 0: using minus, 1: using repeat data */
+		dp_gen_cfg->src1_hsc_rpt_ctrl = ge2d_config->src1_hsc_rpt_ctrl;
+		/* 1bit, 0: using minus  1: using repeat data */
+		dp_gen_cfg->src1_vsc_rpt_ctrl = ge2d_config->src1_vsc_rpt_ctrl;
+	} else {
+		/* 1bit, 0: using minus, 1: using repeat data */
+		dp_gen_cfg->src1_hsc_rpt_ctrl = 1;
+		/* 1bit, 0: using minus  1: using repeat data */
+		dp_gen_cfg->src1_vsc_rpt_ctrl = 1;
+	}
+	dp_gen_cfg->src1_gb_alpha = 0xff;
+	dp_gen_cfg->src1_gb_alpha_en = 0;
+#ifdef CONFIG_GE2D_SRC2
+	dp_gen_cfg->src2_gb_alpha = 0xff;
+	dp_gen_cfg->src2_gb_alpha_en = 0;
+#endif
+	dp_gen_cfg->src2_key_en = ge2d_config->src2_key.key_enable;
+	dp_gen_cfg->src2_key_mode = ge2d_config->src2_key.key_mode;
+	dp_gen_cfg->src2_key =   ge2d_config->src2_key.key_color;
+	dp_gen_cfg->src2_key_mask = ge2d_config->src2_key.key_mask;
+
+	dp_gen_cfg->bitmask_en = ge2d_config->bitmask_en;
+	dp_gen_cfg->bitmask = ge2d_config->bitmask;
+	dp_gen_cfg->bytemask_only = ge2d_config->bytemask_only;
+
+	ge2d_cmd_cfg = ge2d_wq_get_cmd(context);
+
+	ge2d_cmd_cfg->src1_fill_color_en = ge2d_config->src_para.fill_color_en;
+
+	ge2d_cmd_cfg->src2_x_rev = ge2d_config->src2_para.x_rev;
+	ge2d_cmd_cfg->src2_y_rev = ge2d_config->src2_para.y_rev;
+	ge2d_cmd_cfg->src2_fill_color_en =
+		ge2d_config->src2_para.fill_color_en;
+
+	ge2d_cmd_cfg->vsc_phase_slope = ge2d_config->vsc_phase_slope;
+	ge2d_cmd_cfg->vsc_ini_phase = ge2d_config->vf_init_phase;
+	ge2d_cmd_cfg->vsc_phase_step = ge2d_config->vsc_start_phase_step;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = ge2d_config->vf_rpt_num;
+
+	/* let internal decide */
+	ge2d_cmd_cfg->hsc_phase_slope = ge2d_config->hsc_phase_slope;
+	ge2d_cmd_cfg->hsc_ini_phase = ge2d_config->hf_init_phase;
+	ge2d_cmd_cfg->hsc_phase_step = ge2d_config->hsc_start_phase_step;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = ge2d_config->hf_rpt_num;
+
+	ge2d_cmd_cfg->src1_cmult_asel = 0;
+	ge2d_cmd_cfg->src2_cmult_asel = 0;
+	context->config.update_flag = UPDATE_ALL;
+	/* context->config.src1_data.ddr_burst_size_y = 3; */
+	/* context->config.src1_data.ddr_burst_size_cb = 3; */
+	/* context->config.src1_data.ddr_burst_size_cr = 3; */
+	/* context->config.src2_dst_data.ddr_burst_size= 3; */
+
+	return  0;
+}
+EXPORT_SYMBOL(ge2d_context_config_ex);
+
+int ge2d_context_config_ex_ion(struct ge2d_context_s *context,
+			   struct config_para_ex_ion_s *ge2d_config)
+{
+	struct src_dst_para_s  tmp;
+	struct ge2d_src1_gen_s *src1_gen_cfg;
+	struct ge2d_src2_dst_data_s *src2_dst_data_cfg;
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg;
+	struct ge2d_dp_gen_s *dp_gen_cfg;
+	struct ge2d_cmd_s *ge2d_cmd_cfg;
+	int top, left, width, height;
+	unsigned int src_addr = 0, src2_addr = 0, dst_addr = 0;
+	unsigned int src_stride = 0, src2_stride = 0, dst_stride = 0;
+
+	/* setup src and dst */
+	switch (ge2d_config->src_para.mem_type) {
+	case CANVAS_OSD0:
+	case CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->src_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->src_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src_para.format = tmp.ge2d_color_index;
+		src_addr = tmp.phy_addr;
+		src_stride = tmp.stride;
+
+		ge2d_log_dbg("ge2d: src1-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->src_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->src_para.format);
+
+		top = ge2d_config->src_para.top;
+		left = ge2d_config->src_para.left;
+		width = ge2d_config->src_para.width;
+		height = ge2d_config->src_para.height;
+		if ((left + width > tmp.xres) ||
+		    (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d src error: out of range\n");
+			return -1;
+		}
+		ge2d_config->src_para.width = tmp.xres;
+		ge2d_config->src_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			src_addr,
+			src_stride,
+			ge2d_config->src_para.format);
+		break;
+	case CANVAS_ALLOC:
+		top = ge2d_config->src_para.top;
+		left = ge2d_config->src_para.left;
+		width = ge2d_config->src_para.width;
+		height = ge2d_config->src_para.height;
+		if ((left + width > ge2d_config->src_planes[0].w)
+		    || (top + height > ge2d_config->src_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: src alloc, out of range\n");
+			return -1;
+		}
+		if (ge2d_meson_dev.canvas_status == 1) {
+			if (build_ge2d_addr_config_ion(
+				&ge2d_config->src_planes[0],
+				ge2d_config->src_para.format,
+				&src_addr,
+				&src_stride) < 0)
+				return -1;
+			ge2d_log_dbg("ge2d alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+				src_addr,
+				src_stride,
+				ge2d_config->src_para.format);
+
+		} else {
+			if (build_ge2d_config_ex_ion(
+				context,
+				&ge2d_config->src_planes[0],
+				ge2d_config->src_para.format,
+				AML_GE2D_SRC) < 0)
+			return -1;
+			ge2d_config->src_para.canvas_index = 0;
+			ge2d_log_dbg("ge2d src alloc,format:0x%x\n",
+					 ge2d_config->src_para.format);
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (ge2d_config->src2_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->src2_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->src2_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src2_para.format = tmp.ge2d_color_index;
+		src2_addr = tmp.phy_addr;
+		src2_stride = tmp.stride;
+
+		ge2d_log_dbg("ge2d: src2-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->src2_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->src2_para.format);
+
+		top = ge2d_config->src2_para.top;
+		left = ge2d_config->src2_para.left;
+		width = ge2d_config->src2_para.width;
+		height = ge2d_config->src2_para.height;
+		if ((left + width > tmp.xres) || (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d error: src2: osd%d, out of range\n",
+				ge2d_config->src2_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		ge2d_config->src2_para.width = tmp.xres;
+		ge2d_config->src2_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			src2_addr,
+			src2_stride,
+			ge2d_config->src2_para.format);
+		break;
+	case  CANVAS_ALLOC:
+		top = ge2d_config->src2_para.top;
+		left = ge2d_config->src2_para.left;
+		width = ge2d_config->src2_para.width;
+		height = ge2d_config->src2_para.height;
+		if ((left + width > ge2d_config->src2_planes[0].w)
+		    || (top + height > ge2d_config->src2_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: src2: alloc, out of range\n");
+			return -1;
+		}
+		/*if (ge2d_config->src2_planes[0].addr ==
+		 *		ge2d_config->src_planes[0].addr)
+		 *	index = ge2d_config->src_para.canvas_index;
+		 * else
+		 */
+		if (ge2d_meson_dev.canvas_status == 1) {
+			if (build_ge2d_addr_config_ion(
+				&ge2d_config->src2_planes[0],
+				ge2d_config->src2_para.format,
+				&src2_addr,
+				&src2_stride) < 0)
+				return -1;
+			ge2d_log_dbg("ge2d alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+				src2_addr,
+				src2_stride,
+				ge2d_config->src2_para.format);
+		} else {
+			if (build_ge2d_config_ex_ion(
+				context,
+				&ge2d_config->src2_planes[0],
+				ge2d_config->src2_para.format,
+				AML_GE2D_SRC2) < 0)
+				return -1;
+			ge2d_config->src2_para.canvas_index = 0;
+			ge2d_log_dbg("ge2d src2 alloc,format:0x%x\n",
+				ge2d_config->src2_para.format);
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (ge2d_config->dst_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->dst_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->dst_para.canvas_index = tmp.canvas_index;
+		ge2d_config->dst_para.format = tmp.ge2d_color_index;
+		dst_addr = tmp.phy_addr;
+		dst_stride = tmp.stride;
+
+		ge2d_log_dbg("ge2d: dst-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->dst_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->dst_para.format);
+
+		top = ge2d_config->dst_para.top;
+		left = ge2d_config->dst_para.left;
+		width = ge2d_config->dst_para.width;
+		height = ge2d_config->dst_para.height;
+		if ((left + width > tmp.xres) || (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d error: dst: osd%d, out of range\n",
+				ge2d_config->dst_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		ge2d_config->dst_para.width = tmp.xres;
+		ge2d_config->dst_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			dst_addr,
+			dst_stride,
+			ge2d_config->dst_para.format);
+		break;
+	case  CANVAS_ALLOC:
+		top = ge2d_config->dst_para.top;
+		left = ge2d_config->dst_para.left;
+		width = ge2d_config->dst_para.width;
+		height = ge2d_config->dst_para.height;
+		if ((left + width > ge2d_config->dst_planes[0].w)
+		    || (top + height > ge2d_config->dst_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: dst: alloc, out of range\n");
+			return -1;
+		}
+		/*if (ge2d_config->dst_planes[0].addr ==
+		 *		ge2d_config->src_planes[0].addr)
+		 *	index = ge2d_config->src_para.canvas_index;
+		 * else if (ge2d_config->dst_planes[0].addr ==
+		 *		ge2d_config->src2_planes[0].addr)
+		 *	index = ge2d_config->src2_para.canvas_index;
+		 * else
+		 */
+		if (ge2d_meson_dev.canvas_status == 1) {
+			if (build_ge2d_addr_config_ion(
+				&ge2d_config->dst_planes[0],
+				ge2d_config->dst_para.format,
+				&dst_addr,
+				&dst_stride) < 0)
+				return -1;
+			ge2d_log_dbg("ge2d alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+				dst_addr,
+				dst_stride,
+				ge2d_config->dst_para.format);
+		} else {
+			if (build_ge2d_config_ex_ion(
+				context,
+				&ge2d_config->dst_planes[0],
+				ge2d_config->dst_para.format,
+				AML_GE2D_DST) < 0)
+				return -1;
+			ge2d_config->dst_para.canvas_index = 0;
+			ge2d_log_dbg("ge2d: dst alloc,format:0x%x\n",
+				ge2d_config->dst_para.format);
+		}
+		break;
+	default:
+		break;
+	}
+
+	ge2dgen_rendering_dir(context, ge2d_config->src_para.x_rev,
+			      ge2d_config->src_para.y_rev,
+			      ge2d_config->dst_para.x_rev,
+			      ge2d_config->dst_para.y_rev,
+			      ge2d_config->dst_xy_swap);
+	ge2dgen_const_color(context, ge2d_config->alu_const_color);
+
+	ge2dgen_src(context, ge2d_config->src_para.canvas_index,
+		    ge2d_config->src_para.format,
+		    src_addr,
+		    src_stride);
+	ge2dgen_src_clip(context, ge2d_config->src_para.left,
+			ge2d_config->src_para.top,
+			ge2d_config->src_para.width,
+			ge2d_config->src_para.height);
+	ge2dgen_src_key(context, ge2d_config->src_key.key_enable,
+			ge2d_config->src_key.key_color,
+			ge2d_config->src_key.key_mask,
+			ge2d_config->src_key.key_mode);
+#ifdef CONFIG_GE2D_SRC2
+	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha,
+		ge2d_config->src2_gb_alpha);
+#else
+	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha, 0);
+#endif
+	ge2dgen_src_color(context, ge2d_config->src_para.color);
+
+	ge2dgen_src2(context, ge2d_config->src2_para.canvas_index,
+		     ge2d_config->src2_para.format,
+		     src2_addr,
+		     src2_stride);
+	ge2dgen_src2_clip(context, ge2d_config->src2_para.left,
+			  ge2d_config->src2_para.top,
+			  ge2d_config->src2_para.width,
+			  ge2d_config->src2_para.height);
+
+	ge2dgen_dst(context, ge2d_config->dst_para.canvas_index,
+		    ge2d_config->dst_para.format,
+		    dst_addr,
+		    dst_stride);
+	ge2dgen_dst_clip(context, ge2d_config->dst_para.left,
+			 ge2d_config->dst_para.top,
+			 ge2d_config->dst_para.width,
+			 ge2d_config->dst_para.height,
+			 DST_CLIP_MODE_INSIDE);
+
+	src1_gen_cfg = ge2d_wq_get_src_gen(context);
+	src1_gen_cfg->fill_mode = ge2d_config->src_para.fill_mode;
+	src1_gen_cfg->chfmt_rpt_pix = 0;
+	src1_gen_cfg->cvfmt_rpt_pix = 0;
+	/* src1_gen_cfg->clipx_start_ex = 0; */
+	/* src1_gen_cfg->clipx_end_ex = 1; */
+	/* src1_gen_cfg->clipy_start_ex = 1; */
+	/* src1_gen_cfg->clipy_end_ex = 1; */
+
+	src2_dst_data_cfg = ge2d_wq_get_dst_data(context);
+	src2_dst_data_cfg->src2_def_color = ge2d_config->src2_para.color;
+
+	src2_dst_gen_cfg = ge2d_wq_get_dst_gen(context);
+	src2_dst_gen_cfg->src2_fill_mode = ge2d_config->src2_para.fill_mode;
+
+	dp_gen_cfg = ge2d_wq_get_dp_gen(context);
+
+	dp_gen_cfg->src1_vsc_phase0_always_en =
+		ge2d_config->src1_hsc_phase0_always_en;
+	dp_gen_cfg->src1_hsc_phase0_always_en =
+		ge2d_config->src1_vsc_phase0_always_en;
+	if ((context->config.v_scale_coef_type == FILTER_TYPE_GAU0) ||
+		(context->config.v_scale_coef_type == FILTER_TYPE_GAU0_BOT) ||
+		(context->config.v_scale_coef_type == FILTER_TYPE_GAU1) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU0) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU0_BOT) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU1)) {
+		/* 1bit, 0: using minus, 1: using repeat data */
+		dp_gen_cfg->src1_hsc_rpt_ctrl = ge2d_config->src1_hsc_rpt_ctrl;
+		/* 1bit, 0: using minus  1: using repeat data */
+		dp_gen_cfg->src1_vsc_rpt_ctrl = ge2d_config->src1_vsc_rpt_ctrl;
+	} else {
+		/* 1bit, 0: using minus, 1: using repeat data */
+		dp_gen_cfg->src1_hsc_rpt_ctrl = 1;
+		/* 1bit, 0: using minus  1: using repeat data */
+		dp_gen_cfg->src1_vsc_rpt_ctrl = 1;
+	}
+	dp_gen_cfg->src1_gb_alpha = ge2d_config->src1_gb_alpha & 0xff;
+	dp_gen_cfg->src1_gb_alpha_en = ge2d_config->src1_gb_alpha_en & 1;
+#ifdef CONFIG_GE2D_SRC2
+	dp_gen_cfg->src2_gb_alpha = ge2d_config->src2_gb_alpha & 0xff;
+	dp_gen_cfg->src2_gb_alpha_en = ge2d_config->src2_gb_alpha_en & 1;
+#endif
+	dp_gen_cfg->src2_key_en = ge2d_config->src2_key.key_enable;
+	dp_gen_cfg->src2_key_mode = ge2d_config->src2_key.key_mode;
+	dp_gen_cfg->src2_key =   ge2d_config->src2_key.key_color;
+	dp_gen_cfg->src2_key_mask = ge2d_config->src2_key.key_mask;
+
+	dp_gen_cfg->bitmask_en = ge2d_config->bitmask_en;
+	dp_gen_cfg->bitmask = ge2d_config->bitmask;
+	dp_gen_cfg->bytemask_only = ge2d_config->bytemask_only;
+
+	ge2d_cmd_cfg = ge2d_wq_get_cmd(context);
+
+	ge2d_cmd_cfg->src1_fill_color_en = ge2d_config->src_para.fill_color_en;
+
+	ge2d_cmd_cfg->src2_x_rev = ge2d_config->src2_para.x_rev;
+	ge2d_cmd_cfg->src2_y_rev = ge2d_config->src2_para.y_rev;
+	ge2d_cmd_cfg->src2_fill_color_en =
+		ge2d_config->src2_para.fill_color_en;
+#ifdef CONFIG_GE2D_SRC2
+	ge2d_cmd_cfg->src2_cmult_ad = ge2d_config->src2_cmult_ad;
+#endif
+
+	ge2d_cmd_cfg->vsc_phase_slope = ge2d_config->vsc_phase_slope;
+	ge2d_cmd_cfg->vsc_ini_phase = ge2d_config->vf_init_phase;
+	ge2d_cmd_cfg->vsc_phase_step = ge2d_config->vsc_start_phase_step;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = ge2d_config->vf_rpt_num;
+
+	/* let internal decide */
+	ge2d_cmd_cfg->hsc_phase_slope = ge2d_config->hsc_phase_slope;
+	ge2d_cmd_cfg->hsc_ini_phase = ge2d_config->hf_init_phase;
+	ge2d_cmd_cfg->hsc_phase_step = ge2d_config->hsc_start_phase_step;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = ge2d_config->hf_rpt_num;
+	ge2d_cmd_cfg->src1_cmult_asel = ge2d_config->src1_cmult_asel;
+	ge2d_cmd_cfg->src2_cmult_asel = ge2d_config->src2_cmult_asel;
+
+	ge2d_cmd_cfg->src1_fmt = ge2d_config->src_para.format;
+	ge2d_cmd_cfg->src2_fmt = ge2d_config->src2_para.format;
+	ge2d_cmd_cfg->dst_fmt = ge2d_config->dst_para.format;
+
+	context->config.update_flag = UPDATE_ALL;
+	/* context->config.src1_data.ddr_burst_size_y = 3; */
+	/* context->config.src1_data.ddr_burst_size_cb = 3; */
+	/* context->config.src1_data.ddr_burst_size_cr = 3; */
+	/* context->config.src2_dst_data.ddr_burst_size= 3; */
+
+	return  0;
+}
+int ge2d_context_config_ex_mem(struct ge2d_context_s *context,
+			   struct config_para_ex_memtype_s *ge2d_config_mem)
+{
+	struct src_dst_para_s  tmp;
+	struct ge2d_src1_gen_s *src1_gen_cfg;
+	struct ge2d_src2_dst_data_s *src2_dst_data_cfg;
+	struct ge2d_src2_dst_gen_s *src2_dst_gen_cfg;
+	struct ge2d_dp_gen_s *dp_gen_cfg;
+	struct ge2d_cmd_s *ge2d_cmd_cfg;
+	int top, left, width, height;
+	unsigned int src_addr = 0, src2_addr = 0, dst_addr = 0;
+	unsigned int src_stride = 0, src2_stride = 0, dst_stride = 0;
+	struct config_para_ex_ion_s *ge2d_config;
+	int i;
+
+	ge2d_config = &(ge2d_config_mem->_ge2d_config_ex);
+	/* reset dms_used flag */
+	for (i = 0; i < MAX_PLANE; i++) {
+		context->config.src_dma_cfg[i].dma_used = 0;
+		context->config.src2_dma_cfg[i].dma_used = 0;
+		context->config.dst_dma_cfg[i].dma_used = 0;
+	}
+	/* setup src and dst */
+	switch (ge2d_config->src_para.mem_type) {
+	case CANVAS_OSD0:
+	case CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->src_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->src_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src_para.format = tmp.ge2d_color_index;
+		src_addr = tmp.phy_addr;
+		src_stride = tmp.stride;
+
+		ge2d_log_dbg("ge2d: src1-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->src_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->src_para.format);
+
+		top = ge2d_config->src_para.top;
+		left = ge2d_config->src_para.left;
+		width = ge2d_config->src_para.width;
+		height = ge2d_config->src_para.height;
+		if ((left + width > tmp.xres) ||
+		    (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d src error: out of range\n");
+			return -1;
+		}
+		ge2d_config->src_para.width = tmp.xres;
+		ge2d_config->src_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			src_addr,
+			src_stride,
+			ge2d_config->src_para.format);
+		break;
+	case CANVAS_ALLOC:
+		top = ge2d_config->src_para.top;
+		left = ge2d_config->src_para.left;
+		width = ge2d_config->src_para.width;
+		height = ge2d_config->src_para.height;
+		if ((left + width > ge2d_config->src_planes[0].w)
+		    || (top + height > ge2d_config->src_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: src alloc, out of range\n");
+			return -1;
+		}
+		if (ge2d_meson_dev.canvas_status == 1) {
+			if (ge2d_config_mem->src1_mem_alloc_type ==
+				AML_GE2D_MEM_ION) {
+				if (build_ge2d_addr_config_ion(
+					&ge2d_config->src_planes[0],
+					ge2d_config->src_para.format,
+					&src_addr,
+					&src_stride) < 0)
+					return -1;
+				ge2d_log_dbg("ge2d ion alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+					src_addr,
+					src_stride,
+					ge2d_config->src_para.format);
+			} else if (ge2d_config_mem->src1_mem_alloc_type ==
+				AML_GE2D_MEM_DMABUF) {
+				if (build_ge2d_addr_config_dma(
+					context,
+					&ge2d_config->src_planes[0],
+					ge2d_config->src_para.format,
+					&src_addr,
+					&src_stride,
+					DMA_TO_DEVICE,
+					AML_GE2D_SRC) < 0)
+					return -1;
+				ge2d_log_dbg("ge2d dma alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+					src_addr,
+					src_stride,
+					ge2d_config->src_para.format);
+			}
+		} else {
+			if (ge2d_config_mem->src1_mem_alloc_type ==
+				AML_GE2D_MEM_ION) {
+				if (build_ge2d_config_ex_ion(
+					context,
+					&ge2d_config->src_planes[0],
+					ge2d_config->src_para.format,
+					AML_GE2D_SRC) < 0)
+					return -1;
+				ge2d_config->src_para.canvas_index = 0;
+				ge2d_log_dbg("ge2d ion alloc,format:0x%x\n",
+					ge2d_config->src_para.format);
+			} else if (ge2d_config_mem->src1_mem_alloc_type ==
+				AML_GE2D_MEM_DMABUF) {
+				if (build_ge2d_config_ex_dma(
+					context,
+					&ge2d_config->src_planes[0],
+					ge2d_config->src_para.format,
+					DMA_TO_DEVICE,
+					AML_GE2D_SRC) < 0)
+					return -1;
+				ge2d_config->src_para.canvas_index = 0;
+				ge2d_log_dbg("ge2d dma alloc,format:0x%x\n",
+					ge2d_config->src_para.format);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (ge2d_config->src2_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->src2_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->src2_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src2_para.format = tmp.ge2d_color_index;
+		src2_addr = tmp.phy_addr;
+		src2_stride = tmp.stride;
+
+		ge2d_log_dbg("ge2d: src2-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->src2_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->src2_para.format);
+
+		top = ge2d_config->src2_para.top;
+		left = ge2d_config->src2_para.left;
+		width = ge2d_config->src2_para.width;
+		height = ge2d_config->src2_para.height;
+		if ((left + width > tmp.xres) || (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d error: src2: osd%d, out of range\n",
+				ge2d_config->src2_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		ge2d_config->src2_para.width = tmp.xres;
+		ge2d_config->src2_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			src2_addr,
+			src2_stride,
+			ge2d_config->src2_para.format);
+		break;
+	case  CANVAS_ALLOC:
+		top = ge2d_config->src2_para.top;
+		left = ge2d_config->src2_para.left;
+		width = ge2d_config->src2_para.width;
+		height = ge2d_config->src2_para.height;
+		if ((left + width > ge2d_config->src2_planes[0].w)
+		    || (top + height > ge2d_config->src2_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: src2: alloc, out of range\n");
+			return -1;
+		}
+		/*if (ge2d_config->src2_planes[0].addr ==
+		 *		ge2d_config->src_planes[0].addr)
+		 *	index = ge2d_config->src_para.canvas_index;
+		 * else
+		 */
+		if (ge2d_meson_dev.canvas_status == 1) {
+			if (ge2d_config_mem->src2_mem_alloc_type ==
+				AML_GE2D_MEM_ION) {
+				if (build_ge2d_addr_config_ion(
+					&ge2d_config->src2_planes[0],
+					ge2d_config->src2_para.format,
+					&src2_addr,
+					&src2_stride) < 0)
+					return -1;
+				ge2d_log_dbg("ge2d ion alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+					src2_addr,
+					src2_stride,
+					ge2d_config->src2_para.format);
+			} else if (ge2d_config_mem->src2_mem_alloc_type ==
+				AML_GE2D_MEM_DMABUF) {
+				if (build_ge2d_addr_config_dma(
+					context,
+					&ge2d_config->src2_planes[0],
+					ge2d_config->src2_para.format,
+					&src2_addr,
+					&src2_stride,
+					DMA_TO_DEVICE,
+					AML_GE2D_SRC2) < 0)
+					return -1;
+				ge2d_log_dbg("ge2d dma alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+					src2_addr,
+					src2_stride,
+					ge2d_config->src2_para.format);
+			}
+		} else {
+			if (ge2d_config_mem->src2_mem_alloc_type ==
+				AML_GE2D_MEM_ION) {
+				if (build_ge2d_config_ex_ion(
+					context,
+					&ge2d_config->src2_planes[0],
+					ge2d_config->src2_para.format,
+					AML_GE2D_SRC2) < 0)
+					return -1;
+				ge2d_config->src2_para.canvas_index = 0;
+				ge2d_log_dbg("ge2d src2 ion alloc,format:0x%x\n",
+					ge2d_config->src2_para.format);
+			} else if (ge2d_config_mem->src2_mem_alloc_type ==
+				AML_GE2D_MEM_DMABUF) {
+				if (build_ge2d_config_ex_dma(
+					context,
+					&ge2d_config->src2_planes[0],
+					ge2d_config->src2_para.format,
+					DMA_TO_DEVICE,
+					AML_GE2D_SRC2) < 0)
+					return -1;
+				ge2d_config->src2_para.canvas_index = 0;
+				ge2d_log_dbg("ge2d src2 dma alloc,format:0x%x\n",
+					ge2d_config->src2_para.format);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	switch (ge2d_config->dst_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if (setup_display_property(&tmp,
+			(ge2d_config->dst_para.mem_type == CANVAS_OSD0) ?
+			OSD1_CANVAS_INDEX : OSD2_CANVAS_INDEX) < 0)
+			return -1;
+		ge2d_config->dst_para.canvas_index = tmp.canvas_index;
+		ge2d_config->dst_para.format = tmp.ge2d_color_index;
+		dst_addr = tmp.phy_addr;
+		dst_stride = tmp.stride;
+
+		ge2d_log_dbg("ge2d: dst-->type: osd%d, format: 0x%x !!\n",
+			     ge2d_config->dst_para.mem_type - CANVAS_OSD0,
+			     ge2d_config->dst_para.format);
+
+		top = ge2d_config->dst_para.top;
+		left = ge2d_config->dst_para.left;
+		width = ge2d_config->dst_para.width;
+		height = ge2d_config->dst_para.height;
+		if ((left + width > tmp.xres) || (top + height > tmp.yres)) {
+			ge2d_log_dbg("ge2d error: dst: osd%d, out of range\n",
+				ge2d_config->dst_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		ge2d_config->dst_para.width = tmp.xres;
+		ge2d_config->dst_para.height = tmp.yres;
+		ge2d_log_dbg("ge2d osd phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+			dst_addr,
+			dst_stride,
+			ge2d_config->dst_para.format);
+		break;
+	case  CANVAS_ALLOC:
+		top = ge2d_config->dst_para.top;
+		left = ge2d_config->dst_para.left;
+		width = ge2d_config->dst_para.width;
+		height = ge2d_config->dst_para.height;
+		if ((left + width > ge2d_config->dst_planes[0].w)
+		    || (top + height > ge2d_config->dst_planes[0].h)) {
+			ge2d_log_dbg("ge2d error: dst: alloc, out of range\n");
+			return -1;
+		}
+		/*if (ge2d_config->dst_planes[0].addr ==
+		 *		ge2d_config->src_planes[0].addr)
+		 *	index = ge2d_config->src_para.canvas_index;
+		 * else if (ge2d_config->dst_planes[0].addr ==
+		 *		ge2d_config->src2_planes[0].addr)
+		 *	index = ge2d_config->src2_para.canvas_index;
+		 * else
+		 */
+		if (ge2d_meson_dev.canvas_status == 1) {
+			if (ge2d_config_mem->dst_mem_alloc_type ==
+				AML_GE2D_MEM_ION) {
+				if (build_ge2d_addr_config_ion(
+					&ge2d_config->dst_planes[0],
+					ge2d_config->dst_para.format,
+					&dst_addr,
+					&dst_stride) < 0)
+					return -1;
+				ge2d_log_dbg("ge2d ion alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+					dst_addr,
+					dst_stride,
+					ge2d_config->dst_para.format);
+			} else if (ge2d_config_mem->dst_mem_alloc_type ==
+				AML_GE2D_MEM_DMABUF) {
+				if (build_ge2d_addr_config_dma(
+					context,
+					&ge2d_config->dst_planes[0],
+					ge2d_config->dst_para.format,
+					&dst_addr,
+					&dst_stride,
+					DMA_FROM_DEVICE,
+					AML_GE2D_DST) < 0)
+					return -1;
+				ge2d_log_dbg("ge2d dma alloc phy_addr:0x%x,stride=0x%x,format:0x%x\n",
+					dst_addr,
+					dst_stride,
+					ge2d_config->dst_para.format);
+			}
+		} else {
+			if (ge2d_config_mem->dst_mem_alloc_type ==
+				AML_GE2D_MEM_ION) {
+				if (build_ge2d_config_ex_ion(
+					context,
+					&ge2d_config->dst_planes[0],
+					ge2d_config->dst_para.format,
+					AML_GE2D_DST) < 0)
+					return -1;
+				ge2d_config->dst_para.canvas_index = 0;
+				ge2d_log_dbg("ge2d: dst ion alloc,format:0x%x\n",
+					ge2d_config->dst_para.format);
+			} else if (ge2d_config_mem->dst_mem_alloc_type ==
+				AML_GE2D_MEM_DMABUF) {
+				if (build_ge2d_config_ex_dma(
+					context,
+					&ge2d_config->dst_planes[0],
+					ge2d_config->dst_para.format,
+					DMA_FROM_DEVICE,
+					AML_GE2D_DST) < 0)
+					return -1;
+				ge2d_config->dst_para.canvas_index = 0;
+				ge2d_log_dbg("ge2d: dst dma alloc,format:0x%x\n",
+					ge2d_config->dst_para.format);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+
+	ge2dgen_rendering_dir(context, ge2d_config->src_para.x_rev,
+			      ge2d_config->src_para.y_rev,
+			      ge2d_config->dst_para.x_rev,
+			      ge2d_config->dst_para.y_rev,
+			      ge2d_config->dst_xy_swap);
+	ge2dgen_const_color(context, ge2d_config->alu_const_color);
+
+	ge2dgen_src(context, ge2d_config->src_para.canvas_index,
+		    ge2d_config->src_para.format,
+		    src_addr,
+		    src_stride);
+	ge2dgen_src_clip(context, ge2d_config->src_para.left,
+			ge2d_config->src_para.top,
+			ge2d_config->src_para.width,
+			ge2d_config->src_para.height);
+	ge2dgen_src_key(context, ge2d_config->src_key.key_enable,
+			ge2d_config->src_key.key_color,
+			ge2d_config->src_key.key_mask,
+			ge2d_config->src_key.key_mode);
+#ifdef CONFIG_GE2D_SRC2
+	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha,
+		ge2d_config->src2_gb_alpha);
+#else
+	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha, 0);
+#endif
+	ge2dgen_src_color(context, ge2d_config->src_para.color);
+
+	ge2dgen_src2(context, ge2d_config->src2_para.canvas_index,
+		     ge2d_config->src2_para.format,
+		     src2_addr,
+		     src2_stride);
+	ge2dgen_src2_clip(context, ge2d_config->src2_para.left,
+			  ge2d_config->src2_para.top,
+			  ge2d_config->src2_para.width,
+			  ge2d_config->src2_para.height);
+
+	ge2dgen_dst(context, ge2d_config->dst_para.canvas_index,
+		    ge2d_config->dst_para.format,
+		    dst_addr,
+		    dst_stride);
+	ge2dgen_dst_clip(context, ge2d_config->dst_para.left,
+			 ge2d_config->dst_para.top,
+			 ge2d_config->dst_para.width,
+			 ge2d_config->dst_para.height,
+			 DST_CLIP_MODE_INSIDE);
+
+	src1_gen_cfg = ge2d_wq_get_src_gen(context);
+	src1_gen_cfg->fill_mode = ge2d_config->src_para.fill_mode;
+	src1_gen_cfg->chfmt_rpt_pix = 0;
+	src1_gen_cfg->cvfmt_rpt_pix = 0;
+	/* src1_gen_cfg->clipx_start_ex = 0; */
+	/* src1_gen_cfg->clipx_end_ex = 1; */
+	/* src1_gen_cfg->clipy_start_ex = 1; */
+	/* src1_gen_cfg->clipy_end_ex = 1; */
+
+	src2_dst_data_cfg = ge2d_wq_get_dst_data(context);
+	src2_dst_data_cfg->src2_def_color = ge2d_config->src2_para.color;
+
+	src2_dst_gen_cfg = ge2d_wq_get_dst_gen(context);
+	src2_dst_gen_cfg->src2_fill_mode = ge2d_config->src2_para.fill_mode;
+
+	dp_gen_cfg = ge2d_wq_get_dp_gen(context);
+
+	dp_gen_cfg->src1_vsc_phase0_always_en =
+		ge2d_config->src1_hsc_phase0_always_en;
+	dp_gen_cfg->src1_hsc_phase0_always_en =
+		ge2d_config->src1_vsc_phase0_always_en;
+	if ((context->config.v_scale_coef_type == FILTER_TYPE_GAU0) ||
+		(context->config.v_scale_coef_type == FILTER_TYPE_GAU0_BOT) ||
+		(context->config.v_scale_coef_type == FILTER_TYPE_GAU1) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU0) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU0_BOT) ||
+		(context->config.h_scale_coef_type == FILTER_TYPE_GAU1)) {
+		/* 1bit, 0: using minus, 1: using repeat data */
+		dp_gen_cfg->src1_hsc_rpt_ctrl = ge2d_config->src1_hsc_rpt_ctrl;
+		/* 1bit, 0: using minus  1: using repeat data */
+		dp_gen_cfg->src1_vsc_rpt_ctrl = ge2d_config->src1_vsc_rpt_ctrl;
+	} else {
+		/* 1bit, 0: using minus, 1: using repeat data */
+		dp_gen_cfg->src1_hsc_rpt_ctrl = 1;
+		/* 1bit, 0: using minus  1: using repeat data */
+		dp_gen_cfg->src1_vsc_rpt_ctrl = 1;
+	}
+	dp_gen_cfg->src1_gb_alpha = ge2d_config->src1_gb_alpha & 0xff;
+	dp_gen_cfg->src1_gb_alpha_en = ge2d_config->src1_gb_alpha_en & 1;
+#ifdef CONFIG_GE2D_SRC2
+	dp_gen_cfg->src2_gb_alpha = ge2d_config->src2_gb_alpha & 0xff;
+	dp_gen_cfg->src2_gb_alpha_en = ge2d_config->src2_gb_alpha_en & 1;
+#endif
+	dp_gen_cfg->src2_key_en = ge2d_config->src2_key.key_enable;
+	dp_gen_cfg->src2_key_mode = ge2d_config->src2_key.key_mode;
+	dp_gen_cfg->src2_key =   ge2d_config->src2_key.key_color;
+	dp_gen_cfg->src2_key_mask = ge2d_config->src2_key.key_mask;
+
+	dp_gen_cfg->bitmask_en = ge2d_config->bitmask_en;
+	dp_gen_cfg->bitmask = ge2d_config->bitmask;
+	dp_gen_cfg->bytemask_only = ge2d_config->bytemask_only;
+
+	ge2d_cmd_cfg = ge2d_wq_get_cmd(context);
+
+	ge2d_cmd_cfg->src1_fill_color_en = ge2d_config->src_para.fill_color_en;
+
+	ge2d_cmd_cfg->src2_x_rev = ge2d_config->src2_para.x_rev;
+	ge2d_cmd_cfg->src2_y_rev = ge2d_config->src2_para.y_rev;
+	ge2d_cmd_cfg->src2_fill_color_en =
+		ge2d_config->src2_para.fill_color_en;
+#ifdef CONFIG_GE2D_SRC2
+	ge2d_cmd_cfg->src2_cmult_ad = ge2d_config->src2_cmult_ad;
+#endif
+
+	ge2d_cmd_cfg->vsc_phase_slope = ge2d_config->vsc_phase_slope;
+	ge2d_cmd_cfg->vsc_ini_phase = ge2d_config->vf_init_phase;
+	ge2d_cmd_cfg->vsc_phase_step = ge2d_config->vsc_start_phase_step;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = ge2d_config->vf_rpt_num;
+
+	/* let internal decide */
+	ge2d_cmd_cfg->hsc_phase_slope = ge2d_config->hsc_phase_slope;
+	ge2d_cmd_cfg->hsc_ini_phase = ge2d_config->hf_init_phase;
+	ge2d_cmd_cfg->hsc_phase_step = ge2d_config->hsc_start_phase_step;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = ge2d_config->hf_rpt_num;
+	ge2d_cmd_cfg->src1_cmult_asel = ge2d_config->src1_cmult_asel;
+	ge2d_cmd_cfg->src2_cmult_asel = ge2d_config->src2_cmult_asel;
+	context->config.update_flag = UPDATE_ALL;
+	/* context->config.src1_data.ddr_burst_size_y = 3; */
+	/* context->config.src1_data.ddr_burst_size_cb = 3; */
+	/* context->config.src1_data.ddr_burst_size_cr = 3; */
+	/* context->config.src2_dst_data.ddr_burst_size= 3; */
+	memcpy(&context->config.matrix_custom, &ge2d_config_mem->matrix_custom,
+	       sizeof(struct ge2d_matrix_s));
+
+	return  0;
+}
+
+int ge2d_buffer_alloc(struct ge2d_dmabuf_req_s *ge2d_req_buf)
+{
+	struct device *dev;
+
+	dev = &(ge2d_manager.pdev->dev);
+	return ge2d_dma_buffer_alloc(ge2d_manager.buffer,
+		dev, ge2d_req_buf);
+}
+
+int ge2d_buffer_export(struct ge2d_dmabuf_exp_s *ge2d_exp_buf)
+{
+	return ge2d_dma_buffer_export(ge2d_manager.buffer, ge2d_exp_buf);
+}
+
+int ge2d_buffer_free(int index)
+{
+	return ge2d_dma_buffer_free(ge2d_manager.buffer, index);
+
+}
+
+void ge2d_buffer_dma_flush(int dma_fd)
+{
+	struct device *dev;
+
+	dev = &(ge2d_manager.pdev->dev);
+	ge2d_dma_buffer_dma_flush(dev, dma_fd);
+}
+
+void ge2d_buffer_cache_flush(int dma_fd)
+{
+	struct device *dev;
+
+	dev = &(ge2d_manager.pdev->dev);
+	ge2d_dma_buffer_cache_flush(dev, dma_fd);
+}
+
+static int ge2d_buffer_get_phys(struct aml_dma_cfg *cfg, unsigned long *addr)
+{
+	return ge2d_dma_buffer_get_phys(ge2d_manager.buffer, cfg, addr);
+}
+
+static int ge2d_buffer_unmap(struct aml_dma_cfg *cfg)
+{
+	return ge2d_dma_buffer_unmap_info(ge2d_manager.buffer, cfg);
+}
+
+struct ge2d_context_s *create_ge2d_work_queue(void)
+{
+	int  i;
+	struct ge2d_queue_item_s *p_item;
+	struct ge2d_context_s *ge2d_work_queue;
+	int  empty;
+
+	if (!ge2d_manager.probe)
+		return NULL;
+	ge2d_work_queue = kzalloc(sizeof(struct ge2d_context_s), GFP_KERNEL);
+	ge2d_work_queue->config.h_scale_coef_type = FILTER_TYPE_BILINEAR;
+	ge2d_work_queue->config.v_scale_coef_type = FILTER_TYPE_BILINEAR;
+	ge2d_work_queue->ge2d_request_exit = 0;
+	if (IS_ERR(ge2d_work_queue)) {
+		ge2d_log_err("can't create work queue\n");
+		return NULL;
+	}
+	INIT_LIST_HEAD(&ge2d_work_queue->work_queue);
+	INIT_LIST_HEAD(&ge2d_work_queue->free_queue);
+	init_waitqueue_head(&ge2d_work_queue->cmd_complete);
+	spin_lock_init(&ge2d_work_queue->lock);  /* for process lock. */
+	for (i = 0; i < MAX_GE2D_CMD; i++) {
+		p_item = kcalloc(1,
+				sizeof(struct ge2d_queue_item_s),
+				GFP_KERNEL);
+		if (IS_ERR(p_item)) {
+			ge2d_log_err("can't request queue item memory\n");
+			return NULL;
+		}
+		list_add_tail(&p_item->list, &ge2d_work_queue->free_queue);
+	}
+
+	/* put this process queue  into manager queue list. */
+	/* maybe process queue is changing . */
+	spin_lock(&ge2d_manager.event.sem_lock);
+	empty = list_empty(&ge2d_manager.process_queue);
+	list_add_tail(&ge2d_work_queue->list, &ge2d_manager.process_queue);
+	spin_unlock(&ge2d_manager.event.sem_lock);
+	return ge2d_work_queue; /* find it */
+}
+EXPORT_SYMBOL(create_ge2d_work_queue);
+
+int  destroy_ge2d_work_queue(struct ge2d_context_s *ge2d_work_queue)
+{
+	struct ge2d_queue_item_s *pitem, *tmp;
+	struct list_head		*head;
+	int empty, timeout = 0;
+
+	if (ge2d_work_queue) {
+		/* first detatch it from the process queue,then delete it . */
+		/* maybe process queue is changing .so we lock it. */
+		spin_lock(&ge2d_manager.event.sem_lock);
+		list_del(&ge2d_work_queue->list);
+		empty = list_empty(&ge2d_manager.process_queue);
+		spin_unlock(&ge2d_manager.event.sem_lock);
+		if ((ge2d_manager.current_wq == ge2d_work_queue) &&
+		    (ge2d_manager.ge2d_state == GE2D_STATE_RUNNING)) {
+			ge2d_work_queue->ge2d_request_exit = 1;
+			timeout = wait_for_completion_timeout(
+					&ge2d_manager.event.process_complete,
+					msecs_to_jiffies(500));
+			if (!timeout)
+				ge2d_log_err("wait timeout\n");
+			/* condition so complex ,simplify it . */
+			ge2d_manager.last_wq = NULL;
+		} /* else we can delete it safely. */
+
+		head = &ge2d_work_queue->work_queue;
+		list_for_each_entry_safe(pitem, tmp, head, list) {
+			if (pitem) {
+				list_del(&pitem->list);
+				kfree(pitem);
+			}
+		}
+		head = &ge2d_work_queue->free_queue;
+		list_for_each_entry_safe(pitem, tmp, head, list) {
+			if (pitem) {
+				list_del(&pitem->list);
+				kfree(pitem);
+			}
+		}
+
+		kfree(ge2d_work_queue);
+		ge2d_work_queue = NULL;
+		return 0;
+	}
+
+	return  -1;
+}
+EXPORT_SYMBOL(destroy_ge2d_work_queue);
+
+int ge2d_wq_init(struct platform_device *pdev,
+	int irq, struct clk *clk)
+{
+	ge2d_manager.pdev = pdev;
+	ge2d_irq = irq;
+	ge2d_clk = clk;
+
+	ge2d_log_info("ge2d: pdev=%px, irq=%d, clk=%px\n",
+		pdev, irq, clk);
+
+	// Alloc Canvas
+	ge2d_manager.canvas = meson_canvas_get(&pdev->dev);
+	if (IS_ERR(ge2d_manager.canvas)) {
+		ge2d_log_err("can't get meson canvas\n");
+		return -1;
+	}
+	for (int i = 0; i < sizeof(ge2d_manager.alloced_canvas_index); i++) {
+		if (0 != meson_canvas_alloc(ge2d_manager.canvas, &ge2d_manager.alloced_canvas_index[i])) {
+			ge2d_log_err("meson_canvas_alloc(%p) failed.\n", ge2d_manager.canvas);
+			// free pre-alloced canvas
+			for (int j = 0; j < i; j++) {
+				meson_canvas_free(ge2d_manager.canvas, ge2d_manager.alloced_canvas_index[j]);
+			}
+			return -1;
+		}
+		ge2d_log_info("Canvas ALLOC: [%d] = %d\n", i, ge2d_manager.alloced_canvas_index[i]);
+	}
+	
+	ge2d_manager.irq_num = request_irq(ge2d_irq,
+					ge2d_wq_handle,
+					IRQF_SHARED,
+					"ge2d",
+					(void *)&ge2d_manager);
+	if (ge2d_manager.irq_num < 0) {
+		ge2d_log_err("ge2d request irq error\n");
+		return -1;
+	}
+
+	/* prepare bottom half */
+	spin_lock_init(&ge2d_manager.event.sem_lock);
+	sema_init(&ge2d_manager.event.cmd_in_sem, 1);
+	init_waitqueue_head(&ge2d_manager.event.cmd_complete);
+	init_completion(&ge2d_manager.event.process_complete);
+	INIT_LIST_HEAD(&ge2d_manager.process_queue);
+	ge2d_manager.last_wq = NULL;
+	ge2d_manager.ge2d_thread = NULL;
+	ge2d_manager.buffer = ge2d_dma_buffer_create();
+	if (!ge2d_manager.buffer)
+		return -1;
+
+	if (ge2d_start_monitor()) {
+		ge2d_log_err("ge2d create thread error\n");
+		return -1;
+	}
+	ge2d_manager.probe = 1;
+	return 0;
+}
+
+int ge2d_wq_deinit(void)
+{
+	ge2d_stop_monitor();
+	ge2d_log_info("deinit ge2d device\n");
+	if (ge2d_manager.irq_num >= 0) {
+		free_irq(ge2d_manager.irq_num, &ge2d_manager);
+		ge2d_manager.irq_num = -1;
+	}
+	ge2d_irq = -1;
+	clk_disable_unprepare(ge2d_clk);
+	ge2d_dma_buffer_destroy(ge2d_manager.buffer);
+	ge2d_manager.buffer = NULL;
+	ge2d_manager.pdev = NULL;
+
+	// Free Canvas
+	for (int i = 0; i < sizeof(ge2d_manager.alloced_canvas_index); i++) {
+		meson_canvas_free(ge2d_manager.canvas, ge2d_manager.alloced_canvas_index[i]);
+		ge2d_manager.alloced_canvas_index[i] = 0;
+	}
+	
+	return  0;
+}
+
diff -Naur a/vendor/amlogic/ge2d/ge2d_wq.h b/vendor/amlogic/ge2d/ge2d_wq.h
--- a/vendor/amlogic/ge2d/ge2d_wq.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/ge2d_wq.h	2022-06-24 14:37:49.854257283 +0800
@@ -0,0 +1,43 @@
+/*
+ * vendor/amlogic/media/common/ge2d/ge2d_wq.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _GE2D_WQ_H_
+#define _GE2D_WQ_H_
+#ifdef CONFIG_AMLOGIC_ION
+#include <ion/ion.h>
+
+extern struct ion_client *ge2d_ion_client;
+#endif
+
+extern ssize_t work_queue_status_show(struct class *cla,
+		struct class_attribute *attr, char *buf);
+
+extern ssize_t free_queue_status_show(struct class *cla,
+		struct class_attribute *attr, char *buf);
+
+extern int ge2d_setup(int irq, struct reset_control *rstc);
+extern int ge2d_wq_init(struct platform_device *pdev,
+	int irq, struct clk *clk);
+extern int ge2d_wq_deinit(void);
+
+int ge2d_buffer_alloc(struct ge2d_dmabuf_req_s *ge2d_req_buf);
+int ge2d_buffer_free(int index);
+int ge2d_buffer_export(struct ge2d_dmabuf_exp_s *ge2d_exp_buf);
+void ge2d_buffer_dma_flush(int dma_fd);
+void ge2d_buffer_cache_flush(int dma_fd);
+void ge2d_pwr_config(bool enable);
+#endif
diff -Naur a/vendor/amlogic/ge2d/Kconfig b/vendor/amlogic/ge2d/Kconfig
--- a/vendor/amlogic/ge2d/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/Kconfig	2022-05-31 11:56:47.713259502 +0800
@@ -0,0 +1,16 @@
+#
+# GE2D Module
+#
+menu "Amlogic GE2D Module"
+config  AMLOGIC_MEDIA_GE2D
+	bool "Amlogic GE2D Module"
+	default n
+	help
+		Select to enable GE2D graphic 2D engine.
+config	AMLOGIC_MEDIA_GE2D_MORE_SECURITY
+	bool "Amlogic GE2D not use physical addr"
+	default n
+	depends on AMLOGIC_MEDIA_GE2D
+	help
+		Select to enable GE2D not use physical addr.
+endmenu
diff -Naur a/vendor/amlogic/ge2d/Makefile b/vendor/amlogic/ge2d/Makefile
--- a/vendor/amlogic/ge2d/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/Makefile	2022-05-31 11:56:47.713259502 +0800
@@ -0,0 +1,11 @@
+ge2d-objs = bitblt.o \
+	fillrect.o \
+	ge2d_hw.o \
+	ge2dgen.o \
+	ge2d_wq.o \
+	stretchblt.o \
+	ge2d_main.o \
+	blend.o \
+	ge2d_dmabuf.o
+
+obj-$(CONFIG_AMLOGIC_MEDIA_GE2D) += ge2d.o
diff -Naur a/vendor/amlogic/ge2d/stretchblt.c b/vendor/amlogic/ge2d/stretchblt.c
--- a/vendor/amlogic/ge2d/stretchblt.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/ge2d/stretchblt.c	2022-06-24 14:37:49.897553335 +0800
@@ -0,0 +1,141 @@
+/*
+ * vendor/amlogic/media/common/ge2d/stretchblt.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* Amlogic Headers */
+#include <linux/amlogic/media/ge2d/ge2d.h>
+
+static void _stretchblt(struct ge2d_context_s *wq,
+			       int src_x, int src_y, int src_w, int src_h,
+			       int dst_x, int dst_y, int dst_w, int dst_h,
+			       int block)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + src_w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + src_h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + dst_w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + dst_h - 1;
+
+	ge2d_cmd_cfg->sc_hsc_en = 1;
+	ge2d_cmd_cfg->sc_vsc_en = 1;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+	ge2d_cmd_cfg->hsc_div_en = 1;
+#ifdef CONFIG_GE2D_ADV_NUM
+	ge2d_cmd_cfg->hsc_adv_num =
+		((dst_w - 1) < 1024) ? (dst_w - 1) : 0;
+#else
+	ge2d_cmd_cfg->hsc_adv_num = 0;
+#endif
+	ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->wait_done_flag   = block;
+
+	ge2d_wq_add_work(wq);
+}
+
+void stretchblt(struct ge2d_context_s *wq,
+		int src_x, int src_y, int src_w, int src_h,
+		int dst_x, int dst_y, int dst_w, int dst_h)
+{
+	_stretchblt(wq,
+		    src_x, src_y, src_w, src_h,
+		    dst_x, dst_y, dst_w, dst_h, 1);
+}
+EXPORT_SYMBOL(stretchblt);
+
+void stretchblt_noblk(struct ge2d_context_s *wq,
+		      int src_x, int src_y, int src_w, int src_h,
+		      int dst_x, int dst_y, int dst_w, int dst_h)
+{
+	_stretchblt(wq,
+		    src_x, src_y, src_w, src_h,
+		    dst_x, dst_y, dst_w, dst_h, 0);
+}
+EXPORT_SYMBOL(stretchblt_noblk);
+
+static void _stretchblt_noalpha(struct ge2d_context_s *wq,
+				int src_x, int src_y, int src_w, int src_h,
+				int dst_x, int dst_y, int dst_w, int dst_h,
+				int blk)
+{
+	struct ge2d_cmd_s *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+	struct ge2d_dp_gen_s *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+	if (dp_gen_cfg->alu_const_color != 0xff) {
+		dp_gen_cfg->alu_const_color = 0xff;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+
+
+
+	ge2d_cmd_cfg->src1_x_start = src_x;
+	ge2d_cmd_cfg->src1_x_end   = src_x + src_w - 1;
+	ge2d_cmd_cfg->src1_y_start = src_y;
+	ge2d_cmd_cfg->src1_y_end   = src_y + src_h - 1;
+
+	ge2d_cmd_cfg->dst_x_start  = dst_x;
+	ge2d_cmd_cfg->dst_x_end    = dst_x + dst_w - 1;
+	ge2d_cmd_cfg->dst_y_start  = dst_y;
+	ge2d_cmd_cfg->dst_y_end    = dst_y + dst_h - 1;
+
+	ge2d_cmd_cfg->sc_hsc_en = 1;
+	ge2d_cmd_cfg->sc_vsc_en = 1;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+	ge2d_cmd_cfg->hsc_div_en = 1;
+#ifdef CONFIG_GE2D_ADV_NUM
+	ge2d_cmd_cfg->hsc_adv_num =
+		((dst_w - 1) < 1024) ? (dst_w - 1) : 0;
+#else
+	ge2d_cmd_cfg->hsc_adv_num = 0;
+#endif
+	ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET;
+	ge2d_cmd_cfg->wait_done_flag   = 1;
+
+	ge2d_wq_add_work(wq);
+}
+
+void stretchblt_noalpha(struct ge2d_context_s *wq,
+			int src_x, int src_y, int src_w, int src_h,
+			int dst_x, int dst_y, int dst_w, int dst_h)
+{
+	_stretchblt_noalpha(wq,
+			    src_x, src_y, src_w, src_h,
+			    dst_x, dst_y, dst_w, dst_h, 1);
+}
+EXPORT_SYMBOL(stretchblt_noalpha);
+
+void stretchblt_noalpha_noblk(struct ge2d_context_s *wq,
+			      int src_x, int src_y, int src_w, int src_h,
+			      int dst_x, int dst_y, int dst_w, int dst_h)
+{
+	_stretchblt_noalpha(wq,
+			    src_x, src_y, src_w, src_h,
+			    dst_x, dst_y, dst_w, dst_h, 0);
+}
+EXPORT_SYMBOL(stretchblt_noalpha_noblk);
diff -Naur a/vendor/amlogic/input/Kconfig b/vendor/amlogic/input/Kconfig
--- a/vendor/amlogic/input/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/input/Kconfig	2022-06-06 09:15:34.505066937 +0800
@@ -0,0 +1,10 @@
+#
+# Amlogic Input Module
+#
+menu "Amlogic Input Module"
+config  AMLOGIC_INPUT
+	bool "Amlogic Input Module"
+	default n
+	help
+		Select to enable Input.
+endmenu
diff -Naur a/vendor/amlogic/input/keyboard/gpio_keypad.c b/vendor/amlogic/input/keyboard/gpio_keypad.c
--- a/vendor/amlogic/input/keyboard/gpio_keypad.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/input/keyboard/gpio_keypad.c	2022-07-05 11:21:56.933871769 +0800
@@ -0,0 +1,466 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ *	Driver for buttons on GPIO lines not capable of generating interrupts
+ *
+ *	Copyright (C) 2022 AlgoIdeas <yu19881234@163.com>
+ *	Copyright (C) 2007-2010 Gabor Juhos <juhosg@openwrt.org>
+ *	Copyright (C) 2010 Nuno Goncalves <nunojpg@gmail.com>
+ *
+ *	This file was based on: /drivers/input/misc/cobalt_btns.c
+ *	Copyright (C) 2007 Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
+ *
+ *	also was based on: /drivers/input/keyboard/gpio_keys.c
+ *	Copyright 2005 Phil Blundell
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/property.h>
+
+#ifdef CONFIG_DRIVERS_HDF_INPUT
+#include "hdf_hid_adapter.h"
+#endif
+
+#define DRV_NAME	"gpio-keypad"
+
+struct gpio_keys_button_data {
+	struct gpio_desc *gpiod;
+	int last_state;
+	int count;
+	int threshold;
+};
+
+struct gpio_keypad_dev {
+	struct input_dev *input;
+	struct device *dev;
+	const struct gpio_keys_platform_data *pdata;
+	unsigned long rel_axis_seen[BITS_TO_LONGS(REL_CNT)];
+	unsigned long abs_axis_seen[BITS_TO_LONGS(ABS_CNT)];
+	struct gpio_keys_button_data data[];
+};
+
+#ifdef CONFIG_DRIVERS_HDF_INPUT
+static InputDevice *g_hidInputDev = NULL;
+#endif
+
+static InputDevice* HidRegisterHdfKeyPadDev(void) 
+{
+	InputDevice* inputDev = NULL;
+	HidInfo hidInfo;
+
+	hidInfo.devType = INDEV_TYPE_KEYBOARD;
+	hidInfo.eventType[0] = SET_BIT(EV_KEY);
+	hidInfo.keyCode[3] = SET_BIT(KEY_POWER);
+	hidInfo.devName = "gpio_keypad";
+	inputDev = HidRegisterHdfInputDev(&hidInfo);
+
+	return inputDev;
+}
+
+static void gpio_keys_button_event(struct input_dev *input,
+					 const struct gpio_keys_button *button,
+					 int state)
+{
+	struct gpio_keypad_dev *bdev = input_get_drvdata(input);
+	unsigned int type = button->type ?: EV_KEY;
+
+	if (type == EV_REL) {
+		if (state) {
+			input_event(input, type, button->code, button->value);
+			__set_bit(button->code, bdev->rel_axis_seen);
+		}
+	} else if (type == EV_ABS) {
+		if (state) {
+			input_event(input, type, button->code, button->value);
+			__set_bit(button->code, bdev->abs_axis_seen);
+		}
+	} else {
+		input_event(input, type, button->code, state);
+		input_sync(input);
+	}
+}
+
+static void gpio_keypad_check_state(struct input_dev *input,
+					 const struct gpio_keys_button *button,
+					 struct gpio_keys_button_data *bdata)
+{
+	int state;
+
+	state = gpiod_get_value_cansleep(bdata->gpiod);
+	if (state < 0) {
+		dev_err(input->dev.parent,
+			"failed to get gpio state: %d\n", state);
+	} else {
+		gpio_keys_button_event(input, button, state);
+
+		if (state != bdata->last_state) {
+			bdata->count = 0;
+			bdata->last_state = state;
+
+#ifdef CONFIG_DRIVERS_HDF_INPUT
+			InputManager *inputManager = GetInputManager();
+			if ((g_hidInputDev == NULL) || (inputManager == NULL)) {
+				return ;
+			}
+
+			if (button->code == KEY_POWER) {
+				HidReportEvent(g_hidInputDev, EV_KEY, KEY_POWER, !state);
+				HidReportEvent(g_hidInputDev, EV_SYN, SYN_REPORT, 0);
+			}
+#endif
+		}
+	}
+}
+
+static void gpio_keypad_poll(struct input_dev *input)
+{
+	struct gpio_keypad_dev *bdev = input_get_drvdata(input);
+	const struct gpio_keys_platform_data *pdata = bdev->pdata;
+	int i;
+
+	memset(bdev->rel_axis_seen, 0, sizeof(bdev->rel_axis_seen));
+	memset(bdev->abs_axis_seen, 0, sizeof(bdev->abs_axis_seen));
+
+	for (i = 0; i < pdata->nbuttons; i++) {
+		struct gpio_keys_button_data *bdata = &bdev->data[i];
+
+		if (bdata->count < bdata->threshold) {
+			bdata->count++;
+			gpio_keys_button_event(input, &pdata->buttons[i],
+								 bdata->last_state);
+		} else {
+			gpio_keypad_check_state(input, &pdata->buttons[i],
+								 bdata);
+		}
+	}
+
+	for_each_set_bit(i, input->relbit, REL_CNT) {
+		if (!test_bit(i, bdev->rel_axis_seen))
+			input_event(input, EV_REL, i, 0);
+	}
+
+	for_each_set_bit(i, input->absbit, ABS_CNT) {
+		if (!test_bit(i, bdev->abs_axis_seen))
+			input_event(input, EV_ABS, i, 0);
+	}
+
+	input_sync(input);
+}
+
+static int gpio_keypad_open(struct input_dev *input)
+{
+	struct gpio_keypad_dev *bdev = input_get_drvdata(input);
+	const struct gpio_keys_platform_data *pdata = bdev->pdata;
+
+	if (pdata->enable)
+		pdata->enable(bdev->dev);
+
+	return 0;
+}
+
+static void gpio_keypad_close(struct input_dev *input)
+{
+	struct gpio_keypad_dev *bdev = input_get_drvdata(input);
+	const struct gpio_keys_platform_data *pdata = bdev->pdata;
+
+	if (pdata->disable)
+		pdata->disable(bdev->dev);
+}
+
+static struct gpio_keys_platform_data *
+gpio_keypad_get_devtree_pdata(struct device *dev)
+{
+	struct gpio_keys_platform_data *pdata;
+	struct gpio_keys_button *button;
+	struct fwnode_handle *child;
+	int nbuttons;
+
+	nbuttons = device_get_child_node_count(dev);
+	if (nbuttons == 0)
+		return ERR_PTR(-EINVAL);
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata) + nbuttons * sizeof(*button),
+					 GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	button = (struct gpio_keys_button *)(pdata + 1);
+
+	pdata->buttons = button;
+	pdata->nbuttons = nbuttons;
+
+	pdata->rep = device_property_present(dev, "autorepeat");
+	device_property_read_u32(dev, "poll-interval", &pdata->poll_interval);
+
+	device_property_read_string(dev, "label", &pdata->name);
+
+	device_for_each_child_node(dev, child) {
+		if (fwnode_property_read_u32(child, "linux,code",
+							 &button->code)) {
+			dev_err(dev, "button without keycode\n");
+			fwnode_handle_put(child);
+			return ERR_PTR(-EINVAL);
+		}
+
+		fwnode_property_read_string(child, "label", &button->desc);
+
+		if (fwnode_property_read_u32(child, "linux,input-type",
+							 &button->type))
+			button->type = EV_KEY;
+
+		if (fwnode_property_read_u32(child, "linux,input-value",
+							 (u32 *)&button->value))
+			button->value = 1;
+
+		button->wakeup =
+			fwnode_property_read_bool(child, "wakeup-source") ||
+			/* legacy name */
+			fwnode_property_read_bool(child, "gpio-key,wakeup");
+
+		if (fwnode_property_read_u32(child, "debounce-interval",
+							 &button->debounce_interval))
+			button->debounce_interval = 5;
+
+		button++;
+	}
+
+	return pdata;
+}
+
+static void gpio_keypad_set_abs_params(struct input_dev *input,
+	const struct gpio_keys_platform_data *pdata, unsigned int code)
+{
+	int i, min = 0, max = 0;
+
+	for (i = 0; i < pdata->nbuttons; i++) {
+		const struct gpio_keys_button *button = &pdata->buttons[i];
+
+		if (button->type != EV_ABS || button->code != code)
+			continue;
+
+		if (button->value < min)
+			min = button->value;
+		if (button->value > max)
+			max = button->value;
+	}
+
+	input_set_abs_params(input, code, min, max, 0, 0);
+}
+
+static const struct of_device_id gpio_keypad_of_match[] = {
+	{ .compatible = "amlogic, gpio_keypad", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, gpio_keypad_of_match);
+
+static int gpio_keypad_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fwnode_handle *child = NULL;
+	const struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);
+	struct gpio_keypad_dev *bdev;
+	struct input_dev *input;
+	int error;
+	int i;
+
+	if (!pdata) {
+		pdata = gpio_keypad_get_devtree_pdata(dev);
+		if (IS_ERR(pdata))
+			return PTR_ERR(pdata);
+	}
+
+	if (!pdata->poll_interval) {
+		dev_err(dev, "missing poll_interval value\n");
+		return -EINVAL;
+	}
+
+	bdev = devm_kzalloc(dev, struct_size(bdev, data, pdata->nbuttons),
+					GFP_KERNEL);
+	if (!bdev) {
+		dev_err(dev, "no memory for private data\n");
+		return -ENOMEM;
+	}
+
+	input = devm_input_allocate_device(dev);
+	if (!input) {
+		dev_err(dev, "no memory for input device\n");
+		return -ENOMEM;
+	}
+
+	input_set_drvdata(input, bdev);
+
+	input->name = "gpio_keypad";
+	input->phys = "gpio_keypad/input0";
+
+	input->id.bustype = BUS_HOST;
+	input->id.vendor = 0x0001;
+	input->id.product = 0x0001;
+	input->id.version = 0x0100;
+
+	input->open = gpio_keypad_open;
+	input->close = gpio_keypad_close;
+
+	__set_bit(EV_KEY, input->evbit);
+	if (pdata->rep)
+		__set_bit(EV_REP, input->evbit);
+
+	for (i = 0; i < pdata->nbuttons; i++) {
+		const struct gpio_keys_button *button = &pdata->buttons[i];
+		struct gpio_keys_button_data *bdata = &bdev->data[i];
+		unsigned int type = button->type ?: EV_KEY;
+
+		if (button->wakeup) {
+			dev_err(dev, DRV_NAME " does not support wakeup\n");
+			fwnode_handle_put(child);
+			return -EINVAL;
+		}
+
+		if (!dev_get_platdata(dev)) {
+			/* No legacy static platform data */
+			child = device_get_next_child_node(dev, child);
+			if (!child) {
+				dev_err(dev, "missing child device node\n");
+				return -EINVAL;
+			}
+
+			bdata->gpiod = devm_fwnode_gpiod_get(dev, child,
+									 NULL, GPIOD_IN,
+									 button->desc);
+			if (IS_ERR(bdata->gpiod)) {
+				error = PTR_ERR(bdata->gpiod);
+				if (error != -EPROBE_DEFER)
+					dev_err(dev,
+						"failed to get gpio: %d\n",
+						error);
+				fwnode_handle_put(child);
+				return error;
+			}
+		} else if (gpio_is_valid(button->gpio)) {
+			/*
+			 * Legacy GPIO number so request the GPIO here and
+			 * convert it to descriptor.
+			 */
+			unsigned flags = GPIOF_IN;
+
+			if (button->active_low)
+				flags |= GPIOF_ACTIVE_LOW;
+
+			error = devm_gpio_request_one(dev, button->gpio,
+					flags, button->desc ? : DRV_NAME);
+			if (error) {
+				dev_err(dev,
+					"unable to claim gpio %u, err=%d\n",
+					button->gpio, error);
+				return error;
+			}
+
+			bdata->gpiod = gpio_to_desc(button->gpio);
+			if (!bdata->gpiod) {
+				dev_err(dev,
+					"unable to convert gpio %u to descriptor\n",
+					button->gpio);
+				return -EINVAL;
+			}
+		}
+
+		bdata->last_state = -1;
+		bdata->threshold = DIV_ROUND_UP(button->debounce_interval,
+						pdata->poll_interval);
+
+		input_set_capability(input, type, button->code);
+		if (type == EV_ABS)
+			gpio_keypad_set_abs_params(input, pdata,
+							button->code);
+	}
+
+	fwnode_handle_put(child);
+
+	bdev->input = input;
+	bdev->dev = dev;
+	bdev->pdata = pdata;
+
+	error = input_setup_polling(input, gpio_keypad_poll);
+	if (error) {
+		dev_err(dev, "unable to set up polling, err=%d\n", error);
+		return error;
+	}
+
+	input_set_poll_interval(input, pdata->poll_interval);
+
+	error = input_register_device(input);
+	if (error) {
+		dev_err(dev, "unable to register polled device, err=%d\n",
+			error);
+		return error;
+	}
+
+	/* report initial state of the buttons */
+	for (i = 0; i < pdata->nbuttons; i++)
+		gpio_keypad_check_state(input, &pdata->buttons[i],
+							 &bdev->data[i]);
+
+	input_sync(input);
+
+#ifdef CONFIG_DRIVERS_HDF_INPUT
+	HidInfo *info = (HidInfo *)kmalloc(sizeof(HidInfo), GFP_KERNEL);
+	if (info == NULL) {
+		printk("%s: malloc failed\n",__func__);
+		return -EINVAL;
+	}
+
+	info->devName = input->name;
+	memcpy(info->devProp, input->propbit, sizeof(unsigned long) * BITS_TO_LONGS(INPUT_PROP_CNT));
+	memcpy(info->eventType, input->evbit, sizeof(unsigned long) * BITS_TO_LONGS(EV_CNT));
+	memcpy(info->keyCode, input->keybit, sizeof(unsigned long) * BITS_TO_LONGS(KEY_CNT));
+	memcpy(info->relCode, input->relbit, sizeof(unsigned long) * BITS_TO_LONGS(REL_CNT));
+	memcpy(info->absCode, input->absbit, sizeof(unsigned long) * BITS_TO_LONGS(ABS_CNT));
+	memcpy(info->miscCode, input->mscbit, sizeof(unsigned long) * BITS_TO_LONGS(MSC_CNT));
+	memcpy(info->ledCode, input->ledbit, sizeof(unsigned long) * BITS_TO_LONGS(LED_CNT));
+	memcpy(info->soundCode, input->sndbit, sizeof(unsigned long) * BITS_TO_LONGS(SND_CNT));
+	memcpy(info->forceCode, input->ffbit, sizeof(unsigned long) * BITS_TO_LONGS(FF_CNT));
+	memcpy(info->switchCode, input->swbit, sizeof(unsigned long) * BITS_TO_LONGS(SW_CNT));
+	for (i = 0; i < BITS_TO_LONGS(ABS_CNT); i++) {
+		if (input->absbit[i] != 0) {
+			memcpy(info->axisInfo, input->absinfo, sizeof(struct input_absinfo) * ABS_CNT);
+			break;
+		}
+	}
+
+	info->bustype = input->id.bustype;
+	info->vendor = input->id.vendor;
+	info->product = input->id.product;
+	info->version = input->id.version;
+	SendInfoToHdf(info);
+	kfree(info);
+	info = NULL;
+
+	g_hidInputDev = HidRegisterHdfKeyPadDev();
+	if (NULL == g_hidInputDev) {
+		pr_err("HidRegisterHdfKeyPadDev error\n");
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+static struct platform_driver gpio_keypad_driver = {
+	.probe	= gpio_keypad_probe,
+	.driver	= {
+		.name	= DRV_NAME,
+		.of_match_table = gpio_keypad_of_match,
+	},
+};
+module_platform_driver(gpio_keypad_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("AlgoIdeas <yu19881234@163.com>");
+MODULE_DESCRIPTION("GPIO KeyPad driver");
+MODULE_ALIAS("platform:" DRV_NAME);
diff -Naur a/vendor/amlogic/input/keyboard/Kconfig b/vendor/amlogic/input/keyboard/Kconfig
--- a/vendor/amlogic/input/keyboard/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/input/keyboard/Kconfig	2022-01-25 04:25:14.000000000 +0800
@@ -0,0 +1,27 @@
+#
+# Kyeboard device configuration
+#
+
+menuconfig AMLOGIC_INPUT_KEYBOARD
+	bool "Keyboards and keypads"
+	default n
+	help
+	  Say Y here, and a list of supported keyboards and keypads will be displayed.
+	  This option doesn't affect the kernel.
+
+	  If unsure, say Y.
+
+config AMLOGIC_ADC_KEYPADS
+	tristate "Meson ADC keypad support"
+	depends on AMLOGIC_INPUT_KEYBOARD
+	depends on MESON_SARADC
+	default n
+	help
+	  Say Y here if you want to use the Meson ADC keypad.
+
+config AMLOGIC_GPIO_KEY
+        tristate "Amlogic gpio key device surport"
+        depends on AMLOGIC_INPUT_KEYBOARD
+	default n
+        help
+          Say Y here if you want to use the amlogic hold key.
diff -Naur a/vendor/amlogic/input/keyboard/Makefile b/vendor/amlogic/input/keyboard/Makefile
--- a/vendor/amlogic/input/keyboard/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/input/keyboard/Makefile	2022-06-30 16:25:40.030803814 +0800
@@ -0,0 +1,24 @@
+#
+# Makefile for the keyboard device drivers.
+# Support OpenHammony HDF Input
+#
+
+# Each configuration option enables a list of files.
+
+ifeq ($(CONFIG_DRIVERS_HDF_INPUT), y)
+HDF_ROOT_DIR = -I$(srctree)/drivers/hdf
+ccflags-$(CONFIG_DRIVERS_HDF_INPUT) += $(HDF_ROOT_DIR)/framework/model/input/driver \
+             $(HDF_ROOT_DIR)/framework/include/core \
+             $(HDF_ROOT_DIR)/framework/core/common/include/host \
+             $(HDF_ROOT_DIR)/framework/include/utils \
+             $(HDF_ROOT_DIR)/framework/include/osal \
+             $(HDF_ROOT_DIR)/inner_api/utils \
+             $(HDF_ROOT_DIR)/inner_api/osal/shared \
+             $(HDF_ROOT_DIR)/inner_api/core \
+             $(HDF_ROOT_DIR)/inner_api/host/shared \
+             $(HDF_ROOT_DIR)/framework/ability/sbuf/include \
+             $(HDF_ROOT_DIR)/khdf/osal/include \
+             $(HDF_ROOT_DIR)/evdev
+endif
+
+obj-y	+= gpio_keypad.o
diff -Naur a/vendor/amlogic/input/Makefile b/vendor/amlogic/input/Makefile
--- a/vendor/amlogic/input/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/input/Makefile	2022-05-18 15:00:36.550000000 +0800
@@ -0,0 +1,8 @@
+#
+# Makefile for the amlogic input  driver.
+#
+
+#Each configuration option enables a list of files.
+
+obj-y += keyboard/
+
diff -Naur a/vendor/amlogic/iomap/iomap.c b/vendor/amlogic/iomap/iomap.c
--- a/vendor/amlogic/iomap/iomap.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/iomap/iomap.c	2022-06-24 14:37:49.996000883 +0800
@@ -0,0 +1,328 @@
+/*
+ * vendor/amlogic/iomap/iomap.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/regmap.h>
+#include <linux/device.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/iomap.h>
+#include <asm/compiler.h>
+#undef pr_fmt
+#define pr_fmt(fmt) "aml_iomap: " fmt
+
+
+static const struct of_device_id iomap_dt_match[] = {
+	{ .compatible = "amlogic, iomap" },
+	{ /* sentinel */ },
+};
+
+static void __iomem *meson_reg_map[IO_BUS_MAX] = { NULL };
+static uint meson_reg_max[IO_BUS_MAX] = { 0 };
+void __iomem *vpp_base;
+unsigned int vpp_max;
+
+inline int aml_reg_read(u32 bus_type, unsigned int reg, unsigned int *val)
+{
+	if (
+		bus_type < IO_BUS_MAX &&
+		(meson_reg_map[bus_type]) &&
+		(meson_reg_max[bus_type] >= reg)) {
+		*val = readl((meson_reg_map[bus_type]+reg));
+		return 0;
+	} else
+		return -1;
+}
+EXPORT_SYMBOL(aml_reg_read);
+
+inline int aml_reg_write(u32 bus_type, unsigned int reg, unsigned int val)
+{
+	if (
+		bus_type < IO_BUS_MAX &&
+		(meson_reg_map[bus_type]) &&
+		(meson_reg_max[bus_type] >= reg)) {
+		writel(val, (meson_reg_map[bus_type]+reg));
+		return 0;
+	} else
+		return -1;
+}
+EXPORT_SYMBOL(aml_reg_write);
+
+int aml_regmap_update_bits(u32 bus_type,
+					unsigned int reg, unsigned int mask,
+					unsigned int val)
+{
+	int ret = 0;
+	unsigned int tmp, orig;
+
+	ret = aml_reg_read(bus_type, reg, &orig);
+	if (ret) {
+		pr_err("read bus reg %x error %d\n", reg, ret);
+		return ret;
+	}
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	ret = aml_reg_write(bus_type, reg, tmp);
+	if (ret)
+		pr_err("write bus reg %x error %d\n", reg, ret);
+	return ret;
+}
+EXPORT_SYMBOL(aml_regmap_update_bits);
+
+/*
+ * CBUS REG Read Write and Update some bits
+ */
+int aml_read_cbus(unsigned int reg)
+{
+	int ret, val;
+
+	ret = aml_reg_read(IO_CBUS_BASE, reg<<2, &val);
+	if (ret) {
+		pr_err("read cbus reg %x error %d\n", reg, ret);
+		return -1;
+	} else
+		return val;
+}
+EXPORT_SYMBOL(aml_read_cbus);
+
+void aml_write_cbus(unsigned int reg, unsigned int val)
+{
+	int ret;
+
+	ret = aml_reg_write(IO_CBUS_BASE, reg<<2, val);
+	if (ret)
+		pr_err("write cbus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_write_cbus);
+
+void aml_cbus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	int ret;
+
+	ret = aml_regmap_update_bits(IO_CBUS_BASE, reg<<2, mask, val);
+	if (ret)
+		pr_err("write cbus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_cbus_update_bits);
+
+/*
+ * AO REG Read Write and Update some bits
+ */
+int aml_read_aobus(unsigned int reg)
+{
+	int ret, val;
+
+	ret = aml_reg_read(IO_AOBUS_BASE, reg, &val);
+	if (ret) {
+		pr_err("read ao bus reg %x error %d\n", reg, ret);
+		return -1;
+	} else
+		return val;
+}
+EXPORT_SYMBOL(aml_read_aobus);
+
+void aml_write_aobus(unsigned int reg, unsigned int val)
+{
+	int ret;
+
+	ret = aml_reg_write(IO_AOBUS_BASE, reg, val);
+	if (ret)
+		pr_err("write ao bus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_write_aobus);
+
+void aml_aobus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	int ret;
+
+	ret = aml_regmap_update_bits(IO_AOBUS_BASE, reg, mask, val);
+	if (ret)
+		pr_err("write aobus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_aobus_update_bits);
+
+
+/*
+ ** VCBUS Bus REG Read Write and Update some bits
+ */
+int aml_read_vcbus(unsigned int reg)
+{
+	int ret, val;
+
+	ret = aml_reg_read(IO_VAPB_BUS_BASE, reg<<2, &val);
+
+	if (ret) {
+		pr_err("read vcbus reg %x error %d\n", reg, ret);
+		return -1;
+	} else
+		return val;
+}
+EXPORT_SYMBOL(aml_read_vcbus);
+
+
+void aml_write_vcbus(unsigned int reg, unsigned int val)
+{
+	int ret;
+
+	ret = aml_reg_write(IO_VAPB_BUS_BASE, reg<<2, val);
+
+	if (ret)
+		pr_err("write vcbus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_write_vcbus);
+
+void aml_vcbus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	int ret;
+
+	ret = aml_regmap_update_bits(IO_VAPB_BUS_BASE,
+			reg<<2, mask, val);
+	if (ret)
+		pr_err("write vcbus reg %x error %d\n", reg, ret);
+
+}
+EXPORT_SYMBOL(aml_vcbus_update_bits);
+
+
+/*
+ ** DOS BUS Bus REG Read Write and Update some bits
+ */
+int aml_read_dosbus(unsigned int reg)
+{
+	int ret, val;
+
+	ret = aml_reg_read(IO_APB_BUS_BASE, reg<<2, &val);
+	if (ret) {
+		pr_err("read vcbus reg %x error %d\n", reg, ret);
+		return -1;
+	} else
+		return val;
+}
+EXPORT_SYMBOL(aml_read_dosbus);
+
+void aml_write_dosbus(unsigned int reg, unsigned int val)
+{
+	int ret;
+
+	ret = aml_reg_write(IO_APB_BUS_BASE, reg<<2, val);
+	if (ret)
+		pr_err("write vcbus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_write_dosbus);
+
+void aml_dosbus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	int ret;
+
+	ret = aml_regmap_update_bits(IO_APB_BUS_BASE, reg<<2, mask, val);
+	if (ret)
+		pr_err("write vcbus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_dosbus_update_bits);
+
+/*
+ * HIUBUS REG Read Write and Update some bits
+ */
+int aml_read_hiubus(unsigned int reg)
+{
+	int ret, val;
+
+	ret = aml_reg_read(IO_HIUBUS_BASE, reg<<2, &val);
+	if (ret) {
+		pr_err("read cbus reg %x error %d\n", reg, ret);
+		return -1;
+	} else
+		return val;
+}
+EXPORT_SYMBOL(aml_read_hiubus);
+
+void aml_write_hiubus(unsigned int reg, unsigned int val)
+{
+	int ret;
+
+	ret = aml_reg_write(IO_HIUBUS_BASE, reg<<2, val);
+	if (ret)
+		pr_err("write cbus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_write_hiubus);
+
+void aml_hiubus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	int ret;
+
+	ret = aml_regmap_update_bits(IO_HIUBUS_BASE, reg<<2, mask, val);
+	if (ret)
+		pr_err("write cbus reg %x error %d\n", reg, ret);
+}
+EXPORT_SYMBOL(aml_hiubus_update_bits);
+
+static int iomap_probe(struct platform_device *pdev)
+{
+	int i = 0;
+/* void __iomem *base; */
+	struct resource res;
+	struct device_node *np, *child;
+
+	np = pdev->dev.of_node;
+
+	for_each_child_of_node(np, child) {
+		if (of_address_to_resource(child, 0, &res))
+			return -1;
+		meson_reg_map[i] = ioremap(res.start, resource_size(&res));
+		meson_reg_max[i] = res.end  - res.start;
+		i++;
+	}
+	if (i > IO_VAPB_BUS_BASE) {
+		vpp_base = meson_reg_map[IO_VAPB_BUS_BASE];
+		vpp_max = meson_reg_max[IO_VAPB_BUS_BASE];
+	}
+	pr_info("amlogic iomap probe done\n");
+	return 0;
+}
+
+
+
+static  struct platform_driver iomap_platform_driver = {
+	.probe		= iomap_probe,
+	.driver		= {
+		.owner		= THIS_MODULE,
+		.name		= "iomap_version",
+		.of_match_table	= iomap_dt_match,
+	},
+};
+
+int __init meson_iomap_version_init(void)
+{
+
+	int ret;
+
+	ret = platform_driver_register(&iomap_platform_driver);
+
+	return ret;
+}
+core_initcall(meson_iomap_version_init);
diff -Naur a/vendor/amlogic/iomap/Kconfig b/vendor/amlogic/iomap/Kconfig
--- a/vendor/amlogic/iomap/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/iomap/Kconfig	2022-05-31 11:56:47.713259502 +0800
@@ -0,0 +1,7 @@
+# Amlogic iomap driver
+#
+config AMLOGIC_IOMAP
+    bool "Amlogic iomap support"
+    select REGMAP_MMIO
+    help
+      This is the Amlogic Iomap  driver
diff -Naur a/vendor/amlogic/iomap/Makefile b/vendor/amlogic/iomap/Makefile
--- a/vendor/amlogic/iomap/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/iomap/Makefile	2022-05-31 11:56:47.713259502 +0800
@@ -0,0 +1 @@
+obj-y	+=iomap.o
diff -Naur a/vendor/amlogic/Kconfig b/vendor/amlogic/Kconfig
--- a/vendor/amlogic/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/Kconfig	2022-07-04 10:15:10.802006361 +0800
@@ -0,0 +1,38 @@
+#
+# Amlogic driver configuration
+#
+config AMLOGIC_DRIVER
+	bool "Amlogic Peripheral drivers"
+	default n
+	help
+		this option is provided for control amlogic
+		drivers, if you want to use amlogic driver
+		please open it
+
+config AMLOGIC_MODIFY
+	bool "Amlogic modify for kernel code"
+	default n
+	help
+		this option is set up for AMLOGIC modify of
+		standard kernel source code. All modify of kernel
+		standard code should be wrapped by this config
+
+if AMLOGIC_DRIVER
+menu "Amlogic Device Drivers"
+source "vendor/amlogic/battery/Kconfig"
+source "vendor/amlogic/codecs/Kconfig"
+source "vendor/amlogic/wifi/Kconfig"
+source "vendor/amlogic/unifykey/Kconfig"
+source "vendor/amlogic/iomap/Kconfig"
+source "vendor/amlogic/pm/Kconfig"
+source "vendor/amlogic/secmon/Kconfig"
+source "vendor/amlogic/reboot/Kconfig"
+source "vendor/amlogic/cpu_version/Kconfig"
+source "vendor/amlogic/media/Kconfig"
+source "vendor/amlogic/ge2d/Kconfig"
+source "vendor/amlogic/canvas/Kconfig"
+source "vendor/amlogic/media/common/codec_mm/Kconfig"
+source "vendor/amlogic/input/Kconfig"
+source "vendor/amlogic/wifi/Kconfig"
+endmenu
+endif
diff -Naur a/vendor/amlogic/make-boot.sh b/vendor/amlogic/make-boot.sh
--- a/vendor/amlogic/make-boot.sh	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/make-boot.sh	2022-06-30 16:01:00.580474631 +0800
@@ -0,0 +1,32 @@
+#!/bin/bash
+#
+# Copyright (c) 2022 Unionman Technology Co., Ltd.
+#
+# This software is licensed under the terms of the GNU General Public
+# License version 2, as published by the Free Software Foundation, and
+# may be copied, distributed, and modified under those terms.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+#
+
+set -e
+
+BOOT_LINUX=${1}/kernel/src_tmp/linux-5.10
+OUT_IMAGE=${1}/unionpi_tiger/packages/phone/images
+MKBOOT_IMG=${1}/../device/board/unionman/unionpi_tiger/common/tools/linux/mkbootimg
+
+function make_boot_image()
+{
+	${MKBOOT_IMG} --kernel ${BOOT_LINUX}/arch/arm64/boot/Image.gz --base 0x0 --kernel_offset 0x1080000 --cmdline "" --ramdisk  ${OUT_IMAGE}/ramdisk.img --second ${OUT_IMAGE}/dtb.img --output ${OUT_IMAGE}/boot.img > /dev/null
+
+	mkdir -p ${BOOT_LINUX}/unionpi_tiger
+	cp ${BOOT_LINUX}/arch/arm64/boot/Image.gz ${BOOT_LINUX}/unionpi_tiger
+
+	return $?
+}
+
+make_boot_image
diff -Naur a/vendor/amlogic/Makefile b/vendor/amlogic/Makefile
--- a/vendor/amlogic/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/Makefile	2022-07-04 10:16:21.050763386 +0800
@@ -0,0 +1,18 @@
+##########################################
+########## Amlogic Drivers ###############
+##########################################
+obj-$(CONFIG_AMLOGIC_BATTERY)         += battery/
+obj-$(CONFIG_AMLOGIC_BLUETOOTH)       += bluetooth/
+obj-$(CONFIG_AMLOGIC_MEDIA_CANVAS)    += canvas/
+obj-$(CONFIG_SND_SOC)                 += codecs/
+obj-$(CONFIG_AMLOGIC_REBOOT)          += reboot/
+obj-$(CONFIG_AMLOGIC_SEC)             += secmon/
+obj-$(CONFIG_AMLOGIC_EFUSE_UNIFYKEY)  += unifykey/
+obj-$(CONFIG_MMC_MESON_GX)            += mmc/
+obj-$(CONFIG_AMLOGIC_IOMAP)           += iomap/
+obj-$(CONFIG_AMLOGIC_CPU_VERSION)     += cpu_version/
+obj-$(CONFIG_AMLOGIC_MEDIA)           += media/
+obj-$(CONFIG_AMLOGIC_MEDIA_GE2D)      += ge2d/
+obj-$(CONFIG_AMLOGIC_INPUT)           += input/
+obj-$(CONFIG_AMLOGIC_WIFI)            += wifi/
+obj-$(CONFIG_MESON_GX_PM)             += pm/
\ No newline at end of file
diff -Naur a/vendor/amlogic/media/common/codec_mm/codec_mm.c b/vendor/amlogic/media/common/codec_mm/codec_mm.c
--- a/vendor/amlogic/media/common/codec_mm/codec_mm.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/codec_mm.c	2022-06-24 14:37:50.106498487 +0800
@@ -0,0 +1,2628 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/codec_mm.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/cma.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/libfdt_env.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/genalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-map-ops.h>
+#include <linux/delay.h>
+
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/codec_mm_scatter.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
+//#include <linux/amlogic/media/video_sink/video_keeper.h>
+//#include <linux/amlogic/media/utils/vdec_reg.h>
+
+#include "codec_mm_priv.h"
+#include "codec_mm_scatter_priv.h"
+#include "codec_mm_keeper_priv.h"
+#include <linux/highmem.h>
+#include <linux/page-flags.h>
+#include <linux/vmalloc.h>
+#ifdef CONFIG_AMLOGIC_TEE
+#include <linux/amlogic/tee.h>
+#endif
+
+#define TVP_POOL_NAME "TVP_POOL"
+#define CMA_RES_POOL_NAME "CMA_RES"
+
+#define CONFIG_PATH "media.codec_mm"
+#define CONFIG_PREFIX "media"
+
+#define MM_ALIGN_DOWN(addr, size)  ((addr) & (~((size) - 1)))
+#define MM_ALIGN_UP2N(addr, alg2n) ((addr+(1<<alg2n)-1)&(~((1<<alg2n)-1)))
+
+#define RES_IS_MAPED
+#define DEFAULT_TVP_SIZE_FOR_4K (236 * SZ_1M)
+#define DEFAULT_TVP_SIZE_FOR_NO4K (160 * SZ_1M)
+
+#define ALLOC_MAX_RETRY 1
+
+#define CODEC_MM_FOR_DMA_ONLY(flags) \
+	((flags & CODEC_MM_FLAGS_FROM_MASK) == CODEC_MM_FLAGS_DMA)
+
+#define CODEC_MM_FOR_CPU_ONLY(flags) \
+	((flags & CODEC_MM_FLAGS_FROM_MASK) == CODEC_MM_FLAGS_CPU)
+
+#define CODEC_MM_FOR_DMACPU(flags) \
+	((flags & CODEC_MM_FLAGS_FROM_MASK) == CODEC_MM_FLAGS_DMA_CPU)
+
+#define RESERVE_MM_ALIGNED_2N	17
+
+#define RES_MEM_FLAGS_HAVE_MAPED 0x4
+static int dump_mem_infos(void *buf, int size);
+static int dump_free_mem_infos(void *buf, int size);
+
+#if 1
+int cma_mmu_op(struct page *page, int count, bool set)
+{
+	pgd_t *pgd;
+	pud_t *pud;
+	pmd_t *pmd;
+	pte_t *pte;
+	unsigned long addr, end;
+	struct mm_struct *mm;
+
+	if (!page || PageHighMem(page))
+		return -EINVAL;
+
+	addr = (unsigned long)page_address(page);
+	end  = addr + count * PAGE_SIZE;
+	mm = &init_mm;
+	for (; addr < end; addr += PAGE_SIZE) {
+		pgd = pgd_offset(mm, addr);
+		if (pgd_none(*pgd) || pgd_bad(*pgd))
+			break;
+
+		pud = pud_offset((p4d_t*)pgd, addr);
+		if (pud_none(*pud) || pud_bad(*pud))
+			break;
+
+		pmd = pmd_offset(pud, addr);
+		if (pmd_none(*pmd))
+			break;
+
+		pte = pte_offset_map(pmd, addr);
+		if (set)
+			set_pte_at(mm, addr, pte, mk_pte(page, PAGE_KERNEL));
+		else
+			pte_clear(mm, addr, pte);
+		pte_unmap(pte);
+	#ifdef CONFIG_ARM
+		pr_debug("%s, add:%lx, pgd:%p %x, pmd:%p %x, pte:%p %x\n",
+			__func__, addr, pgd, (int)pgd_val(*pgd),
+			pmd, (int)pmd_val(*pmd), pte, (int)pte_val(*pte));
+	#elif defined(CONFIG_ARM64)
+		pr_debug("%s, add:%lx, pgd:%p %llx, pmd:%p %llx, pte:%p %llx\n",
+			__func__, addr, pgd, pgd_val(*pgd),
+			pmd, pmd_val(*pmd), pte, pte_val(*pte));
+	#endif
+		page++;
+	}
+	return 0;
+}
+#endif
+
+/*
+ *debug_mode:
+ *
+ *disable reserved:1
+ *disable cma:2
+ *disable sys memory:4
+ *disable half memory:8,
+ *	only used half memory,for debug.
+ *	return nomem,if alloced > total/2;
+ *dump memory info on failed:0x10,
+ *trace memory alloc/free info:0x20,
+ */
+static u32 debug_mode;
+
+static u32 debug_sc_mode;
+u32 codec_mm_get_sc_debug_mode(void)
+{
+	return debug_sc_mode;
+}
+EXPORT_SYMBOL(codec_mm_get_sc_debug_mode);
+
+static u32 debug_keep_mode;
+u32 codec_mm_get_keep_debug_mode(void)
+{
+	return debug_keep_mode;
+}
+EXPORT_SYMBOL(codec_mm_get_keep_debug_mode);
+
+static int default_tvp_size;
+static int default_tvp_4k_size;
+static int default_cma_res_size;
+
+#define TVP_MAX_SLOT 8
+/*
+ *tvp_mode == 0 means protect secure memory in secmem ta
+ *tvp_mode == 1 means use protect secure memory in codec_mm
+ */
+static u32 tvp_mode;
+
+struct extpool_mgt_s {
+	struct gen_pool *gen_pool[TVP_MAX_SLOT];
+	struct codec_mm_s *mm[TVP_MAX_SLOT];
+	int slot_num;
+	int alloced_size;
+	int total_size;
+	struct mutex pool_lock;
+};
+
+struct codec_mm_mgt_s {
+	struct cma *cma;
+	struct device *dev;
+	struct list_head mem_list;
+	struct gen_pool *res_pool;
+	struct extpool_mgt_s tvp_pool;
+	struct extpool_mgt_s cma_res_pool;
+	struct reserved_mem rmem;
+	int total_codec_mem_size;
+	int total_alloced_size;
+	int total_cma_size;
+	int total_reserved_size;
+	int max_used_mem_size;
+
+	int alloced_res_size;
+	int alloced_cma_size;
+	int alloced_sys_size;
+	int alloced_for_sc_size;
+	int alloced_for_sc_cnt;
+	int alloced_from_coherent;
+	int phys_vmaped_page_cnt;
+
+	int alloc_from_sys_pages_max;
+	int enable_kmalloc_on_nomem;
+	int res_mem_flags;
+	int global_memid;
+	/*1:for 1080p,2:for 4k*/
+	int tvp_enable;
+	/*1:for 1080p,2:for 4k */
+	int fastplay_enable;
+	spinlock_t lock;
+	atomic_t tvp_user_count;
+	/* for tvp operator used */
+	struct mutex tvp_protect_lock;
+};
+
+#define PHY_OFF() offsetof(struct codec_mm_s, phy_addr)
+#define HANDLE_OFF() offsetof(struct codec_mm_s, mem_handle)
+#define VADDR_OFF() offsetof(struct codec_mm_s, vbuffer)
+#define VAL_OFF_VAL(mem, off) (*(unsigned long *)((unsigned long)(mem) + off))
+
+#ifndef CONFIG_AMLOGIC_TEE
+uint32_t tee_protect_tvp_mem(uint32_t start, uint32_t size,
+			uint32_t *handle)
+{
+	return 0xFFFFFFFF;
+}
+
+void tee_unprotect_tvp_mem(uint32_t handle)
+{
+}
+#endif
+
+static int codec_mm_extpool_pool_release(struct extpool_mgt_s *tvp_pool);
+
+static struct codec_mm_mgt_s *get_mem_mgt(void)
+{
+	int ret = 0;
+	int handle = 0;
+	static struct codec_mm_mgt_s mgt;
+	static int inited;
+
+	if (!inited) {
+		memset(&mgt, 0, sizeof(struct codec_mm_mgt_s));
+		/*If tee_protect_tvp_mem is not implement
+		 *will return 0xFFFFFFF we used to init use
+		 *which mode
+		 */
+		ret = tee_protect_tvp_mem(0, 0, &handle);
+		if (ret == 0xFFFFFFFF)
+			tvp_mode = 0;
+		else
+			tvp_mode = 1;
+		mutex_init(&mgt.tvp_protect_lock);
+		inited++;
+	}
+	return &mgt;
+};
+
+
+static void *codec_mm_extpool_alloc(
+	struct extpool_mgt_s *tvp_pool,
+	void **from_pool, int size)
+{
+	int i = 0;
+	void *handle = NULL;
+
+	for (i = 0; i < tvp_pool->slot_num; i++) {
+		if (!tvp_pool->gen_pool[i])
+			return NULL;
+		handle = (void *)gen_pool_alloc(
+				tvp_pool->gen_pool[i],
+				size);
+		if (handle) {
+			*from_pool = tvp_pool->gen_pool[i];
+			return handle;
+		}
+	}
+	return NULL;
+}
+
+static void *codec_mm_extpool_free(struct gen_pool *from_pool,
+	void *handle, int size)
+{
+	gen_pool_free(from_pool,
+			(unsigned long)handle, size);
+	return 0;
+}
+
+
+static int codec_mm_valid_mm_locked(struct codec_mm_s *mmhandle)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem;
+	int have_found = 0;
+
+	if (!list_empty(&mgt->mem_list)) {
+		list_for_each_entry(mem, &mgt->mem_list, list) {
+			if (mem == mmhandle) {
+				have_found =  1;
+				break;
+			}
+		}
+	}
+	return have_found;
+}
+
+
+/*
+ *have_space:
+ *1:	can alloced from reserved
+ *2:	can alloced from cma
+ *4:  can alloced from sys.
+ *8:  can alloced from tvp.
+ *
+ *flags:
+ *	is tvp = (flags & 1)
+ */
+static int codec_mm_alloc_pre_check_in(
+	struct codec_mm_mgt_s *mgt, int need_size, int flags)
+{
+	int have_space = 0;
+	int aligned_size = PAGE_ALIGN(need_size);
+
+	if (aligned_size <= mgt->total_reserved_size - mgt->alloced_res_size)
+		have_space |= 1;
+	if (aligned_size <= mgt->cma_res_pool.total_size -
+		mgt->cma_res_pool.alloced_size)
+		have_space |= 1;
+
+	if (aligned_size <= mgt->total_cma_size - mgt->alloced_cma_size)
+		have_space |= 2;
+
+	if (aligned_size / PAGE_SIZE <= mgt->alloc_from_sys_pages_max)
+		have_space |= 4;
+	if (aligned_size <= mgt->tvp_pool.total_size -
+		mgt->tvp_pool.alloced_size)
+		have_space |= 8;
+
+	if (flags & 1)
+		have_space = have_space & 8;
+
+	if (debug_mode & 0xf) {
+		have_space = have_space & (~(debug_mode & 1));
+		have_space = have_space & (~(debug_mode & 2));
+		have_space = have_space & (~(debug_mode & 4));
+		if (debug_mode & 8) {
+			if (mgt->total_alloced_size >
+				mgt->total_codec_mem_size / 2) {
+				pr_info("codec mm memory is limited by %d, (bit8 enable)\n",
+					debug_mode);
+				have_space = 0;
+			}
+		}
+	}
+
+	return have_space;
+}
+
+static ulong codec_mm_search_phy_addr(char *vaddr)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem = NULL;
+	ulong phy_addr = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mgt->lock, flags);
+
+	list_for_each_entry(mem, &mgt->mem_list, list) {
+		if (vaddr - mem->vbuffer >= 0 &&
+			vaddr - mem->vbuffer < mem->buffer_size) {
+
+			if (mem->phy_addr)
+				phy_addr = mem->phy_addr +
+					(vaddr - mem->vbuffer);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&mgt->lock, flags);
+
+	return phy_addr;
+}
+
+static void *codec_mm_search_vaddr(unsigned long phy_addr)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem = NULL;
+	void *vaddr = NULL;
+	unsigned long flags;
+
+	if (!PageHighMem(phys_to_page(phy_addr)))
+		return phys_to_virt(phy_addr);
+
+	spin_lock_irqsave(&mgt->lock, flags);
+
+	list_for_each_entry(mem, &mgt->mem_list, list) {
+		if (phy_addr >= mem->phy_addr &&
+			phy_addr < mem->phy_addr + mem->buffer_size) {
+
+			if (mem->vbuffer)
+				vaddr = mem->vbuffer +
+					(phy_addr - mem->phy_addr);
+			break;
+		}
+	}
+
+	spin_unlock_irqrestore(&mgt->lock, flags);
+
+	return vaddr;
+}
+
+u8 *codec_mm_vmap(ulong addr, u32 size)
+{
+	u8 *vaddr = NULL;
+	struct page **pages = NULL;
+	u32 i, npages, offset = 0;
+	ulong phys, page_start;
+	pgprot_t pgprot = PAGE_KERNEL;
+
+	if (!PageHighMem(phys_to_page(addr)))
+		return phys_to_virt(addr);
+
+	offset = offset_in_page(addr);
+	page_start = addr - offset;
+	npages = DIV_ROUND_UP(size + offset, PAGE_SIZE);
+
+	pages = kmalloc_array(npages, sizeof(struct page *), GFP_KERNEL);
+	if (!pages)
+		return NULL;
+
+	for (i = 0; i < npages; i++) {
+		phys = page_start + i * PAGE_SIZE;
+		pages[i] = pfn_to_page(phys >> PAGE_SHIFT);
+	}
+
+	vaddr = vmap(pages, npages, VM_MAP, pgprot);
+	if (!vaddr) {
+		pr_err("the phy(%lx) vmaped fail, size: %d\n",
+			page_start, npages << PAGE_SHIFT);
+		kfree(pages);
+		return NULL;
+	}
+
+	kfree(pages);
+
+	if (debug_mode & 0x20) {
+		pr_info("[HIGH-MEM-MAP] %s, pa(%lx) to va(%p), size: %d\n",
+			__func__, page_start, vaddr, npages << PAGE_SHIFT);
+	}
+
+	return vaddr + offset;
+}
+EXPORT_SYMBOL(codec_mm_vmap);
+
+void codec_mm_unmap_phyaddr(u8 *vaddr)
+{
+	void *addr = (void *)(PAGE_MASK & (ulong)vaddr);
+
+	if (is_vmalloc_or_module_addr(vaddr))
+		vunmap(addr);
+}
+EXPORT_SYMBOL(codec_mm_unmap_phyaddr);
+
+static void *codec_mm_map_phyaddr(struct codec_mm_s *mem)
+{
+	void *vaddr = NULL;
+	unsigned int phys = mem->phy_addr;
+	unsigned int size = mem->buffer_size;
+
+	if (!PageHighMem(phys_to_page(phys)))
+		return phys_to_virt(phys);
+
+	vaddr = codec_mm_vmap(phys, size);
+	/*vaddr = ioremap(phy_addr, size);*/
+
+	mem->flags |= CODEC_MM_FLAGS_FOR_PHYS_VMAPED;
+
+	return vaddr;
+}
+
+static int codec_mm_alloc_in(
+	struct codec_mm_mgt_s *mgt, struct codec_mm_s *mem)
+{
+	int try_alloced_from_sys = 0;
+	int try_alloced_from_reserved = 0;
+	int align_2n = mem->align2n < PAGE_SHIFT ? PAGE_SHIFT : mem->align2n;
+	int try_cma_first = mem->flags & CODEC_MM_FLAGS_CMA_FIRST;
+	int max_retry = ALLOC_MAX_RETRY;
+	int have_space;
+	int alloc_trace_mask = 0;
+
+	int can_from_res = (((mgt->res_pool != NULL) ||
+		(mgt->cma_res_pool.total_size > 0)) &&	/*have res */
+		!(mem->flags & CODEC_MM_FLAGS_CMA)) ||	/*must not CMA */
+		((mem->flags & CODEC_MM_FLAGS_RESERVED) ||/*need RESERVED */
+		CODEC_MM_FOR_DMA_ONLY(mem->flags) ||	/*NO CPU */
+		((mem->flags & CODEC_MM_FLAGS_CPU) &&
+			(mgt->res_mem_flags & RES_MEM_FLAGS_HAVE_MAPED)));
+	 /*CPU*/
+	int can_from_cma = ((mgt->total_cma_size > 0) &&/*have cma */
+		!(mem->flags & CODEC_MM_FLAGS_RESERVED)) ||
+		(mem->flags & CODEC_MM_FLAGS_CMA);	/*can from CMA */
+	/*not always reserved. */
+
+	int can_from_sys = (mem->flags & CODEC_MM_FLAGS_DMA_CPU) &&
+		(mem->page_count <= mgt->alloc_from_sys_pages_max);
+
+	int can_from_tvp = (mem->flags & CODEC_MM_FLAGS_TVP);
+
+	if (can_from_tvp) {
+		can_from_sys = 0;
+		can_from_res = 0;
+		can_from_cma = 0;
+	}
+
+	have_space = codec_mm_alloc_pre_check_in(mgt, mem->buffer_size, 0);
+	if (!have_space)
+		return -10001;
+
+	can_from_res = can_from_res && (have_space & 1);
+	can_from_cma = can_from_cma && (have_space & 2);
+	can_from_sys = can_from_sys && (have_space & 4);
+	can_from_tvp = can_from_tvp && (have_space & 8);
+	if (!can_from_res && !can_from_cma &&
+		!can_from_sys && !can_from_tvp) {
+		if (debug_mode & 0x10)
+			pr_info("error, codec mm have space:%x\n",
+				have_space);
+		return -10002;
+	}
+
+	do {
+		if ((mem->flags & CODEC_MM_FLAGS_DMA_CPU) &&
+			mem->page_count <= mgt->alloc_from_sys_pages_max &&
+			align_2n <= PAGE_SHIFT) {
+			alloc_trace_mask |= 1 << 0;
+			mem->mem_handle = (void *)__get_free_pages(GFP_KERNEL,
+				get_order(mem->buffer_size));
+			mem->from_flags =
+				AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES;
+			if (mem->mem_handle) {
+				mem->vbuffer = mem->mem_handle;
+				mem->phy_addr = virt_to_phys(mem->mem_handle);
+				break;
+			}
+			try_alloced_from_sys = 1;
+		}
+		/*cma first. */
+		if (try_cma_first && can_from_cma) {
+			/*
+			 *normal cma.
+			 */
+			alloc_trace_mask |= 1 << 1;
+			mem->mem_handle = dma_alloc_from_contiguous(mgt->dev,
+					mem->page_count,
+					align_2n - PAGE_SHIFT, false);
+			mem->from_flags = AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA;
+			if (mem->mem_handle) {
+				mem->vbuffer = mem->mem_handle;
+				mem->phy_addr =
+				 page_to_phys((struct page *)mem->mem_handle);
+#ifdef CONFIG_ARM64
+				if (mem->flags & CODEC_MM_FLAGS_CMA_CLEAR) {
+					/*dma_clear_buffer((struct page *)*/
+					/*mem->vbuffer, mem->buffer_size);*/
+				}
+#endif
+				break;
+			}
+		}
+		/*reserved alloc..*/
+		if ((can_from_res && mgt->res_pool) &&
+			(align_2n <= RESERVE_MM_ALIGNED_2N)) {
+			int aligned_buffer_size = ALIGN(mem->buffer_size,
+				(1 << RESERVE_MM_ALIGNED_2N));
+			alloc_trace_mask |= 1 << 2;
+			mem->mem_handle = (void *)gen_pool_alloc(mgt->res_pool,
+							aligned_buffer_size);
+			mem->from_flags =
+				AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED;
+			if (mem->mem_handle) {
+				/*default is no maped */
+				mem->vbuffer = NULL;
+				mem->phy_addr = (unsigned long)mem->mem_handle;
+				mem->buffer_size = aligned_buffer_size;
+				break;
+			}
+			try_alloced_from_reserved = 1;
+		}
+		/*can_from_res is reserved.. */
+		if (can_from_res) {
+			if (mgt->cma_res_pool.total_size > 0 &&
+				(mgt->cma_res_pool.alloced_size +
+					mem->buffer_size) <
+				mgt->cma_res_pool.total_size) {
+				/*
+				 *from cma res first.
+				 */
+				int aligned_buffer_size =
+					ALIGN(mem->buffer_size,
+						(1 << RESERVE_MM_ALIGNED_2N));
+				alloc_trace_mask |= 1 << 3;
+				mem->mem_handle =
+					(void *)codec_mm_extpool_alloc(
+						&mgt->cma_res_pool,
+						&mem->from_ext,
+						aligned_buffer_size);
+				mem->from_flags =
+					AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES;
+				if (mem->mem_handle) {
+					/*no vaddr for TVP MEMORY */
+					mem->vbuffer = NULL;
+					mem->phy_addr =
+						(unsigned long)mem->mem_handle;
+					mem->buffer_size = aligned_buffer_size;
+					break;
+				}
+			}
+
+		}
+		if (can_from_cma) {
+			/*
+			 *normal cma.
+			 */
+			alloc_trace_mask |= 1 << 4;
+			mem->mem_handle = dma_alloc_from_contiguous(mgt->dev,
+					mem->page_count,
+					align_2n - PAGE_SHIFT, false);
+			mem->from_flags = AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA;
+			if (mem->mem_handle) {
+				mem->phy_addr =
+					page_to_phys((struct page *)
+						mem->mem_handle);
+
+				if (mem->flags & CODEC_MM_FLAGS_CPU)
+					mem->vbuffer =
+						codec_mm_map_phyaddr(mem);
+#ifdef CONFIG_ARM64
+				if (mem->flags & CODEC_MM_FLAGS_CMA_CLEAR) {
+					/*dma_clear_buffer((struct page *)*/
+					/*mem->vbuffer, mem->buffer_size);*/
+				}
+#endif
+				break;
+			}
+		}
+		if (can_from_tvp &&
+				align_2n <= RESERVE_MM_ALIGNED_2N) {
+			/* 64k,aligend */
+			int aligned_buffer_size = ALIGN(mem->buffer_size,
+					(1 << RESERVE_MM_ALIGNED_2N));
+			alloc_trace_mask |= 1 << 5;
+			mem->mem_handle = (void *)codec_mm_extpool_alloc(
+					&mgt->tvp_pool,
+					&mem->from_ext,
+					aligned_buffer_size);
+			mem->from_flags =
+				AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP;
+			if (mem->mem_handle) {
+				/*no vaddr for TVP MEMORY */
+				mem->vbuffer = NULL;
+				mem->phy_addr = (unsigned long)mem->mem_handle;
+				mem->buffer_size = aligned_buffer_size;
+				break;
+			}
+		}
+
+		if ((mem->flags & CODEC_MM_FLAGS_DMA_CPU) &&
+			mgt->enable_kmalloc_on_nomem &&
+			!try_alloced_from_sys) {
+			alloc_trace_mask |= 1 << 6;
+			mem->mem_handle = (void *)__get_free_pages(GFP_KERNEL,
+				get_order(mem->buffer_size));
+			mem->from_flags =
+				AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES;
+			if (mem->mem_handle) {
+				mem->vbuffer = mem->mem_handle;
+				mem->phy_addr =
+					virt_to_phys((void *)mem->mem_handle);
+				break;
+			}
+		}
+	} while (--max_retry > 0);
+	if (mem->mem_handle)
+		return 0;
+	else {
+		if (debug_mode & 0x10) {
+			pr_info("codec mm have space:%x\n",
+				have_space);
+			pr_info("canfrom: %d,%d,%d,%d\n",
+				can_from_tvp,
+				can_from_sys,
+				can_from_res,
+				can_from_cma);
+			pr_info("alloc flags:%d,align=%d,%d,pages:%d,s:%d\n",
+				mem->flags,
+				mem->align2n,
+				align_2n,
+				mem->page_count,
+				mem->buffer_size);
+			pr_info("try alloc mask:%x\n",
+				alloc_trace_mask);
+		}
+		return -10003;
+	}
+}
+
+static int codec_mm_tvp_pool_unprotect(struct extpool_mgt_s *tvp_pool)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	int ret = -1;
+	int i = 0;
+
+	if (mgt->tvp_pool.alloced_size <= 0) {
+		for (i = 0; i < tvp_pool->slot_num; i++) {
+			pr_info("unprotect tvp %d handle is %d\n",
+				i, tvp_pool->mm[i]->tvp_handle);
+			if (tvp_pool->mm[i]->tvp_handle > 0) {
+				tee_unprotect_tvp_mem(
+					tvp_pool->mm[i]->tvp_handle);
+				tvp_pool->mm[i]->tvp_handle = -1;
+			}
+		}
+		ret = 0;
+	}
+	return ret;
+}
+
+static void codec_mm_free_in(struct codec_mm_mgt_s *mgt,
+		struct codec_mm_s *mem)
+{
+	unsigned long flags;
+	if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA) {
+		if (mem->flags & CODEC_MM_FLAGS_FOR_PHYS_VMAPED)
+			codec_mm_unmap_phyaddr(mem->vbuffer);
+
+		dma_release_from_contiguous(mgt->dev,
+			mem->mem_handle, mem->page_count);
+	} else if (mem->from_flags ==
+		AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED) {
+		gen_pool_free(mgt->res_pool,
+			(unsigned long)mem->mem_handle, mem->buffer_size);
+	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP) {
+		codec_mm_extpool_free(
+			(struct gen_pool *)mem->from_ext,
+			mem->mem_handle,
+			mem->buffer_size);
+	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES) {
+		free_pages((unsigned long)mem->mem_handle,
+			get_order(mem->buffer_size));
+	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES) {
+		codec_mm_extpool_free(
+			(struct gen_pool *)mem->from_ext,
+			mem->mem_handle,
+			mem->buffer_size);
+	}
+	spin_lock_irqsave(&mgt->lock, flags);
+	if (!(mem->flags & CODEC_MM_FLAGS_FOR_LOCAL_MGR))
+		mgt->total_alloced_size -= mem->buffer_size;
+	if (mem->flags & CODEC_MM_FLAGS_FOR_SCATTER) {
+		mgt->alloced_for_sc_size -= mem->buffer_size;
+		mgt->alloced_for_sc_cnt--;
+	}
+
+	if (mem->flags & CODEC_MM_FLAGS_FOR_PHYS_VMAPED)
+		mgt->phys_vmaped_page_cnt -= mem->page_count;
+
+	if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA) {
+		mgt->alloced_cma_size -= mem->buffer_size;
+	} else if (mem->from_flags ==
+		AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED) {
+		mgt->alloced_res_size -= mem->buffer_size;
+	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP) {
+		mgt->tvp_pool.alloced_size -= mem->buffer_size;
+	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES) {
+		mgt->alloced_sys_size -= mem->buffer_size;
+	} else if (mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES) {
+		mgt->cma_res_pool.alloced_size -= mem->buffer_size;
+	}
+
+	spin_unlock_irqrestore(&mgt->lock, flags);
+	if ((mem->from_flags == AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP) &&
+	    (tvp_mode >= 1)) {
+		mutex_lock(&mgt->tvp_protect_lock);
+		if (atomic_read(&mgt->tvp_user_count) == 0) {
+			if (codec_mm_tvp_pool_unprotect(&mgt->tvp_pool) == 0) {
+				codec_mm_extpool_pool_release(&mgt->tvp_pool);
+				mgt->tvp_enable = 0;
+				pr_info("disalbe tvp\n");
+			}
+		}
+		mutex_unlock(&mgt->tvp_protect_lock);
+	}
+	return;
+}
+
+struct codec_mm_s *codec_mm_alloc(const char *owner, int size,
+	int align2n, int memflags)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem = kmalloc(sizeof(struct codec_mm_s),
+		GFP_KERNEL);
+	int count;
+	int ret;
+	unsigned long flags;
+
+	if (!mem) {
+		pr_err("not enough mem for struct codec_mm_s\n");
+		return NULL;
+	}
+
+	if (mgt->tvp_enable & 3) {
+		/*if tvp & video decoder used tvp memory.*/
+		   /*Audio don't protect for default now.*/
+		if (memflags & CODEC_MM_FLAGS_TVP) {
+			/*clear other flags, when tvp mode.*/
+			memflags = memflags & (~CODEC_MM_FLAGS_FROM_MASK);
+			memflags |= CODEC_MM_FLAGS_TVP;
+		}
+	} else { /*tvp not enabled*/
+		if (memflags & CODEC_MM_FLAGS_TVP) {
+			pr_err("TVP not enabled, when alloc from tvp %s need %d\n",
+				owner, size);
+		}
+	}
+	if ((memflags & CODEC_MM_FLAGS_FROM_MASK) == 0)
+		memflags |= CODEC_MM_FLAGS_DMA;
+
+	memset(mem, 0, sizeof(struct codec_mm_s));
+	mem->buffer_size = PAGE_ALIGN(size);
+	count = mem->buffer_size / PAGE_SIZE;
+	mem->page_count = count;
+	mem->align2n = align2n;
+	mem->flags = memflags;
+	ret = codec_mm_alloc_in(mgt, mem);
+	if (ret < 0 &&
+		mgt->alloced_for_sc_cnt > 0 && /*have used for scatter.*/
+		!(memflags & CODEC_MM_FLAGS_FOR_SCATTER)) {
+		/*if not scatter, free scatter caches. */
+		pr_err(" No mem ret=%d, clear scatter cache!!\n", ret);
+		dump_free_mem_infos(NULL, 0);
+		if (memflags & CODEC_MM_FLAGS_TVP)
+			codec_mm_scatter_free_all_ignorecache(2);
+		else
+			codec_mm_scatter_free_all_ignorecache(1);
+		ret = codec_mm_alloc_in(mgt, mem);
+	}
+	if (ret < 0) {
+		pr_err("not enough mem for %s size %d, ret=%d\n",
+				owner, size, ret);
+		pr_err("mem flags %d %d, %d\n",
+				memflags,
+				mem->flags,
+				align2n);
+		kfree(mem);
+		if (debug_mode & 0x10)
+			dump_mem_infos(NULL, 0);
+		return NULL;
+	}
+
+	atomic_set(&mem->use_cnt, 1);
+	mem->owner[0] = owner;
+	spin_lock_init(&mem->lock);
+	spin_lock_irqsave(&mgt->lock, flags);
+	mem->mem_id = mgt->global_memid++;
+	list_add_tail(&mem->list, &mgt->mem_list);
+	switch (mem->from_flags) {
+	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_PAGES:
+		mgt->alloced_sys_size += mem->buffer_size;
+		break;
+	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA:
+		mgt->alloced_cma_size += mem->buffer_size;
+		break;
+	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP:
+		mgt->tvp_pool.alloced_size += mem->buffer_size;
+		break;
+	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED:
+		mgt->alloced_res_size += mem->buffer_size;
+		break;
+	case AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES:
+		mgt->cma_res_pool.alloced_size += mem->buffer_size;
+		break;
+	default:
+		pr_err("error alloc flags %d\n", mem->from_flags);
+	}
+	if (!(mem->flags & CODEC_MM_FLAGS_FOR_LOCAL_MGR)) {
+		mgt->total_alloced_size += mem->buffer_size;
+		if (mgt->total_alloced_size > mgt->max_used_mem_size)
+			mgt->max_used_mem_size = mgt->total_alloced_size;
+	}
+	if ((mem->flags & CODEC_MM_FLAGS_FOR_SCATTER)) {
+		mgt->alloced_for_sc_size += mem->buffer_size;
+		mgt->alloced_for_sc_cnt++;
+	}
+
+	if (mem->flags & CODEC_MM_FLAGS_FOR_PHYS_VMAPED)
+		mgt->phys_vmaped_page_cnt += mem->page_count;
+
+	spin_unlock_irqrestore(&mgt->lock, flags);
+	mem->alloced_jiffies = get_jiffies_64();
+	if (debug_mode & 0x20)
+		pr_err("%s alloc size %d at %lx from %d,2n:%d,flags:%d\n",
+			owner, size, mem->phy_addr,
+			mem->from_flags,
+			align2n,
+			memflags);
+	return mem;
+}
+EXPORT_SYMBOL(codec_mm_alloc);
+
+void codec_mm_release(struct codec_mm_s *mem, const char *owner)
+{
+
+	int index;
+	unsigned long flags;
+	int i;
+	const char *max_owner;
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	if (!mem)
+		return;
+
+	spin_lock_irqsave(&mgt->lock, flags);
+	if (!codec_mm_valid_mm_locked(mem)) {
+		pr_err("codec mm not valied!\n");
+		spin_unlock_irqrestore(&mgt->lock, flags);
+		return;
+	}
+	index = atomic_dec_return(&mem->use_cnt);
+	max_owner = mem->owner[index];
+	for (i = 0; i < index; i++) {
+		if (mem->owner[i] && strcmp(owner, mem->owner[i]) == 0)
+			mem->owner[i] = max_owner;
+	}
+	if (debug_mode & 0x20)
+		pr_err("%s free mem size %d at %lx from %d,index =%d\n",
+			owner, mem->buffer_size, mem->phy_addr,
+			mem->from_flags, index);
+	mem->owner[index] = NULL;
+	if (index == 0) {
+		list_del(&mem->list);
+		spin_unlock_irqrestore(&mgt->lock, flags);
+		codec_mm_free_in(mgt, mem);
+		kfree(mem);
+		return;
+	}
+	spin_unlock_irqrestore(&mgt->lock, flags);
+}
+EXPORT_SYMBOL(codec_mm_release);
+
+void *codec_mm_dma_alloc_coherent(const char *owner, int size,
+	dma_addr_t *dma_handle, gfp_t flag, int memflags)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	void *addr = NULL;
+
+	addr = dma_alloc_coherent(mgt->dev, size, dma_handle, flag);
+	return addr;
+}
+EXPORT_SYMBOL(codec_mm_dma_alloc_coherent);
+
+void codec_mm_dma_free_coherent(const char *owner, int size,
+	void *cpu_addr, dma_addr_t dma_handle, int memflags)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	dma_free_coherent(mgt->dev, size, cpu_addr, dma_handle);
+}
+EXPORT_SYMBOL(codec_mm_dma_free_coherent);
+
+void codec_mm_release_with_check(struct codec_mm_s *mem, const char *owner)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&mgt->lock, flags);
+	ret = codec_mm_valid_mm_locked(mem);
+	spin_unlock_irqrestore(&mgt->lock, flags);
+	if (ret) {
+		/*for check,*/
+		return codec_mm_release(mem, owner);
+	}
+}
+EXPORT_SYMBOL(codec_mm_release_with_check);
+
+void codec_mm_dma_flush(void *vaddr,
+	int size,
+	enum dma_data_direction dir)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	dma_addr_t dma_addr;
+	ulong phy_addr;
+
+	if (is_vmalloc_or_module_addr(vaddr)) {
+		phy_addr = codec_mm_search_phy_addr(vaddr);
+		if (!phy_addr)
+			phy_addr = page_to_phys(vmalloc_to_page(vaddr))
+				+ offset_in_page(vaddr);
+		if (phy_addr && PageHighMem(phys_to_page(phy_addr)))
+			dma_sync_single_for_device(mgt->dev,
+					phy_addr, size, dir);
+		return;
+	}
+
+	/* only apply to the lowmem. */
+	dma_addr = dma_map_single(mgt->dev, vaddr, size, dir);
+	if (dma_mapping_error(mgt->dev, dma_addr)) {
+		pr_err("dma map %d bytes error\n", size);
+		return;
+	}
+
+	dma_sync_single_for_device(mgt->dev, dma_addr, size, dir);
+	dma_unmap_single(mgt->dev, dma_addr, size, dir);
+}
+EXPORT_SYMBOL(codec_mm_dma_flush);
+
+int codec_mm_has_owner(struct codec_mm_s *mem, const char *owner)
+{
+	int index;
+	int i;
+	unsigned long flags;
+	int is_owner = 0;
+
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	if (mem) {
+		spin_lock_irqsave(&mgt->lock, flags);
+		if (!codec_mm_valid_mm_locked(mem)) {
+			spin_unlock_irqrestore(&mgt->lock, flags);
+			pr_err("codec mm %p not valied!\n", mem);
+			return 0;
+		}
+
+		index = atomic_read(&mem->use_cnt);
+
+		for (i = 0; i < index; i++) {
+			if (mem->owner[i] &&
+				strcmp(owner, mem->owner[i]) == 0) {
+				is_owner = 1;
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&mgt->lock, flags);
+	}
+
+	return is_owner;
+}
+
+int codec_mm_request_shared_mem(struct codec_mm_s *mem, const char *owner)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	unsigned long flags;
+	int ret = -1;
+
+	spin_lock_irqsave(&mgt->lock, flags);
+	if (!codec_mm_valid_mm_locked(mem)) {
+		ret = -2;
+		goto out;
+	}
+	if (atomic_read(&mem->use_cnt) > 7) {
+		ret = -3;
+		goto out;
+	}
+	ret = 0;
+	mem->owner[atomic_inc_return(&mem->use_cnt) - 1] = owner;
+
+out:
+	spin_unlock_irqrestore(&mgt->lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_request_shared_mem);
+
+static struct codec_mm_s *codec_mm_get_by_val_off(unsigned long val, int off)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem, *want_mem;
+	unsigned long flags;
+
+	want_mem = NULL;
+	spin_lock_irqsave(&mgt->lock, flags);
+	if (!list_empty(&mgt->mem_list)) {
+		list_for_each_entry(mem, &mgt->mem_list, list) {
+			if (mem && VAL_OFF_VAL(mem, off) == val)
+				want_mem = mem;
+		}
+	}
+	spin_unlock_irqrestore(&mgt->lock, flags);
+	return want_mem;
+}
+
+unsigned long codec_mm_alloc_for_dma(const char *owner, int page_cnt,
+	int align2n, int memflags)
+{
+	struct codec_mm_s *mem;
+
+	mem = codec_mm_alloc(owner, page_cnt << PAGE_SHIFT, align2n, memflags);
+	if (!mem)
+		return 0;
+	return mem->phy_addr;
+}
+EXPORT_SYMBOL(codec_mm_alloc_for_dma);
+
+unsigned long codec_mm_alloc_for_dma_ex(
+		const char *owner,
+		int page_cnt,
+		int align2n,
+		int memflags,
+		int ins_id,
+		int buffer_id)
+{
+	struct codec_mm_s *mem;
+
+	mem = codec_mm_alloc(owner, page_cnt << PAGE_SHIFT, align2n, memflags);
+	if (!mem)
+		return 0;
+	mem->ins_id = ins_id;
+	mem->ins_buffer_id = buffer_id;
+	if (debug_mode & 0x20) {
+		pr_err("%s, for ins %d, buffer id:%d\n",
+			mem->owner[0] ? mem->owner[0] : "no",
+			mem->ins_id,
+			buffer_id);
+	}
+	return mem->phy_addr;
+}
+EXPORT_SYMBOL(codec_mm_alloc_for_dma_ex);
+
+int codec_mm_free_for_dma(const char *owner, unsigned long phy_addr)
+{
+	struct codec_mm_s *mem;
+
+	mem = codec_mm_get_by_val_off(phy_addr, PHY_OFF());
+
+	if (mem)
+		codec_mm_release(mem, owner);
+	else
+		return -1;
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_free_for_dma);
+
+static int codec_mm_init_tvp_pool(
+			struct extpool_mgt_s *tvp_pool,
+			struct codec_mm_s *mm)
+{
+	struct gen_pool *pool;
+	int ret;
+
+	pool = gen_pool_create(RESERVE_MM_ALIGNED_2N, -1);
+	if (!pool)
+		return -ENOMEM;
+	ret = gen_pool_add(pool, mm->phy_addr, mm->buffer_size, -1);
+	if (ret < 0) {
+		gen_pool_destroy(pool);
+		return -1;
+	}
+	tvp_pool->gen_pool[tvp_pool->slot_num] = pool;
+	mm->tvp_handle = -1;
+	tvp_pool->mm[tvp_pool->slot_num] = mm;
+	return 0;
+}
+
+static int codec_mm_tvp_pool_protect(struct extpool_mgt_s *tvp_pool)
+{
+	int ret = 0;
+	int i = 0;
+
+	for (i = 0; i < tvp_pool->slot_num; i++) {
+		if (tvp_pool->mm[i]->tvp_handle == -1) {
+			ret = tee_protect_tvp_mem(
+				(uint32_t)tvp_pool->mm[i]->phy_addr,
+				(uint32_t)tvp_pool->mm[i]->buffer_size,
+				&tvp_pool->mm[i]->tvp_handle);
+			pr_info("protect tvp %d %d ret %d\n",
+				i, tvp_pool->mm[i]->tvp_handle, ret);
+		} else {
+			pr_info("protect tvp %d %d ret %d\n",
+				i, tvp_pool->mm[i]->tvp_handle, ret);
+		}
+	}
+	return ret;
+}
+
+int codec_mm_extpool_pool_alloc(
+	struct extpool_mgt_s *tvp_pool,
+	int size, int memflags, int for_tvp)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem;
+	int alloced_size = tvp_pool->total_size;
+	int try_alloced_size = size;
+	int ret;
+
+/*alloced from reserved*/
+	mutex_lock(&tvp_pool->pool_lock);
+	try_alloced_size = mgt->total_reserved_size - mgt->alloced_res_size;
+	if (try_alloced_size > 0 && for_tvp) {
+		int retry = 0;
+		try_alloced_size = min_t(int,
+			size - alloced_size, try_alloced_size);
+		try_alloced_size = MM_ALIGN_DOWN(try_alloced_size,
+			RESERVE_MM_ALIGNED_2N);
+		do {
+			mem = codec_mm_alloc(TVP_POOL_NAME,
+						try_alloced_size,
+						RESERVE_MM_ALIGNED_2N,
+						CODEC_MM_FLAGS_FOR_LOCAL_MGR |
+						CODEC_MM_FLAGS_RESERVED);
+
+			if (mem) {
+				ret = codec_mm_init_tvp_pool(
+					tvp_pool,
+					mem);
+				if (ret < 0) {
+					codec_mm_release(mem, TVP_POOL_NAME);
+				} else {
+					alloced_size += try_alloced_size;
+					tvp_pool->slot_num++;
+				}
+				break;
+			} else {
+				try_alloced_size = try_alloced_size - 4 * SZ_1M;
+				if (try_alloced_size < 16 * SZ_1M)
+					break;
+			}
+		} while (retry++ < 10);
+	}
+	if (alloced_size >= size) {
+		/*alloc finished. */
+		goto alloced_finished;
+	}
+
+/*alloced from cma:*/
+	try_alloced_size = mgt->total_cma_size - mgt->alloced_cma_size;
+	if (try_alloced_size > 0) {
+		int retry = 0;
+
+		try_alloced_size = min_t(int,
+			size - alloced_size, try_alloced_size);
+		try_alloced_size = MM_ALIGN_DOWN(try_alloced_size,
+			RESERVE_MM_ALIGNED_2N);
+		do {
+			mem = codec_mm_alloc(
+					for_tvp ?
+						TVP_POOL_NAME :
+						CMA_RES_POOL_NAME,
+					try_alloced_size,
+					RESERVE_MM_ALIGNED_2N,
+					CODEC_MM_FLAGS_FOR_LOCAL_MGR |
+					CODEC_MM_FLAGS_CMA);
+			if (mem) {
+				struct page *mm = mem->mem_handle;
+
+				if (mem->from_flags ==
+					AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES)
+					mm = phys_to_page(
+						(unsigned long)mm);
+				if (for_tvp) {
+					cma_mmu_op(mm,
+						mem->page_count,
+						0);
+				}
+				ret = codec_mm_init_tvp_pool(
+					tvp_pool,
+					mem);
+				if (ret < 0) {
+					if (for_tvp) {
+						cma_mmu_op(mm,
+							mem->page_count,
+							1);
+					}
+					codec_mm_release(mem, TVP_POOL_NAME);
+				} else {
+					alloced_size += try_alloced_size;
+					tvp_pool->slot_num++;
+				}
+				break;
+			} else {
+				try_alloced_size = try_alloced_size - 4 * SZ_1M;
+				if (try_alloced_size < 16 * SZ_1M)
+					break;
+			}
+		} while (retry++ < 10);
+	}
+
+alloced_finished:
+	if (alloced_size > 0)
+		tvp_pool->total_size = alloced_size;
+	if (tvp_mode >= 1 && for_tvp)
+		codec_mm_tvp_pool_protect(tvp_pool);
+	mutex_unlock(&tvp_pool->pool_lock);
+	return alloced_size;
+}
+EXPORT_SYMBOL(codec_mm_extpool_pool_alloc);
+
+/*
+ *call this before free all
+ *alloced TVP memory;
+ *it not free,some memory may free ignore.
+ *return :
+ */
+static int codec_mm_extpool_pool_release(struct extpool_mgt_s *tvp_pool)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	int i;
+	int ignored = 0;
+	mutex_lock(&tvp_pool->pool_lock);
+	for (i = 0; i < tvp_pool->slot_num; i++) {
+		struct gen_pool *gpool = tvp_pool->gen_pool[i];
+		int slot_mem_size = 0;
+
+		if (gpool) {
+			if (gen_pool_avail(gpool) != gen_pool_size(gpool)) {
+				pr_err("ERROR: TVP pool is not free.\n");
+				ignored++;
+				continue;	/*ignore this free now, */
+			}
+			slot_mem_size = gen_pool_size(gpool);
+			gen_pool_destroy(tvp_pool->gen_pool[i]);
+			if (tvp_pool->mm[i]) {
+				struct page *mm = tvp_pool->mm[i]->mem_handle;
+
+				if (tvp_pool->mm[i]->from_flags ==
+					AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES)
+					mm = phys_to_page(
+						(unsigned long)mm);
+				cma_mmu_op(mm,
+					tvp_pool->mm[i]->page_count,
+					1);
+				codec_mm_release(tvp_pool->mm[i],
+					TVP_POOL_NAME);
+			}
+		}
+		mgt->tvp_pool.total_size -= slot_mem_size;
+		tvp_pool->gen_pool[i] = NULL;
+		tvp_pool->mm[i] = NULL;
+	}
+	if (ignored > 0) {
+		int before_free_slot = tvp_pool->slot_num + 1;
+
+		for (i = 0; i < tvp_pool->slot_num; i++) {
+			if (tvp_pool->gen_pool[i] && before_free_slot < i) {
+				tvp_pool->gen_pool[before_free_slot] =
+					tvp_pool->gen_pool[i];
+				tvp_pool->mm[before_free_slot] =
+					tvp_pool->mm[i];
+				tvp_pool->gen_pool[i] = NULL;
+				tvp_pool->mm[i] = NULL;
+				before_free_slot++;
+			}
+			if (!tvp_pool->gen_pool[i] && before_free_slot > i) {
+				before_free_slot = i;
+				/**/
+			}
+		}
+
+	}
+	tvp_pool->slot_num = ignored;
+	mutex_unlock(&tvp_pool->pool_lock);
+	return ignored;
+}
+
+/*
+ *victor_size
+ *=sizeof(res)/sizeof(ulong)
+ *res[0]=addr1_start;
+ *res[1]=addr1_end;
+ *res[2]=addr2_start;
+ *res[3]=addr2_end;
+ *..
+ *res[2*n]=addrx_start;
+ *res[2*n+1]=addrx_end;
+ *
+ *return n;
+ */
+static int codec_mm_tvp_get_mem_resource(ulong *res, int victor_size)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct extpool_mgt_s *tvp_pool = &mgt->tvp_pool;
+	int i;
+	mutex_lock(&tvp_pool->pool_lock);
+	for (i = 0; i < tvp_pool->slot_num && i < victor_size / 2; i++) {
+		if (tvp_pool->mm[i]) {
+			res[2 * i] = tvp_pool->mm[i]->phy_addr;
+			res[2 * i + 1] = tvp_pool->mm[i]->phy_addr +
+				tvp_pool->mm[i]->buffer_size - 1;
+		}
+	}
+	mutex_unlock(&tvp_pool->pool_lock);
+	return i;
+}
+
+static int codec_mm_is_in_tvp_region(ulong phy_addr)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct extpool_mgt_s *tvp_pool = &mgt->tvp_pool;
+	int i;
+	int in = 0, in2 = 0;
+	mutex_lock(&tvp_pool->pool_lock);
+	for (i = 0; i < tvp_pool->slot_num; i++) {
+		if (tvp_pool->mm[i]) {
+			in = tvp_pool->mm[i]->phy_addr <= phy_addr;
+			in2 = (tvp_pool->mm[i]->phy_addr +
+				tvp_pool->mm[i]->buffer_size - 1) >= phy_addr;
+			in = in && in2;
+			if (in)
+				break;
+			in = 0;
+		}
+	}
+	mutex_unlock(&tvp_pool->pool_lock);
+	return in;
+}
+
+void *codec_mm_phys_to_virt(unsigned long phy_addr)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	if (codec_mm_is_in_tvp_region(phy_addr))
+		return NULL;	/* no virt for tvp memory; */
+
+	if (phy_addr >= mgt->rmem.base &&
+		phy_addr < mgt->rmem.base + mgt->rmem.size) {
+		if (mgt->res_mem_flags & RES_MEM_FLAGS_HAVE_MAPED)
+			return codec_mm_search_vaddr(phy_addr);
+		return NULL;	/* no virt for reserved memory; */
+	}
+
+	return codec_mm_search_vaddr(phy_addr);
+}
+EXPORT_SYMBOL(codec_mm_phys_to_virt);
+
+unsigned long codec_mm_virt_to_phys(void *vaddr)
+{
+	return page_to_phys((struct page *)vaddr);
+}
+EXPORT_SYMBOL(codec_mm_virt_to_phys);
+
+unsigned long dma_get_cma_size_int_byte(struct device *dev)
+{
+	unsigned long size = 0;
+	struct cma *cma = NULL;
+
+	if (!dev) {
+		pr_err("CMA: NULL DEV\n");
+		return 0;
+	}
+
+	cma = dev_get_cma_area(dev);
+	if (!cma) {
+		pr_err("CMA:  NO CMA region\n");
+		return 0;
+	}
+	size = cma_get_size(cma);
+	return size;
+}
+EXPORT_SYMBOL(dma_get_cma_size_int_byte);
+
+
+static int codec_mm_get_cma_size_int_byte(struct device *dev)
+{
+	static int static_size = -1;
+	struct cma *cma = NULL;
+
+	if (static_size >= 0)
+		return static_size;
+	if (!dev) {
+		pr_err("CMA: NULL DEV\n");
+		return 0;
+	}
+
+	cma = dev_get_cma_area(dev);
+	if (!cma) {
+		pr_err("CMA:  NO CMA region\n");
+		return 0;
+	}
+	if (cma == dev_get_cma_area(NULL))
+		static_size = 0;/*ignore default cma pool*/
+	else
+		static_size = cma_get_size(cma);
+
+	return static_size;
+}
+
+static int dump_mem_infos(void *buf, int size)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem;
+	unsigned long flags;
+
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+
+	if (!pbuf) {
+		pbuf = sbuf;
+		size = 512;
+	}
+	s = snprintf(pbuf, size - tsize,
+		"codec mem info:\n\ttotal codec mem size:%d MB\n",
+		mgt->total_codec_mem_size / SZ_1M);
+	tsize += s;
+	pbuf += s;
+
+	s = snprintf(pbuf, size - tsize,
+		"\talloced size= %d MB\n\tmax alloced: %d MB\n",
+		mgt->total_alloced_size / SZ_1M,
+		mgt->max_used_mem_size / SZ_1M);
+	tsize += s;
+	pbuf += s;
+
+	s = snprintf(pbuf, size - tsize,
+		"\tCMA:%d,RES:%d,TVP:%d,SYS:%d,VMAPED:%d MB\n",
+		mgt->alloced_cma_size / SZ_1M,
+		mgt->alloced_res_size / SZ_1M,
+		mgt->tvp_pool.alloced_size / SZ_1M,
+		mgt->alloced_sys_size / SZ_1M,
+		(mgt->phys_vmaped_page_cnt << PAGE_SHIFT) / SZ_1M);
+	tsize += s;
+	pbuf += s;
+
+	if (mgt->res_pool) {
+		s = snprintf(pbuf, size - tsize,
+			"\t[%d]RES size:%d MB,alloced:%d MB free:%d MB\n",
+			AMPORTS_MEM_FLAGS_FROM_GET_FROM_REVERSED,
+			(int)(gen_pool_size(mgt->res_pool) / SZ_1M),
+			(int)(mgt->alloced_res_size / SZ_1M),
+			(int)(gen_pool_avail(mgt->res_pool) / SZ_1M));
+		tsize += s;
+		pbuf += s;
+	}
+
+	s = snprintf(pbuf, size - tsize,
+			"\t[%d]CMA size:%d MB:alloced: %d MB,free:%d MB\n",
+			AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA,
+			(int)(mgt->total_cma_size / SZ_1M),
+			(int)(mgt->alloced_cma_size / SZ_1M),
+			(int)((mgt->total_cma_size -
+			mgt->alloced_cma_size) / SZ_1M));
+	tsize += s;
+	pbuf += s;
+
+	if (mgt->tvp_pool.slot_num > 0) {
+		s = snprintf(pbuf, size - tsize,
+			"\t[%d]TVP size:%d MB,alloced:%d MB free:%d MB\n",
+			AMPORTS_MEM_FLAGS_FROM_GET_FROM_TVP,
+			(int)(mgt->tvp_pool.total_size / SZ_1M),
+			(int)(mgt->tvp_pool.alloced_size / SZ_1M),
+			(int)((mgt->tvp_pool.total_size -
+					mgt->tvp_pool.alloced_size) / SZ_1M));
+		tsize += s;
+		pbuf += s;
+	}
+	if (mgt->cma_res_pool.slot_num > 0) {
+		s = snprintf(pbuf, size - tsize,
+			"\t[%d]CMA_RES size:%d MB,alloced:%d MB free:%d MB\n",
+				AMPORTS_MEM_FLAGS_FROM_GET_FROM_CMA_RES,
+				(int)(mgt->cma_res_pool.total_size / SZ_1M),
+				(int)(mgt->cma_res_pool.alloced_size / SZ_1M),
+				(int)((mgt->cma_res_pool.total_size -
+				mgt->cma_res_pool.alloced_size) / SZ_1M));
+		tsize += s;
+		pbuf += s;
+	}
+
+	if (!buf && tsize > 0) {
+		pr_info("%s", sbuf);
+		pbuf = sbuf;
+		sbuf[0] = '\0';
+		tsize = 0;
+	}
+	spin_lock_irqsave(&mgt->lock, flags);
+	if (list_empty(&mgt->mem_list)) {
+		spin_unlock_irqrestore(&mgt->lock, flags);
+		return tsize;
+	}
+	list_for_each_entry(mem, &mgt->mem_list, list) {
+		s = snprintf(pbuf, size - tsize,
+			"\t[%d].%d:%s.%d,addr=%p,size=%d,from=%d,cnt=%d,",
+			mem->mem_id,
+			mem->ins_id,
+			mem->owner[0] ? mem->owner[0] : "no",
+			mem->ins_buffer_id,
+			(void *)mem->phy_addr,
+			mem->buffer_size,
+			mem->from_flags,
+			atomic_read(&mem->use_cnt)
+			);
+		s += snprintf(pbuf + s, size - tsize,
+			"flags=%d,used:%u ms\n",
+			mem->flags, jiffies_to_msecs(get_jiffies_64() -
+			mem->alloced_jiffies));
+
+		tsize += s;
+		if (buf) {
+			pbuf += s;
+			if (tsize > size - 256) {
+				s += snprintf(pbuf + s, size - tsize,
+					"\n\t\t**NOT END**\n");
+				tsize += s;
+				break;/*no memory for dump now.*/
+			}
+		} else {
+			pr_info("%s", sbuf);
+			tsize = 0;
+		}
+	}
+	spin_unlock_irqrestore(&mgt->lock, flags);
+
+	return tsize;
+}
+
+
+static int dump_free_mem_infos(void *buf, int size)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem;
+	unsigned long flags;
+	int i = 0, j, k;
+	unsigned long minphy;
+	u32 cma_base_phy, cma_end_phy;
+	struct dump_buf_s {
+		unsigned long phy_addr;
+		int buffer_size;
+		int align2n;
+	} *usedb, *freeb;
+	int total_free_size = 0;
+
+	usedb = kzalloc(sizeof(struct dump_buf_s) * 256, GFP_KERNEL);
+	if (usedb == NULL)
+		return 0;
+	freeb = usedb + 128;
+
+	spin_lock_irqsave(&mgt->lock, flags);
+	list_for_each_entry(mem, &mgt->mem_list, list) {
+		usedb[i].phy_addr = mem->phy_addr;
+		usedb[i].buffer_size = mem->buffer_size;
+		usedb[i].align2n = mem->align2n;
+		if (++i >= 128) {
+			pr_info("too many memlist in codec_mm, break;\n");
+			break;
+		}
+	};
+	cma_base_phy = cma_get_base(dev_get_cma_area(mgt->dev));
+	cma_end_phy = cma_base_phy + dma_get_cma_size_int_byte(mgt->dev);
+	spin_unlock_irqrestore(&mgt->lock, flags);
+	pr_info("free cma idea[%x-%x] from codec_mm items %d\n", cma_base_phy,
+				cma_end_phy, i);
+	for (j = 0; j < i; j++) { /* free */
+		freeb[j].phy_addr = usedb[j].phy_addr +
+			MM_ALIGN_UP2N(usedb[j].buffer_size, usedb[j].align2n);
+		minphy = cma_end_phy;
+		for (k = 0; k < i; k++) { /* used */
+			if (usedb[k].phy_addr >= freeb[j].phy_addr &&
+						usedb[k].phy_addr < minphy)
+				minphy = usedb[k].phy_addr;
+		}
+		freeb[j].buffer_size = minphy - freeb[j].phy_addr;
+		total_free_size += freeb[j].buffer_size;
+		if (freeb[j].buffer_size > 0)
+			pr_info("\t[%d] free buf phyaddr=%p, used [%p,%x], size=%x\n",
+				j, (void *)freeb[j].phy_addr,
+				(void *)usedb[j].phy_addr,
+				usedb[j].buffer_size, freeb[j].buffer_size);
+	}
+	pr_info("total_free_size %x\n", total_free_size);
+	kfree(usedb);
+	return 0;
+}
+
+int codec_mm_enable_tvp(void)
+{
+	int ret;
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	mutex_lock(&mgt->tvp_protect_lock);
+	if (tvp_mode == 0) {
+		pr_err("not support in tvp_mode 0\n");
+		mutex_unlock(&mgt->tvp_protect_lock);
+		return -1;
+	}
+	ret = atomic_add_return(1, &mgt->tvp_user_count);
+	if (ret == 1) {
+		codec_mm_extpool_pool_alloc(
+			&mgt->tvp_pool,
+			default_tvp_4k_size, 0, 1);
+		mgt->tvp_enable = 2;
+	}
+	pr_info("tvp_user_count is %d\n", atomic_read(&mgt->tvp_user_count));
+	mutex_unlock(&mgt->tvp_protect_lock);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_enable_tvp);
+
+int codec_mm_disable_tvp(void)
+{
+	int ret = -1;
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	mutex_lock(&mgt->tvp_protect_lock);
+	if (tvp_mode == 0) {
+		pr_err("not support in tvp_mode 0\n");
+		mutex_unlock(&mgt->tvp_protect_lock);
+		return ret;
+	}
+	if (atomic_dec_and_test(&mgt->tvp_user_count)) {
+		if (codec_mm_tvp_pool_unprotect(&mgt->tvp_pool) == 0) {
+			ret = codec_mm_extpool_pool_release(&mgt->tvp_pool);
+			mgt->tvp_enable = 0;
+			pr_info("disalbe tvp\n");
+			mutex_unlock(&mgt->tvp_protect_lock);
+			return ret;
+		}
+	}
+	ret = 0;
+	if (atomic_read(&mgt->tvp_user_count) < 0)
+		atomic_set(&mgt->tvp_user_count, 0);
+	pr_info("tvp_user_count is %d\n",
+		atomic_read(&mgt->tvp_user_count));
+	mutex_unlock(&mgt->tvp_protect_lock);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_disable_tvp);
+
+int codec_mm_video_tvp_enabled(void)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	return mgt->tvp_enable;
+}
+EXPORT_SYMBOL(codec_mm_video_tvp_enabled);
+
+int codec_mm_get_total_size(void)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	int total_size = mgt->total_codec_mem_size;
+
+	if ((debug_mode & 0xf) == 0) {	/*no debug memory mode. */
+		return total_size;
+	}
+	/*
+	 *disable reserved:1
+	 *disable cma:2
+	 *disable sys memory:4
+	 *disable half memory:8,
+	 */
+	if (debug_mode & 0x8)
+		total_size -= mgt->total_codec_mem_size / 2;
+	if (debug_mode & 0x1) {
+		total_size -= mgt->total_reserved_size;
+		total_size -= mgt->cma_res_pool.total_size;
+	}
+	if (debug_mode & 0x2)
+		total_size -= mgt->total_cma_size;
+	if (total_size < 0)
+		total_size = 0;
+	return total_size;
+}
+EXPORT_SYMBOL(codec_mm_get_total_size);
+
+int codec_mm_get_free_size(void)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	return codec_mm_get_total_size() -
+		mgt->total_alloced_size;
+}
+EXPORT_SYMBOL(codec_mm_get_free_size);
+
+int codec_mm_get_reserved_size(void)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	return mgt->total_reserved_size;
+}
+EXPORT_SYMBOL(codec_mm_get_reserved_size);
+
+struct device *v4l_get_dev_from_codec_mm(void)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	return mgt->dev;
+}
+EXPORT_SYMBOL(v4l_get_dev_from_codec_mm);
+
+struct codec_mm_s *v4l_reqbufs_from_codec_mm(const char *owner,
+	unsigned int addr, unsigned int size, unsigned int index)
+{
+	unsigned long flags;
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	struct codec_mm_s *mem = NULL;
+	int buf_size = PAGE_ALIGN(size);
+
+	mem = kzalloc(sizeof(struct codec_mm_s), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(mem))
+		goto out;
+
+	mem->owner[0]    = owner;
+	mem->mem_handle  = NULL;
+	mem->buffer_size = buf_size;
+	mem->page_count  = buf_size / PAGE_SIZE;
+	mem->phy_addr    = addr;
+	mem->ins_buffer_id = index;
+	mem->alloced_jiffies = get_jiffies_64();
+	mem->from_flags
+		= AMPORTS_MEM_FLAGS_FROM_GET_FROM_COHERENT;
+
+	spin_lock_irqsave(&mgt->lock, flags);
+
+	mem->mem_id = mgt->global_memid++;
+	mgt->alloced_from_coherent += buf_size;
+	mgt->total_alloced_size += buf_size;
+	mgt->alloced_cma_size += buf_size;
+	list_add_tail(&mem->list, &mgt->mem_list);
+
+	spin_unlock_irqrestore(&mgt->lock, flags);
+
+	if (debug_mode & 0x20)
+		pr_info("%s alloc coherent size %d at %lx from %d.\n",
+			owner, buf_size, mem->phy_addr, mem->from_flags);
+out:
+	return mem;
+}
+EXPORT_SYMBOL(v4l_reqbufs_from_codec_mm);
+
+void v4l_freebufs_back_to_codec_mm(const char *owner, struct codec_mm_s *mem)
+{
+	unsigned long flags;
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	if (IS_ERR_OR_NULL(mem))
+		return;
+
+	if (!mem->owner[0] || strcmp(owner, mem->owner[0]) ||
+		!mem->buffer_size)
+		goto out;
+
+	spin_lock_irqsave(&mgt->lock, flags);
+
+	mgt->alloced_from_coherent -= mem->buffer_size;
+	mgt->total_alloced_size -= mem->buffer_size;
+	mgt->alloced_cma_size -= mem->buffer_size;
+	list_del(&mem->list);
+
+	spin_unlock_irqrestore(&mgt->lock, flags);
+
+	if (debug_mode & 0x20)
+		pr_info("%s free mem size %d at %lx from %d\n", mem->owner[0],
+			mem->buffer_size, mem->phy_addr, mem->from_flags);
+out:
+	kfree(mem);
+}
+EXPORT_SYMBOL(v4l_freebufs_back_to_codec_mm);
+
+/*
+ *with_wait:
+ *1: if no mem, do wait and free some cache.
+ *0: do not wait.
+ */
+int codec_mm_enough_for_size(int size, int with_wait)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	int have_mem = codec_mm_alloc_pre_check_in(mgt, size, 0);
+
+	if (!have_mem && with_wait && mgt->alloced_for_sc_cnt > 0) {
+		pr_err(" No mem, clear scatter cache!!\n");
+		codec_mm_scatter_free_all_ignorecache(1);
+		have_mem = codec_mm_alloc_pre_check_in(mgt, size, 0);
+		if (have_mem)
+			return 1;
+		if (debug_mode & 0x20)
+			dump_mem_infos(NULL, 0);
+		msleep(50);
+		return 0;
+	}
+	return 1;
+}
+EXPORT_SYMBOL(codec_mm_enough_for_size);
+
+int codec_mm_mgt_init(struct device *dev)
+{
+
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	INIT_LIST_HEAD(&mgt->mem_list);
+	mgt->dev = dev;
+	mgt->alloc_from_sys_pages_max = 4;
+	if (mgt->rmem.size > 0) {
+		unsigned long aligned_addr;
+		int aligned_size;
+		/*mem aligned, */
+		mgt->res_pool = gen_pool_create(RESERVE_MM_ALIGNED_2N, -1);
+		if (!mgt->res_pool)
+			return -ENOMEM;
+		aligned_addr = ((unsigned long)mgt->rmem.base +
+			((1 << RESERVE_MM_ALIGNED_2N) - 1)) &
+			(~((1 << RESERVE_MM_ALIGNED_2N) - 1));
+		aligned_size = mgt->rmem.size -
+			(int)(aligned_addr - (unsigned long)mgt->rmem.base);
+		gen_pool_add(mgt->res_pool,
+			aligned_addr, aligned_size, -1);
+		pr_debug("add reserve memory %p(aligned %p) size=%x(aligned %x)\n",
+			(void *)mgt->rmem.base, (void *)aligned_addr,
+			(int)mgt->rmem.size, (int)aligned_size);
+		mgt->total_reserved_size = aligned_size;
+		mgt->total_codec_mem_size = aligned_size;
+#ifdef RES_IS_MAPED
+		mgt->res_mem_flags |= RES_MEM_FLAGS_HAVE_MAPED;
+#endif
+	}
+	mgt->total_cma_size = codec_mm_get_cma_size_int_byte(mgt->dev);
+	mgt->total_codec_mem_size += mgt->total_cma_size;
+	/*2M for audio not protect.*/
+	default_tvp_4k_size = mgt->total_codec_mem_size - SZ_1M * 2;
+	if (default_tvp_4k_size > DEFAULT_TVP_SIZE_FOR_4K)
+		default_tvp_4k_size = DEFAULT_TVP_SIZE_FOR_4K;
+	/*97MB -> 160MB, may not enough for h265*/
+	default_tvp_size = (mgt->total_codec_mem_size - (SZ_1M * 2)) >
+			DEFAULT_TVP_SIZE_FOR_NO4K ?
+				DEFAULT_TVP_SIZE_FOR_NO4K :
+				default_tvp_4k_size;
+
+	default_cma_res_size = mgt->total_cma_size;
+	mgt->global_memid = 0;
+	mutex_init(&mgt->tvp_pool.pool_lock);
+	mutex_init(&mgt->cma_res_pool.pool_lock);
+	spin_lock_init(&mgt->lock);
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_mgt_init);
+
+static int __init amstream_test_init(void)
+{
+#if 0
+	unsigned long buf[4];
+	struct codec_mm_s *mem[20];
+
+	mem[0] = codec_mm_alloc("test0", 1024 * 1024, 0, 0);
+	mem[1] = codec_mm_alloc("test1", 1024 * 1024, 0, 0);
+	mem[2] = codec_mm_alloc("test2", 1024 * 1024, 0, 0);
+	mem[3] = codec_mm_alloc("test32", 1024 * 1024, 0, 0);
+	mem[4] = codec_mm_alloc("test3", 400 * 1024, 0, 0);
+	mem[5] = codec_mm_alloc("test3", 400 * 1024, 0, 0);
+	mem[6] = codec_mm_alloc("test666", 400 * 1024, 0, 0);
+	mem[7] = codec_mm_alloc("test3", 8 * 1024 * 1024, 0, 0);
+	mem[8] = codec_mm_alloc("test4", 3 * 1024 * 1024, 0, 0);
+	pr_info("TT:%p,%p,%p,%p\n", mem[0], mem[1], mem[2], mem[3]);
+	dump_mem_infos(NULL, 0);
+	codec_mm_release(mem[1], "test1");
+	codec_mm_release(mem[7], "test3");
+	codec_mm_request_shared_mem(mem[3], "test55");
+	codec_mm_request_shared_mem(mem[6], "test667");
+	dump_mem_infos(NULL, 0);
+	codec_mm_release(mem[3], "test32");
+	codec_mm_release(mem[0], "test1");
+	codec_mm_request_shared_mem(mem[3], "test57");
+	codec_mm_request_shared_mem(mem[3], "test58");
+	codec_mm_release(mem[3], "test55");
+	dump_mem_infos(NULL, 0);
+	mem[8] = codec_mm_alloc("test4", 8 * 1024 * 1024, 0,
+		CODEC_MM_FLAGS_DMA);
+	mem[9] = codec_mm_alloc("test5", 4 * 1024 * 1024, 0,
+		CODEC_MM_FLAGS_TVP);
+	mem[10] = codec_mm_alloc("test6", 10 * 1024 * 1024, 0,
+		CODEC_MM_FLAGS_DMA_CPU);
+	dump_mem_infos(NULL, 0);
+
+	buf[0] = codec_mm_alloc_for_dma("streambuf1",
+		8 * 1024 * 1024 / PAGE_SIZE, 0, 0);
+	buf[1] = codec_mm_alloc_for_dma("streambuf2",
+		2 * 1024 * 1024 / PAGE_SIZE, 0, 0);
+	buf[2] = codec_mm_alloc_for_dma("streambuf2",
+		118 * 1024 / PAGE_SIZE, 0, 0);
+	buf[3] = codec_mm_alloc_for_dma("streambuf2",
+		(jiffies & 0x7f) * 1024 / PAGE_SIZE, 0, 0);
+	dump_mem_infos(NULL, 0);
+	codec_mm_free_for_dma("streambuf2", buf[3]);
+	codec_mm_free_for_dma("streambuf2", buf[1]);
+	codec_mm_free_for_dma("streambuf2", buf[2]);
+	codec_mm_free_for_dma("streambuf1", buf[0]);
+	dump_mem_infos(NULL, 0);
+#endif
+
+	return 0;
+}
+
+static ssize_t codec_mm_dump_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	size_t ret;
+
+	ret = dump_mem_infos(buf, PAGE_SIZE);
+	return ret;
+}
+
+static ssize_t codec_mm_scatter_dump_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	size_t ret;
+
+	ret = codec_mm_scatter_info_dump(buf, PAGE_SIZE);
+	return ret;
+}
+
+static ssize_t codec_mm_keeper_dump_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	size_t ret;
+
+	ret = codec_mm_keeper_dump_info(buf, PAGE_SIZE);
+	return ret;
+}
+
+static ssize_t tvp_enable_show(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	ssize_t size = 0;
+
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	mutex_lock(&mgt->tvp_protect_lock);
+	size += sprintf(buf, "tvp_flag=%d\n",
+			(tvp_mode << 4) + mgt->tvp_enable);
+	size += sprintf(buf + size, "tvp ref count=%d\n",
+			atomic_read(&mgt->tvp_user_count));
+	size += sprintf(buf + size, "tvp enable help:\n");
+	size += sprintf(buf + size, "echo n > tvp_enable\n");
+	size += sprintf(buf + size, "0: disable tvp(tvp size to 0)\n");
+	size += sprintf(buf + size,
+		"1: enable tvp for 1080p playing(use default size)\n");
+	size += sprintf(buf + size,
+		"2: enable tvp for 4k playing(use default 4k size)\n");
+	mutex_unlock(&mgt->tvp_protect_lock);
+	return size;
+}
+
+static ssize_t tvp_enable_store(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	unsigned int val;
+	ssize_t ret;
+
+	val = -1;
+	/*ret = sscanf(buf, "%d", &val);*/
+	ret = kstrtoint(buf, 0, &val);
+	if (ret != 0)
+		return -EINVAL;
+	switch (tvp_mode) {
+	case  0: {
+		/*
+		 * always free all scatter cache for
+		 * tvp changes.
+		 */
+		mutex_lock(&mgt->tvp_protect_lock);
+		codec_mm_keeper_free_all_keep(2);
+		codec_mm_scatter_free_all_ignorecache(3);
+		switch (val) {
+		case 0:
+			ret = codec_mm_extpool_pool_release(&mgt->tvp_pool);
+			mgt->tvp_enable = 0;
+			pr_info("disalbe tvp\n");
+			break;
+		case 1:
+			codec_mm_extpool_pool_alloc(
+				&mgt->tvp_pool,
+				default_tvp_size, 0, 1);
+			mgt->tvp_enable = 1;
+			pr_info("enable tvp for 1080p\n");
+			break;
+		case 2:
+			codec_mm_extpool_pool_alloc(
+				&mgt->tvp_pool,
+				default_tvp_4k_size, 0, 1);
+			mgt->tvp_enable = 2;
+			pr_info("enable tvp for 4k\n");
+			break;
+		default:
+			pr_err("unknown cmd! %d\n", val);
+		}
+		mutex_unlock(&mgt->tvp_protect_lock);
+		break;
+	}
+	case 1: {
+		switch (val) {
+		case 0:
+			codec_mm_disable_tvp();
+			break;
+		case 1:
+		case 2:
+			codec_mm_enable_tvp();
+			break;
+		default:
+			pr_err("unknown cmd! %d\n", val);
+		}
+		break;
+	}
+	default:
+		break;
+	}
+	return size;
+}
+
+static ssize_t fastplay_enable_show(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	ssize_t size = 0;
+
+	size += sprintf(buf, "fastplay enable help:\n");
+	size += sprintf(buf + size, "echo n > tvp_enable\n");
+	size += sprintf(buf + size, "0: disable fastplay\n");
+	size += sprintf(buf + size,
+		"1: enable fastplay for 1080p playing(use default size)\n");
+	return size;
+}
+
+static ssize_t fastplay_enable_store(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t size)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+	unsigned int val;
+	ssize_t ret;
+
+	val = -1;
+	/*ret = sscanf(buf, "%d", &val);*/
+	ret = kstrtoint(buf, 0, &val);
+	if (ret != 0)
+		return -EINVAL;
+	switch (val) {
+	case 0:
+		ret = codec_mm_extpool_pool_release(&mgt->cma_res_pool);
+		mgt->fastplay_enable = 0;
+		pr_err("disalbe fastplay\n");
+		break;
+	case 1:
+		codec_mm_extpool_pool_alloc(
+			&mgt->cma_res_pool,
+			default_cma_res_size, 0, 0);
+		mgt->fastplay_enable = 1;
+		pr_err("enable fastplay\n");
+		break;
+	default:
+		pr_err("unknown cmd! %d\n", val);
+	}
+	return size;
+}
+
+static ssize_t config_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	ssize_t ret;
+
+	ret = configs_list_path_nodes(CONFIG_PATH, buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	return ret;
+}
+
+static ssize_t config_store(struct class *class,
+			struct class_attribute *attr,
+			const char *buf, size_t size)
+{
+	int ret;
+
+	ret = configs_set_prefix_path_valonpath(CONFIG_PREFIX, buf);
+	if (ret < 0)
+		pr_err("set config failed %s\n", buf);
+	return size;
+}
+
+static ssize_t tvp_region_show(struct class *class,
+	struct class_attribute *attr, char *buf)
+{
+	size_t ret;
+	ulong res_victor[16];
+	int i;
+	int off = 0;
+
+	ret = codec_mm_tvp_get_mem_resource(res_victor, 8);
+	for (i = 0; i < ret; i++) {
+		off += sprintf(buf + off,
+			"segment%d:0x%p - 0x%p (size:0x%x)\n",
+			i,
+			(void *)res_victor[2 * i],
+			(void *)res_victor[2 * i + 1],
+			(int)(res_victor[2 * i + 1] - res_victor[2 * i] + 1));
+	}
+	return off;
+}
+
+static ssize_t debug_show(struct class *class,
+		struct class_attribute *attr,
+		char *buf)
+{
+	ssize_t size = 0;
+
+	size += sprintf(buf, "mm_scatter help:\n");
+	size += sprintf(buf + size, "echo n > mm_scatter_debug\n");
+	size += sprintf(buf + size, "n==0: clear all debugs)\n");
+	size += sprintf(buf + size,
+	"n=1: dump all alloced scatters\n");
+	size += sprintf(buf + size,
+	"n=2: dump all slots\n");
+
+	size += sprintf(buf + size,
+	"n=3: dump all free slots\n");
+
+	size += sprintf(buf + size,
+	"n=4: dump all sid hash table\n");
+
+	size += sprintf(buf + size,
+	"n=5: free all free slot now!\n");
+
+	size += sprintf(buf + size,
+	"n=6: clear all time infos!\n");
+
+	size += sprintf(buf + size,
+	"n=10: force free all keeper\n");
+
+	size += sprintf(buf + size,
+	"n=20: dump memory,# 20 #addr(hex) #len\n");
+
+	size += sprintf(buf + size,
+	"n==100: cmd mode p1 p ##mode:0,dump, 1,alloc 2,more,3,free some,4,free all\n");
+	return size;
+}
+
+static int codec_mm_mem_dump(unsigned long addr, int isphy, int len)
+{
+	void *vaddr;
+	int is_map = 0;
+
+	pr_info("start dump addr: %p %d\n", (void *)addr, len);
+	if (!isphy) {
+		vaddr = (void *)addr;
+	} else {
+		vaddr = ioremap(
+					addr, len);
+		if (!vaddr) {
+			pr_info("map addr: %p len: %d, failed\n",
+				(void *)addr, len);
+			vaddr = codec_mm_phys_to_virt(addr);
+		} else {
+			is_map = 1;
+		}
+	}
+	if (vaddr) {
+		unsigned int *p, *vint;
+		int i;
+
+		vint = (unsigned int *)vaddr;
+		for (i = 0; i <= len - 32; i += sizeof(int) * 8) {
+			p = (int *)&vint[i];
+			pr_info("%p: %08x %08x %08x %08x %08x %08x %08x %08x\n",
+			p,
+			p[0], p[1], p[2], p[3],
+			p[4], p[5], p[6], p[7]);
+		}
+	}
+	if (vaddr && is_map) {
+		/*maped free...*/
+		iounmap(vaddr);
+	}
+	return 0;
+}
+
+static ssize_t debug_store(struct class *class,
+		struct class_attribute *attr,
+		const char *buf, size_t size)
+{
+	unsigned int val;
+	ssize_t ret;
+
+	val = -1;
+	/*ret = sscanf(buf, "%d", &val);*/
+	ret = kstrtoint(buf, 0, &val);
+	if (ret != 0)
+		return -EINVAL;
+	switch (val) {
+	case 0:
+		pr_info("clear debug!\n");
+		break;
+	case 1:
+		codec_mm_dump_all_scatters();
+		break;
+	case 2:
+		codec_mm_dump_all_slots();
+		break;
+	case 3:
+		codec_mm_dump_free_slots();
+		break;
+	case 4:
+		codec_mm_dump_all_hash_table();
+		break;
+	case 5:
+		codec_mm_free_all_free_slots();
+		break;
+	case 6:
+		codec_mm_clear_alloc_infos();
+		break;
+	case 10:
+		codec_mm_keeper_free_all_keep(1);
+		break;
+	case 11:
+		dump_mem_infos(NULL, 0);
+		break;
+	case 12:
+		dump_free_mem_infos(NULL, 0);
+		break;
+	case 20: {
+		int cmd, len;
+		unsigned int addr;
+
+		cmd = len = 0;
+		addr = 0;
+		ret = sscanf(buf, "%d %x %d", &cmd, &addr, &len);
+		if (addr > 0 && len > 0)
+			codec_mm_mem_dump(addr, 1, len);
+		}
+		break;
+	case 100:{
+			int cmd, mode, p1, p2;
+
+			mode = p1 = p2 = 0;
+			ret = sscanf(buf, "%d %d %d %d", &cmd, &mode, &p1, &p2);
+			codec_mm_scatter_test(mode, p1, p2);
+		}
+		break;
+	default:
+		pr_err("unknown cmd! %d\n", val);
+	}
+	return size;
+
+}
+
+static ssize_t debug_sc_mode_show(struct class *class,
+				  struct class_attribute *attr, char *buf)
+{
+	ssize_t size = 0;
+
+	size = sprintf(buf, "%u\n", debug_sc_mode);
+
+	return size;
+}
+
+static ssize_t debug_sc_mode_store(struct class *class,
+				   struct class_attribute *attr,
+				   const char *buf, size_t size)
+{
+	unsigned int val;
+	ssize_t ret;
+
+	val = -1;
+	ret = kstrtoint(buf, 0, &val);
+	if (ret != 0)
+		return -EINVAL;
+
+	debug_sc_mode = val;
+
+	return size;
+}
+
+static ssize_t debug_keep_mode_show(struct class *class,
+					struct class_attribute *attr, char *buf)
+{
+	ssize_t size = 0;
+
+	size = sprintf(buf, "%u\n", debug_keep_mode);
+
+	return size;
+}
+
+static ssize_t debug_keep_mode_store(struct class *class,
+					 struct class_attribute *attr,
+					 const char *buf, size_t size)
+{
+	unsigned int val;
+	ssize_t ret;
+
+	val = -1;
+	ret = kstrtoint(buf, 0, &val);
+	if (ret != 0)
+		return -EINVAL;
+
+	debug_keep_mode = val;
+
+	return size;
+}
+
+static CLASS_ATTR_RO(codec_mm_dump);
+static CLASS_ATTR_RO(codec_mm_scatter_dump);
+static CLASS_ATTR_RO(codec_mm_keeper_dump);
+static CLASS_ATTR_RO(tvp_region);
+static CLASS_ATTR_RW(tvp_enable);
+static CLASS_ATTR_RW(fastplay_enable);
+static CLASS_ATTR_RW(config);
+static CLASS_ATTR_RW(debug);
+//static CLASS_ATTR_RW(debug_mode);
+static CLASS_ATTR_RW(debug_sc_mode);
+static CLASS_ATTR_RW(debug_keep_mode);
+
+static struct attribute *codec_mm_class_attrs[] = {
+	&class_attr_codec_mm_dump.attr,
+	&class_attr_codec_mm_scatter_dump.attr,
+	&class_attr_codec_mm_keeper_dump.attr,
+	&class_attr_tvp_region.attr,
+	&class_attr_tvp_enable.attr,
+	&class_attr_fastplay_enable.attr,
+	&class_attr_config.attr,
+	&class_attr_debug.attr,
+	//&class_attr_debug_mode.attr,
+	&class_attr_debug_sc_mode.attr,
+	&class_attr_debug_keep_mode.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(codec_mm_class);
+
+static struct class codec_mm_class = {
+		.name = "codec_mm",
+		.class_groups = codec_mm_class_groups,
+	};
+
+static struct mconfig codec_mm_configs[] = {
+	MC_PI32("default_tvp_size", &default_tvp_size),
+	MC_PI32("default_tvp_4k_size", &default_tvp_4k_size),
+	MC_PI32("default_cma_res_size", &default_cma_res_size),
+};
+static struct mconfig_node codec_mm_trigger_node;
+int codec_mm_trigger_fun(const char *trigger, int id, const char *buf, int size)
+{
+	int ret = size;
+
+	switch (trigger[0]) {
+	case 't':
+		tvp_enable_store(NULL, NULL, buf, size);
+		break;
+	case 'f':
+		fastplay_enable_store(NULL, NULL, buf, size);
+		break;
+	case 'd':
+		debug_store(NULL, NULL, buf, size);
+		break;
+	default:
+		ret = -1;
+	}
+	return size;
+}
+int codec_mm_trigger_help_fun(const char *trigger, int id, char *sbuf, int size)
+{
+	int ret = -1;
+	void *buf, *getbuf = NULL;
+
+	if (size < PAGE_SIZE) {
+		getbuf = (void *)__get_free_page(GFP_KERNEL);
+
+		if (!getbuf)
+			return -ENOMEM;
+		buf = getbuf;
+	} else {
+		buf = sbuf;
+	}
+	switch (trigger[0]) {
+	case 't':
+		ret = tvp_enable_show(NULL, NULL, buf);
+		break;
+	case 'f':
+		ret = fastplay_enable_show(NULL, NULL, buf);
+		break;
+	case 'd':
+		ret = debug_show(NULL, NULL, buf);
+		break;
+	default:
+		pr_err("unknown trigger:[%s]\n", trigger);
+		ret = -1;
+	}
+	if (ret > 0 && getbuf != NULL) {
+		ret = min_t(int, ret, size);
+
+		strncpy(sbuf, buf, ret);
+	}
+	if (getbuf != NULL)
+		free_page((unsigned long)getbuf);
+	return ret;
+}
+
+static struct mconfig codec_mm_trigger[] = {
+	MC_FUN("tvp_enable", codec_mm_trigger_help_fun, codec_mm_trigger_fun),
+	MC_FUN("fastplay", codec_mm_trigger_help_fun, codec_mm_trigger_fun),
+	MC_FUN("debug", codec_mm_trigger_help_fun, codec_mm_trigger_fun),
+};
+
+
+static int codec_mm_probe(struct platform_device *pdev)
+{
+
+	int r;
+
+	pdev->dev.platform_data = get_mem_mgt();
+	r = of_reserved_mem_device_init(&pdev->dev);
+	if (r == 0)
+		pr_debug("codec_mm_probe mem init done\n");
+
+	codec_mm_mgt_init(&pdev->dev);
+	r = class_register(&codec_mm_class);
+	if (r) {
+		pr_err("vdec class create fail.\n");
+		return r;
+	}
+	r = of_reserved_mem_device_init(&pdev->dev);
+	if (r == 0)
+		pr_debug("codec_mm reserved memory probed done\n");
+
+	pr_info("codec_mm_probe ok\n");
+
+	codec_mm_scatter_mgt_init();
+	codec_mm_keeper_mgr_init();
+	amstream_test_init();
+	codec_mm_scatter_mgt_test();
+	REG_PATH_CONFIGS(CONFIG_PATH, codec_mm_configs);
+	INIT_REG_NODE_CONFIGS(CONFIG_PATH, &codec_mm_trigger_node,
+		"trigger", codec_mm_trigger, CONFIG_FOR_RW | CONFIG_FOR_T);
+	return 0;
+}
+
+static const struct of_device_id amlogic_mem_dt_match[] = {
+	{
+			.compatible = "amlogic, codec, mm",
+		},
+	{},
+};
+
+static struct platform_driver codec_mm_driver = {
+	.probe = codec_mm_probe,
+	.remove = NULL,
+	.driver = {
+			.owner = THIS_MODULE,
+			.name = "codec_mm",
+			.of_match_table = amlogic_mem_dt_match,
+
+		}
+};
+
+static int __init codec_mm_module_init(void)
+{
+
+	pr_err("codec_mm_module_init\n");
+
+	if (platform_driver_register(&codec_mm_driver)) {
+		pr_err("failed to register amports mem module\n");
+		return -ENODEV;
+
+	}
+
+	return 0;
+}
+
+arch_initcall(codec_mm_module_init);
+MODULE_DESCRIPTION("AMLOGIC amports mem  driver");
+MODULE_LICENSE("GPL");
+
+#if 0
+static int __init codec_mm_cma_setup(struct reserved_mem *rmem)
+{
+	int ret;
+	phys_addr_t base, size, align;
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	align = (phys_addr_t) PAGE_SIZE << max(MAX_ORDER - 1, pageblock_order);
+	base = ALIGN(rmem->base, align);
+	size = round_down(rmem->size - (base - rmem->base), align);
+	ret = cma_init_reserved_mem(base, size, 0, &mgt->cma);
+	if (ret) {
+		pr_info("TT:vdec: cma init reserve area failed.\n");
+		mgt->cma = NULL;
+		return ret;
+	}
+#ifndef CONFIG_ARM64
+	dma_contiguous_early_fixup(base, size);
+#endif
+	pr_info("TT:vdec: cma setup\n");
+	return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(codec_mm_cma, "amlogic, codec-mm-cma",
+	codec_mm_cma_setup);
+
+#endif
+static int codec_mm_reserved_init(struct reserved_mem *rmem, struct device *dev)
+{
+	struct codec_mm_mgt_s *mgt = get_mem_mgt();
+
+	mgt->rmem = *rmem;
+	pr_debug("codec_mm_reserved_init %p->%p\n",
+		(void *)mgt->rmem.base,
+		(void *)mgt->rmem.base + mgt->rmem.size);
+	return 0;
+}
+
+static const struct reserved_mem_ops codec_mm_rmem_vdec_ops = {
+	.device_init = codec_mm_reserved_init,
+};
+
+static int __init codec_mm_res_setup(struct reserved_mem *rmem)
+{
+	rmem->ops = &codec_mm_rmem_vdec_ops;
+	pr_debug("vdec: reserved mem setup\n");
+
+	return 0;
+}
+
+RESERVEDMEM_OF_DECLARE(codec_mm_reserved, "amlogic, codec-mm-reserved",
+	codec_mm_res_setup);
+
+module_param(debug_mode, uint, 0664);
+MODULE_PARM_DESC(debug_mode, "\n debug module\n");
+module_param(debug_sc_mode, uint, 0664);
+MODULE_PARM_DESC(debug_sc_mode, "\n debug scatter module\n");
+module_param(debug_keep_mode, uint, 0664);
+MODULE_PARM_DESC(debug_keep_mode, "\n debug keep module\n");
+module_param(tvp_mode, uint, 0664);
+MODULE_PARM_DESC(tvp_mode, "\n tvp module\n");
diff -Naur a/vendor/amlogic/media/common/codec_mm/codec_mm_keeper.c b/vendor/amlogic/media/common/codec_mm/codec_mm_keeper.c
--- a/vendor/amlogic/media/common/codec_mm/codec_mm_keeper.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/codec_mm_keeper.c	2022-06-24 14:37:50.130813817 +0800
@@ -0,0 +1,290 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/codec_mm_keeper.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/list.h>
+#include <linux/genalloc.h>
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/codec_mm_scatter.h>
+#include <linux/amlogic/media/codec_mm/codec_mm_keeper.h>
+
+#include <linux/workqueue.h>
+#include "codec_mm_priv.h"
+#include "codec_mm_scatter_priv.h"
+#define KEEP_NAME "keeper"
+#define MAX_KEEP_FRAME 16
+#define START_KEEP_ID 0x9
+#define MAX_KEEP_ID    (INT_MAX - 1)
+
+struct keep_mem_info {
+	void *handle;
+	int keep_id;
+	int type;
+	int user;
+	u64 delay_on_jiffies64;
+};
+
+struct codec_mm_keeper_mgr {
+	int num;
+	spinlock_t lock;
+	struct delayed_work dealy_work;
+	int work_runs;
+	struct keep_mem_info keep_list[MAX_KEEP_FRAME];
+	int next_id;		/*id for keep & free. */
+};
+
+static struct codec_mm_keeper_mgr codec_keeper_mgr_private;
+static struct codec_mm_keeper_mgr *get_codec_mm_keeper_mgr(void)
+{
+	return &codec_keeper_mgr_private;
+}
+
+int is_codec_mm_keeped(void *mem_handle)
+{
+	return codec_mm_has_owner(mem_handle, KEEP_NAME);
+}
+EXPORT_SYMBOL(is_codec_mm_keeped);
+/*
+*not call in interrupt;
+*/
+int codec_mm_keeper_mask_keep_mem(void *mem_handle, int type)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	int keep_id = -1;
+	int i;
+	unsigned long flags;
+	int ret;
+	int slot_i = -1;
+	int have_samed = 0;
+
+	if (codec_mm_get_keep_debug_mode() & 1)
+		pr_err("codec_mm_keeper_mask_keep_mem %p\n", mem_handle);
+	if (!mem_handle) {
+		pr_err("NULL mem_handle for keeper!!\n");
+		return -2;
+	}
+	if (type != MEM_TYPE_CODEC_MM_SCATTER &&
+		type != MEM_TYPE_CODEC_MM) {
+		pr_err("not valid type for keeper!!,%d\n", type);
+		return -3;
+	}
+	if (type == MEM_TYPE_CODEC_MM_SCATTER) {
+		ret = codec_mm_scatter_inc_for_keeper(mem_handle);
+		if (ret < 0) {
+			pr_err("keeper scatter failed,%d,handle:%p\n",
+				ret, mem_handle);
+			if (codec_mm_get_keep_debug_mode() & 1)
+				codec_mm_dump_all_scatters();
+			return -4;
+		}
+	} else if (type == MEM_TYPE_CODEC_MM) {
+		ret = codec_mm_request_shared_mem(mem_handle, KEEP_NAME);
+		if (ret < 0) {
+			pr_err("keeper codec mm failed,%d,handle:%p\n",
+				ret, mem_handle);
+			return -4;
+		}
+	}
+	spin_lock_irqsave(&mgr->lock, flags);
+	keep_id = mgr->next_id++;
+	if (mgr->next_id >= MAX_KEEP_ID)
+		mgr->next_id = START_KEEP_ID;
+	for (i = 0; i < MAX_KEEP_FRAME; i++) {
+		if (!mgr->keep_list[i].handle && slot_i < 0)
+			slot_i = i;
+		else if (mgr->keep_list[i].handle == mem_handle) {
+			have_samed = 1;
+			keep_id = mgr->keep_list[i].keep_id;
+			break;
+		}
+	}
+	if (slot_i >= 0 && !have_samed) {
+		mgr->keep_list[slot_i].handle = mem_handle;
+		mgr->keep_list[slot_i].keep_id = keep_id;
+		mgr->keep_list[slot_i].type = type;
+		mgr->keep_list[slot_i].user = 1;
+		mgr->num++;
+	} else {
+		if (!have_samed)
+			keep_id = -1;
+	}
+	if (codec_mm_get_keep_debug_mode() & 1) {
+		/*keeped info */
+		pr_err("codec_mm_keeper_mask_keep_mem %p id=%d\n",
+			mem_handle, keep_id);
+	}
+	if (keep_id < 0 || have_samed) {
+		if (type == MEM_TYPE_CODEC_MM_SCATTER)
+			ret = codec_mm_scatter_dec_keeper_user(mem_handle, 0);
+		else if (type == MEM_TYPE_CODEC_MM)
+			codec_mm_release_with_check(mem_handle, KEEP_NAME);
+		if (keep_id < 0)
+			pr_err("keep mem failed because keep buffer fulled!!!\n");
+	}
+	spin_unlock_irqrestore(&mgr->lock, flags);
+
+	return keep_id;
+}
+EXPORT_SYMBOL(codec_mm_keeper_mask_keep_mem);
+
+/*
+*can call in irq
+*/
+int codec_mm_keeper_unmask_keeper(int keep_id, int delayms)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	int i;
+	unsigned long flags;
+
+	if (codec_mm_get_keep_debug_mode() & 1)
+		pr_err("codec_mm_keeper_unmask_keeper %d\n", keep_id);
+	if (keep_id < START_KEEP_ID || keep_id >= MAX_KEEP_ID) {
+		pr_err("invalid keepid %d\n", keep_id);
+		return -1;
+	}
+	spin_lock_irqsave(&mgr->lock, flags);
+	for (i = 0; i < MAX_KEEP_FRAME; i++) {
+		if (keep_id == mgr->keep_list[i].keep_id) {
+			mgr->keep_list[i].user--;	/*mask can free. */
+			mgr->keep_list[i].delay_on_jiffies64 =
+				get_jiffies_64() + delayms * HZ / 1000;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&mgr->lock, flags);
+	schedule_delayed_work(&mgr->dealy_work, delayms);/*do free later, */
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_keeper_unmask_keeper);
+
+static int codec_mm_keeper_free_keep(int index)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	void *mem_handle = NULL;
+	int type;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mgr->lock, flags);
+	mem_handle = mgr->keep_list[index].handle;
+	type = mgr->keep_list[index].type;
+	mgr->keep_list[index].handle = NULL;
+	mgr->keep_list[index].delay_on_jiffies64 = 0;
+	mgr->num--;
+	spin_unlock_irqrestore(&mgr->lock, flags);
+	if (!mem_handle)
+		return -1;
+	if (type == MEM_TYPE_CODEC_MM)
+		codec_mm_release_with_check(mem_handle, KEEP_NAME);
+	else if (type == MEM_TYPE_CODEC_MM_SCATTER) {
+		struct codec_mm_scatter *sc = mem_handle;
+
+		codec_mm_scatter_dec_keeper_user(sc, 0);
+	}
+
+	return 0;
+}
+
+/*
+*can't call it
+*in irq/timer.tasklet
+*/
+int codec_mm_keeper_free_all_keep(int force)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	int i;
+	int time_after, want_free;
+	for (i = 0; i < MAX_KEEP_FRAME; i++) {
+		struct keep_mem_info *info = &mgr->keep_list[i];
+		if (!info->handle || info->keep_id < 0)
+			continue;
+		want_free = 0;
+		time_after = time_after64(get_jiffies_64(),
+				info->delay_on_jiffies64);
+		if (force == 1)
+			want_free = 1;
+		else if (force == 2 && info->user <= 0)
+			want_free = 1;
+		else if (info->user <= 0 && time_after)
+			want_free = 1;
+
+		if (want_free)
+			codec_mm_keeper_free_keep(i);
+	}
+
+	return 0;
+}
+
+int codec_mm_keeper_dump_info(void *buf, int size)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+
+	if (!pbuf)
+		pbuf = sbuf;
+#define BUFPRINT(args...) \
+		do {\
+			s = sprintf(pbuf, args);\
+			tsize += s;\
+			pbuf += s;\
+		} while (0)\
+
+	BUFPRINT("dump keep list:next_id=%d,work_run:%d,num=%d\n",
+			mgr->next_id,
+			mgr->work_runs,
+			mgr->num);
+	for (i = 0; i < MAX_KEEP_FRAME; i++) {
+		BUFPRINT("keeper:[%d]:\t\tid:%d\thandle:%p,type:%d,user:%d\n",
+			i,
+			mgr->keep_list[i].keep_id,
+			mgr->keep_list[i].handle,
+			mgr->keep_list[i].type,
+			mgr->keep_list[i].user);
+	}
+#undef BUFPRINT
+	if (!buf)
+		pr_info("%s", sbuf);
+	return tsize;
+}
+
+static void codec_mm_keeper_monitor(struct work_struct *work)
+{
+	struct codec_mm_keeper_mgr *mgr = container_of(work,
+					struct codec_mm_keeper_mgr,
+					dealy_work.work);
+	mgr->work_runs++;
+	codec_mm_keeper_free_all_keep(0);
+	if (mgr->num > 0) /*have some not free, run later.*/
+		schedule_delayed_work(&mgr->dealy_work, 10);
+}
+
+int codec_mm_keeper_mgr_init(void)
+{
+	struct codec_mm_keeper_mgr *mgr = get_codec_mm_keeper_mgr();
+
+	memset(mgr, 0, sizeof(struct codec_mm_keeper_mgr));
+	mgr->next_id = START_KEEP_ID;
+	spin_lock_init(&mgr->lock);
+	INIT_DELAYED_WORK(&mgr->dealy_work, codec_mm_keeper_monitor);
+	return 0;
+}
diff -Naur a/vendor/amlogic/media/common/codec_mm/codec_mm_keeper_priv.h b/vendor/amlogic/media/common/codec_mm/codec_mm_keeper_priv.h
--- a/vendor/amlogic/media/common/codec_mm/codec_mm_keeper_priv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/codec_mm_keeper_priv.h	2022-06-24 14:37:50.153606920 +0800
@@ -0,0 +1,24 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/codec_mm_keeper_priv.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef CODEC_MM_KEEP_PRIV_HEADER
+#define CODEC_MM_KEEP_PRIV_HEADER
+int codec_mm_keeper_mgr_init(void);
+int codec_mm_keeper_dump_info(void *buf, int size);
+int codec_mm_keeper_free_all_keep(int force);
+
+#endif
diff -Naur a/vendor/amlogic/media/common/codec_mm/codec_mm_priv.h b/vendor/amlogic/media/common/codec_mm/codec_mm_priv.h
--- a/vendor/amlogic/media/common/codec_mm/codec_mm_priv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/codec_mm_priv.h	2022-06-24 14:37:50.174206631 +0800
@@ -0,0 +1,59 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/codec_mm_priv.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef AML_MM_HEADER
+#define AML_MM_HEADER
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+
+#include<linux/printk.h>
+
+#ifndef INFO_PREFIX
+#define INFO_PREFIX "codec_mm"
+#endif
+
+/*#define codec_print(KERN_LEVEL, args...) \*/
+		/*printk(KERN_LEVEL INFO_PREFIX ":" args)*/
+
+
+#define codec_info(args...) pr_info(args)
+#define codec_err(args...)  pr_err(args)
+#define codec_waring(args...)  pr_warn(args)
+
+/*
+ *#ifdef pr_info
+ *#undef pr_info
+ *#undef pr_err
+ *#undef pr_warn
+ *#undef pr_warning
+ *
+ *#define pr_info(args...) codec_info(args)
+ *#define pr_err(args...) codec_err(args)
+ *#define pr_warn(args...) codec_waring(args)
+ *#define pr_warning pr_warn
+ *
+ *#endif
+*/
+
+
+extern void dma_clear_buffer(struct page *page, size_t size);
+
+u32 codec_mm_get_sc_debug_mode(void);
+u32 codec_mm_get_keep_debug_mode(void);
+
+#endif /**/
diff -Naur a/vendor/amlogic/media/common/codec_mm/codec_mm_scatter.c b/vendor/amlogic/media/common/codec_mm/codec_mm_scatter.c
--- a/vendor/amlogic/media/common/codec_mm/codec_mm_scatter.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/codec_mm_scatter.c	2022-06-24 14:37:50.212708286 +0800
@@ -0,0 +1,3038 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/codec_mm_scatter.c
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/cma.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/libfdt_env.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <linux/genalloc.h>
+#include <linux/dma-mapping.h>
+#include <linux/dma-map-ops.h>
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/codec_mm_scatter.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
+#include <linux/completion.h>
+#include <linux/sched/clock.h>
+
+#include "codec_mm_priv.h"
+#include "codec_mm_scatter_priv.h"
+#define KERNEL_ATRACE_TAG KERNEL_ATRACE_TAG_CODEC_MM
+#include <linux/amlogic/meson_atrace.h>
+
+
+#define SCATTER_MEM "SCATTER_MEM"
+
+/*#define PHY_ADDR_NEED_64BITS*/
+#if PAGE_SHIFT >= 12
+#define SID_MASK 0xfff
+#elif PAGE_SHIFT >= 8
+#define SID_MASK 0xff
+#else
+#error "unsupport PAGE_SHIFT PAGE_SHIFT must >= 8" ## PAGE_SHIFT
+#endif
+
+#define MAX_ADDR_SHIFT PAGE_SHIFT
+#define MAX_SID (SID_MASK - 1)
+#define MAX_HASH_SID (MAX_SID - 1)
+
+#define ADDR_SEED(paddr) (((paddr) >> (MAX_ADDR_SHIFT << 1)) +\
+					((paddr) >> MAX_ADDR_SHIFT) +\
+					(paddr))
+
+/*
+*hash ID: 0-MAX_HASH_SID
+*ONE_PAGE_SID: MAX_SID
+*/
+#define HASH_PAGE_ADDR(paddr) (ADDR_SEED(paddr) % MAX_SID)
+#define SLOT_TO_SID(slot)	HASH_PAGE_ADDR(((slot->phy_addr)>>PAGE_SHIFT))
+
+#define ONE_PAGE_SID (SID_MASK)
+#define PAGE_SID(mm_page)  (page_sid_type)((mm_page) & SID_MASK)
+#define PAGE_ADDR(mm_page) (ulong)(((mm_page) >> MAX_ADDR_SHIFT)\
+			<< MAX_ADDR_SHIFT)
+
+#define ADDR2PAGE(addr, sid)	(((addr) & (~SID_MASK)) | (sid))
+
+#define PAGE_SID_OF_MMS(mms, id) PAGE_SID((mms)->pages_list[id])
+#define PAGE_ADDR_OF_MMS(mms, id) PAGE_ADDR((mms)->pages_list[id])
+
+#define INVALID_ID(mms, id) (!(mms) ||\
+					!(mms)->pages_list ||\
+					(mms)->page_cnt <= (id) ||\
+					(id) < 0)
+
+#define SID_OF_ONEPAGE(sid)	   ((sid) == ONE_PAGE_SID)
+#define ADDR2BIT(base, addr)  (((addr) - (base)) >> PAGE_SHIFT)
+#define BIT2ADDR(base, bit)   ((base) + (1<<PAGE_SHIFT) * (bit))
+#define VALID_SID(sid) (((sid) < MAX_SID) || SID_OF_ONEPAGE(sid))
+#define VALID_BIT(slot, bit) (bit >= 0 && ((slot->pagemap_size << 3) > bit))
+#define CODEC_MM_S_ERR(x) ((-1000) - (x))
+
+/*#define SCATTER_DEBUG*/
+#define ERR_LOG(args...) pr_err(args)
+#define WAR_LOG(args...) pr_warn(args)
+#define INFO_LOG(args...) pr_info(args)
+
+#ifdef SCATTER_DEBUG
+#define DBG_LOG(args...) pr_info(args)
+#else
+#define DBG_LOG(args...)
+#endif
+#define MAX_SYS_BLOCK_PAGE 128
+#define MIN_SYS_BLOCK_PAGE 8
+
+/*#define USE_KMALLOC_FOR_SCATTER*/
+#ifdef USE_KMALLOC_FOR_SCATTER
+#define SC_ALLOC(s, f) kmalloc(s, f)
+#define SC_FREE(p) kfree(p)
+#else
+#define SC_ALLOC(s, f) vmalloc(s)
+#define SC_FREE(p) vfree(p)
+
+#endif
+#define MAX_SC_LIST 64
+#define MK_TAG(a, b, c, d) (((a) << 24) | ((b) << 16) |\
+					((c) << 8) | d)
+#define SMGT_IDENTIFY_TAG MK_TAG('Z', 'S', 'C', 'Z')
+
+struct codec_mm_scatter_s {
+	u32 keep_size_PAGE;
+	u32 reserved_block_mm_M;
+	u32 try_alloc_in_cma_page_cnt;
+	u32 try_alloc_in_sys_page_cnt_max;
+	u32 try_alloc_in_sys_page_cnt_min;
+	u32 enable_slot_from_sys;
+	u32 no_cache_size_M;
+	u32 support_from_slot_sys;
+	u32 no_alloc_from_sys;
+};
+
+struct codec_mm_scatter_mgt {
+	unsigned int tag;/*=*/
+	struct codec_mm_slot *slot_list_map[MAX_SID];
+	int tvp_mode;
+	int codec_mm_num;
+	int total_page_num;
+	int alloced_page_num;
+	int max_alloced;
+	u32 try_alloc_in_cma_page_cnt;
+	u32 try_alloc_in_sys_page_cnt;
+	u32 try_alloc_in_sys_page_cnt_max;
+	u32 try_alloc_in_sys_page_cnt_min;
+	int alloc_from_cma_first;
+	u32 enable_slot_from_sys;
+	u32 no_cache_size_M;
+	u32 no_alloc_from_sys;
+	u32 support_from_slot_sys;
+	int one_page_cnt;
+	int scatters_cnt;
+	int slot_cnt;
+	u32 reserved_block_mm_M;
+	u32 keep_size_PAGE;
+	int mem_flags;
+
+	int alloc_from_sys_sc_cnt;
+	int alloc_from_sys_page_cnt;
+	int alloc_from_sys_max_page_cnt;
+
+	int delay_free_on;
+	int force_cache_on;
+	int force_cache_page_cnt;
+	u64 delay_free_timeout_jiffies64;
+
+/*time states*/
+	int alloc_max_us;
+	u64 alloc_total_us;
+	int alloc_cnt;
+	int alloc_10us_less_cnt;
+	int alloc_10_50us_cnt;
+	int alloc_50_100us_cnt;
+	int alloc_100_1000us_cnt;
+	int alloc_1_10ms_cnt;
+	int alloc_10_100ms_cnt;
+	int alloc_100ms_up_cnt;
+/*free time states*/
+	int free_max_us;
+	u64 free_total_us;
+	int free_cnt;
+	int free_10us_less_cnt;
+	int free_10_50us_cnt;
+	int free_50_100us_cnt;
+	int free_100_1000us_cnt;
+	int free_1_10ms_cnt;
+	int free_10_100ms_cnt;
+	int free_100ms_up_cnt;
+
+	struct delayed_work dealy_work;
+	int scatter_task_run_num;
+	struct codec_mm_scatter *cache_scs[2];
+	int cached_pages;
+	spinlock_t list_lock;
+	struct mutex monitor_lock;
+	struct completion complete;
+	struct list_head free_list;	/*slot */
+	struct list_head scatter_list;	/*scatter list */
+	struct codec_mm_scatter *scmap[MAX_SC_LIST];/*used for valid check. */
+};
+#define is_cache_sc(smgt, mms)  ((smgt->cache_scs[0] == mms) ||\
+						(smgt->cache_scs[1] == mms))
+
+static struct codec_mm_scatter_s g_scatter;
+static struct codec_mm_scatter_mgt *scatter_mgt;
+static struct codec_mm_scatter_mgt *scatter_tvp_mgt;
+static struct codec_mm_scatter_mgt *codec_mm_get_scatter_mgt(
+	int is_tvp)
+{
+	if (is_tvp)
+		return scatter_tvp_mgt;
+	return scatter_mgt;
+}
+int codec_mm_scatter_valid_locked(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms);
+
+/*#define MY_MUTEX_DEBUG*/
+#ifdef MY_MUTEX_DEBUG
+#define codec_mm_scatter_lock(s) \
+	codec_mm_scatter_lock_debug(s, __LINE__)
+
+#define codec_mm_list_lock(s) \
+	codec_mm_list_lock_debug(s, __LINE__)
+
+static inline int mutex_trylock_time(
+	struct mutex *lock, int wait)
+{
+	unsigned long timeout = jiffies + wait;
+	int locked = mutex_trylock(lock);
+
+	while (!locked && time_before(jiffies, timeout)) {
+		msleep(20);
+		locked = mutex_trylock(lock);
+	}
+	return locked;
+}
+
+#define TRY_MLOCK_INFO(lock, line, time, info)\
+		static int last_lock_line;\
+		while (!mutex_trylock_time((lock), time)) {\
+			pr_err(info " mutex has lock on %d,new lock on %d\n",\
+			last_lock_line, line);\
+		} \
+		last_lock_line = line;\
+
+
+static inline int spin_trylock_time(
+			spinlock_t *lock, int wait)
+{
+	unsigned long timeout = jiffies + wait;
+	int locked = spin_trylock(lock);
+
+	while (!locked && time_before(jiffies, timeout)) {
+		msleep(20);
+		locked = spin_trylock(lock);
+	}
+	return locked;
+}
+
+#define TRY_SLOCK_INFO(lock, line, time, info)\
+		static int last_lock_line;\
+		while (!spin_trylock_time((lock), time)) {\
+			pr_err(info " spin has lock on %d,new lock on %d\n",\
+			last_lock_line, line);\
+		} \
+		last_lock_line = line;\
+
+
+static inline void codec_mm_scatter_lock_debug(
+	struct codec_mm_scatter *mms,
+	int line)
+{
+	TRY_MLOCK_INFO(&mms->mutex, line, 10 * HZ, "mms");
+}
+
+static inline void codec_mm_list_lock_debug(
+	struct codec_mm_scatter_mgt *smgt, int line)
+{
+	TRY_SLOCK_INFO(&smgt->list_lock, line, 10 * HZ, "list");
+}
+#else
+static inline void codec_mm_scatter_lock(
+	struct codec_mm_scatter *mms)
+{
+	mutex_lock(&mms->mutex);
+}
+static inline int codec_mm_scatter_trylock(
+	struct codec_mm_scatter *mms)
+{
+	return mutex_trylock(&mms->mutex);
+}
+
+static inline void codec_mm_list_lock(
+	struct codec_mm_scatter_mgt *smgt)
+{
+	spin_lock(&smgt->list_lock);
+}
+#endif
+static inline void codec_mm_scatter_unlock(
+	struct codec_mm_scatter *mms)
+{
+	mutex_unlock(&mms->mutex);
+}
+
+static inline void codec_mm_list_unlock(
+	struct codec_mm_scatter_mgt *smgt)
+{
+	spin_unlock(&smgt->list_lock);
+}
+
+static int codec_mm_scatter_alloc_want_pages_in(
+		struct codec_mm_scatter_mgt *smgt,
+		struct codec_mm_scatter *mms,
+		int want_pages);
+
+static struct workqueue_struct *codec_mm_scatter_wq_get(void)
+{
+	static struct workqueue_struct *codec_mm_scatter_wq;
+
+	if (!codec_mm_scatter_wq) {
+		codec_mm_scatter_wq =
+			create_singlethread_workqueue("codec_mm_sc");
+	}
+	return codec_mm_scatter_wq;
+}
+
+
+static int codec_mm_schedule_delay_work(struct codec_mm_scatter_mgt *smgt,
+	int delay_ms, int for_update)
+{
+	bool ret;
+	if (!for_update && delayed_work_pending(&smgt->dealy_work))
+		return 0;
+	if (delayed_work_pending(&smgt->dealy_work))
+		cancel_delayed_work(&smgt->dealy_work);
+	if (codec_mm_scatter_wq_get()) {
+		ret = queue_delayed_work(codec_mm_scatter_wq_get(),
+			&smgt->dealy_work, delay_ms * HZ / 1000);
+	} else
+		ret = schedule_delayed_work(&smgt->dealy_work,
+			delay_ms * HZ / 1000);
+	return ret;
+}
+
+static inline u64 codec_mm_get_current_us(void)
+{
+	return div64_u64(local_clock(), 1000);
+}
+
+static void codec_mm_update_alloc_time(
+	struct codec_mm_scatter_mgt *smgt, u64 startus)
+{
+	int spend_time_us;
+
+	spend_time_us = (int)(codec_mm_get_current_us() - startus);
+	if (spend_time_us > 0 && spend_time_us < 100000000) {
+		/*	>0 && less than 100s*/
+			/*else think time base changed.*/
+		smgt->alloc_cnt++;
+		if (spend_time_us < 10)
+			smgt->alloc_10us_less_cnt++;
+		else if (spend_time_us < 50)
+			smgt->alloc_10_50us_cnt++;
+		else if (spend_time_us < 100)
+			smgt->alloc_50_100us_cnt++;
+		else if (spend_time_us < 1000)
+			smgt->alloc_100_1000us_cnt++;
+		else if (spend_time_us < 10000)
+			smgt->alloc_1_10ms_cnt++;
+		else if (spend_time_us < 100000)
+			smgt->alloc_10_100ms_cnt++;
+		else
+			smgt->alloc_100ms_up_cnt++;
+
+		smgt->alloc_total_us += spend_time_us;
+		if (spend_time_us > smgt->alloc_max_us) {
+			/*..*/
+			smgt->alloc_max_us  = spend_time_us;
+		}
+	}
+}
+
+static void codec_mm_update_free_time(
+	struct codec_mm_scatter_mgt *smgt, u64 startus)
+{
+	int spend_time_us;
+
+	spend_time_us = (int)(codec_mm_get_current_us() - startus);
+	if (spend_time_us > 0 && spend_time_us < 100000000) {
+		/*	>0 && less than 100s*/
+			/*else think time base changed.*/
+		smgt->free_cnt++;
+		if (spend_time_us < 10)
+			smgt->free_10us_less_cnt++;
+		else if (spend_time_us < 50)
+			smgt->free_10_50us_cnt++;
+		else if (spend_time_us < 100)
+			smgt->free_50_100us_cnt++;
+		else if (spend_time_us < 1000)
+			smgt->free_100_1000us_cnt++;
+		else if (spend_time_us < 10000)
+			smgt->free_1_10ms_cnt++;
+		else if (spend_time_us < 100000)
+			smgt->free_10_100ms_cnt++;
+		else
+			smgt->free_100ms_up_cnt++;
+
+		smgt->free_total_us += spend_time_us;
+		if (spend_time_us > smgt->free_max_us) {
+			/*..*/
+			smgt->free_max_us	= spend_time_us;
+		}
+	}
+}
+
+static void codec_mm_clear_alloc_infos_in(
+	struct codec_mm_scatter_mgt *smgt)
+{
+	smgt->alloc_cnt = 0;
+	smgt->alloc_10us_less_cnt = 0;
+	smgt->alloc_10_50us_cnt = 0;
+	smgt->alloc_50_100us_cnt = 0;
+	smgt->alloc_100_1000us_cnt = 0;
+	smgt->alloc_1_10ms_cnt = 0;
+	smgt->alloc_10_100ms_cnt = 0;
+	smgt->alloc_100ms_up_cnt = 0;
+	smgt->alloc_total_us = 0;
+	smgt->alloc_max_us = 0;
+
+	smgt->free_cnt = 0;
+	smgt->free_10us_less_cnt = 0;
+	smgt->free_10_50us_cnt = 0;
+	smgt->free_50_100us_cnt = 0;
+	smgt->free_100_1000us_cnt = 0;
+	smgt->free_1_10ms_cnt = 0;
+	smgt->free_10_100ms_cnt = 0;
+	smgt->free_100ms_up_cnt = 0;
+	smgt->free_total_us = 0;
+	smgt->free_max_us = 0;
+}
+void codec_mm_clear_alloc_infos(void)
+{
+	codec_mm_clear_alloc_infos_in(codec_mm_get_scatter_mgt(0));
+	codec_mm_clear_alloc_infos_in(codec_mm_get_scatter_mgt(1));
+}
+
+#if 0
+static int codec_mm_slot_get_info(struct codec_mm_scatter_mgt *smgt,
+			int *free_pages, int *slot_num, int *max_sg_pages)
+{
+	struct codec_mm_slot *slot;
+	int total_pages = 0;
+	int alloced_pages = 0;
+	int slot_used_num = 0;
+	int max_free_pages_sg = 0;
+
+	codec_mm_list_lock(smgt);
+	if (!list_empty(&smgt->free_list)) {
+		struct list_head *header, *list;
+
+		header = &smgt->free_list;
+		list = header->prev;
+		while (list != header) {
+			slot = list_entry(list, struct codec_mm_slot,
+				free_list);
+			total_pages += slot->page_num;
+			alloced_pages += slot->alloced_page_num;
+			slot_used_num++;
+			if (slot->page_num - slot->alloced_page_num >
+					max_free_pages_sg)
+				max_free_pages_sg = slot->page_num -
+					slot->alloced_page_num;
+			list = list->prev;
+		};
+	}
+	codec_mm_list_unlock(smgt);
+	if (total_pages < alloced_pages)
+		return 0;
+	*free_pages = total_pages - alloced_pages;
+	*slot_num = slot_used_num;
+	*max_sg_pages = max_free_pages_sg;
+	return 0;
+}
+#endif
+
+static int codec_mm_set_slot_in_hash(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_slot *slot)
+{
+
+	page_sid_type sid = SLOT_TO_SID(slot);
+
+	if (sid > MAX_SID) {
+		ERR_LOG("ERROR sid %d", sid);
+		return -1;
+	}
+	slot->sid = sid;
+	INIT_LIST_HEAD(&slot->sid_list);
+	INIT_LIST_HEAD(&slot->free_list);
+	codec_mm_list_lock(smgt);
+	if (!smgt->slot_list_map[sid]) {
+		smgt->slot_list_map[sid] = slot;
+		slot->isroot = 1;
+	} else {
+		struct codec_mm_slot *f_slot = smgt->slot_list_map[sid];
+
+		list_add_tail(&slot->sid_list, &f_slot->sid_list);
+		slot->isroot = 0;
+	}
+	smgt->total_page_num += slot->page_num;
+	smgt->slot_cnt++;
+	if (slot->from_type == SLOT_FROM_GET_FREE_PAGES) {
+		smgt->alloc_from_sys_sc_cnt++;
+		smgt->alloc_from_sys_page_cnt += slot->page_num;
+		if (smgt->alloc_from_sys_page_cnt >
+			smgt->alloc_from_sys_max_page_cnt)
+			smgt->alloc_from_sys_max_page_cnt =
+				smgt->alloc_from_sys_page_cnt;
+	}
+	list_add_tail(&slot->free_list, &smgt->free_list);
+	codec_mm_list_unlock(smgt);
+	return 0;
+}
+
+static struct codec_mm_slot *codec_mm_find_slot_in_hash(
+	struct codec_mm_scatter_mgt *smgt,
+	page_sid_type sid, ulong addr)
+{
+	struct codec_mm_slot *fslot, *slot;
+
+	if (!VALID_SID(sid) || SID_OF_ONEPAGE(sid))
+		return NULL;
+	codec_mm_list_lock(smgt);
+	fslot = smgt->slot_list_map[sid];
+	if (!fslot) {
+		ERR_LOG("not valid sid %d\n",
+			(int)sid);
+		goto err;
+	}
+	slot = fslot;
+	while (!(addr >= slot->phy_addr &&	/*optimization with hash? */
+			 addr <
+			 (slot->phy_addr +
+			(slot->page_num << PAGE_SHIFT)))) {
+		/*not in range. */
+
+		slot = list_entry(slot->sid_list.prev,
+			struct codec_mm_slot, sid_list);
+		/*
+		*pr_err("Slot range from =%p->%p\n",
+		*(void *)slot->phy_addr,
+		*(void *)slot->phy_addr +
+		*(slot->page_num << PAGE_SHIFT));
+		*/
+		if (slot == fslot) {
+			ERR_LOG("can't find valid slot, for addr =%p\n",
+				(void *)addr);
+			goto err;
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	return slot;
+err:
+	codec_mm_list_unlock(smgt);
+	return NULL;
+}
+
+static int codec_mm_slot_free(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_slot *slot)
+{
+	int ret = 0;
+
+	codec_mm_list_lock(smgt);
+	if (slot->alloced_page_num > 0 || slot->on_alloc_free) {
+		codec_mm_list_unlock(smgt);
+		return -1;
+	}
+	if (!list_empty(&slot->free_list))
+		list_del(&slot->free_list);
+	if (!list_empty(&slot->sid_list)) {
+		if (slot->isroot) {
+			struct codec_mm_slot *next_slot;
+
+			next_slot = list_entry(slot->sid_list.next,
+				struct codec_mm_slot, sid_list);
+			next_slot->isroot = 1;
+			smgt->slot_list_map[slot->sid] = next_slot;
+		}
+		list_del(&slot->sid_list);
+	} else {		/*no sid list,clear map */
+		smgt->slot_list_map[slot->sid] = NULL;
+	}
+	smgt->slot_cnt--;
+	smgt->total_page_num -= slot->page_num;
+	if (slot->from_type == SLOT_FROM_GET_FREE_PAGES) {
+		smgt->alloc_from_sys_sc_cnt--;
+		smgt->alloc_from_sys_page_cnt -= slot->page_num;
+	}
+	codec_mm_list_unlock(smgt);
+	switch (slot->from_type) {
+	case SLOT_FROM_CODEC_MM:
+		if (slot->mm)
+			codec_mm_release(slot->mm, SCATTER_MEM);
+		else
+			ERR_LOG("ERR:slot->mm is ERROR:%p\n", slot->mm);
+		break;
+	case SLOT_FROM_GET_FREE_PAGES:
+		if (slot->page_header != 0)
+			free_pages(slot->page_header,
+				get_order(PAGE_SIZE * slot->page_num));
+		else
+			ERR_LOG("ERR:slot->page_header is ERROR:%p\n",
+				(void *)slot->page_header);
+		break;
+		/*other */
+	default:
+		ERR_LOG("unknown from type:%d\n", slot->from_type);
+		ret = -1;
+	}
+
+	kfree(slot->pagemap);
+	kfree(slot);
+	return 0;
+}
+static int codec_mm_slot_try_free(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_slot *slot)
+{
+	if (smgt->keep_size_PAGE > 0) {
+		/*delay free, when size < delay_free_M MB */
+		int free_pages = smgt->total_page_num - smgt->alloced_page_num;
+
+		if (free_pages < smgt->keep_size_PAGE)
+			return -1;
+	}
+	return codec_mm_slot_free(smgt, slot);
+}
+
+static inline int codec_mm_slot_init_bitmap(struct codec_mm_slot *slot)
+{
+	slot->alloced_page_num = 0;
+	/*bytes = 8bits for 8 pages.
+	*1 more for less than 8 page.
+	*another for reserved.
+	*/
+	slot->pagemap_size = (slot->page_num >> 3) + 2;
+	slot->pagemap = kmalloc(slot->pagemap_size, GFP_KERNEL);
+	if (!slot->pagemap) {
+		ERR_LOG("ERROR.init pagemap failed\n");
+		return -1;
+	}
+	memset(slot->pagemap, 0, slot->pagemap_size);
+	slot->next_bit = 0;
+	return 0;
+}
+
+/*
+*flags : 1. don't used codecmm.
+*/
+static struct codec_mm_slot *codec_mm_slot_alloc(
+	struct codec_mm_scatter_mgt *smgt,
+	int size, int flags)
+{
+	struct codec_mm_slot *slot;
+	struct codec_mm_s *mm;
+	int try_alloc_size = size;
+	int have_alloced = 0;
+
+	if (try_alloc_size > 0 && try_alloc_size <= PAGE_SIZE)
+		return NULL;	/*don't alloc less than one PAGE. */
+	slot = kmalloc(sizeof(struct codec_mm_slot), GFP_KERNEL);
+	if (!slot)
+		return NULL;
+	memset(slot, 0, sizeof(struct codec_mm_slot));
+	do {
+		if (flags & 1)
+			break;	/*ignore codec_mm */
+		if ((try_alloc_size <= 0 ||
+			try_alloc_size > 64 * 1024) &&	/*must > 512K. */
+			(smgt->tvp_mode ||
+				(codec_mm_get_free_size() >
+				smgt->reserved_block_mm_M * SZ_1M))) {
+			/*try from codec_mm */
+			if (try_alloc_size <= 0) {
+				try_alloc_size =
+					smgt->try_alloc_in_cma_page_cnt *
+					PAGE_SIZE;
+			}
+			if (codec_mm_get_free_size() < try_alloc_size)
+				try_alloc_size = codec_mm_get_free_size();
+			mm = codec_mm_alloc(SCATTER_MEM, try_alloc_size, 0,
+					CODEC_MM_FLAGS_FOR_VDECODER |
+					CODEC_MM_FLAGS_FOR_SCATTER |
+					(smgt->tvp_mode ?
+						CODEC_MM_FLAGS_TVP : 0)
+					);
+			if (mm != NULL) {
+				slot->from_type = SLOT_FROM_CODEC_MM;
+				slot->mm = mm;
+				slot->page_num = mm->page_count;
+				slot->phy_addr = mm->phy_addr;
+				codec_mm_slot_init_bitmap(slot);
+				if (slot->pagemap == NULL) {
+					codec_mm_release(mm, SCATTER_MEM);
+					break;	/*try next. */
+				}
+				have_alloced = 1;
+				DBG_LOG("alloced from codec mm %d!!!\n",
+					slot->page_num);
+			}
+		}
+	} while (0);
+	if (!have_alloced && !smgt->support_from_slot_sys) {
+		/*not enabled from sys */
+		goto error;
+	}
+	if (!have_alloced) {	/*init for sys alloc */
+		if (size <= 0)
+			try_alloc_size =
+				smgt->try_alloc_in_sys_page_cnt << PAGE_SHIFT;
+		else
+			try_alloc_size = PAGE_ALIGN(size);
+		if (try_alloc_size <= PAGE_SIZE << 1) {
+			DBG_LOG("try too small %d, try one page now,\n",
+				try_alloc_size);
+			goto error;	/*don't alloc 1 page with slot. */
+		}
+	}
+	if (!have_alloced) {
+		/*tvp not support alloc from sys.*/
+		if (smgt->tvp_mode || smgt->no_alloc_from_sys)
+			goto error;
+	}
+	while (!have_alloced) {
+		/*don't alloc 1 page with slot. */
+		/*try alloc from sys. */
+		int page_order = get_order(try_alloc_size);
+		slot->page_header = __get_free_pages(
+			__GFP_IO | __GFP_NOWARN | __GFP_NORETRY,
+			page_order);
+		if (!slot->page_header) {
+			if ((try_alloc_size >> (PAGE_SHIFT + 1)) >=
+				smgt->try_alloc_in_sys_page_cnt_min) {
+				try_alloc_size = try_alloc_size >> 1;
+				smgt->try_alloc_in_sys_page_cnt =
+					try_alloc_size >> PAGE_SHIFT;
+				continue;	/*try less block memory. */
+			} else {
+				/*disabled from sys
+				   *may auto enabled when free more.
+				 */
+				smgt->support_from_slot_sys = 0;
+				/*
+				 * ERR_LOG("alloc sys failed size =%d!!!\n",
+				 *	try_alloc_size);
+				 */
+				goto error;
+			}
+		}
+		slot->from_type = SLOT_FROM_GET_FREE_PAGES;
+		slot->mm = NULL;
+		slot->page_num = 1 << page_order;
+		slot->phy_addr =
+			virt_to_phys((unsigned long *)slot->page_header);
+		codec_mm_slot_init_bitmap(slot);
+		if (slot->pagemap == NULL) {
+			free_pages(slot->page_header, page_order);
+			goto error;
+		}
+		have_alloced = 1;
+		break;
+	}
+	codec_mm_set_slot_in_hash(smgt, slot);
+
+	return slot;
+error:
+	kfree(slot);
+	return NULL;
+}
+
+static int codec_mm_slot_free_page(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_slot *slot, ulong phy_addr)
+{
+	int bit;
+
+	if (!slot || !slot->pagemap || slot->page_num <= 0)
+		return CODEC_MM_S_ERR(4);
+
+	bit = ADDR2BIT(slot->phy_addr, phy_addr);
+	if (!VALID_BIT(slot, bit))
+		return CODEC_MM_S_ERR(5);	/*!!!out of page map.!! */
+	codec_mm_list_lock(smgt);
+	slot->on_alloc_free++;
+	if (!test_and_clear_bit(bit, slot->pagemap)) {
+		ERR_LOG("ERROR,page is ready free before!!! page=%p\n",
+			(void *)phy_addr);
+		slot->on_alloc_free--;
+		codec_mm_list_unlock(smgt);
+		return CODEC_MM_S_ERR(6);
+	}
+	slot->alloced_page_num--;
+	slot->on_alloc_free--;
+	codec_mm_list_unlock(smgt);
+	return 0;
+}
+
+static int codec_mm_slot_alloc_pages(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_slot *slot,
+	phy_addr_type  *pages, int num)
+{
+	int alloced = 0;
+	int need = num;
+	int can_alloced;
+	phy_addr_type page;
+	int tryn;
+	int i;
+
+	if (!slot || !slot->pagemap)
+		return -1;
+	if (slot->alloced_page_num >= slot->page_num)
+		return -2;
+	tryn = slot->page_num;
+	can_alloced = slot->page_num - slot->alloced_page_num;
+	need = need > can_alloced ? can_alloced : need;
+	i = slot->next_bit;
+	/*if not one alloc free. quit this one */
+	while (need > 0 && (slot->on_alloc_free == 1)) {
+		if (!VALID_BIT(slot, i)) {
+			ERR_LOG("ERROR alloc in slot %p\n",
+					slot);
+			ERR_LOG("\ti=%d,slot->pagemap=%p\n",
+					i,
+					slot->pagemap);
+			break;
+		}
+		codec_mm_list_lock(smgt);
+		if (!test_and_set_bit(i, slot->pagemap)) {
+			page = ADDR2PAGE(BIT2ADDR(slot->phy_addr, i),
+				slot->sid);
+			slot->alloced_page_num++;
+			pages[alloced] = page;
+			alloced++;
+			need--;
+		}
+		codec_mm_list_unlock(smgt);
+		i++;
+		if (i >= slot->page_num)
+			i = 0;
+		if (--tryn <= 0)
+			break;
+	}
+	slot->next_bit = i;
+	if (i >= slot->page_num)
+		slot->next_bit = 0;
+	DBG_LOG("alloced from %p, %d,%d,%d\n",
+			slot, slot->page_num,
+			slot->alloced_page_num, alloced);
+	return alloced;
+}
+
+static inline phy_addr_type codec_mm_get_page_addr(
+		struct codec_mm_scatter *mms,
+		int id)
+{
+	phy_addr_type page;
+
+	if (INVALID_ID(mms, id))
+		return 0;
+	page = mms->pages_list[id];
+	return PAGE_ADDR(page);
+}
+
+static inline page_sid_type codec_mm_get_page_sid(
+		struct codec_mm_scatter *mms,
+		int id)
+{
+	phy_addr_type page;
+
+	if (INVALID_ID(mms, id))
+		return 0;
+	page = mms->pages_list[id];
+	return PAGE_SID(page);
+}
+
+static int codec_mm_page_free_to_slot(
+	struct codec_mm_scatter_mgt *smgt,
+	page_sid_type sid, ulong addr)
+{
+	struct codec_mm_slot *slot;
+	int ret;
+	int slot_free = 0;
+
+	slot = codec_mm_find_slot_in_hash(smgt, sid, addr);
+	if (!slot)
+		return -1;
+	ret = codec_mm_slot_free_page(smgt, slot, addr);
+	if (ret != 0)
+		ERR_LOG("free slot addr error =%p ret=%d\n",
+			(void *)addr, ret);
+
+	if (slot->alloced_page_num == 0)
+		slot_free = (codec_mm_slot_try_free(smgt, slot) == 0);
+
+	if (!slot_free) {	/*move to have free list. */
+		codec_mm_list_lock(smgt);
+		if (list_empty(&slot->free_list) &&
+			(slot->alloced_page_num < slot->page_num)) {
+			DBG_LOG("add to  free %p, %d,%d,%d\n",
+				slot, slot->page_num,
+				slot->alloced_page_num, ret);
+			list_add_tail(&slot->free_list, &smgt->free_list);
+		}
+		codec_mm_list_unlock(smgt);
+	}
+
+	return 0;
+}
+
+static int codec_mm_page_alloc_from_one_pages(
+	struct codec_mm_scatter_mgt *smgt,
+	phy_addr_type *pages, int num)
+{
+	int neednum = num;
+	int alloced = 0;
+
+	while (neednum > 0) {	/*one page  alloc */
+		void *vpage = (void *)__get_free_page(GFP_KERNEL);
+		ulong page;
+		page_sid_type sid;
+
+		if (vpage != NULL) {
+			page = virt_to_phys(vpage);
+			sid = ONE_PAGE_SID;
+			page |= sid;
+			pages[alloced++] = page;
+			neednum--;
+		} else {
+			/*can't alloced memofy from ONEPAGE alloc */
+			WAR_LOG("Out of memory OnePage alloc =%d,%d\n",
+				alloced, num);
+			break;
+		}
+	}
+	codec_mm_list_lock(smgt);
+	smgt->total_page_num += alloced;
+	smgt->one_page_cnt += alloced;
+	smgt->alloced_page_num += alloced;
+	codec_mm_list_unlock(smgt);
+	return alloced;
+}
+
+static int codec_mm_page_alloc_from_slot(
+	struct codec_mm_scatter_mgt *smgt,
+	phy_addr_type *pages, int num)
+{
+	struct codec_mm_slot *slot = NULL;
+	int alloced = 0;
+	int neednum = num;
+	int n;
+
+	codec_mm_list_lock(smgt);
+	if (!smgt->tvp_mode &&
+		list_empty(&smgt->free_list) &&
+		(codec_mm_get_free_size() </*no codec mm*/
+		smgt->reserved_block_mm_M * SZ_1M) &&
+		!smgt->support_from_slot_sys) {/*no sys*/
+		codec_mm_list_unlock(smgt);
+		return 0;
+	}
+	codec_mm_list_unlock(smgt);
+
+	do {
+		slot = NULL;
+		if (smgt->total_page_num <= 0 ||	/*no codec mm. */
+			smgt->alloced_page_num == smgt->total_page_num ||
+			list_empty(&smgt->free_list)) {
+			/*codec_mm_scatter_info_dump(NULL, 0);*/
+			slot = codec_mm_slot_alloc(smgt, 0, 0);
+			if (!slot) {
+				u32 alloc_pages =
+					 smgt->try_alloc_in_cma_page_cnt/4;
+				/*
+				   *ERR_LOG("can't alloc slot from system\n");
+				 */
+				if (codec_mm_get_sc_debug_mode() &
+						0x01) {
+					pr_info("alloc default cma size fail, try %d pages\n",
+							alloc_pages);
+				}
+				slot = codec_mm_slot_alloc(smgt,
+					 alloc_pages * PAGE_SIZE, 0);
+				if (!slot) {
+					if (codec_mm_get_sc_debug_mode() &
+						0x01) {
+						pr_info("slot alloc 4M fail!\n");
+					}
+					break;
+				}
+			}
+		}
+		codec_mm_list_lock(smgt);
+		if (slot && slot->on_alloc_free != 0) {
+			ERR_LOG("the slot on alloc/free1: %d\n",
+				slot->on_alloc_free);
+			slot = NULL;	/*slot used on another alloc. */
+		}
+		if (!slot && !list_empty(&smgt->free_list)) {
+			slot = list_entry(smgt->free_list.next,
+				struct codec_mm_slot, free_list);
+			if (!slot)
+				ERR_LOG("ERROR!!!!.slot is NULL!!!!\n");
+			else if (slot->on_alloc_free != 0) {
+				ERR_LOG("the slot on alloc/free: %d\n",
+					slot->on_alloc_free);
+				slot = NULL;
+			}
+		}
+		if (slot && slot->on_alloc_free == 0) {	/*del from free list. */
+			slot->on_alloc_free++;
+			list_del_init(&slot->free_list);
+		} else {
+			slot = NULL;
+		}
+		codec_mm_list_unlock(smgt);
+		if (slot) {
+			n = codec_mm_slot_alloc_pages(smgt,
+				slot,
+				&pages[alloced], neednum);
+			codec_mm_list_lock(smgt);
+			slot->on_alloc_free--;	/*alloc use end */
+			if (slot->alloced_page_num < slot->page_num &&
+				list_empty(&slot->free_list)) {
+				DBG_LOG("slot have free: %p, t:%d,a:%d,%d\n",
+					slot, slot->page_num,
+					slot->alloced_page_num, alloced);
+				list_add_tail(&slot->free_list,
+					&smgt->free_list);
+				/*no free now, del from free list.,*/
+				   /*and init to empty */
+			}
+			codec_mm_list_unlock(smgt);
+			if (n > 0) {
+				alloced += n;
+				neednum -= n;
+			} else {
+				DBG_LOG("alloced fail neednum:%d n=%d\n",
+					neednum, n);
+				DBG_LOG("smgt->free_list.next:%p\n",
+					smgt->free_list.next);
+				DBG_LOG("smgt->free_list.prev:%p\n",
+					smgt->free_list.prev);
+				DBG_LOG("slot->free_list:%p\n",
+					&slot->free_list);
+				DBG_LOG("slot->free_list.next:%p\n",
+					slot->free_list.next);
+				/*codec_mm_dump_slot(slot, NULL, 0); */
+				continue;	/*try next. */
+			}
+		} else {
+			/*not alloced enough in block mode, try one page next */
+			/*ERR_LOG("get free slot failed neednum: %d\n",
+			   *neednum);
+			 */
+			break;
+		}
+	} while (neednum > 0);
+	if (neednum > 0 && 0) {
+		WAR_LOG("1can't alloc enough pages!!alloced=%d,need=%d\n",
+			alloced, num);
+		WAR_LOG("2can't alloc enough pages!!alloced=%d,need=%d\n",
+			alloced, num);
+	}
+	codec_mm_list_lock(smgt);
+	smgt->alloced_page_num += alloced;
+	if (smgt->max_alloced < smgt->alloced_page_num)
+		smgt->max_alloced = smgt->alloced_page_num;
+	codec_mm_list_unlock(smgt);
+	return alloced;
+}
+
+/*flags & 1; alloc.*/
+static struct codec_mm_scatter *codec_mm_get_next_cache_scatter(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *cur_mms,
+	int flags)
+{
+	struct codec_mm_scatter *mms = NULL;
+
+	codec_mm_list_lock(smgt);
+	if (cur_mms) {
+		if (smgt->cache_scs[0] == cur_mms)
+			mms = smgt->cache_scs[1];
+		else
+			mms = smgt->cache_scs[0];
+	} else if (smgt->cache_scs[0] && smgt->cache_scs[1]) {
+		int more_pages = flags & 1;
+		int id = -1;
+
+		if (smgt->cache_scs[0]->page_cnt >=
+			smgt->cache_scs[1]->page_cnt)
+			id = more_pages ? 0 : 1;
+		else
+			id = more_pages ? 1 : 0;
+		mms = smgt->cache_scs[id];
+	} else {
+		if (smgt->cache_scs[0])
+			mms = smgt->cache_scs[0];
+		else
+			mms = smgt->cache_scs[1];
+	}
+	codec_mm_list_unlock(smgt);
+	return mms;
+}
+
+
+static int codec_mm_page_alloc_from_free_scatter(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *src_mms,
+	phy_addr_type *pages, int num, int wait)
+{
+	struct codec_mm_scatter *mms;
+	int need = num;
+	int alloced = 0;
+
+	mms = src_mms;
+	if (!mms)
+		return 0;
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_from_cache_scatter_1);
+	if (!wait) {
+		if (!codec_mm_scatter_trylock(mms))
+			return 0;/*mms is locked try another.*/
+	} else
+		codec_mm_scatter_lock(mms);
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_from_cache_scatter_2);
+	alloced = min(mms->page_cnt, need);
+	if (alloced > 0) {
+		mms->page_cnt -= alloced;
+		mms->page_tail -= alloced;
+#if 1
+		memcpy(pages, &mms->pages_list[mms->page_tail + 1],
+			alloced * sizeof(phy_addr_type));
+#else
+	/*alloc from first*/
+		memcpy(pages, &mms->pages_list[0],
+			alloced * sizeof(phy_addr_type));
+		memmove(&mms->pages_list[0],
+			&mms->pages_list[alloced],
+			mms->page_cnt * sizeof(phy_addr_type));
+#endif
+		memset(&mms->pages_list[mms->page_tail + 1], 0,
+			alloced * sizeof(phy_addr_type));
+	}
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_from_cache_scatter_3);
+	codec_mm_list_lock(smgt);
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_from_cache_scatter_4);
+	smgt->cached_pages -= alloced;
+	codec_mm_list_unlock(smgt);
+	codec_mm_scatter_unlock(mms);
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_from_cache_scatter_5);
+	return alloced;
+}
+
+static int codec_mm_page_alloc_from_cache_scatter(
+	struct codec_mm_scatter_mgt *smgt,
+	phy_addr_type *pages, int num)
+{
+	struct codec_mm_scatter *src_mms;
+	int alloced;
+
+	src_mms = codec_mm_get_next_cache_scatter(smgt, NULL, 1);
+	alloced = codec_mm_page_alloc_from_free_scatter(smgt,
+		src_mms, pages, num, 0);
+	if (alloced < num) {
+		src_mms = codec_mm_get_next_cache_scatter(smgt, src_mms, 1);
+		alloced += codec_mm_page_alloc_from_free_scatter(smgt,
+			src_mms, &pages[alloced], num - alloced, 1);
+	}
+	return alloced;
+}
+
+
+static int codec_mm_page_alloc_all_locked(
+		struct codec_mm_scatter_mgt *smgt,
+		phy_addr_type *pages, int num, int iscache)
+{
+	int alloced = 0;
+	int can_from_scatter = iscache ? 0 : 1;
+	int can_from_slot = 1;
+	int new_alloc;
+
+	while (alloced < num) {
+		new_alloc = 0;
+		if (can_from_scatter) {
+			ATRACE_COUNTER("mmu alloc",
+				MMU_ALLOC_from_free_scatter);
+			new_alloc = codec_mm_page_alloc_from_cache_scatter(
+				smgt,
+				pages + alloced,
+				num - alloced);
+			ATRACE_COUNTER("mmu alloc",
+				MMU_ALLOC_from_free_scatter_end);
+			if (new_alloc <= 0)
+				can_from_scatter = 0;
+		} else if (can_from_slot) {
+			ATRACE_COUNTER("mmu alloc",
+						MMU_ALLOC_from_slot);
+			new_alloc = codec_mm_page_alloc_from_slot(
+				smgt,
+				pages + alloced,
+				num - alloced);
+			ATRACE_COUNTER("mmu alloc",
+				MMU_ALLOC_from_slot_end);
+			if (new_alloc <= 0)
+				can_from_slot = 0;
+		} else if (!smgt->no_alloc_from_sys && !smgt->tvp_mode) {
+			new_alloc = codec_mm_page_alloc_from_one_pages(
+				smgt,
+				pages + alloced,
+				num - alloced);
+			if (new_alloc <= 0)
+				break;
+		} else {
+			break;
+		}
+		alloced += new_alloc;
+	}
+	return alloced;
+}
+
+static int codec_mm_pages_free_to_scatter(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *src_mms,
+	struct codec_mm_scatter *dst_mms,
+	int wait)
+{
+	int moved = 0;
+	int left;
+
+	if (src_mms->page_used >= src_mms->page_cnt)
+		return -1;	/*no need free. */
+	if (!dst_mms || src_mms  == dst_mms)
+		return 0;
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_DTS);
+	if (!wait) {
+		if (!codec_mm_scatter_trylock(dst_mms))
+			return -2;/*mms is locked try another.*/
+	} else
+		codec_mm_scatter_lock(dst_mms);
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_DTS_LOCK);
+	moved = min(src_mms->page_cnt - src_mms->page_used,
+		dst_mms->page_max_cnt - dst_mms->page_cnt);
+	left = src_mms->page_cnt - moved;
+	if (moved > 0) {
+		memcpy(&dst_mms->pages_list[dst_mms->page_tail + 1],
+			&src_mms->pages_list[left],
+			moved * sizeof(phy_addr_type));
+		memset(&src_mms->pages_list[left], 0,
+			sizeof(phy_addr_type) * moved);
+	}
+	dst_mms->page_cnt += moved;
+	dst_mms->page_tail += moved;
+	src_mms->page_cnt -= moved;
+	src_mms->page_tail -= moved;
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_SMGT);
+	codec_mm_list_lock(smgt);
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_SMGT_LOCK);
+	smgt->cached_pages += moved;
+	codec_mm_list_unlock(smgt);
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_SMGT_LOCK_DONE);
+	codec_mm_scatter_unlock(dst_mms);
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_DTS_LOCK_DONE);
+	return moved;
+}
+
+static int codec_mm_page_free_to_cache_scatter(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *src_mms)
+{
+	struct codec_mm_scatter *dst_mms;
+	int alloced;
+
+	dst_mms = codec_mm_get_next_cache_scatter(smgt, NULL, 0);
+	alloced = codec_mm_pages_free_to_scatter(smgt, src_mms,
+		dst_mms, 0);
+	if (alloced == -2) {
+		dst_mms = codec_mm_get_next_cache_scatter(smgt, dst_mms, 0);
+		alloced += codec_mm_pages_free_to_scatter(smgt, src_mms,
+			dst_mms, 1);
+	}
+	return alloced;
+}
+
+
+/*
+*free one page in mms;
+*/
+static int codec_mm_scatter_free_page_id_locked(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms, int id)
+{
+	page_sid_type sid;
+	int ret;
+
+	if (INVALID_ID(mms, id))
+		return CODEC_MM_S_ERR(1);
+	sid = PAGE_SID_OF_MMS(mms, id);
+	if (!VALID_SID(sid))
+		return CODEC_MM_S_ERR(2);
+	if (SID_OF_ONEPAGE(sid)) {
+		ulong phy_addr = PAGE_ADDR_OF_MMS(mms, id);
+
+		free_page((unsigned long)phys_to_virt(phy_addr));
+		codec_mm_list_lock(smgt);
+		smgt->one_page_cnt--;
+		smgt->total_page_num--;
+		codec_mm_list_unlock(smgt);
+		if (id == mms->page_tail)
+			mms->page_tail--;
+		mms->page_cnt--;
+		return 0;
+	}
+	ret = codec_mm_page_free_to_slot(smgt, sid, PAGE_ADDR_OF_MMS(mms, id));
+	if (!ret) {
+		mms->page_cnt--;
+		mms->page_tail--;
+	}
+	return ret;
+}
+
+/*
+*free one page in mms;
+*/
+static int codec_mm_scatter_free_pages_in_locked(
+	struct codec_mm_scatter *mms,
+	int start_id)
+{
+	struct codec_mm_scatter_mgt *smgt =
+		(struct codec_mm_scatter_mgt *)mms->manager;
+	int i;
+	int ret;
+	int id = start_id;
+	int freeNum = 0;
+	int not_continue_print = 1;
+
+	for (i = mms->page_tail; i >= id; i--) {
+		ret = codec_mm_scatter_free_page_id_locked(smgt, mms, i);
+		if (ret < 0) {
+			if (not_continue_print) {
+				ERR_LOG("page free error.%d,id=%d, addr:%d\n",
+					ret, i,
+					(int)mms->pages_list[i]);
+				codec_mm_dump_scatter(mms, NULL, 0);
+			}
+			not_continue_print = 0;
+		} else {
+			not_continue_print = 1;
+		}
+		freeNum++;
+		mms->pages_list[i] = (phy_addr_type) 0;
+	}
+	codec_mm_list_lock(smgt);
+	smgt->alloced_page_num -= freeNum;
+	if (is_cache_sc(smgt, mms))
+		smgt->cached_pages -= freeNum;
+	codec_mm_list_unlock(smgt);
+	return 0;
+}
+
+/*
+ *fast_mode:
+ *1: set page_used: call by owner
+ *2: free to scatter: call by owner
+ *3: free to slot or others: call by owner
+ *
+ *free_mode:
+ *0: free from id pages.
+ *1: free not used pages;call by moniter.
+ *2: less pages.: call by moniter for cache
+ *   id is negative.
+ */
+static int codec_mm_scatter_free_tail_pages_in(
+	struct codec_mm_scatter *mms,
+	int id,
+	int fast_mode,
+	int free_mode)
+{
+	struct codec_mm_scatter_mgt *smgt;
+	int start_free_id = id;
+
+	if (!mms)
+		return -1;
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START);
+	codec_mm_scatter_lock(mms);
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_LOCK);
+	if (free_mode == 1)
+		start_free_id = mms->page_used;
+	if (free_mode == 2) {
+		if (id > 0) {
+			if (id >= mms->page_cnt)
+				start_free_id = 0;
+			else
+				start_free_id = mms->page_cnt - id;
+		} else
+			start_free_id = -1;
+	}
+	if ((start_free_id < 0) ||
+		(start_free_id >= mms->page_cnt) ||
+		(mms->page_tail < 0)) {
+		if (mms &&
+			start_free_id != mms->page_cnt) {
+			ERR_LOG(
+				"mms[%p],free error id %d(%d),cnt=%d ,=m:%d,%d\n",
+				mms,
+				id,
+				start_free_id,
+				mms->page_cnt,
+				fast_mode,
+				free_mode);
+		}
+		codec_mm_scatter_unlock(mms);
+		ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_LOCK_DONE);
+		return -1;
+	}
+	smgt = (struct codec_mm_scatter_mgt *)mms->manager;
+	codec_mm_list_lock(smgt);
+	mms->page_used = start_free_id;
+	codec_mm_list_unlock(smgt);
+
+	if (fast_mode == 1) {
+		codec_mm_scatter_unlock(mms);
+		ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_LOCK_DONE);
+		return 0;
+	}
+	if (fast_mode == 2 || fast_mode == 3) {
+		u64 startus;
+
+		startus = codec_mm_get_current_us();
+		codec_mm_page_free_to_cache_scatter(smgt, mms);
+		codec_mm_update_free_time(smgt, startus);
+		if (fast_mode == 2 || mms->page_used == mms->page_cnt) {
+			codec_mm_scatter_unlock(mms);
+			ATRACE_COUNTER("mmu_free",
+				MMU_FREE_SCATTER_START_LOCK_DONE);
+			return 0;
+		}
+	}
+	codec_mm_scatter_free_pages_in_locked(mms, start_free_id);
+	codec_mm_scatter_unlock(mms);
+	ATRACE_COUNTER("mmu_free", MMU_FREE_SCATTER_START_LOCK_DONE);
+	return 0;
+}
+
+int codec_mm_scatter_free_tail_pages(
+		struct codec_mm_scatter *mms,
+		int start_id)
+{
+	int ret = 0;
+	ret = codec_mm_scatter_free_tail_pages_in(
+			mms,
+			start_id, 0, 0);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_scatter_free_tail_pages);
+
+int codec_mm_scatter_free_tail_pages_fast(
+	struct codec_mm_scatter *mms,
+	int start_free_id)
+{
+	int ret = 0;
+	if (!mms)
+		return -1;
+	if (start_free_id < mms->page_cnt)
+		ret = codec_mm_scatter_free_tail_pages_in(
+				mms,
+				start_free_id, 2, 0);
+	codec_mm_schedule_delay_work(
+		(struct codec_mm_scatter_mgt *)mms->manager,
+		100, 0);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_scatter_free_tail_pages_fast);
+
+int codec_mm_scatter_free_unused_pages(struct codec_mm_scatter *mms)
+{
+	int ret = 0;
+	ret = codec_mm_scatter_free_tail_pages_in(mms,
+			0, 0, 1);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_scatter_free_unused_pages);
+
+int codec_mm_scatter_less_pages(struct codec_mm_scatter *mms,
+	int nums)
+{
+	int ret = 0;
+
+	ret = codec_mm_scatter_free_tail_pages_in(mms,
+			nums, 0, 2);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_scatter_less_pages);
+
+/*free all pages only
+*don't free scatter
+*/
+int codec_mm_scatter_free_all_pages(struct codec_mm_scatter *mms)
+{
+	int ret;
+
+	ret = codec_mm_scatter_free_tail_pages(mms, 0);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_scatter_free_all_pages);
+
+static inline int codec_mm_scatter_map_add_locked(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms)
+{
+	int i;
+
+	for (i = 0; i < MAX_SC_LIST; i++) {
+		if (smgt->scmap[i] == NULL) {
+			smgt->scmap[i] = mms;
+			return i;
+		}
+	}
+	return -1;
+}
+
+static inline int codec_mm_scatter_map_del_locked(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms)
+{
+	int i;
+
+	for (i = 0; i < MAX_SC_LIST; i++) {
+		if (smgt->scmap[i] == mms) {
+			smgt->scmap[i] = NULL;
+			return i;
+		}
+	}
+	return 0;
+}
+
+int codec_mm_scatter_valid_locked(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms)
+{
+	int i;
+	int valid = 0;
+
+	for (i = 0; i < MAX_SC_LIST; i++) {
+		if (smgt->scmap[i] == mms) {
+			valid = 1;
+			break;
+		}
+	}
+	return valid;
+}
+EXPORT_SYMBOL(codec_mm_scatter_valid_locked);
+
+/*free scatter's all */
+static int codec_mm_scatter_free_on_nouser_ext(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms,
+	int not_in_mgt)
+{
+	int ret = 0;
+	int free;
+
+	codec_mm_scatter_lock(mms);
+	codec_mm_list_lock(smgt);
+	ret = atomic_read(&mms->user_cnt);
+	if (ret > 0) {
+		codec_mm_list_unlock(smgt);
+		codec_mm_scatter_unlock(mms);
+		/*>0 have another user. */
+		/*pr_err("ERROR, scatter is not free.cnt:%d\n", ret); */
+		return 0;
+	}
+	/*to free now */
+	free = mms->page_cnt;
+	if (!list_empty(&mms->list))
+		list_del(&mms->list);
+	if (!not_in_mgt) {
+		smgt->scatters_cnt--;
+	codec_mm_scatter_map_del_locked(smgt, mms);
+	}
+
+	codec_mm_list_unlock(smgt);
+	codec_mm_scatter_unlock(mms);
+	if (mms->page_cnt > 0)
+		ret = codec_mm_scatter_free_tail_pages_in(mms, 0, 0, 0);
+	if (free >= 256 &&
+		(smgt->try_alloc_in_sys_page_cnt <
+			smgt->try_alloc_in_sys_page_cnt_max) &&
+		(smgt->total_page_num < (1024 * 1024 * 32 >> PAGE_SHIFT))) {
+		smgt->try_alloc_in_sys_page_cnt *= 2;
+		if (!smgt->support_from_slot_sys) {
+			smgt->support_from_slot_sys =
+				smgt->enable_slot_from_sys;
+		}
+	}
+
+	SC_FREE(mms);
+	return ret;
+}
+/*free scatter's all */
+static int codec_mm_scatter_free_on_nouser(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms)
+{
+	return codec_mm_scatter_free_on_nouser_ext(
+		smgt, mms, 0);
+}
+
+/*
+*mask for other use it.
+*/
+static int codec_mm_scatter_inc_user_in1(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms,
+	int cnt)
+{
+	int ret = -1;
+	int old_user;
+
+	codec_mm_list_lock(smgt);
+	if (!codec_mm_scatter_valid_locked(smgt, mms)) {
+		codec_mm_list_unlock(smgt);
+		return -1;
+	}
+	old_user = atomic_read(&mms->user_cnt);
+	if (old_user >= 0) {
+		ret = atomic_add_return(cnt, &mms->user_cnt);
+		if (old_user == 1)
+			mms->tofree_jiffies = jiffies;
+	}
+	codec_mm_list_unlock(smgt);
+	return ret <= 0 ? ret : 0;	/*must add before user cnt >= 0 */
+}
+static int codec_mm_scatter_inc_user_in(
+	struct codec_mm_scatter *mms,
+	int cnt)
+{
+	struct codec_mm_scatter_mgt *smgt;
+	int ret;
+
+	if (!mms)
+		return -1;
+	smgt = codec_mm_get_scatter_mgt(0);
+	ret = codec_mm_scatter_inc_user_in1(smgt,
+			mms,
+			cnt);
+	if (ret < 0) {
+		smgt = codec_mm_get_scatter_mgt(1);
+		ret = codec_mm_scatter_inc_user_in1(smgt,
+			mms,
+			cnt);
+	}
+	return ret;
+}
+
+/*mask scatter's to free.*/
+static int codec_mm_scatter_dec_user_in1(
+		struct codec_mm_scatter_mgt *smgt,
+		struct codec_mm_scatter *mms,
+		int delay_free_ms, int cnt)
+{
+	int after_users = 1;
+
+	codec_mm_list_lock(smgt);
+	if (!codec_mm_scatter_valid_locked(smgt, mms)) {
+		codec_mm_list_unlock(smgt);
+		return -1;
+	}
+	if (atomic_read(&mms->user_cnt) >= 1) {
+		after_users = atomic_sub_return(cnt, &mms->user_cnt);
+		if (after_users == 0) {
+			/*is free time*/
+			mms->tofree_jiffies  = jiffies +
+				delay_free_ms * HZ/1000;
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	if (after_users == 0)
+		codec_mm_schedule_delay_work(smgt, 0, 1);
+	return 0;
+}
+/*mask scatter's to free.*/
+static int codec_mm_scatter_dec_user_in(
+		struct codec_mm_scatter *mms,
+		int delay_free_ms, int cnt)
+{
+	struct codec_mm_scatter_mgt *smgt;
+	int ret;
+
+	if (!mms)
+		return -1;
+	smgt = codec_mm_get_scatter_mgt(0);
+	ret = codec_mm_scatter_dec_user_in1(smgt,
+			mms,
+			delay_free_ms,
+			cnt);
+	if (ret < 0) {
+		smgt = codec_mm_get_scatter_mgt(1);
+		ret = codec_mm_scatter_dec_user_in1(smgt,
+			mms,
+			delay_free_ms,
+			cnt);
+	}
+	return ret;
+}
+
+/*
+*maybe a render/sink.video/osd/
+*/
+int codec_mm_scatter_inc_for_keeper(void *sc_mm)
+{
+	struct codec_mm_scatter *mms = sc_mm;
+
+	return codec_mm_scatter_inc_user_in(mms, 100);
+}
+EXPORT_SYMBOL(codec_mm_scatter_inc_for_keeper);
+
+/*
+*maybe a render/sink.video/osd/
+*/
+int codec_mm_scatter_dec_keeper_user(void *sc_mm, int delay_ms)
+{
+	struct codec_mm_scatter *mms = sc_mm;
+
+	return codec_mm_scatter_dec_user_in(mms, delay_ms, 100);
+}
+EXPORT_SYMBOL(codec_mm_scatter_dec_keeper_user);
+
+int codec_mm_scatter_dec_owner_user(void *sc_mm, int delay_ms)
+{
+	struct codec_mm_scatter *mms = sc_mm;
+	int ret = codec_mm_scatter_dec_user_in(mms, delay_ms, 1000);
+
+	if (ret)
+		ERR_LOG("dec_owner_user error %p\n", mms);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_scatter_dec_owner_user);
+
+/*
+*max pages:
+*want pages now,
+*maybe:
+*	max pages == support 4k,need pages;
+*	page num = current size need pages;
+*/
+struct codec_mm_scatter *codec_mm_scatter_alloc_new(
+	struct codec_mm_scatter_mgt *smgt,
+	int max_page,
+	int page_num)
+{
+	struct codec_mm_scatter *mms;
+	int ret;
+
+	if (max_page < page_num)
+		return NULL;
+
+	mms = SC_ALLOC(sizeof(struct codec_mm_scatter) + sizeof(phy_addr_type) *
+		max_page, GFP_KERNEL);
+	if (!mms) {
+		ERR_LOG("no enough for mm scatter!!!!\n");
+		return NULL;
+	}
+	memset(mms, 0, sizeof(struct codec_mm_scatter));
+	mms->pages_list = (phy_addr_type *) (mms + 1);
+	mms->page_max_cnt = max_page;
+	INIT_LIST_HEAD(&mms->list);
+	memset(mms->pages_list, 0, sizeof(phy_addr_type) * max_page);
+	mms->page_cnt = 0;
+	mms->page_tail = -1;
+	mms->manager = (void *)smgt;
+	atomic_set(&mms->user_cnt, 0);
+	mutex_init(&mms->mutex);
+	if (page_num > 0) {
+		ret = codec_mm_page_alloc_all_locked(smgt,
+				mms->pages_list, page_num,
+				is_cache_sc(smgt, mms));
+		if (ret <= 0)
+			goto error;
+		mms->page_cnt = ret;
+		mms->page_tail = mms->page_cnt - 1;
+	}
+	atomic_set(&mms->user_cnt, 1000);
+	codec_mm_list_lock(smgt);
+	mms->page_used = mms->page_cnt;
+	list_add_tail(&mms->list, &smgt->scatter_list);
+	smgt->scatters_cnt++;
+	codec_mm_scatter_map_add_locked(smgt, mms);
+	codec_mm_list_unlock(smgt);
+	return mms;
+error:
+	codec_mm_scatter_free_on_nouser_ext(smgt, mms, 1);
+	return NULL;
+}
+EXPORT_SYMBOL(codec_mm_scatter_alloc_new);
+
+/*
+*max pages:
+*want pages now,
+*maybe:
+*	max pages == support 4k,need pages;
+*	page num = current size need pages;
+*/
+struct codec_mm_scatter *codec_mm_scatter_alloc(
+	int max_page, int page_num,
+	int istvp)
+{
+	struct codec_mm_scatter_mgt *smgt;
+	struct codec_mm_scatter *mms, *alloced_mms;
+	struct list_head *pos, *next;
+	int ret;
+	u64 startus;
+
+	smgt = codec_mm_get_scatter_mgt(istvp);
+	startus = codec_mm_get_current_us();
+	alloced_mms = NULL;
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_SCATTER_START);
+	codec_mm_list_lock(smgt);
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_SCATTER_START_LOCK);
+	if (!list_empty(&smgt->scatter_list)) {	/*try find a free scatter. */
+		pos = smgt->scatter_list.prev;	/*free on prev. */
+		while (pos != &smgt->scatter_list) {
+			next = pos->prev;
+			mms = list_entry(pos, struct codec_mm_scatter, list);
+			if (mms->page_max_cnt >= max_page &&
+				atomic_read(&mms->user_cnt) == 0) {
+				if (atomic_add_return(1000,
+						&mms->user_cnt) == 1000) {
+					mms->page_used = mms->page_cnt;
+					alloced_mms = mms;
+					break;
+				} else
+					atomic_sub(1000, &mms->user_cnt);
+			}
+			pos = next;
+		}
+	}
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_SCATTER_START_LOCK_DONE);
+	codec_mm_list_unlock(smgt);
+	if (!alloced_mms) {
+		/*
+		*just alloc mms first,
+		*alloc pages later.
+		*/
+		ATRACE_COUNTER("mmu alloc",
+			MMU_ALLOC_SCATTER_ALLOC_NEW);
+		alloced_mms = codec_mm_scatter_alloc_new(smgt, max_page, 0);
+		ATRACE_COUNTER("mmu alloc",
+			MMU_ALLOC_SCATTER_ALLOC_NEW_END);
+	}
+	if (alloced_mms) {
+		ATRACE_COUNTER("mmu alloc",
+			MMU_ALLOC_SCATTER_ALLOC_WANT_PAGE_IN);
+		ret = codec_mm_scatter_alloc_want_pages_in(smgt, alloced_mms,
+			page_num);
+		ATRACE_COUNTER("mmu alloc",
+			MMU_ALLOC_SCATTER_ALLOC_WANT_PAGE_IN_END);
+		if (ret < 0) {
+			atomic_sub(1000, &alloced_mms->user_cnt);
+			return NULL;
+		}
+		/*pr_info("reused old mms! %p\n", alloced_mms);*/
+		codec_mm_update_alloc_time(smgt, startus);
+		return alloced_mms;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL(codec_mm_scatter_alloc);
+
+static int codec_mm_scatter_alloc_want_pages_in(
+	struct codec_mm_scatter_mgt *smgt,
+	struct codec_mm_scatter *mms,
+	int want_pages)
+{
+	int ret = 0;
+
+	if (want_pages > mms->page_max_cnt)
+		return CODEC_MM_S_ERR(100);
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_SCATTER_LOCK);
+	codec_mm_scatter_lock(mms);
+	codec_mm_list_lock(smgt);
+	mms->page_used = want_pages;
+	codec_mm_list_unlock(smgt);
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_SCATTER_LOCK_END);
+	if (want_pages > mms->page_cnt) {
+		ret = codec_mm_page_alloc_all_locked(
+				smgt,
+				&mms->pages_list[mms->page_tail + 1],
+					want_pages - mms->page_cnt,
+				is_cache_sc(smgt, mms));
+		if (ret <= 0) {
+			codec_mm_scatter_unlock(mms);
+			ERR_LOG("can't alloc want pages %d\n", want_pages);
+			return ret;
+		}
+		mms->page_cnt += ret;
+		mms->page_tail += ret;
+	}
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_LIST_LOCK_START);
+	codec_mm_list_lock(smgt);
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_LIST_LOCK);
+	if (ret > 0 && is_cache_sc(smgt, mms))
+		smgt->cached_pages += ret;
+
+	codec_mm_list_unlock(smgt);
+	ATRACE_COUNTER("mmu alloc", MMU_ALLOC_LIST_LOCK_END);
+	codec_mm_scatter_unlock(mms);
+	if (smgt->cached_pages < smgt->keep_size_PAGE / 2) {
+		/*try alloc more cache.*/
+		codec_mm_schedule_delay_work(smgt, 0, 1);
+	}
+	return 0;
+}
+
+int codec_mm_scatter_alloc_want_pages(
+		struct codec_mm_scatter *mms,
+		int want_pages)
+{
+	struct codec_mm_scatter_mgt *smgt;
+	int ret;
+	u64 startus;
+	if (!mms)
+		return -1;
+	smgt = (struct codec_mm_scatter_mgt *)mms->manager;
+	startus = codec_mm_get_current_us();
+	ret = codec_mm_scatter_alloc_want_pages_in(
+		smgt, mms, want_pages);
+	codec_mm_update_alloc_time(smgt, startus);
+	return ret;
+}
+EXPORT_SYMBOL(codec_mm_scatter_alloc_want_pages);
+
+int codec_mm_free_all_free_slots_in(struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_slot *slot, *to_free;
+
+	do {
+		to_free = NULL;
+		codec_mm_list_lock(smgt);
+		{
+			struct list_head *header, *list;
+
+			header = &smgt->free_list;
+			list = header->prev;
+			while (list != header) {
+				slot = list_entry(list, struct codec_mm_slot,
+					free_list);
+				if (slot->alloced_page_num == 0) {
+					list_del_init(&slot->free_list);
+					to_free = slot;
+					break;
+				}
+				list = list->prev;
+			};
+		}
+		codec_mm_list_unlock(smgt);
+		if (!to_free)
+			break;
+		codec_mm_slot_free(smgt, to_free);
+	} while (1);
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_free_all_free_slots);
+
+int codec_mm_free_all_free_slots(void)
+{
+	codec_mm_free_all_free_slots_in(codec_mm_get_scatter_mgt(0));
+	codec_mm_free_all_free_slots_in(codec_mm_get_scatter_mgt(1));
+	return 0;
+}
+
+static int codec_mm_scatter_info_dump_in(
+	struct codec_mm_scatter_mgt *smgt,
+	void *buf, int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int n;
+
+	if (!pbuf)
+		pbuf = sbuf;
+
+#define BUFPRINT(args...) \
+		do {\
+			s = sprintf(pbuf, args);\
+			tsize += s;\
+			pbuf += s; \
+		} while (0)
+
+	BUFPRINT("codec %sscattered memory info:\n",
+		smgt->tvp_mode ? "TVP " : "");
+	BUFPRINT("\ttotal size:%dM, %d Bytes,pages:%d\n",
+			 (smgt->total_page_num << PAGE_SHIFT) / SZ_1M,
+			 smgt->total_page_num << PAGE_SHIFT,
+			 smgt->total_page_num);
+	n = smgt->alloced_page_num;
+	BUFPRINT("\talloced size:%dM, %d Bypes,pages:%d\n",
+			 (n << PAGE_SHIFT) / SZ_1M,
+			 n << PAGE_SHIFT,
+			 n);
+	BUFPRINT("\tmax alloced:%d M | %d pages\n",
+		(smgt->max_alloced << PAGE_SHIFT) / SZ_1M,
+		smgt->max_alloced);
+	BUFPRINT("\tscatter cached:%d M |%d pages\n",
+		(smgt->cached_pages << PAGE_SHIFT) / SZ_1M,
+		smgt->cached_pages);
+
+	BUFPRINT("\talloc from sys size:%d\n",
+		(smgt->alloc_from_sys_sc_cnt +
+		smgt->one_page_cnt) << PAGE_SHIFT);
+
+	BUFPRINT("\talloc from sys sc cnt:%d\n",
+		smgt->alloc_from_sys_sc_cnt);
+	BUFPRINT("\talloc from sys pages cnt:%d pages\n",
+		smgt->alloc_from_sys_page_cnt);
+	BUFPRINT("\talloc from sys max pages cnt:%d pages\n",
+		smgt->alloc_from_sys_max_page_cnt);
+	BUFPRINT("\tscatter_task_run:%d\n",
+		smgt->scatter_task_run_num);
+	BUFPRINT("\tone_page_cnt:%d\n",
+		smgt->one_page_cnt);
+	BUFPRINT("\tcatters cnt:%d\n", smgt->scatters_cnt);
+	BUFPRINT("\tslot cnt:%d\n", smgt->slot_cnt);
+	BUFPRINT("\tcma alloc block size:%d\n",
+		smgt->try_alloc_in_cma_page_cnt);
+	BUFPRINT("\tsys alloc block size:%d\n",
+			smgt->try_alloc_in_sys_page_cnt);
+	BUFPRINT("\tdelay_free_on:%d\n",
+			smgt->delay_free_on);
+	BUFPRINT("\tdelay_free_on time:%lld jiffies\n",
+			smgt->delay_free_timeout_jiffies64);
+	BUFPRINT("\tcurrent time:%lld\n",
+			get_jiffies_64());
+	BUFPRINT("\talloc time max us:%d\n",
+			smgt->alloc_max_us);
+	BUFPRINT("\talloc cnt:%d step:%d:%d:%d:%d:%d:%d:%d\n",
+			smgt->alloc_cnt,
+			smgt->alloc_10us_less_cnt,
+			smgt->alloc_10_50us_cnt,
+			smgt->alloc_50_100us_cnt,
+			smgt->alloc_100_1000us_cnt,
+			smgt->alloc_1_10ms_cnt,
+			smgt->alloc_10_100ms_cnt,
+			smgt->alloc_100ms_up_cnt
+			);
+	BUFPRINT("\tfree time max us:%d\n",
+			smgt->free_max_us);
+	BUFPRINT("\tfree cnt:%d step:%d:%d:%d:%d:%d:%d:%d\n",
+			smgt->free_cnt,
+			smgt->free_10us_less_cnt,
+			smgt->free_10_50us_cnt,
+			smgt->free_50_100us_cnt,
+			smgt->free_100_1000us_cnt,
+			smgt->free_1_10ms_cnt,
+			smgt->free_10_100ms_cnt,
+			smgt->free_100ms_up_cnt
+			);
+	{
+		int average_timeus;
+		u64 divider = smgt->alloc_total_us;
+
+		do_div(divider, smgt->alloc_cnt);
+		average_timeus = (smgt->alloc_cnt == 0 ?
+			0 : (int)divider);
+		BUFPRINT("\talloc time average us:%d\n",
+			average_timeus);
+		divider = smgt->free_total_us;
+
+		do_div(divider, smgt->free_cnt);
+		average_timeus = (smgt->free_cnt == 0 ?
+			0 : (int)divider);
+		BUFPRINT("\tfree time average us:%d\n",
+			average_timeus);
+	}
+
+#undef BUFPRINT
+	if (!buf)
+		INFO_LOG("%s", sbuf);
+	return tsize;
+}
+EXPORT_SYMBOL(codec_mm_scatter_info_dump);
+
+int codec_mm_scatter_info_dump(
+	void *buf, int size)
+{
+	char *pbuf = buf;
+	int esize = size;
+	int ret;
+
+	ret = codec_mm_scatter_info_dump_in(
+		codec_mm_get_scatter_mgt(0),
+		pbuf,
+		esize);
+	if (buf != NULL && ret > 0) {
+		pbuf += ret;
+		esize -= ret;
+	}
+	ret += codec_mm_scatter_info_dump_in(
+		codec_mm_get_scatter_mgt(1),
+		pbuf,
+		esize);
+	return ret;
+}
+
+int codec_mm_dump_slot(struct codec_mm_slot *slot, void *buf, int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+	int sum;
+	char bits_incharNhalf[] = { 0, 1, 1, 2, 1, 2, 2, 3,
+		1, 2, 2, 3, 2, 2, 3, 4, 1, 2};
+
+	if (!pbuf)
+		pbuf = sbuf;
+
+#define BUFPRINT(args...) \
+		do {\
+			s = sprintf(pbuf, args);\
+			tsize += s;\
+			pbuf += s; \
+		} while (0)
+
+	BUFPRINT("slot info:%p\n", slot);
+	BUFPRINT("\tfrom:%s\n",
+		(slot->from_type == SLOT_FROM_CODEC_MM ? "codec_mm" :
+			"sys"));
+	BUFPRINT("\tbase addr range:%p<-->%p\n",
+			 (void *)slot->phy_addr,
+			 (void *)(slot->phy_addr +
+			 (slot->page_num << PAGE_SHIFT)
+					 - 1));
+	BUFPRINT("\tpage_num:%d\n", slot->page_num);
+	BUFPRINT("\talloced:%d,free:%d\n", slot->alloced_page_num,
+		slot->page_num - slot->alloced_page_num);
+	BUFPRINT("\tnext bit:%d\n", slot->next_bit);
+	BUFPRINT("\tsid:%x\n", slot->sid);
+	BUFPRINT("\troot:%d\n", slot->isroot);
+	sum = 0;
+	for (i = 0; i < slot->pagemap_size; i++) {
+		int c = ((unsigned char *)slot->pagemap)[i];
+
+		sum += bits_incharNhalf[c & 0xf] + bits_incharNhalf[c >> 4];
+	}
+	BUFPRINT("\tbitmap.setbits.sum:%d\n", sum);
+	BUFPRINT("\tbitmap");
+	i = 0;
+	while (i < slot->pagemap_size && i < 16)
+		BUFPRINT(":%02x", ((char *)slot->pagemap)[i++]);
+	BUFPRINT("\n");
+#undef BUFPRINT
+	if (!buf)
+		INFO_LOG("%s", sbuf);
+	return 0;
+
+}
+EXPORT_SYMBOL(codec_mm_dump_slot);
+
+int codec_mm_dump_all_slots_in(struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_slot *slot, *fslot;
+	int total_pages = 0;
+	int alloced_pages = 0;
+	int slot_cnt = 0;
+	int i;
+
+	codec_mm_list_lock(smgt);
+	INFO_LOG("start dump all slots!\n");
+	for (i = 0; i < MAX_SID; i++) {
+		fslot = smgt->slot_list_map[i];
+		if (fslot) {
+			codec_mm_dump_slot(fslot, NULL, 0);
+			slot_cnt++;
+			total_pages += fslot->page_num;
+			alloced_pages += fslot->alloced_page_num;
+			if (!list_empty(&fslot->sid_list)) {
+				slot = list_entry(fslot->sid_list.next,
+					struct codec_mm_slot, sid_list);
+				while (slot != fslot) {
+					codec_mm_dump_slot(slot, NULL, 0);
+					slot_cnt++;
+					total_pages += slot->page_num;
+					alloced_pages += slot->alloced_page_num;
+					slot = list_entry(slot->sid_list.next,
+						struct codec_mm_slot, sid_list);
+				}
+			}
+		}
+
+	}
+	codec_mm_list_unlock(smgt);
+	INFO_LOG("end dump, slot cnt:%d total pages:%d, free:%d\n",
+		slot_cnt,
+		total_pages,
+		total_pages - alloced_pages);
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_dump_all_slots);
+
+int codec_mm_dump_all_slots(void)
+{
+	codec_mm_dump_all_slots_in(codec_mm_get_scatter_mgt(0));
+	codec_mm_dump_all_slots_in(codec_mm_get_scatter_mgt(1));
+	return 0;
+}
+
+
+int codec_mm_dump_all_hash_table_in(
+	struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_slot *slot, *fslot;
+	int i;
+	int total_pages = 0;
+	int alloced_pages = 0;
+
+	INFO_LOG("start dump sid hash table!\n");
+	codec_mm_list_lock(smgt);
+	for (i = 0; i < MAX_SID; i++) {
+		int cnt = 0;
+		int pages = 0;
+		int alloced = 0;
+
+		fslot = smgt->slot_list_map[i];
+		if (fslot) {
+			cnt++;
+			pages += fslot->page_num;
+			alloced += fslot->alloced_page_num;
+			if (!list_empty(&fslot->sid_list)) {
+				slot = list_entry(fslot->sid_list.next,
+					struct codec_mm_slot, sid_list);
+				while (slot != fslot) {
+					cnt++;
+					pages += slot->page_num;
+					alloced += slot->alloced_page_num;
+					slot = list_entry(slot->sid_list.next,
+						struct codec_mm_slot, sid_list);
+				}
+			}
+		}
+		if (cnt > 0) {
+			total_pages += pages;
+			alloced_pages += alloced;
+			INFO_LOG(
+			"\tSID(%d):\tslots:%d,\tpages:%d:\tfree pages:%d\n",
+			i, cnt, pages, pages - alloced);
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	INFO_LOG("end dump sid hash table, total pages:%d, free:%d\n",
+		total_pages, total_pages - alloced_pages);
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_dump_all_hash_table);
+
+int codec_mm_dump_all_hash_table(void)
+{
+	codec_mm_dump_all_hash_table_in(codec_mm_get_scatter_mgt(0));
+	codec_mm_dump_all_hash_table_in(codec_mm_get_scatter_mgt(1));
+	return 0;
+}
+
+
+static int codec_mm_dump_free_slots_in(struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_slot *slot;
+	int total_pages = 0;
+	int alloced_pages = 0;
+
+	INFO_LOG("dump all free slots:\n");
+	codec_mm_list_lock(smgt);
+	if (!list_empty(&smgt->free_list)) {
+		struct list_head *header, *list;
+
+		header = &smgt->free_list;
+		list = header->prev;
+		while (list != header) {
+			slot = list_entry(list, struct codec_mm_slot,
+				free_list);
+			codec_mm_dump_slot(slot, NULL, 0);
+			total_pages += slot->page_num;
+			alloced_pages += slot->alloced_page_num;
+			list = list->prev;
+		};
+	}
+	codec_mm_list_unlock(smgt);
+	INFO_LOG("end all free slots: total pages:%d, freed:%d\n",
+		total_pages,
+		total_pages - alloced_pages);
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_dump_free_slots);
+
+int codec_mm_dump_free_slots(void)
+{
+	codec_mm_dump_free_slots_in(codec_mm_get_scatter_mgt(0));
+	codec_mm_dump_free_slots_in(codec_mm_get_scatter_mgt(1));
+	return 0;
+}
+
+int codec_mm_dump_scatter(
+	struct codec_mm_scatter *mms,
+	void *buf, int size)
+{
+	char *pbuf = buf;
+	char sbuf[512];
+	int tsize = 0;
+	int s;
+	int i;
+
+	if (!pbuf)
+		pbuf = sbuf;
+
+#define BUFPRINT(args...) \
+		do {\
+			s = sprintf(pbuf, args);\
+			tsize += s;\
+			pbuf += s; \
+		} while (0)
+
+	BUFPRINT("scatter info:%p\n", mms);
+	BUFPRINT("\tsize:%d\n", (int)(mms->page_cnt * PAGE_SIZE));
+	BUFPRINT("\tmax:%d\n", mms->page_max_cnt);
+	BUFPRINT("\tpage_cnt:%d\n", mms->page_cnt);
+	BUFPRINT("\tpage_used:%d\n", mms->page_used);
+	BUFPRINT("\tpage_tail:%d\n", mms->page_tail);
+	BUFPRINT("\tuser_cnt:%d\n", atomic_read(&mms->user_cnt));
+	BUFPRINT("\ttofree_jiffies:%ld\n", mms->tofree_jiffies);
+
+	i = 0;
+	while (i < mms->page_cnt && i < 16)
+		BUFPRINT(":%x", (u32) mms->pages_list[i++]);
+	BUFPRINT("\n");
+#undef BUFPRINT
+	if (!buf)
+		INFO_LOG("%s", sbuf);
+
+	return 0;
+
+}
+EXPORT_SYMBOL(codec_mm_dump_scatter);
+
+static  int codec_mm_dump_all_scatters_in(struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_scatter *mms;
+	struct list_head *pos, *tmp;
+
+	INFO_LOG("start dump all scatters!\n");
+	codec_mm_list_lock(smgt);
+	do {
+		if (list_empty(&smgt->scatter_list))
+			break;
+		list_for_each_safe(pos, tmp, &smgt->scatter_list) {
+			mms = list_entry(pos, struct codec_mm_scatter, list);
+			codec_mm_dump_scatter(mms, 0, 0);
+		}
+	} while (0);
+	INFO_LOG("start dump free scatters!\n");
+	if (smgt->cache_scs[0])
+		codec_mm_dump_scatter(smgt->cache_scs[0], 0, 0);
+	if (smgt->cache_scs[1])
+		codec_mm_dump_scatter(smgt->cache_scs[1], 0, 0);
+	codec_mm_list_unlock(smgt);
+	INFO_LOG("finished dump all scatters!\n");
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_dump_all_scatters);
+
+int codec_mm_dump_all_scatters(void)
+{
+	codec_mm_dump_all_scatters_in(codec_mm_get_scatter_mgt(0));
+	codec_mm_dump_all_scatters_in(codec_mm_get_scatter_mgt(1));
+	return 0;
+}
+
+
+
+int codec_mm_scatter_update_config(struct codec_mm_scatter_mgt *smgt)
+{
+	smgt->keep_size_PAGE = g_scatter.keep_size_PAGE;
+	smgt->reserved_block_mm_M = g_scatter.reserved_block_mm_M;
+	smgt->try_alloc_in_cma_page_cnt = g_scatter.try_alloc_in_cma_page_cnt;
+	smgt->try_alloc_in_sys_page_cnt_max
+		= g_scatter.try_alloc_in_sys_page_cnt_max;
+	smgt->try_alloc_in_sys_page_cnt_min
+		= g_scatter.try_alloc_in_sys_page_cnt_min;
+	smgt->enable_slot_from_sys = g_scatter.enable_slot_from_sys;
+	smgt->support_from_slot_sys = g_scatter.support_from_slot_sys;
+	smgt->no_cache_size_M = g_scatter.no_cache_size_M;
+	smgt->no_alloc_from_sys = g_scatter.no_alloc_from_sys;
+	return 0;
+}
+int codec_mm_scatter_size(int is_tvp)
+{
+	struct codec_mm_scatter_mgt *smgt;
+	smgt = codec_mm_get_scatter_mgt(is_tvp ? 1 : 0);
+
+	return smgt->total_page_num;
+}
+EXPORT_SYMBOL(codec_mm_scatter_size);
+
+int codec_mm_scatter_mgt_delay_free_swith(
+	int on,
+	int delay_ms,
+	int wait_size_M,
+	int is_tvp)
+{
+	struct codec_mm_scatter_mgt *smgt;
+
+	smgt = codec_mm_get_scatter_mgt(is_tvp);
+	codec_mm_list_lock(smgt);
+	if (on) {
+		smgt->delay_free_on++;
+		smgt->delay_free_timeout_jiffies64 =
+			get_jiffies_64() + delay_ms * HZ/1000;
+	} else {
+		smgt->delay_free_on--;
+		if (smgt->delay_free_on <= 0) {
+			smgt->delay_free_on = 0;
+			smgt->delay_free_timeout_jiffies64 =
+				get_jiffies_64() + delay_ms * HZ/1000;
+		}
+	}
+	codec_mm_list_unlock(smgt);
+	if (on && wait_size_M > 0 /*&& !is_tvp*/) {
+		smgt->force_cache_on = 1;
+		smgt->force_cache_page_cnt = wait_size_M >> PAGE_SHIFT;
+		smgt->delay_free_timeout_jiffies64 =
+			get_jiffies_64() + 10000 * HZ/1000;
+		codec_mm_schedule_delay_work(smgt, 0, 1);/*start cache*/
+#if 0
+		while (smgt->total_page_num < smgt->force_cache_page_cnt) {
+			if (smgt->cache_scs[0] &&
+				(smgt->cached_pages >= 65000)) {
+				/*cache sc fulled.*/
+				break;
+			}
+			if (try_max-- <= 0 || time_after64(get_jiffies_64(),
+					start_time + HZ)) {
+				break;
+			}
+			ret = wait_for_completion_timeout(
+				&smgt->complete,
+				HZ/10);
+
+			if (ret == 0)
+				pr_debug("codec_mm_scatter_mgt_delay_free_swith time out\n");
+		}
+		pr_info("end: cached pages: %d, speed %d ms\n",
+			smgt->cached_pages,
+			(int)(get_jiffies_64() - start_time) * 1000/HZ);
+		smgt->force_cache_on = 0;
+		smgt->delay_free_timeout_jiffies64 =
+			get_jiffies_64() + delay_ms * HZ/1000;
+#endif
+	} else if (on) {
+		codec_mm_schedule_delay_work(smgt, 0, 1);
+	} else {
+		codec_mm_schedule_delay_work(smgt, delay_ms, 0);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_scatter_mgt_delay_free_swith);
+
+static void codec_mm_scatter_cache_manage(
+	struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_scatter *mms;
+	int alloced = 0;
+	int total_free_page = smgt->total_page_num -
+		smgt->alloced_page_num + smgt->cached_pages;
+
+	if (smgt->delay_free_on > 0 && smgt->keep_size_PAGE > 0) {
+		/*if alloc too much ,don't cache any more.*/
+		if (smgt->no_cache_size_M > 0 &&
+			(smgt->cached_pages <= smgt->keep_size_PAGE) &&
+			(smgt->total_page_num >=
+			 (smgt->no_cache_size_M * (SZ_1M >> PAGE_SHIFT)))) {
+			/*have enough pages for most movies.*/
+			  /*don't cache more.*/
+			if (smgt->force_cache_on) {
+				smgt->force_cache_on = 0;
+				smgt->delay_free_timeout_jiffies64 =
+					get_jiffies_64() + 2000 * HZ/1000;
+			}
+		} else if ((smgt->cached_pages < smgt->keep_size_PAGE) ||
+			(smgt->force_cache_on &&/*on star cache*/
+			(smgt->total_page_num < smgt->force_cache_page_cnt))
+		) {/*first 500ms ,alloc double.*/
+			mms = codec_mm_get_next_cache_scatter(smgt, NULL, 0);
+			if (mms) {
+				int need;
+				int once_alloc = 1000;/*once 4M*/
+
+				if (smgt->force_cache_on) {
+					once_alloc = 4000;
+					if ((smgt->total_page_num -
+						smgt->alloced_page_num) >
+							once_alloc) {
+						once_alloc =
+							smgt->total_page_num -
+							smgt->alloced_page_num;
+					}
+				}
+				need = mms->page_cnt + once_alloc;
+				if ((need - mms->page_cnt) > once_alloc)
+					need = mms->page_cnt + once_alloc;
+				if (need > smgt->force_cache_page_cnt)
+					need = smgt->force_cache_page_cnt;
+				if (need > mms->page_max_cnt)
+					need = mms->page_max_cnt - 4;
+				if (need > mms->page_cnt) {
+					ATRACE_COUNTER("mmu alloc",
+					MMU_ALLOC_SCATTER_ALLOC_WANT_PAGE_IN_2);
+					alloced =
+					!codec_mm_scatter_alloc_want_pages_in(
+						smgt,
+						mms,
+						need);
+				ATRACE_COUNTER("mmu alloc",
+				MMU_ALLOC_SCATTER_ALLOC_WANT_PAGE_IN_2_END);
+				} else {
+					alloced = 0;
+				}
+			} else {
+				alloced = 0;
+			}
+			/*wake up wait.*/
+			if (alloced &&
+				smgt->force_cache_on &&
+				(smgt->cached_pages >=
+				 smgt->force_cache_page_cnt)) {
+				smgt->force_cache_on = 0;
+				smgt->delay_free_timeout_jiffies64 =
+					get_jiffies_64() + 2000 * HZ/1000;
+			}
+		} else if ((smgt->cached_pages >
+			(smgt->keep_size_PAGE + 1000)) &&
+			time_after64(get_jiffies_64(),
+			smgt->delay_free_timeout_jiffies64)) {
+			/*wait time out can free.*/
+			mms = codec_mm_get_next_cache_scatter(smgt, NULL, 0);
+			if (mms) {/*only free some 1M cache*/
+				codec_mm_scatter_less_pages(mms,
+					256);
+			}
+			codec_mm_free_all_free_slots_in(smgt);
+			/*free some slots.*/
+		}
+	} else if (smgt->delay_free_on <= 0 &&
+			time_after64(get_jiffies_64(),
+			smgt->delay_free_timeout_jiffies64)) {
+		/*free all free pages, no delay needed.*/
+		codec_mm_free_all_free_slots_in(smgt);
+	}
+	if (smgt->keep_size_PAGE > 0 && smgt->delay_free_on) {
+		if (((smgt->force_cache_on ||
+			  (total_free_page < smgt->keep_size_PAGE)) /*&&*/
+			/*!smgt->tvp_mode*/) &&
+			alloced) {/*if failed may deadlock...*/
+			/*ignore keep on tvp mode.*/
+			if (smgt->force_cache_on && !smgt->tvp_mode)
+				codec_mm_schedule_delay_work(smgt, 0, 1);
+			else
+				codec_mm_schedule_delay_work(smgt, 10, 0);
+		} else
+			codec_mm_schedule_delay_work(smgt, 100, 0);
+	} else if (!smgt->delay_free_on && smgt->total_page_num > 0) {
+		codec_mm_schedule_delay_work(smgt, 100, 0);
+	}
+}
+
+
+static int codec_mm_scatter_scatter_arrange(
+	struct codec_mm_scatter_mgt *smgt)
+{
+	struct codec_mm_scatter *mms;
+	struct codec_mm_scatter *first_free_mms = NULL;
+	struct list_head *pos, *tmp;
+	int n = 0;
+
+	if (smgt->delay_free_on > 0 && !smgt->cache_scs[0]) {
+		/*cache1*/
+		mms = codec_mm_scatter_alloc_new(smgt, 16384, 0);
+		if (mms) {
+			codec_mm_list_lock(smgt);
+			list_del_init(&mms->list);
+			smgt->cache_scs[0] = mms;
+			codec_mm_list_unlock(smgt);
+		}
+		/*cache2*/
+		mms = codec_mm_scatter_alloc_new(smgt, 16384, 0);
+		if (mms) {
+			codec_mm_list_lock(smgt);
+			list_del_init(&mms->list);
+			smgt->cache_scs[1] = mms;
+			codec_mm_list_unlock(smgt);
+		}
+	}
+	if (smgt->delay_free_on <= 0 && smgt->cache_scs[0] &&
+		time_after64(get_jiffies_64(),
+			smgt->delay_free_timeout_jiffies64)) {
+		struct codec_mm_scatter *mms0, *mms1;
+		codec_mm_list_lock(smgt);
+		mms0 = smgt->cache_scs[0];
+		mms1 = smgt->cache_scs[1];
+		smgt->cache_scs[0] = NULL;
+		smgt->cache_scs[1] = NULL;
+		smgt->cached_pages = 0;
+		codec_mm_list_unlock(smgt);
+		if (mms0) {
+			codec_mm_scatter_dec_owner_user(mms0, 0);
+			codec_mm_scatter_free_on_nouser(smgt, mms0);
+		}
+		if (mms1) {
+			codec_mm_scatter_dec_owner_user(mms1, 0);
+			codec_mm_scatter_free_on_nouser(smgt, mms1);
+		}
+	}
+
+	codec_mm_list_lock(smgt);
+	if (list_empty(&smgt->scatter_list)) {
+		codec_mm_list_unlock(smgt);
+		return 0;
+	}
+	list_for_each_safe(pos, tmp, &smgt->scatter_list) {
+		mms = list_entry(pos, struct codec_mm_scatter, list);
+		if (atomic_read(&mms->user_cnt) == 0 &&
+			time_after(jiffies, mms->tofree_jiffies)) {
+			if (!first_free_mms ||
+				mms->tofree_jiffies <
+				first_free_mms->tofree_jiffies)
+				first_free_mms = mms;
+		} else
+			n++;
+	}
+	if (first_free_mms)
+		list_move_tail(&mms->list, &smgt->scatter_list);
+	codec_mm_list_unlock(smgt);
+
+	return 0;
+}
+
+static int codec_mm_scatter_scatter_clear(
+	struct codec_mm_scatter_mgt *smgt,
+	int force)/*not check jiffies & cache*/
+{
+	struct codec_mm_scatter *mms, *to_free_mms, *less_page_mms;
+	struct list_head *pos, *tmp;
+	int to_free_mms_cnt = 0;
+
+	codec_mm_list_lock(smgt);
+	to_free_mms = NULL;
+	less_page_mms = NULL;
+	list_for_each_safe(pos, tmp, &smgt->scatter_list) {
+		mms = list_entry(pos, struct codec_mm_scatter, list);
+		if (atomic_read(&mms->user_cnt) == 0) {
+			if (!to_free_mms ||
+				(mms->tofree_jiffies <
+					to_free_mms->tofree_jiffies))
+				to_free_mms = mms;
+			to_free_mms_cnt++;
+		}
+		if (!less_page_mms && mms->page_used < mms->page_cnt) {
+			less_page_mms = mms;
+			break;
+		}
+	}
+
+	if ((to_free_mms != NULL) &&
+		(((to_free_mms_cnt > 1 || !smgt->delay_free_on) &&
+		time_after(jiffies, to_free_mms->tofree_jiffies)) ||
+		force)) {	/*force== no checktimeer. */
+		/*set to nagative for free now. */
+		int cnt = atomic_sub_return(100000, &to_free_mms->user_cnt);
+
+		if (cnt != -100000) {
+			atomic_add(100000, &to_free_mms->user_cnt);
+			to_free_mms = NULL;
+		} else {
+			list_del_init(&to_free_mms->list);
+		}
+	} else {
+		to_free_mms = NULL;
+	}
+	codec_mm_list_unlock(smgt);
+	if (to_free_mms != NULL)
+		codec_mm_scatter_free_on_nouser(smgt, to_free_mms);
+	if (less_page_mms && (less_page_mms != to_free_mms))
+		codec_mm_scatter_free_unused_pages(less_page_mms);
+	return (to_free_mms != NULL) || (less_page_mms != NULL);
+}
+
+/*
+*clear all ignore any cache.
+*
+*return the total num alloced.
+*0 is all freeed.
+*N is have some pages not alloced.
+*flags: 0: cache only,
+*       1: all no user;
+*       2: all, ignore the time check.
+*/
+static int codec_mm_scatter_free_all_ignorecache_in(
+	struct codec_mm_scatter_mgt *smgt, int flags)
+{
+	int need_retry = 1;
+	int retry_num = 0;
+
+	mutex_lock(&smgt->monitor_lock);
+	pr_info("force free all scatter ignorecache!\n");
+	/*free cache: always*/
+	do {
+		struct codec_mm_scatter *mms;
+		/*clear cache first. */
+		/*disabled free on first. */
+		smgt->delay_free_on = 0;
+		codec_mm_list_lock(smgt);
+		mms = smgt->cache_scs[0];
+		smgt->cache_scs[0] = smgt->cache_scs[1];
+		smgt->cache_scs[1] = NULL;
+		smgt->cached_pages = 0;
+		codec_mm_list_unlock(smgt);
+		if (mms) {
+			pr_info("cache_sc page_max %d, page_used %d\n",
+					mms->page_max_cnt, mms->page_used);
+			codec_mm_scatter_dec_owner_user(mms, 0);
+			codec_mm_scatter_free_on_nouser(smgt, mms);
+		}
+		/*alloced again on timer?*/
+		  /* check again. */
+	} while (smgt->cache_scs[0] != NULL);
+	/* free cache nouser
+	 *	if flags==2  force
+	 */
+	if (flags >= 1) {
+		do {
+			need_retry = codec_mm_scatter_scatter_clear(
+					smgt, flags == 2);
+		} while ((smgt->scatters_cnt > 0) && (retry_num++ < 1000));
+	}
+
+	if (need_retry || smgt->scatters_cnt > 0) {
+		pr_info("can't free all scatter, because some have used!!\n");
+		/*codec_mm_dump_all_scatters();*/
+	}
+	codec_mm_free_all_free_slots_in(smgt);
+	if (smgt->total_page_num > 0) {
+		/*have some not free,dump tables for debug */
+		pr_info("Some slots have not free!!\n\n");
+		/*codec_mm_dump_all_hash_table();*/
+	}
+	mutex_unlock(&smgt->monitor_lock);
+	return smgt->total_page_num;
+}
+EXPORT_SYMBOL(codec_mm_scatter_free_all_ignorecache);
+
+int codec_mm_scatter_free_all_ignorecache(int flags)
+{
+	if (flags & 1)
+		codec_mm_scatter_free_all_ignorecache_in(
+			codec_mm_get_scatter_mgt(0), 2);
+	if (flags & 2)/*free cache and unused pages*/
+		codec_mm_scatter_free_all_ignorecache_in(
+			codec_mm_get_scatter_mgt(1), 1);
+	return 0;
+}
+
+static void codec_mm_scatter_monitor(struct work_struct *work)
+{
+	struct codec_mm_scatter_mgt *smgt = container_of(work,
+					struct codec_mm_scatter_mgt,
+					dealy_work.work);
+	int needretry = 0;
+
+	codec_mm_scatter_update_config(smgt);
+	mutex_lock(&smgt->monitor_lock);
+	smgt->scatter_task_run_num++;
+
+	codec_mm_scatter_scatter_arrange(smgt);
+	needretry = codec_mm_scatter_scatter_clear(smgt, 0);
+
+	if (needretry)
+		codec_mm_schedule_delay_work(smgt, 10, 0);
+	else if (smgt->scatters_cnt > 0)
+		codec_mm_schedule_delay_work(smgt, 100, 0);
+	codec_mm_scatter_cache_manage(smgt);
+	mutex_unlock(&smgt->monitor_lock);
+}
+
+static int codec_mm_scatter_mgt_alloc_in(struct codec_mm_scatter_mgt **psmgt)
+{
+	struct codec_mm_scatter_mgt *smgt;
+
+	smgt = kmalloc(sizeof(struct codec_mm_scatter_mgt), GFP_KERNEL);
+	if (!smgt) {
+		ERR_LOG("ERR:codec mm mpt init ERROR\n");
+		return -1;
+	}
+	memset(smgt, 0, sizeof(struct codec_mm_scatter_mgt));
+	spin_lock_init(&smgt->list_lock);
+	smgt->tag = SMGT_IDENTIFY_TAG;
+	smgt->alloced_page_num = 0;
+	smgt->try_alloc_in_cma_page_cnt = (16 * 1024 * 1024) / PAGE_SIZE;
+	smgt->try_alloc_in_sys_page_cnt_max = MAX_SYS_BLOCK_PAGE;
+	smgt->try_alloc_in_sys_page_cnt = MAX_SYS_BLOCK_PAGE;
+	smgt->try_alloc_in_sys_page_cnt_min = MIN_SYS_BLOCK_PAGE;
+	smgt->reserved_block_mm_M = 300;
+	smgt->keep_size_PAGE = 20 * SZ_1M >> PAGE_SHIFT;
+	smgt->alloc_from_cma_first = 1;
+	smgt->enable_slot_from_sys = 0;
+	smgt->support_from_slot_sys =
+		smgt->enable_slot_from_sys;
+	smgt->mem_flags = CODEC_MM_FLAGS_CMA_FIRST |
+					CODEC_MM_FLAGS_FOR_VDECODER |
+					CODEC_MM_FLAGS_FOR_SCATTER;
+	if ((totalram_pages() << PAGE_SHIFT) < 800 * SZ_1M) {
+		/*less memory boards don't cache more,*/
+		/*after alloced many pages.*/
+		smgt->no_cache_size_M = 100;
+	} else
+		smgt->no_cache_size_M = 0;
+	init_completion(&smgt->complete);
+	INIT_LIST_HEAD(&smgt->free_list);
+	INIT_LIST_HEAD(&smgt->scatter_list);
+	mutex_init(&smgt->monitor_lock);
+
+	INIT_DELAYED_WORK(&smgt->dealy_work,
+				codec_mm_scatter_monitor);
+	*psmgt = smgt;
+	return 0;
+}
+
+static struct mconfig codec_mm_sc_configs[] = {
+	MC_PU32("keep_size_PAGE", &g_scatter.keep_size_PAGE),
+	MC_PU32("reserved_block_mm_M", &g_scatter.reserved_block_mm_M),
+	MC_PU32("try_alloc_in_cma_page_cnt",
+		&g_scatter.try_alloc_in_cma_page_cnt),
+	MC_PU32("try_alloc_in_sys_page_cnt_max",
+		&g_scatter.try_alloc_in_sys_page_cnt_max),
+	MC_PU32("try_alloc_in_sys_page_cnt_min",
+		&g_scatter.try_alloc_in_sys_page_cnt_min),
+	MC_PU32("enable_slot_from_sys",
+		&g_scatter.enable_slot_from_sys),
+	MC_PU32("no_cache_size_M", &g_scatter.no_cache_size_M),
+	MC_PU32("no_alloc_from_sys", &g_scatter.no_alloc_from_sys),
+};
+
+static struct mconfig_node codec_mm_sc;
+
+int codec_mm_scatter_mgt_init(void)
+{
+	struct codec_mm_scatter_mgt *smgt;
+
+	codec_mm_scatter_mgt_alloc_in(&scatter_mgt);
+	codec_mm_scatter_mgt_alloc_in(&scatter_tvp_mgt);
+	scatter_tvp_mgt->tvp_mode = 1;
+	scatter_tvp_mgt->mem_flags |= CODEC_MM_FLAGS_TVP;
+	smgt = scatter_mgt;
+	g_scatter.keep_size_PAGE = smgt->keep_size_PAGE;
+	g_scatter.reserved_block_mm_M = smgt->reserved_block_mm_M;
+	g_scatter.try_alloc_in_cma_page_cnt = smgt->try_alloc_in_cma_page_cnt;
+	g_scatter.try_alloc_in_sys_page_cnt_max
+		= smgt->try_alloc_in_sys_page_cnt_max;
+	g_scatter.try_alloc_in_sys_page_cnt_min
+		= smgt->try_alloc_in_sys_page_cnt_min;
+	g_scatter.enable_slot_from_sys = smgt->enable_slot_from_sys;
+	g_scatter.support_from_slot_sys = smgt->support_from_slot_sys;
+	g_scatter.no_cache_size_M = smgt->no_cache_size_M;
+	g_scatter.no_alloc_from_sys = 0;
+	INIT_REG_NODE_CONFIGS("media.codec_mm",
+		&codec_mm_sc, "scatter",
+		codec_mm_sc_configs,
+		CONFIG_FOR_RW);
+	return 0;
+}
+
+int codec_mm_scatter_mgt_test(void)
+{
+#if 0
+	struct codec_mm_scatter *sc[64];
+
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.11..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	sc[0] = codec_mm_scatter_alloc(10240, 10000);
+	sc[1] = codec_mm_scatter_alloc(10240, 10000);
+	sc[2] = codec_mm_scatter_alloc(10240, 10000);
+	codec_mm_dump_all_scatters();
+	/*codec_mm_dump_all_slots(); */
+	codec_mm_scatter_free(sc[0]);
+	codec_mm_scatter_free(sc[1]);
+	codec_mm_scatter_free(sc[2]);
+	codec_mm_dump_all_scatters();
+	/*codec_mm_dump_all_slots(); */
+#endif
+#if 0
+	struct codec_mm_scatter *sc[64];
+
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.11..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	sc[0] = codec_mm_scatter_alloc(1024, 512);
+
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.22..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+	sc[1] = codec_mm_scatter_alloc(128, 32);
+	sc[2] = codec_mm_scatter_alloc(128, 64);
+	sc[3] = codec_mm_scatter_alloc(128, 128);
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.33..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+	codec_mm_scatter_free_tail_pages(sc[0], 128);	/* 128 */
+	codec_mm_scatter_free_tail_pages(sc[1], 16);	/* 16 */
+	codec_mm_scatter_free_tail_pages(sc[2], 4);	/* 4/4 */
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.44..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_scatter_free(sc[1]);	/* 0 */
+	sc[4] = codec_mm_scatter_alloc(128, 32);	/* 32 */
+	sc[5] = codec_mm_scatter_alloc(512, 256);	/* 256 */
+	codec_mm_scatter_alloc_want_pages(sc[2], 44);	/* 44-->//48 */
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.55.\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+	codec_mm_scatter_free(sc[0]);
+	codec_mm_scatter_free(sc[2]);
+	codec_mm_scatter_free(sc[3]);
+
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.66..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_scatter_free(sc[4]);
+	codec_mm_scatter_free(sc[5]);
+	INFO_LOG("codec_mm_scatter_mgt_test end dump info.77..\n");
+	codec_mm_scatter_info_dump(NULL, 0);
+	codec_mm_dump_all_scatters();
+	codec_mm_dump_all_slots();
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_scatter_mgt_test);
+
+/*
+*mode:0,dump, 1,alloc 2,more,3,free some,4,free all
+*0:dump ALL
+*1: alloc id,num
+*2: alloc more  id,num
+*3: free tail  id,start
+*4: free all  id
+*5:dump id
+*6:dump all free slots
+*/
+int codec_mm_scatter_test(int mode, int p1, int p2)
+{
+	static int init;
+	static struct codec_mm_scatter *sc[64];
+
+	if (!init) {
+		init++;
+		memset(sc, 0, sizeof(sc));
+	}
+	switch (mode) {
+	case 1:		/*alloc */
+		INFO_LOG(" alloc sc[%d] num %d:\n", p1, p2);
+		if (p1 > 0 && p1 < 64) {
+			if (sc[p1])
+				codec_mm_scatter_free_on_nouser(
+				(struct codec_mm_scatter_mgt *)sc[p1]->manager,
+				sc[p1]);
+			sc[p1] = codec_mm_scatter_alloc(p2 * 2, p2, 0);
+		}
+		break;
+	case 2:		/*alloc more */
+		INFO_LOG(" alloc more sc[%d] num %d\n", p1, p2);
+		if (p1 > 0 && p1 < 64 && sc[p1])
+			codec_mm_scatter_alloc_want_pages(sc[p1], p2);
+		break;
+	case 3:		/*alloc tails */
+		INFO_LOG(" free some sc[%d] start free id %d\n", p1, p2);
+		if (p1 > 0 && p1 < 64 && sc[p1])
+			codec_mm_scatter_free_tail_pages(sc[p1], p2);
+		break;
+	case 4:
+		INFO_LOG(" free sc[%d] all\n", p1);
+		if (p1 > 0 && p1 < 64 && sc[p1]) {
+			codec_mm_scatter_free_on_nouser(
+			(struct codec_mm_scatter_mgt *)sc[p1]->manager,
+			sc[p1]);
+			sc[p1] = NULL;
+		}
+		break;
+	case 5:
+		INFO_LOG(" sc %d info:\n", p1);
+		if (p1 > 0 && p1 < 64 && sc[p1])
+			codec_mm_dump_scatter(sc[p1], NULL, 0);
+		break;
+	case 0:
+	default:{
+			int i;
+
+			INFO_LOG(" dump all test sc info:\n");
+			for (i = 0; i < 64; i++) {
+				if (sc[i] != NULL) {
+					INFO_LOG(" alloc sc[%d] has data\n", i);
+					codec_mm_dump_scatter(sc[i], NULL, 0);
+				}
+			}
+		}
+		break;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(codec_mm_scatter_test);
+
diff -Naur a/vendor/amlogic/media/common/codec_mm/codec_mm_scatter_priv.h b/vendor/amlogic/media/common/codec_mm/codec_mm_scatter_priv.h
--- a/vendor/amlogic/media/common/codec_mm/codec_mm_scatter_priv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/codec_mm_scatter_priv.h	2022-06-24 14:37:50.231810166 +0800
@@ -0,0 +1,72 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/codec_mm_scatter_priv.h
+ *
+ * Copyright (C) 2016 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+*/
+
+#ifndef CODEC_MM_SCATTER_PRIV_HEADER
+#define CODEC_MM_SCATTER_PRIV_HEADER
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/amlogic/media/codec_mm/codec_mm.h>
+#include <linux/amlogic/media/codec_mm/codec_mm_scatter.h>
+
+struct codec_mm_slot {
+	struct codec_mm_s *mm;
+	unsigned long page_header;
+#define SLOT_FROM_CODEC_MM 1
+#define SLOT_FROM_GET_FREE_PAGES 2
+	int from_type;
+	void *pagemap;
+	ulong phy_addr;
+	int pagemap_size;
+	int page_num;
+	int alloced_page_num;
+	int next_bit;
+	int sid;
+	int isroot;
+	int on_alloc_free;
+	spinlock_t lock;
+	struct list_head sid_list;
+	struct list_head free_list;
+};
+
+int codec_mm_dump_slot(struct codec_mm_slot *slot, void *buf, int size);
+
+int codec_mm_scatter_mgt_init(void);
+int codec_mm_scatter_mgt_test(void);
+
+int codec_mm_scatter_info_dump(void *buf, int size);
+int codec_mm_dump_all_slots(void);
+int codec_mm_dump_free_slots(void);
+int codec_mm_dump_all_scatters(void);
+
+int codec_mm_scatter_mgt_test(void);
+int codec_mm_scatter_test(int mode, int p1, int p2);
+int codec_mm_dump_all_hash_table(void);
+
+int codec_mm_scatter_mask_for_keep(void *sc_mm);
+int codec_mm_free_all_free_slots(void);
+int codec_mm_scatter_inc_for_keeper(void *sc_mm);
+int codec_mm_scatter_dec_keeper_user(void *sc_mm, int delay_ms);
+
+int codec_mm_scatter_mgt_get_config(char *buf);
+int codec_mm_scatter_mgt_set_config(const char *buf, size_t size);
+
+int codec_mm_scatter_free_all_ignorecache(int flags);
+
+
+void codec_mm_clear_alloc_infos(void);
+
+#endif
diff -Naur a/vendor/amlogic/media/common/codec_mm/configs/configs.c b/vendor/amlogic/media/common/codec_mm/configs/configs.c
--- a/vendor/amlogic/media/common/codec_mm/configs/configs.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/configs/configs.c	2022-06-24 14:37:50.263538733 +0800
@@ -0,0 +1,1099 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/configs/configs.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/amlogic/media/codec_mm/configs.h>
+#include "configs_priv.h"
+static struct mconfig_node root_node;
+static struct mconfig_node *configs_get_root_node(void)
+{
+	return &root_node;
+}
+
+#ifdef DEBUG_CONFIG
+#define config_debug(args...) pr_info(args)
+#else
+#define config_debug(args...)
+#endif
+int configs_inc_node_ref(
+	struct mconfig_node *node)
+{
+	return atomic_inc_return(&node->ref_cnt);
+}
+
+int configs_dec_node_ref(
+	struct mconfig_node *node)
+{
+	return atomic_dec_return(&node->ref_cnt);
+}
+
+static int configs_put_node(struct mconfig_node *node,
+	int del_parent_ref, struct mconfig_node *root_node)
+{
+	struct mconfig_node *pnode;
+
+	if (!node)
+		return 0;
+	configs_dec_node_ref(node);
+	pnode = node->parent_node;
+	if (!del_parent_ref)
+		return 0;
+	while ((pnode != NULL) && (pnode != root_node)) {
+		configs_dec_node_ref(pnode);
+		pnode = pnode->parent_node;
+	}
+	return 0;
+}
+
+
+static int configs_parser_first_node(
+	const char *root_str,
+	char *sub_str,
+	int sub_size,
+	int *is_end_node)
+{
+	int node_size;
+	char *str;
+	char *pstr;
+
+	if (strlen(root_str) <= 0)
+		return 0;
+	str = strchr(root_str, '.');
+	if (str != NULL) {
+		node_size = str - root_str;
+		*is_end_node = 0;
+	} else {
+		str = strchr(root_str, '=');
+		if (str != NULL)
+			node_size = str - root_str;
+		else
+			node_size = strlen(root_str);
+		*is_end_node = 1;
+	}
+	if (node_size >= MAX_ITEM_NAME - 1)
+		node_size = MAX_ITEM_NAME - 1;
+	if (node_size > 0) {
+		strncpy(sub_str, root_str, node_size);
+		sub_str[node_size] = '\0';
+		pstr = sub_str;
+		while (pstr[0] != '\0' &&
+			pstr[0] != ' ' &&
+			pstr[0] != '\r' &&
+			pstr[0] != '\n') {
+			/*not space. */
+			pstr++;
+		}
+		pstr[0] = '\0';
+	} else
+		sub_str[0] = '\0';
+	return node_size;
+}
+
+static inline const char *configs_parser_str_valstr(
+	const char *root_str)
+{
+	char *str;
+
+	if (strlen(root_str) <= 0)
+		return NULL;
+	str = strchr(root_str, '=');
+	if (str)
+		str = str + 1;	/*del = */
+	return str;
+}
+
+static int configs_parser_value_u32(const char *str, u32 *val)
+{
+	int ret = 0;
+	const char *pstr;
+
+	if (!str || strlen(str) <= 0)
+		return 0;
+	pstr = str;
+	while (pstr[0] == ' ')
+		pstr++;
+	if (pstr[0] == '-') {
+		ret = sscanf(pstr, "-%d", val);
+		*val = -((int)*val);
+	} else if (strstr(pstr, "0x"))
+		ret = sscanf(pstr, "0x%x", val);
+	else if (strstr(pstr, "0x"))
+		ret = sscanf(pstr, "0x%x", val);
+	else {
+		ret = kstrtou32(pstr, 0, val);
+		if (ret == 0)
+			ret = 1;
+	}
+	return ret;
+}
+
+static int configs_parser_value_u64(const char *str, u64 *val)
+{
+	int ret = 0;
+	const char *pstr;
+
+	if (!str || strlen(str) <= 0)
+		return 0;
+	pstr = str;
+	while (pstr[0] == ' ')
+		pstr++;
+	if (pstr[0] == '-') {
+		ret = sscanf(pstr, "-%lld", val);
+		*val = -((int)*val);
+	} else if (strstr(pstr, "0x"))
+		ret = sscanf(pstr, "0x%llx", val);
+	else if (strstr(pstr, "0x"))
+		ret = sscanf(pstr, "0x%llx", val);
+	else {
+		ret = kstrtou64(pstr, 0, val);
+		if (ret == 0)
+			ret = 1;
+	}
+	return ret;
+}
+
+static int configs_parser_value_bool(const char *str, bool *pbool)
+{
+	const char *pstr;
+
+	if (!str || strlen(str) <= 0)
+		return 0;
+	pstr = str;
+	while (pstr[0] == ' ')
+		pstr++;
+	if (str[0] == '1') {
+		*pbool = true;
+	} else if (str[0] == '0') {
+		*pbool = false;
+	} else if (!strcmp(str, "true") ||
+			!strcmp(str, "TRUE") ||
+			!strcmp(str, "true")) {
+		*pbool = true;
+	} else if (strcmp(str, "false") ||
+			!strcmp(str, "FALSE") ||
+			!strcmp(str, "False")) {
+		*pbool = false;
+	} else {
+		return 0;
+	}
+	return 1;
+}
+
+
+static struct mconfig_node *configs_get_node_with_name(
+	struct mconfig_node
+	*rootnode, const char *node_name)
+{
+	struct mconfig_node *snode, *need;
+	struct list_head *node_list, *next;
+
+	need = NULL;
+	if (!rootnode)
+		rootnode = configs_get_root_node();
+	mutex_lock(&rootnode->lock);
+	if (list_empty(&rootnode->son_node_list)) {
+		mutex_unlock(&rootnode->lock);
+		return NULL;
+	}
+	list_for_each_safe(node_list, next, &rootnode->son_node_list) {
+		snode = list_entry(node_list, struct mconfig_node, list);
+		if (!strcmp(snode->name, node_name)) {
+			need = snode;
+			if (snode->active <= 0 ||
+				configs_inc_node_ref(need) < 0)
+				need = NULL;
+			break;
+		}
+	}
+	mutex_unlock(&rootnode->lock);
+	return need;
+}
+
+int configs_init_new_node(struct mconfig_node *node,
+	const char *name, int rw_flags)
+{
+	node->configs = NULL;
+	node->configs_num = 0;
+	node->son_node_num = 0;
+	node->name = name;
+	node->rw_flags = rw_flags;
+	node->depth = 0;
+	node->active = 1;
+	node->prefix[0] = '\0';
+	atomic_set(&node->ref_cnt, 0);
+	mutex_init(&node->lock);
+	INIT_LIST_HEAD(&node->list);
+	INIT_LIST_HEAD(&node->son_node_list);
+	return 0;
+}
+EXPORT_SYMBOL(configs_init_new_node);
+
+int configs_register_node(struct mconfig_node *parent,
+	struct mconfig_node *new_node)
+{
+	if (!parent)
+		parent = configs_get_root_node();
+	if (!parent || new_node == parent)
+		return 0;	/*top node add. */
+	if (parent->depth >= MAX_DEPTH)
+		return -1;	/*too deep path */
+	if (strlen(parent->prefix) + strlen(parent->name) >=
+			MAX_PREFIX_NAME - 2) {
+		pr_err("unsupport deep path %s.%s,len=%d > %d\n",
+		       parent->prefix, parent->name,
+		       (int)(strlen(parent->prefix) + strlen(parent->name) + 1),
+		       MAX_PREFIX_NAME - 1);
+		return -2;	/*unsuport deep path */
+	}
+	if (configs_get_node_with_name(parent, new_node->name) != NULL) {
+		pr_err("have register same node[%s] on %s before\n",
+			new_node->name, parent->name);
+		return -3;
+	}
+	/*
+	 *root.name.bb
+	 *depth:0.1.2
+	 *depth 0 &1 don't sed prefix.
+	 *for ignore "root."
+	 */
+	new_node->depth = parent->depth + 1;
+	if (new_node->depth >= 2) {
+		if (parent->prefix[0]) {
+			strcpy(new_node->prefix, parent->prefix);
+			strcat(new_node->prefix, ".");
+		}
+		strcat(new_node->prefix, parent->name);
+	}
+	mutex_lock(&parent->lock);
+	new_node->parent_node = parent;
+	list_add_tail(&new_node->list, &parent->son_node_list);
+	/*
+	 *node parent not have write permissions,
+	 *del the the node write permissions;
+	 *same as read.
+	 */
+	new_node->rw_flags = parent->rw_flags & new_node->rw_flags;
+	parent->son_node_num++;
+	new_node->active = 1;
+	mutex_unlock(&parent->lock);
+	return 0;
+}
+EXPORT_SYMBOL(configs_register_node);
+
+struct mconfig_node *configs_get_node_path_end_node(
+	struct mconfig_node *root_node, const char *path)
+{
+	char sub_node_name[128];
+	struct mconfig_node *node, *start_node, *parent_node;
+	int i, end;
+	const char *next_path = path;
+
+	if (!path)
+		return NULL;
+	end = 0;
+	start_node = root_node;
+	if (!root_node)
+		start_node = configs_get_root_node();
+	node = start_node;
+	while (!end) {
+		parent_node = node;
+		i = configs_parser_first_node(next_path,
+			sub_node_name, 128, &end);
+		if (i <= 0 || sub_node_name[0] == '\0') {
+			pr_err("can't find [%s] 's node!!\n", path);
+			return NULL;
+		}
+		/*only no top node. */
+		if (end && !root_node && node == start_node) {
+			if (!strcmp(node->name, sub_node_name)) {
+				/*need node is top node */
+				break;
+			}
+		}
+		config_debug("configs_parser_first_node{%s} end%d\n",
+			sub_node_name, end);
+		node = configs_get_node_with_name(parent_node,
+			sub_node_name);
+		if (node == NULL) {
+			pr_err("can't find node:[%s], from:[%s], path=%s\n",
+				sub_node_name, parent_node->name, path);
+			return NULL;
+		}
+		next_path = next_path + i + 1;	/*media.vdec --> vdec */
+		config_debug("get snode[%s] from node[%s], end=%d\n",
+			node->name, parent_node->name, end);
+	}
+	return node;
+}
+EXPORT_SYMBOL(configs_get_node_path_end_node);
+
+int configs_register_path_node(const char *path,
+	struct mconfig_node *new_node)
+{
+	struct mconfig_node *parent = NULL;
+	int ret;
+
+	if (path && strlen(path) > 0) {
+		parent = configs_get_node_path_end_node(NULL, path);
+		if (!parent)
+			return -1;
+	}
+	ret = configs_register_node(parent, new_node);
+	configs_put_node(parent, 1, NULL);
+	return ret;
+}
+EXPORT_SYMBOL(configs_register_path_node);
+
+int configs_register_configs(struct mconfig_node *node,
+	struct mconfig *configs, int num)
+{
+	if (!node)
+		return -1;
+	if (node->configs != NULL || node->configs_num > 0) {
+		pr_err("node[%s] register config before!.\n", node->name);
+		return -2;
+	}
+	if (0) {
+		int i;
+
+		for (i = 0; i < num; i++) {
+			pr_info("init node:%s, config[i].data %lx-%lx\n",
+				node->name,
+				configs[i].ldata[0],
+				configs[i].ldata[1]);
+		}
+	}
+	mutex_lock(&node->lock);
+	node->configs = configs;
+	node->configs_num = num;
+	mutex_unlock(&node->lock);
+	return 0;
+}
+EXPORT_SYMBOL(configs_register_configs);
+
+int configs_register_path_configs(const char *path,
+	struct mconfig *configs, int num)
+{
+	struct mconfig_node *parent = NULL;
+	int ret;
+
+	if (path && strlen(path) > 0) {
+		parent = configs_get_node_path_end_node(NULL, path);
+		if (!parent)
+			return -1;
+		ret = configs_register_configs(parent, configs, num);
+		configs_put_node(parent, 1, NULL);
+		return ret;
+	}
+	return -1;
+}
+EXPORT_SYMBOL(configs_register_path_configs);
+
+int configs_del_endnode(struct mconfig_node *parent,
+	struct mconfig_node *node)
+{
+	struct mconfig_node *parent_node;
+
+	parent_node = node->parent_node;
+	node->active = 0;
+	/*always set it to no active */
+	if (atomic_read(&node->ref_cnt) != 0)
+		return -1;
+	/*always del configs. */
+	node->configs = NULL;
+	node->configs_num = 0;
+	/*do't del node when have son node. */
+	if (node->son_node_num > 0)
+		return -2;
+	if (parent) {
+		mutex_lock(&parent->lock);
+		list_del(&node->list);
+		parent->son_node_num--;
+		mutex_unlock(&parent->lock);
+	}
+	return 0;
+}
+
+static struct mconfig *configs_get_node_config(
+	struct mconfig_node *node, char *name)
+{
+	int i;
+	struct mconfig *config = NULL;
+
+	mutex_lock(&node->lock);
+	for (i = 0; i < node->configs_num; i++) {
+		struct mconfig *val = &node->configs[i];
+
+		if (val && !strcmp(val->item_name, name)) {
+			configs_inc_node_ref(node);
+			config = val;
+			break;
+		}
+	}
+	mutex_unlock(&node->lock);
+	config_debug("get config[%s] from %s-end-%p\n",
+		name, node->name, (void *)config);
+	return config;
+}
+
+static int configs_config2str(struct mconfig *config,
+	char *buf, int size)
+{
+	int ret = 0;
+
+	if (size < 1)
+		return 0;
+	switch (config->type) {
+	case CONFIG_TYPE_PBOOL:
+		ret = snprintf(buf, size, "%s",
+			config->pboolval[0] ? "true" : "false");
+		break;
+	case CONFIG_TYPE_PI32:
+		ret = snprintf(buf, size, "%u", config->pival[0]);
+		break;
+	case CONFIG_TYPE_PU32:
+		ret = snprintf(buf, size, "%d", config->pu32val[0]);
+		break;
+	case CONFIG_TYPE_PU64:
+		ret = snprintf(buf, size, "%llx", config->pu64val[0]);
+		break;
+	case CONFIG_TYPE_PSTR:
+	case CONFIG_TYPE_PCSTR:
+		ret = snprintf(buf, size, "%s", config->str);
+		break;
+	case CONFIG_TYPE_BOOL:
+		ret = snprintf(buf, size, "%s",
+			config->pboolval ? "true" : "false");
+		break;
+	case CONFIG_TYPE_I32:
+		ret = snprintf(buf, size, "%d", config->ival);
+		break;
+	case CONFIG_TYPE_U32:
+		ret = snprintf(buf, size, "%u", config->u32val);
+		break;
+	case CONFIG_TYPE_U64:
+		ret = snprintf(buf, size, "0x%llx", config->u64val);
+		break;
+	case CONFIG_TYPE_FUN:
+		if (!config->f_get)
+			ret = 0;
+		else
+			ret = config->f_get(config->item_name,
+				config->id, buf, size);
+		break;
+	default:
+		ret = -4;
+	}
+	if (ret <= 0) {
+		pr_err("config2str error %s-type:%d,%lx-%lx,ret=%d\n",
+		       config->item_name, config->type,
+		       config->ldata[0], config->ldata[1], ret);
+	} else if (ret >= size) {
+		buf[size - 1] = '\0';
+		ret = size - 1;
+	}
+	return ret;
+}
+
+static int configs_str2config(struct mconfig *config,
+	const char *str)
+{
+	int ret = 0;
+	u32 val;
+	u64 val64;
+	bool bval;
+
+	if (!str || strlen(str) <= 0)
+		return 0;
+	switch (config->type) {
+	case CONFIG_TYPE_PBOOL:
+	case CONFIG_TYPE_BOOL:
+		ret = configs_parser_value_bool(str, &bval);
+		if (ret <= 0)
+			break;
+		if (config->type == CONFIG_TYPE_PBOOL)
+			config->pboolval[0] = bval;
+		else
+			config->boolval = bval;
+		break;
+	case CONFIG_TYPE_PI32:
+	case CONFIG_TYPE_PU32:
+		ret = configs_parser_value_u32(str, (u32 *) &val);
+		if (ret > 0)
+			config->pu32val[0] = val;
+		break;
+	case CONFIG_TYPE_PU64:
+		ret = configs_parser_value_u64(str, (u64 *) &val64);
+		if (ret > 0)
+			config->pu64val[0] = val64;
+		break;
+	case CONFIG_TYPE_PSTR:
+		strncpy(config->str, str, config->size);
+		ret = strlen(config->str);
+		break;
+	case CONFIG_TYPE_I32:
+	case CONFIG_TYPE_U32:
+		ret = configs_parser_value_u32(str, (u32 *) &val);
+		if (ret > 0)
+			config->u32val = val;
+		break;
+	case CONFIG_TYPE_U64:
+		ret = configs_parser_value_u64(str, (u64 *) &val64);
+		if (ret > 0)
+			config->u64val = val64;
+		break;
+	case CONFIG_TYPE_FUN:
+		if (!config->f_set)
+			ret = -1;
+		else
+			ret = config->f_set(config->item_name,
+					config->id,
+					str, strlen(str));
+		break;
+	case CONFIG_TYPE_PCSTR:	/*can't set. */
+	default:
+		ret = -4;
+	}
+	return ret;
+}
+
+static char *configs_build_prefix(
+		struct mconfig_node *node,
+		const char *prefix,
+		int mode,
+		char *buf,
+		int size)
+{
+	if (!buf)
+		return "";
+	buf[0] = '\0';
+	if (mode & LIST_MODE_PATH_FULLPREFIX) {
+		if (node->prefix[0]) {
+			snprintf(buf, size, "%s",
+				node->prefix);
+		}
+	} else if (mode & LIST_MODE_PATH_PREFIX) {
+		if (prefix && prefix[0]) {
+			snprintf(buf, size, "%s",
+				prefix);
+		}
+	}
+	if (buf[0] && buf[strlen(buf) - 1] != '.')
+		strncat(buf, ".", size);
+	return buf;
+}
+
+static int configs_list_node_configs_locked(
+	struct mconfig_node *node,
+	char *buf, int size, const char *prefix,
+	int mode)
+{
+	int i;
+	int ret;
+	int pn_size = 0;
+	struct mconfig *config = NULL;
+	const char *cprefix = prefix;
+
+	if (!buf || size < 8 || !node->configs)
+		return 0;
+	if (!cprefix)
+		cprefix = "";
+	for (i = 0; i < node->configs_num && (size - pn_size) > 8; i++) {
+		config = &node->configs[i];
+		ret = snprintf(buf + pn_size,
+				size - pn_size,
+				" %s%s.%s%s",
+			     cprefix,
+			     node->name,
+			     config->item_name,
+			     (node->rw_flags & CONFIG_FOR_R) ? "=" : "");
+		if (ret > 0)
+			pn_size += ret;
+		if ((mode & LIST_MODE_VAL) &&
+			((mode & CONFIG_FOR_T) ||
+			!(CONFIG_FOR_T & node->rw_flags)) &&
+			(node->rw_flags & CONFIG_FOR_R)) {
+			ret = configs_config2str(config,
+				buf + pn_size, size - pn_size);
+			if (ret > 0) {
+				if ((pn_size + ret) < size) {
+					strcat(buf, "\n");
+					ret++;
+				}
+				pn_size += ret;
+			} else {
+				if (ret == 0 && (pn_size + ret) < size) {
+					strcat(buf, "\n");
+					ret++;
+					continue;
+				}
+				break;
+			}
+		} else {
+			ret = snprintf(buf + pn_size, size - pn_size, "\n");
+			if (ret > 0)
+				pn_size += ret;
+		}
+	}
+	return pn_size;
+}
+
+int configs_list_node_configs(struct mconfig_node *node,
+	char *buf, int size,
+	int mode)
+{
+	int ret;
+
+	mutex_lock(&node->lock);
+	ret = configs_list_node_configs_locked(node, buf,
+		size, NULL, mode);
+	mutex_unlock(&node->lock);
+	return ret;
+}
+
+static int configs_list_nodes_in(struct mconfig_node *node,
+	char *buf, int size, const char *prefix,
+	int mode)
+{
+	int ret;
+	int pn_size = 0;
+	char cprefix[MAX_PREFIX_NAME + MAX_ITEM_NAME];
+	char *c_prefix;
+	char rw[4][4] = { "N", "r", "w", "rw" };
+
+	if (!node || !buf || size <= 0)
+		return 0;
+	if (!(node->rw_flags & mode))
+		return 0;/*LIST_MODE_LIST_RD/WD flags*/
+	config_debug("start dump node %s...\n", node->name);
+	c_prefix = configs_build_prefix(node,
+				prefix,
+				mode,
+				cprefix,
+				MAX_PREFIX_NAME + MAX_ITEM_NAME);
+	mutex_lock(&node->lock);
+	if (mode & LIST_MODE_NODE_INFO) {
+		ret = snprintf(buf + pn_size, size - pn_size,
+				"[NODE]%s%s:[%s/%d/%d/%d]\n",
+			     c_prefix,
+			     node->name,
+			     rw[(node->rw_flags & 3)],
+			     atomic_read(&node->ref_cnt),
+			     node->configs_num,
+			     node->depth);
+		if (ret > 0)
+			pn_size += ret;
+	}
+	if (mode & LIST_MODE_CONFIGS_VAL) {
+		ret = configs_list_node_configs_locked(node, buf + pn_size,
+			size - pn_size, c_prefix, mode);
+		if (ret > 0)
+			pn_size += ret;
+	}
+	if ((mode & LIST_MODE_SUB_NODES) && node->son_node_num > 0) {
+		struct mconfig_node *snode;
+		struct list_head *node_list, *next;
+
+		if (mode & LIST_MODE_PATH_PREFIX) {
+			if (node->depth > 0) {/*not root.*/
+				strncat(cprefix, node->name,
+					MAX_PREFIX_NAME + MAX_ITEM_NAME - 1);
+			}
+		}
+		list_for_each_safe(node_list, next, &node->son_node_list) {
+			snode = list_entry(node_list,
+					struct mconfig_node, list);
+			if (snode) {
+				ret = configs_list_nodes_in(snode,
+					buf + pn_size, size - pn_size,
+					cprefix, mode);
+				if (ret > 0)
+					pn_size += ret;
+			}
+		}
+	}
+	mutex_unlock(&node->lock);
+	return pn_size;
+}
+
+int configs_list_nodes(struct mconfig_node *node,
+	char *buf, int size, int mode)
+{
+	if (!node)
+		node = configs_get_root_node();
+	return configs_list_nodes_in(node, buf, size,
+			NULL,
+			mode);
+}
+
+int configs_list_path_nodes(const char *prefix,
+	char *buf, int size, int mode)
+{
+	struct mconfig_node *node;
+	int ret = 0;
+
+	node = configs_get_node_path_end_node(NULL, prefix);
+	if (node != NULL) {
+		ret = configs_list_nodes(node, buf, size, mode);
+		configs_put_node(node, 1, NULL);
+	}
+	return ret;
+}
+
+static int configs_get_node_path_config(
+	struct mconfig_node *root_node,
+	struct mconfig **config_ret,
+	const char *path,
+	struct mconfig_node **hold_node, int set)
+{
+	char sub_node_name[128];
+	struct mconfig_node *node, *parent_node;
+	struct mconfig *config = NULL;
+	int i, end;
+	const char *next_path = path;
+	int err = 0;
+
+	if (!path)
+		return -EIO;
+	end = 0;
+	if (!root_node)
+		root_node = configs_get_root_node();
+	node = root_node;
+	while (!end) {
+		parent_node = node;
+		i = configs_parser_first_node(next_path,
+			sub_node_name, 128, &end);
+		if (i <= 0 || sub_node_name[0] == '\0') {
+			pr_err("can't find [%s] 's node!!\n", path);
+			return -1;
+		}
+		config_debug("configs_parser_first_node{%s} end%d\n",
+			sub_node_name, end);
+		if (!end) {
+			node = configs_get_node_with_name(parent_node,
+				sub_node_name);
+			if (node == NULL) {
+				if (parent_node != root_node) {
+					node = parent_node;
+					err = -EPERM;
+					goto out;
+				}
+				/*for reset refs. */
+				pr_err("can't find node:[%s], from:[%s], path=%s\n",
+				       sub_node_name, parent_node->name, path);
+				err = -ENOENT;
+				goto out;
+			}
+			next_path = next_path + i + 1;	/*media.vdec --> vdec */
+			config_debug("get snode[%s] from node[%s], end=%d\n",
+				node->name, parent_node->name, end);
+		}
+	}
+	if (set && !(node->rw_flags & CONFIG_FOR_W)) {
+		err = -ENOENT;
+		goto out;
+	}
+	if (!set && !(node->rw_flags & CONFIG_FOR_R)) {
+		err = -EPERM;
+		goto out;
+	}
+	config = configs_get_node_config(node, sub_node_name);
+	if (!config) {
+		/*release node refs. */
+		err = -EPERM;
+	} else
+		*hold_node = node;
+ out:
+	if (config == NULL) {
+		if (node) {
+			configs_put_node(node, 1, root_node);
+			pr_err("can't find node %s's  config:%s\n",
+				node->name, sub_node_name);
+		} else
+			pr_err("can't find node %s from %s\n",
+			sub_node_name, root_node->name);
+	} else {
+		*config_ret = config;
+		err = 0;
+	}
+	return err;
+}
+
+static int configs_setget_config_value(struct mconfig *config,
+	const void *val_set, void *val_get, int size, int set)
+{
+	int s;
+	int ret;
+	void *dst;
+	const void *src;
+
+	if (set) {
+		dst = config->buf_ptr;
+		src = val_set;
+	} else {
+		dst = val_get;
+		src = config->buf_ptr;
+	}
+	if (!dst || !src)
+		return -1;
+	switch (config->type) {
+	case CONFIG_TYPE_PU32:
+	case CONFIG_TYPE_PI32:
+		if (size < sizeof(u32))
+			return -2;
+		((u32 *) dst)[0] = ((const u32 *)src)[0];
+		ret = sizeof(u32);
+		break;
+	case CONFIG_TYPE_PU64:
+		if (size < sizeof(u64))
+			return -2;
+		((u64 *) dst)[0] = ((const u64 *)src)[0];
+		ret = sizeof(u64);
+		break;
+	case CONFIG_TYPE_PCSTR:
+		if (set) {
+			ret = -3;
+			break;
+		}
+		/*rd same as CONFIG_TYPE_PSTR */
+	case CONFIG_TYPE_PSTR:
+		s = min_t(int, size - 1, config->size - 1);
+		if (s > 0)
+			strncpy(dst, src, s);
+		else {
+			ret = -3;
+			break;
+		}
+		ret = s;
+		break;
+	case CONFIG_TYPE_U32:
+	case CONFIG_TYPE_I32:
+		if (size < sizeof(u32))
+			return -2;
+		if (set)
+			config->u32val = ((const u32 *)src)[0];
+		else
+			((u32 *) dst)[0] = config->u32val;
+		ret = sizeof(u32);
+		break;
+	case CONFIG_TYPE_U64:
+		if (size < sizeof(u64))
+			return -2;
+		if (set)
+			config->u64val = ((const u64 *)src)[0];
+		else
+			((u64 *) dst)[0] = config->u64val;
+		ret = sizeof(u64);
+		break;
+	default:
+		ret = -4;
+	}
+	return ret;
+}
+
+static int configs_setget_node_path_value(
+	struct mconfig_node *topnode,
+	const char *path,
+	const void *val_set, void *val_get,
+	int size, int set)
+{
+	struct mconfig_node *node;
+	struct mconfig *config;
+	int ret;
+
+	ret = configs_get_node_path_config(topnode, &config, path, &node, set);
+	if (ret != 0)
+		return ret;
+	if (set)
+		pr_err("start set config val config=%s, val=%x\n",
+		config->item_name, *(int *)val_set);
+	ret = configs_setget_config_value(config, val_set,
+		val_get, size, set);
+	config_debug("setget config val config=%s, ret=%x end\n",
+		config->item_name, ret);
+	configs_put_node(node, 0, topnode);
+	configs_put_node(node, 1, topnode);
+	return ret;
+}
+
+int configs_set_node_path_str(struct mconfig_node *topnode,
+	const char *path, const char *val)
+{
+	struct mconfig_node *node;
+	struct mconfig *config;
+	int ret = -1;
+
+	if (!val || !path || strlen(path) <= 0 || strlen(val) <= 0)
+		return -1;
+	ret = configs_get_node_path_config(topnode, &config, path, &node, 1);
+	if (ret != 0)
+		return ret;
+	config_debug("start set config val config=%s, %s\n",
+		config->item_name, val);
+	mutex_lock(&node->lock);
+	ret = configs_str2config(config, val);
+	mutex_unlock(&node->lock);
+	configs_put_node(node, 0, topnode);
+	configs_put_node(node, 1, topnode);
+	if (ret > 0)
+		ret = 0;/*set ok*/
+	else if (ret == 0)
+		ret = -1;/*val not changed.*/
+	return ret;
+}
+int configs_set_node_nodepath_str(struct mconfig_node *topnode,
+	const char *path, const char *val)
+{
+	if (topnode == NULL) {
+		return configs_set_node_path_str(topnode,
+			path, val);
+	}
+	if (strncmp(topnode->name, path, strlen(topnode->name))) {
+		pr_err("nodepath(%s) must start from node=%s\n",
+			path, topnode->name);
+		return -1;
+	}
+	return configs_set_node_path_str(topnode,
+			path + strlen(topnode->name) + 1, val);
+}
+
+int configs_set_prefix_path_str(const char *prefix,
+	const char *path, const char *str)
+{
+	struct mconfig_node *topnode = NULL;
+	int ret;
+
+	if (prefix && strlen(prefix) > 0) {
+		topnode = configs_get_node_path_end_node(NULL, prefix);
+		if (!topnode) {
+			pr_err("[0]can't get node from %s\n", prefix);
+			return -1;
+		}
+	}
+	ret = configs_set_node_path_str(topnode, path, str);
+	configs_put_node(topnode, 1, NULL);
+	return ret;
+}
+
+int configs_set_node_path_valonpath(
+	struct mconfig_node *topnode,
+	const char *path)
+{
+	return configs_set_node_path_str(topnode, path,
+		configs_parser_str_valstr(path));
+}
+
+int configs_set_prefix_path_valonpath(const char *prefix,
+	const char *path)
+{
+	struct mconfig_node *topnode = NULL;
+	int ret;
+
+	if (prefix && strlen(prefix) > 0) {
+		topnode = configs_get_node_path_end_node(NULL, prefix);
+		if (!topnode) {
+			pr_err("can't get node from %s\n", prefix);
+			return -1;
+		}
+	}
+	ret = configs_set_node_path_str(topnode, path,
+		configs_parser_str_valstr(path));
+	configs_put_node(topnode, 1, NULL);
+	return ret;
+}
+
+int configs_get_node_path_str(struct mconfig_node *topnode,
+	const char *path, char *buf, int size)
+{
+	struct mconfig_node *node;
+	struct mconfig *config;
+	int ret = -1;
+
+	if (!path || strlen(path) <= 0)
+		return -1;
+	ret = configs_get_node_path_config(topnode,
+		&config, path, &node, 0);
+	if (ret != 0)
+		return ret;
+	config_debug("startget config val config=%s\n",
+		config->item_name);
+	ret = configs_config2str(config, buf, size);
+	configs_put_node(node, 0, topnode);
+	configs_put_node(node, 1, topnode);
+	return ret;
+}
+int configs_get_node_nodepath_str(struct mconfig_node *topnode,
+	const char *path, char *buf, int size)
+{
+	if (topnode == NULL)
+		return configs_get_node_path_str(topnode, path, buf, size);
+	if (strncmp(topnode->name, path, strlen(topnode->name))) {
+		pr_err("nodepath(%s) must start from node=%s\n",
+			path, topnode->name);
+		return -1;
+	}
+	return configs_get_node_path_str(topnode,
+		path + strlen(topnode->name) + 1,
+		buf, size);
+
+}
+
+static inline int configs_set_node_path_value(
+	struct mconfig_node *topnode,
+	const char *path, const void *val, int size)
+{
+	return configs_setget_node_path_value(topnode,
+		path, val, NULL, size, 1);
+}
+
+static int configs_get_node_path_value(struct mconfig_node *topnode,
+	const char *path, void *val, int size)
+{
+	return configs_setget_node_path_value(topnode,
+		path, NULL, val, size, 0);
+}
+
+int configs_get_node_path_u32(struct mconfig_node *topnode,
+	const char *path, u32 *val)
+{
+	return configs_get_node_path_value(topnode, path, val, sizeof(u32));
+}
+
+int configs_get_node_path_u64(struct mconfig_node *topnode,
+	const char *path, u64 *val)
+{
+	return configs_get_node_path_value(topnode, path, val, sizeof(u64));
+}
+
+int configs_set_node_path_u32(struct mconfig_node *topnode,
+	const char *path, u32 val)
+{
+	return configs_set_node_path_value(topnode, path, &val, sizeof(u32));
+}
+
+int configs_set_node_path_u64(struct mconfig_node *topnode,
+	const char *path, u64 val)
+{
+	return configs_set_node_path_value(topnode, path, &val,
+		sizeof(u64));
+}
+
+int configs_config_system_init(void)
+{
+	configs_init_new_node(&root_node, "root", CONFIG_FOR_RW);
+	configs_register_node(NULL, &root_node);
+	return 0;
+}
diff -Naur a/vendor/amlogic/media/common/codec_mm/configs/configs_module.c b/vendor/amlogic/media/common/codec_mm/configs/configs_module.c
--- a/vendor/amlogic/media/common/codec_mm/configs/configs_module.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/configs/configs_module.c	2022-06-24 14:37:50.290802131 +0800
@@ -0,0 +1,493 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/configs/configs_module.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/mm.h>
+#include <linux/compat.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/amlogic/media/codec_mm/configs.h>
+#include <linux/amlogic/media/codec_mm/configs_api.h>
+#define MAX_OPENED_CNT 65536
+#include "configs_priv.h"
+#define MODULE_NAME "media-configs-dev"
+
+static struct class *config_dev_class;
+static unsigned int config_major;
+struct mediaconfig_node {
+	const char *parent;
+	const char *name;
+	const char *dev_name;
+	int rw_flags;
+	atomic_t opened_cnt;
+	struct device *class_dev;
+	struct mconfig_node node;
+
+};
+
+static ssize_t all_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_nodes(NULL, buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+
+static ssize_t media_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+
+static ssize_t video_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media.video", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+static ssize_t decoder_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media.decoder", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+static ssize_t vdec_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media.vdec", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+static ssize_t tsync_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media.tsync", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+
+
+static ssize_t amports_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media.amports", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+static ssize_t parser_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media.parser", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+
+static ssize_t config_show(struct class *class,
+			   struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_nodes(NULL, buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+
+static ssize_t config_store(struct class *class,
+			    struct class_attribute *attr,
+			    const char *buf, size_t size)
+{
+	ssize_t ret;
+
+	ret = configs_set_path_valonpath(buf);
+	if (ret >= 0)
+		return size;
+	return ret;
+}
+
+static ssize_t debug_show(struct class *class,
+			  struct class_attribute *attr, char *buf)
+{
+	return config_dump(buf, PAGE_SIZE);
+}
+
+static ssize_t debug_store(struct class *class,
+			   struct class_attribute *attr,
+			   const char *buf, size_t size)
+{
+	configs_config_setstr(buf);
+	return size;
+}
+
+static ssize_t audio_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media.audio", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+static ssize_t vfm_show(struct class *class,
+			struct class_attribute *attr, char *buf)
+{
+	ssize_t s;
+
+	s = configs_list_path_nodes("media.vfm", buf, PAGE_SIZE,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (s > 0)
+		return s;
+	return -EPERM;
+}
+
+static CLASS_ATTR_RO(all);
+static CLASS_ATTR_RO(media);
+static CLASS_ATTR_RO(video);
+static CLASS_ATTR_RO(decoder);
+static CLASS_ATTR_RO(amports);
+static CLASS_ATTR_RO(tsync);
+static CLASS_ATTR_RO(parser);
+static CLASS_ATTR_RO(vdec);
+static CLASS_ATTR_RO(audio);
+static CLASS_ATTR_RO(vfm);
+static CLASS_ATTR_RW(config);
+static CLASS_ATTR_RW(debug);
+
+static struct attribute *configs_class_attrs[] = {
+	&class_attr_all.attr,
+	&class_attr_media.attr,
+	&class_attr_video.attr,
+	&class_attr_decoder.attr,
+	&class_attr_amports.attr,
+	&class_attr_tsync.attr,
+	&class_attr_parser.attr,
+	&class_attr_vdec.attr,
+	&class_attr_audio.attr,
+	&class_attr_vfm.attr,
+	&class_attr_config.attr,
+	&class_attr_debug.attr,
+	NULL
+};
+
+ATTRIBUTE_GROUPS(configs_class);
+
+static struct class media_configs_class = {
+		.name = "media-configs",
+		.class_groups = configs_class_groups,
+};
+
+static struct mediaconfig_node mediaconfig_nodes[] = {
+	{"", "media", "media", CONFIG_FOR_RW},
+	{"media", "decoder", "media.decoder", CONFIG_FOR_RW},
+	{"media", "parser", "media.parser", CONFIG_FOR_RW},
+	{"media", "video", "media.video", CONFIG_FOR_RW},
+	{"media", "amports", "media.amports", CONFIG_FOR_RW},
+	{"media", "tsync", "media.tsync", CONFIG_FOR_RW},
+	{"media", "codec_mm", "media.codec_mm", CONFIG_FOR_RW},
+	{"media", "audio", "media.audio", CONFIG_FOR_RW},
+	{"media", "vfm", "media.vfm", CONFIG_FOR_RW},
+};
+
+struct config_file_private {
+	struct mediaconfig_node *node;
+	char common[128];
+	pid_t pid;
+	pid_t tgid;
+	long opened_jiffies;
+	long last_access_jiffies;
+	long access_get_cnt;
+	long access_set_cnt;
+	long access_dump_cnt;
+	long error_cnt;
+	int enable_trace_get;
+	int enable_trace_set;
+	int last_read_end;
+};
+
+static int configs_open(struct inode *inode, struct file *file)
+{
+	struct mediaconfig_node *node = &mediaconfig_nodes[iminor(inode)];
+	struct config_file_private *priv;
+
+	if (atomic_read(&node->opened_cnt) > MAX_OPENED_CNT) {
+		pr_err("too many files opened.!!\n");
+		return -EMFILE;
+	}
+	priv = kzalloc(sizeof(struct config_file_private), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	file->private_data = priv;
+	priv->pid = current->pid;
+	priv->tgid = current->tgid;
+	priv->opened_jiffies = jiffies;
+	priv->node = node;
+	atomic_inc(&node->opened_cnt);
+	configs_inc_node_ref(&node->node);
+	return 0;
+}
+static ssize_t configs_read(struct file *file, char __user *buf,
+			size_t count, loff_t *ppos)
+{
+	struct config_file_private *priv = file->private_data;
+	struct mediaconfig_node *node = priv->node;
+	int ret;
+
+	if (*ppos > 0)
+		return 0;/*don't support seek read. read end.*/
+	if (!access_ok(buf, count))
+		return -EIO;
+	ret = configs_list_nodes(&node->node, buf, count,
+		LIST_MODE_NODE_CMDVAL_ALL);
+	if (ret > 0)
+		*ppos = ret;
+	return ret;
+}
+
+static int configs_close(struct inode *inode, struct file *file)
+{
+	struct config_file_private *priv = file->private_data;
+	struct mediaconfig_node *node = priv->node;
+
+	configs_dec_node_ref(&node->node);
+	atomic_dec(&node->opened_cnt);
+
+	kfree(priv);
+
+	return 0;
+}
+static long configs_ioctl(struct file *file, unsigned int cmd, ulong arg)
+{
+	struct config_file_private *priv = file->private_data;
+	struct mediaconfig_node *node = priv->node;
+	struct media_config_io_str io;
+	struct media_config_io_str *user_io = (void *)arg;
+	int r = -1;
+
+	priv->last_access_jiffies = jiffies;
+	switch (cmd) {
+	case MEDIA_CONFIG_SET_CMD_STR:
+		priv->access_set_cnt++;
+		r = copy_from_user(io.cmd_path,
+			user_io->cmd_path, sizeof(io.cmd_path));
+		r |= copy_from_user(io.val, user_io->val, sizeof(io.val));
+		/*pr_info("set%s:%s dev=%s\n", io.cmd_path,*/
+		/*io.val, node->dev_name);*/
+		if (r) {
+			r = -EIO;
+			break;
+		}
+		if (!strncmp(io.cmd_path, node->dev_name,
+		strlen(node->dev_name)))
+			r = configs_set_node_nodepath_str(NULL,
+				io.cmd_path,
+				io.val);
+		else
+		    pr_info("set %s %s  not match devname=%s\n",
+		io.cmd_path, io.val, node->dev_name);
+		break;
+	case MEDIA_CONFIG_GET_CMD_STR:
+		r = -1;
+		priv->access_get_cnt++;
+		r = copy_from_user(&io.cmd_path,
+				user_io->cmd_path, sizeof(io.cmd_path));
+		io.cmd_path[sizeof(io.cmd_path) - 1] = '\0';
+		if (r) {
+			r = -EIO;
+			break;
+		}
+		io.val[0] = '\0';
+		if (!strncmp(io.cmd_path, node->dev_name,
+		strlen(node->dev_name))) {
+			r = configs_get_node_nodepath_str(NULL,
+				io.cmd_path,
+				io.val,
+				sizeof(io.val));
+
+		/*pr_info("configs_get_node_nodepath_str*/
+		/*ret %x [%s]\n", r, io.val);*/
+		if (r > 0 && r <= sizeof(io.val) - 1) {
+			/*+1 for end str.*/
+			if (copy_to_user(user_io->val, io.val, r + 1) != 0) {
+				r = -EIO;
+				break;
+				}
+				put_user(r, &user_io->ret);
+				r = 0;
+			} else {
+				 put_user(-1, &user_io->ret);
+			}
+		} else
+			pr_info("set %s %s  not match devname=%s\n",
+			io.cmd_path, io.val, node->dev_name);
+		break;
+	default:
+		r = -EINVAL;
+		pr_err("unsupport cmd %x\n", cmd);
+	}
+	if (r < 0)
+		priv->error_cnt++;
+	return r;
+}
+
+
+
+#ifdef CONFIG_COMPAT
+static long configs_compat_ioctl(struct file *file,
+		unsigned int cmd, ulong arg)
+{
+	return configs_ioctl(file, cmd, (ulong)compat_ptr(arg));
+}
+#endif
+static const struct file_operations configs_fops = {
+	.owner = THIS_MODULE,
+	.open = configs_open,
+	.read = configs_read,
+	.release = configs_close,
+	.unlocked_ioctl = configs_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = configs_compat_ioctl,
+#endif
+};
+
+
+static int __init configs_init_devices(void)
+{
+	int i;
+	int num = sizeof(mediaconfig_nodes)/sizeof(struct mediaconfig_node);
+
+	int r;
+
+	r = class_register(&media_configs_class);
+	if (r) {
+		pr_err("configs class create fail.\n");
+		goto error1;
+	}
+
+	r = register_chrdev(0, MODULE_NAME, &configs_fops);
+	if (r < 0) {
+		pr_err("Can't allocate major for config device\n");
+		goto error1;
+	}
+	config_major = r;
+
+	config_dev_class = class_create(THIS_MODULE, MODULE_NAME);
+	num = sizeof(mediaconfig_nodes)/sizeof(struct mediaconfig_node);
+	for (i = 0; i < num; i++) {
+		struct mediaconfig_node *mnode = &mediaconfig_nodes[i];
+
+		mnode->class_dev = device_create(config_dev_class, NULL,
+				MKDEV(config_major, i), NULL,
+				mnode->dev_name);
+		if (mnode->class_dev == NULL) {
+			pr_err("device_create %s failed\n", mnode->dev_name);
+			r = -1;
+			goto error2;
+		}
+	}
+	return 0;
+#if 0
+error3:
+	for (mnode = &mediaconfig_nodes[0], i = 0; i < num; i++, mnode++)
+		device_destroy(config_dev_class, MKDEV(config_major, i));
+	class_destroy(config_dev_class);
+#endif
+error2:
+	unregister_chrdev(config_major, MODULE_NAME);
+error1:
+	class_destroy(&media_configs_class);
+	return r;
+}
+module_init(configs_init_devices);
+
+static int __init media_configs_system_init(void)
+{
+	int i;
+	int num = sizeof(mediaconfig_nodes)/sizeof(struct mediaconfig_node);
+	struct mediaconfig_node *mnode;
+	int r;
+
+	pr_info("media_configs_system_init\n");
+	configs_config_system_init();
+	for (i = 0; i < num; i++) {
+		mnode = &mediaconfig_nodes[i];
+		configs_init_new_node(&mnode->node, mnode->name,
+				mnode->rw_flags);
+		r = configs_register_path_node(mnode->parent,
+					&mnode->node);
+		if (r < 0) {
+			pr_err("ERR!!!.register node[%s] to [%s] failed!\n",
+				mnode->name, mnode->parent);
+			return r;
+		}
+	}
+
+	return 0;
+}
+
+arch_initcall(media_configs_system_init);
+MODULE_DESCRIPTION("AMLOGIC config modules driver");
+MODULE_LICENSE("GPL");
+
+
diff -Naur a/vendor/amlogic/media/common/codec_mm/configs/configs_priv.h b/vendor/amlogic/media/common/codec_mm/configs/configs_priv.h
--- a/vendor/amlogic/media/common/codec_mm/configs/configs_priv.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/configs/configs_priv.h	2022-06-24 14:37:50.333210579 +0800
@@ -0,0 +1,34 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/configs/configs_priv.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef AMLOGIC_MEDIA_CONFIG_HEADER_PRIV__
+#define AMLOGIC_MEDIA_CONFIG_HEADER_PRIV__
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+int configs_config_system_init(void);
+int configs_inc_node_ref_locked(
+	struct mconfig_node *node);
+int configs_dec_node_ref_locked(
+	struct mconfig_node *node);
+int config_dump(void *buf, int size);
+int configs_config_setstr(const char *buf);
+
+#endif
+
diff -Naur a/vendor/amlogic/media/common/codec_mm/configs/configs_test.c b/vendor/amlogic/media/common/codec_mm/configs/configs_test.c
--- a/vendor/amlogic/media/common/codec_mm/configs/configs_test.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/configs/configs_test.c	2022-06-24 14:37:50.357835024 +0800
@@ -0,0 +1,145 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/configs/configs_test.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/amlogic/media/codec_mm/configs.h>
+
+static struct mconfig_node media;
+static struct mconfig_node vdec;
+static struct mconfig_node decoder;
+static struct mconfig_node parser;
+static struct mconfig_node codec;
+static struct mconfig_node fast;
+static struct mconfig_node fast2;
+
+
+static  struct mconfig vdec_configs[] = {
+	MC_I32("vdec", 1),
+	MC_I32("vdec1", 1),
+	MC_I32("vdec2", 2),
+	MC_I32("vdec3", 3),
+	MC_I32("vdec4", 4),
+
+};
+
+static struct mconfig decoder_configs[] = {
+	MC_I32("264", 1),
+	MC_I32("265", 1),
+	MC_U32("vp9", 2),
+	MC_U32("vc1", 3),
+	MC_U32("rmvb", 4),
+};
+
+
+
+static struct mconfig parser_configs[] = {
+	MC_I32("ts", 1),
+	MC_I32("es", 1),
+	MC_I32("demux", 2),
+	MC_U32("rm", 3),
+	MC_U32("ps", 4),
+};
+
+static struct mconfig vdec_profile[] = {
+	MC_CSTR("265", "compress,di,c,mmu"),
+	MC_CSTR("264",  "compress,di,c,4k"),
+	MC_CSTR("263",  "compress,di,c"),
+	MC_CSTR("vc1",  "compress,di,c"),
+	MC_CSTR("rm",  "compress,di,di,ps"),
+};
+static int a, b, c, d, e;
+struct mconfig fast_profile[] = {
+	MC_PI32("265", &a),
+	MC_PI32("264",  &b),
+	MC_PI32("263",  &c),
+	MC_PI32("vc1",  &d),
+	MC_PI32("rm",  &e),
+};
+
+int dump_set(const char *trigger, int id, const char *buf, int size)
+{
+	pr_err("trigger-->[%s]\n", buf);
+	return size;
+}
+
+
+struct mconfig fast2_profile[] = {
+	MC_FUN("trigger", NULL, &dump_set),
+};
+
+
+
+
+
+
+static int config_test(void)
+{
+	static int init;
+
+	if (init > 0)
+		return 0;
+	init++;
+	configs_init_new_node(&media, "debug", CONFIG_FOR_RW);
+	configs_register_node(NULL, &media);
+
+	configs_init_new_node(&vdec, "vdec", CONFIG_FOR_RW);
+	configs_register_node(&media, &vdec);
+	REG_CONFIGS(&vdec, vdec_configs);
+
+	configs_init_new_node(&decoder, "decoder", CONFIG_FOR_RW);
+	REG_CONFIGS(&decoder, decoder_configs);
+	configs_register_node(&media, &decoder);
+
+	configs_init_new_node(&parser, "parser", CONFIG_FOR_W);
+	REG_CONFIGS(&parser, parser_configs);
+	configs_register_node(&media, &parser);
+
+	configs_init_new_node(&codec, "codec", CONFIG_FOR_R);
+	REG_CONFIGS(&codec, vdec_profile);
+	configs_register_node(&media, &codec);
+
+	configs_init_new_node(&fast, "fast", CONFIG_FOR_RW);
+	REG_CONFIGS(&fast, fast_profile);
+	configs_register_node(&media, &fast);
+
+	configs_init_new_node(&fast2, "trigger", CONFIG_FOR_W);
+	REG_CONFIGS(&fast2, fast2_profile);
+	configs_register_node(&media, &fast2);
+
+	/* configs_register_configs(); */
+	return 0;
+}
+int config_dump(void *buf, int size)
+{
+	config_test();
+	b++;
+	c = b+3;
+	a++;
+	d += 2;
+	return configs_list_nodes(NULL, buf, size,
+		LIST_MODE_FULL_CMDVAL_ALL);
+}
+int configs_config_setstr(const char *buf)
+{
+	int ret;
+
+	config_test();
+	pr_info("-----------start configs_config_setstr\n\n");
+	ret = configs_set_path_valonpath(buf);
+	pr_info("-----------end configs_config_setstr\n\n");
+	return ret;
+}
+
diff -Naur a/vendor/amlogic/media/common/codec_mm/Kconfig b/vendor/amlogic/media/common/codec_mm/Kconfig
--- a/vendor/amlogic/media/common/codec_mm/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/Kconfig	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,9 @@
+#
+# Codec mermory manager driver configuration
+#
+
+config AMLOGIC_MEDIA_CODEC_MM
+	bool "Amlogic codec memory management driver"
+	default n
+	help
+		Select to enable codec related memory management driver.
diff -Naur a/vendor/amlogic/media/common/codec_mm/Makefile b/vendor/amlogic/media/common/codec_mm/Makefile
--- a/vendor/amlogic/media/common/codec_mm/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/Makefile	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,16 @@
+################################
+# Amlogic codec memory manager #
+################################
+
+####################################
+# The order of directories matter. #
+# Do not change.                   #
+####################################
+
+obj-y = codec_mm.o \
+	codec_mm_scatter.o \
+	codec_mm_keeper.o \
+	secmem.o \
+	configs/configs.o configs/configs_module.o \
+	configs/configs_test.o
+
diff -Naur a/vendor/amlogic/media/common/codec_mm/secmem.c b/vendor/amlogic/media/common/codec_mm/secmem.c
--- a/vendor/amlogic/media/common/codec_mm/secmem.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/secmem.c	2022-06-24 14:37:50.412958613 +0800
@@ -0,0 +1,472 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/secmem.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/dma-buf.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/compat.h>
+
+#include "secmem.h"
+
+static int debug;
+module_param(debug, int, 0644);
+
+#define  DEVICE_NAME "secmem"
+#define  CLASS_NAME  "secmem"
+
+#define dprintk(level, fmt, arg...)					      \
+	do {								      \
+		if (debug >= level)					      \
+			pr_info(DEVICE_NAME ": %s: " fmt,  __func__, ## arg); \
+	} while (0)
+
+#define pr_dbg(fmt, args ...)  dprintk(6, fmt, ## args)
+#define pr_error(fmt, args ...) dprintk(1, fmt, ## args)
+#define pr_inf(fmt, args ...) dprintk(8, fmt, ## args)
+#define pr_enter() pr_inf("enter")
+
+struct ksecmem_attachment {
+	struct sg_table sgt;
+	enum dma_data_direction dma_dir;
+};
+
+static int dev_no;
+static struct device *secmem_dev;
+
+
+static int secmem_dma_attach(struct dma_buf *dbuf,
+			     struct dma_buf_attachment *attachment)
+{
+	struct ksecmem_attachment *attach;
+	struct secmem_block *info = dbuf->priv;
+	struct sg_table *sgt;
+	struct page *page;
+	phys_addr_t phys = info->paddr;
+	int ret;
+
+	pr_enter();
+	attach = kzalloc(sizeof(*attach), GFP_KERNEL);
+	if (!attach) {
+		pr_error("kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	sgt = &attach->sgt;
+	ret = sg_alloc_table(sgt, 1, GFP_KERNEL);
+	if (ret) {
+		kfree(attach);
+		return -ENOMEM;
+	}
+
+	page = phys_to_page(phys);
+	sg_set_page(sgt->sgl, page, PAGE_ALIGN(info->size), 0);
+
+	attach->dma_dir = DMA_NONE;
+	attachment->priv = attach;
+
+	return 0;
+}
+
+static void secmem_dma_detach(struct dma_buf *dbuf,
+			      struct dma_buf_attachment *attachment)
+{
+	struct ksecmem_attachment *attach = attachment->priv;
+	struct sg_table *sgt;
+
+	pr_enter();
+	if (!attach)
+		return;
+
+	sgt = &attach->sgt;
+
+//	if (attach->dma_dir != DMA_NONE)
+//		dma_unmap_sg(attachment->dev, sgt->sgl, sgt->orig_nents,
+//			     attach->dma_dir);
+	sg_free_table(sgt);
+	kfree(attach);
+	attachment->priv = NULL;
+}
+
+static struct sg_table *secmem_dma_map_dma_buf(
+		struct dma_buf_attachment *attachment,
+		enum dma_data_direction dma_dir)
+{
+	struct ksecmem_attachment *attach = attachment->priv;
+	struct secmem_block *info = attachment->dmabuf->priv;
+	struct mutex *lock = &attachment->dmabuf->lock;
+	struct sg_table *sgt;
+
+	pr_enter();
+	mutex_lock(lock);
+	sgt = &attach->sgt;
+	if (attach->dma_dir == dma_dir) {
+		mutex_unlock(lock);
+		return sgt;
+	}
+
+	sgt->sgl->dma_address = info->paddr;
+#ifdef CONFIG_NEED_SG_DMA_LENGTH
+	sgt->sgl->dma_length = PAGE_ALIGN(info->size);
+#else
+	sgt->sgl->length = PAGE_ALIGN(info->size);
+#endif
+	pr_dbg("nents %d, %x, %d, %d\n", sgt->nents, info->paddr,
+			sg_dma_len(sgt->sgl), info->size);
+	attach->dma_dir = dma_dir;
+
+	mutex_unlock(lock);
+	return sgt;
+}
+
+static void secmem_dma_unmap_dma_buf(
+		struct dma_buf_attachment *attachment,
+		struct sg_table *sgt,
+		enum dma_data_direction dma_dir)
+{
+	pr_enter();
+}
+
+static void secmem_dma_release(struct dma_buf *dbuf)
+{
+	struct secmem_block *info;
+
+	pr_enter();
+	info = (struct secmem_block *)dbuf->priv;
+	pr_dbg("handle:%x\n", info->handle);
+	kfree(info);
+}
+
+static void *secmem_dma_kmap_atomic(struct dma_buf *dbuf, unsigned long n)
+{
+	pr_enter();
+	return NULL;
+}
+
+static void *secmem_dma_kmap(struct dma_buf *dbuf, unsigned long n)
+{
+	pr_enter();
+	return NULL;
+}
+
+static int secmem_dma_mmap(struct dma_buf *dbuf, struct vm_area_struct *vma)
+{
+	pr_enter();
+	return -EINVAL;
+}
+
+static struct dma_buf_ops secmem_dmabuf_ops = {
+	.attach = secmem_dma_attach,
+	.detach = secmem_dma_detach,
+	.map_dma_buf = secmem_dma_map_dma_buf,
+	.unmap_dma_buf = secmem_dma_unmap_dma_buf,
+	.release = secmem_dma_release,
+	//.kmap_atomic = secmem_dma_kmap_atomic,
+	//.kmap = secmem_dma_kmap,
+	.mmap = secmem_dma_mmap
+};
+
+static struct dma_buf *get_dmabuf(struct secmem_block *info,
+				  unsigned long flags)
+{
+	struct dma_buf *dbuf;
+	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);
+
+	pr_dbg("export handle:%x, paddr:%x, size:%d\n",
+		info->handle, info->paddr, info->size);
+	exp_info.ops = &secmem_dmabuf_ops;
+	exp_info.size = info->size;
+	exp_info.flags = flags;
+	exp_info.priv = (void *)info;
+	dbuf = dma_buf_export(&exp_info);
+	if (IS_ERR(dbuf))
+		return NULL;
+	return dbuf;
+}
+
+static long secmem_export(unsigned long args)
+{
+	int ret;
+	struct secmem_block *info;
+	struct dma_buf *dbuf;
+	int fd;
+
+	pr_enter();
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		pr_error("kmalloc failed\n");
+		goto error_alloc_object;
+	}
+	ret = copy_from_user((void *)info, (void __user *)args,
+			     sizeof(struct secmem_block));
+	if (ret) {
+		pr_error("copy_from_user failed\n");
+		goto error_copy;
+	}
+
+	dbuf = get_dmabuf(info, 0);
+	if (!dbuf) {
+		pr_error("get_dmabuf failed\n");
+		goto error_export;
+	}
+
+	fd = dma_buf_fd(dbuf, O_CLOEXEC);
+	if (fd < 0) {
+		pr_error("dma_buf_fd failed\n");
+		goto error_fd;
+	}
+
+	return fd;
+error_fd:
+	dma_buf_put(dbuf);
+error_export:
+error_copy:
+	kfree(info);
+error_alloc_object:
+	return -EFAULT;
+}
+
+static long secmem_get_handle(unsigned long args)
+{
+	int ret;
+	long res = -EFAULT;
+	int fd;
+	struct dma_buf *dbuf;
+	struct secmem_block *info;
+
+	pr_enter();
+	ret = copy_from_user((void *) &fd, (void __user *) args, sizeof(fd));
+	if (ret) {
+		pr_error("copy_from_user failed\n");
+		goto error_copy;
+	}
+	dbuf = dma_buf_get(fd);
+	if (IS_ERR(dbuf)) {
+		pr_error("dma_buf_get failed\n");
+		goto error_get;
+	}
+	info = dbuf->priv;
+	res = (long) (info->handle & (0xffffffff));
+	dma_buf_put(dbuf);
+error_get:
+error_copy:
+	return res;
+}
+
+static long secmem_get_phyaddr(unsigned long args)
+{
+	int ret;
+	long res = -EFAULT;
+	int fd;
+	struct dma_buf *dbuf;
+	struct secmem_block *info;
+
+	pr_enter();
+	ret = copy_from_user((void *) &fd, (void __user *) args, sizeof(fd));
+	if (ret) {
+		pr_error("copy_from_user failed\n");
+		goto error_copy;
+	}
+	dbuf = dma_buf_get(fd);
+	if (IS_ERR(dbuf)) {
+		pr_error("dma_buf_get failed\n");
+		goto error_get;
+	}
+	info = dbuf->priv;
+	res = (long) (info->paddr & (0xffffffff));
+	dma_buf_put(dbuf);
+error_get:
+error_copy:
+	return res;
+}
+
+static long secmem_import(unsigned long args)
+{
+	int ret;
+	long res = -EFAULT;
+	int fd;
+	struct dma_buf *dbuf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	dma_addr_t paddr;
+
+	pr_enter();
+	ret = copy_from_user((void *)&fd, (void __user *)args,
+			     sizeof(fd));
+	if (ret) {
+		pr_error("copy_from_user failed\n");
+		goto error_copy;
+	}
+	dbuf = dma_buf_get(fd);
+	if (IS_ERR(dbuf)) {
+		pr_error("dma_buf_get failed\n");
+		goto error_get;
+	}
+	attach = dma_buf_attach(dbuf, secmem_dev);
+	if (IS_ERR(attach)) {
+		pr_error("dma_buf_attach failed\n");
+		goto error_attach;
+	}
+	sgt = dma_buf_map_attachment(attach, DMA_FROM_DEVICE);
+	if (IS_ERR(sgt)) {
+		pr_error("dma_buf_map_attachment failed\n");
+		goto error_map;
+	}
+
+	paddr = sg_dma_address(sgt->sgl);
+
+	res = (long) (paddr & (0xffffffff));
+	dma_buf_unmap_attachment(attach, sgt, DMA_FROM_DEVICE);
+error_map:
+	dma_buf_detach(dbuf, attach);
+error_attach:
+	dma_buf_put(dbuf);
+error_get:
+error_copy:
+	return res;
+}
+static int secmem_open(struct inode *inodep, struct file *filep)
+{
+	pr_enter();
+	return 0;
+}
+
+static ssize_t secmem_read(struct file *filep, char *buffer,
+			   size_t len, loff_t *offset)
+{
+	pr_enter();
+	return 0;
+}
+
+static ssize_t secmem_write(struct file *filep, const char *buffer,
+			    size_t len, loff_t *offset)
+{
+	pr_enter();
+	return 0;
+}
+
+static int secmem_release(struct inode *inodep, struct file *filep)
+{
+	pr_enter();
+	return 0;
+}
+
+static long secmem_ioctl(struct file *filep, unsigned int cmd,
+			 unsigned long args)
+{
+	long ret = -EINVAL;
+
+	pr_inf("cmd %x\n", cmd);
+	switch (cmd) {
+	case SECMEM_EXPORT_DMA:
+		ret = secmem_export(args);
+		break;
+	case SECMEM_GET_HANDLE:
+		ret = secmem_get_handle(args);
+		break;
+	case SECMEM_GET_PHYADDR:
+		ret = secmem_get_phyaddr(args);
+		break;
+	case SECMEM_IMPORT_DMA:
+		ret = secmem_import(args);
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long secmem_compat_ioctl(struct file *filep, unsigned int cmd,
+				unsigned long args)
+{
+	unsigned long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = secmem_ioctl(filep, cmd, args);
+	return ret;
+}
+#endif
+
+const struct file_operations fops = {
+	.owner = THIS_MODULE,
+	.open = secmem_open,
+	.read = secmem_read,
+	.write = secmem_write,
+	.release = secmem_release,
+	.unlocked_ioctl = secmem_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = secmem_compat_ioctl,
+#endif
+};
+
+static struct class secmem_class = {
+	.name = CLASS_NAME,
+};
+
+int __init secmem_init(void)
+{
+	int ret;
+
+	ret = register_chrdev(0, DEVICE_NAME, &fops);
+	if (ret < 0) {
+		pr_error("register_chrdev failed\n");
+		goto error_register;
+	}
+	dev_no = ret;
+	ret = class_register(&secmem_class);
+	if (ret < 0) {
+		pr_error("class_register failed\n");
+		goto error_class;
+	}
+
+	secmem_dev = device_create(&secmem_class,
+				   NULL, MKDEV(dev_no, 0),
+				   NULL, DEVICE_NAME);
+	if (IS_ERR(secmem_dev)) {
+		pr_error("device_create failed\n");
+		ret = PTR_ERR(secmem_dev);
+		goto error_create;
+	}
+	pr_dbg("init done\n");
+	return 0;
+error_create:
+	class_unregister(&secmem_class);
+error_class:
+	unregister_chrdev(dev_no, DEVICE_NAME);
+error_register:
+	return ret;
+}
+
+void __exit secmem_exit(void)
+{
+	device_destroy(&secmem_class, MKDEV(dev_no, 0));
+	class_unregister(&secmem_class);
+	class_destroy(&secmem_class);
+	unregister_chrdev(dev_no, DEVICE_NAME);
+	pr_dbg("exit done\n");
+}
+
+module_init(secmem_init);
+module_exit(secmem_exit);
+MODULE_LICENSE("GPL");
diff -Naur a/vendor/amlogic/media/common/codec_mm/secmem.h b/vendor/amlogic/media/common/codec_mm/secmem.h
--- a/vendor/amlogic/media/common/codec_mm/secmem.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/codec_mm/secmem.h	2022-06-24 14:37:50.430184564 +0800
@@ -0,0 +1,37 @@
+/*
+ * vendor/amlogic/media/common/codec_mm/secmem.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _LINUX_SECMEM_H_
+#define _LINUX_SECMEM_H_
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+struct secmem_block {
+	__u32 paddr;
+	__u32 size;
+	__u32 handle;
+};
+
+#define SECMEM_IOC_MAGIC		'S'
+
+#define SECMEM_EXPORT_DMA		_IOWR(SECMEM_IOC_MAGIC, 0x01, int)
+#define SECMEM_GET_HANDLE		_IOWR(SECMEM_IOC_MAGIC, 0x02, int)
+#define SECMEM_GET_PHYADDR		_IOWR(SECMEM_IOC_MAGIC, 0x03, int)
+#define SECMEM_IMPORT_DMA		_IOWR(SECMEM_IOC_MAGIC, 0x04, int)
+
+#endif /* _LINUX_SECMEM_H_ */
diff -Naur a/vendor/amlogic/media/common/Makefile b/vendor/amlogic/media/common/Makefile
--- a/vendor/amlogic/media/common/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/common/Makefile	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,6 @@
+
+##########################################
+########## Amlogic Drivers ###############
+##########################################
+
+obj-$(CONFIG_AMLOGIC_MEDIA_CODEC_MM)	+= codec_mm/
diff -Naur a/vendor/amlogic/media/Kconfig b/vendor/amlogic/media/Kconfig
--- a/vendor/amlogic/media/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/Kconfig	2022-06-06 09:14:48.455282131 +0800
@@ -0,0 +1,10 @@
+#
+# Amlogic Media Module
+#
+menu "Amlogic Media Module"
+config  AMLOGIC_MEDIA
+	bool "Amlogic Media Module"
+	default n
+	help
+		Select to enable Media.
+endmenu
diff -Naur a/vendor/amlogic/media/Makefile b/vendor/amlogic/media/Makefile
--- a/vendor/amlogic/media/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/media/Makefile	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,6 @@
+
+##########################################
+########## Amlogic Drivers ###############
+##########################################
+
+obj-y	+= common/
diff -Naur a/vendor/amlogic/mmc/emmc_key.c b/vendor/amlogic/mmc/emmc_key.c
--- a/vendor/amlogic/mmc/emmc_key.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/mmc/emmc_key.c	2022-06-24 14:47:38.325086185 +0800
@@ -0,0 +1,522 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/types.h>
+#include <linux/err.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/slab.h>
+#include <linux/mmc/emmc_partitions.h>
+#include <linux/amlogic/key_manage.h>
+#include "emmc_key.h"
+#include "../../drivers/mmc/core/core.h"
+
+#define		EMMC_BLOCK_SIZE		(0x100)
+#define		MAX_EMMC_BLOCK_SIZE	(128 * 1024)
+
+#define     MAX_TRANS_BLK        (256)
+
+#define stamp_after(a, b)	((int)(b) - (int)(a)  < 0)
+#define KEY_BACKUP
+
+/*
+ * kernel head file
+ *
+ */
+static struct mmc_card *mmc_card_key;
+static struct aml_emmckey_info_t *emmckey_info;
+
+#ifdef KEY_BACKUP
+static struct aml_key_info key_infos[2] = { {0, 0, 0}, {0, 0, 0} };
+
+int32_t emmc_read_valid_key(void *buffer, int valid_flag)
+{
+	int ret;
+	u64  addr = 0;
+	u32  size = 0;
+	int blk, cnt;
+	unsigned char *dst = NULL;
+	struct mmc_card *card = mmc_card_key;
+	int bit = card->csd.read_blkbits;
+
+	size = EMMC_KEYAREA_SIZE;
+	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET
+		+ (valid_flag - 1) * EMMC_KEYAREA_SIZE;
+	blk = addr >> bit;
+	cnt = size >> bit;
+	dst = (unsigned char *)buffer;
+
+	mmc_claim_host(card->host);
+	do {
+		ret = mmc_read_internal(card, blk, EMMC_BLOCK_SIZE, dst);
+		if (ret) {
+			pr_err("%s [%d] mmc_write_internal error\n",
+				__func__, __LINE__);
+			break;
+		}
+		blk += EMMC_BLOCK_SIZE;
+		cnt -= EMMC_BLOCK_SIZE;
+		dst = (unsigned char *)buffer + MAX_EMMC_BLOCK_SIZE;
+	} while (cnt != 0);
+	pr_info("%s:%d, read %s\n", __func__, __LINE__, (ret) ? "error" : "ok");
+	mmc_release_host(card->host);
+
+	return ret;
+}
+
+/* key read&write operation with backup updates */
+static u64 _calc_key_checksum(void *addr, int size)
+{
+	int i = 0;
+	u32 *buffer;
+	u64 checksum = 0;
+
+	buffer = (u32 *)addr;
+	size = size >> 2;
+	while (i < size)
+		checksum += buffer[i++];
+
+	return checksum;
+}
+
+int32_t emmc_write_one_key(void *buffer, int valid_flag)
+{
+	int ret;
+	u64 blk, cnt, key_glb_offset;
+	unsigned char *src = NULL;
+	struct mmc_card *card = mmc_card_key;
+	int bit = card->csd.read_blkbits;
+	unsigned char *checksum_info;
+
+	checksum_info = kmalloc(512, GFP_KERNEL);
+	if (!checksum_info)
+		return -1;
+
+	memset(checksum_info, 0, 512);
+	key_glb_offset = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
+	blk = (key_glb_offset + (valid_flag % 2) * EMMC_KEYAREA_SIZE) >> bit;
+	cnt = EMMC_KEYAREA_SIZE >> bit;
+	src = (unsigned char *)buffer;
+	memcpy(checksum_info, &key_infos[valid_flag - 1], sizeof(struct aml_key_info));
+	mmc_claim_host(card->host);
+	do {
+		ret = mmc_write_internal(card, blk, EMMC_BLOCK_SIZE, src);
+		if (ret) {
+			pr_err("%s [%d] mmc_write_internal error\n",
+				__func__, __LINE__);
+			goto exit_err;
+		}
+		blk += EMMC_BLOCK_SIZE;
+		cnt -= EMMC_BLOCK_SIZE;
+		src = (unsigned char *)buffer + MAX_EMMC_BLOCK_SIZE;
+		pr_info("cnt %llu\n", cnt);
+	} while (cnt != 0);
+
+	blk = ((key_glb_offset + 2 * (EMMC_KEYAREA_SIZE)) >> bit) + (valid_flag % 2);
+	ret = mmc_write_internal(card, blk, 1, checksum_info);
+	if (ret)
+		pr_err("%s: block # %#llx, ERROR!\n", __func__, blk);
+
+	pr_info("%s:%d, write %s\n", __func__, __LINE__, (ret) ? "error" : "ok");
+	mmc_release_host(card->host);
+
+exit_err:
+	kfree(checksum_info);
+	return ret;
+}
+
+int update_old_key(struct mmc_card *mmc, void *addr)
+{
+	int ret = 0;
+	int valid_flag;
+
+	if (stamp_after(key_infos[1].stamp, key_infos[0].stamp)) {
+		memcpy(&key_infos[1], &key_infos[0], sizeof(struct aml_key_info));
+		valid_flag = 2;
+	} else if (stamp_after(key_infos[0].stamp, key_infos[1].stamp)) {
+		memcpy(&key_infos[0], &key_infos[1], sizeof(struct aml_key_info));
+		valid_flag = 1;
+	} else {
+		pr_info("do nothing\n");
+		return ret;
+	}
+
+	ret = emmc_write_one_key(addr, valid_flag);
+	if (ret)
+		return ret;
+	mmc->key_stamp = key_infos[0].stamp;
+	return ret;
+}
+
+static int _verify_key_checksum(struct mmc_card *mmc, void *addr, int cpy)
+{
+	u64 checksum;
+	int ret = 0;
+	u64 blk;
+	char *checksum_info;
+	int bit = mmc->csd.read_blkbits;
+
+	blk = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET +
+		EMMC_KEYAREA_SIZE * 2;
+	blk = (blk >> bit) + cpy;
+	checksum_info = kmalloc(512, GFP_KERNEL);
+	if (!checksum_info)
+		return -1;
+
+	mmc_claim_host(mmc->host);
+	ret =  mmc_read_internal(mmc, blk, 1, checksum_info);
+	mmc_release_host(mmc->host);
+	if (ret) {
+		pr_err("%s, block # %#llx, ERROR!\n", __func__, blk);
+		kfree(checksum_info);
+		return ret;
+	}
+
+	memcpy(&key_infos[cpy], checksum_info, sizeof(struct aml_key_info));
+	checksum = _calc_key_checksum(addr, EMMC_KEYAREA_SIZE);
+	pr_info("calc %llx, store %llx\n", checksum, key_infos[cpy].checksum);
+
+	kfree(checksum_info);
+	return !(checksum == key_infos[cpy].checksum);
+}
+
+static int write_invalid_key(void *addr, int valid_flag)
+{
+	int ret;
+
+	if (valid_flag > 2 || valid_flag < 1)
+		return -1;
+
+	ret = emmc_read_valid_key(addr, valid_flag);
+	if (ret) {
+		pr_err("read valid key failed\n");
+		return ret;
+	}
+	ret = emmc_write_one_key(addr, valid_flag);
+	if (ret) {
+		pr_err("write invalid key failed\n");
+		return ret;
+	}
+	return ret;
+}
+
+static int _amlmmc_read(struct mmc_card *mmc,
+		     int blk, unsigned char *buf, int cnt)
+{
+	int ret = 0;
+	unsigned char *dst = NULL;
+
+	dst = (unsigned char *)buf;
+	mmc_claim_host(mmc->host);
+	do {
+		ret = mmc_read_internal(mmc, blk, MAX_TRANS_BLK, dst);
+		if (ret) {
+			pr_err("%s: save key error", __func__);
+			ret = -EFAULT;
+			break;
+		}
+		blk += MAX_TRANS_BLK;
+		cnt -= MAX_TRANS_BLK;
+		dst = (unsigned char *)buf + MAX_EMMC_BLOCK_SIZE;
+	} while (cnt != 0);
+	mmc_release_host(mmc->host);
+	return ret;
+}
+
+static int update_key_info(struct mmc_card *mmc, unsigned char *addr)
+{
+	int ret = 0;
+	int cpy = 1;
+	int bit = mmc->csd.read_blkbits;
+	int blk;
+	int cnt = EMMC_KEYAREA_SIZE >> bit;
+	int valid_flag = 0;
+
+	/* read key2 1st, for compatibility without checksum. */
+	while (cpy >= 0) {
+		blk = ((get_reserve_partition_off_from_tbl()
+					+ EMMCKEY_RESERVE_OFFSET)
+			+ cpy * EMMC_KEYAREA_SIZE) >> bit;
+		if (_amlmmc_read(mmc, blk, addr, cnt)) {
+			pr_err("%s: block # %#x ERROR!\n",
+					__func__, blk);
+		} else {
+			ret = _verify_key_checksum(mmc, addr, cpy);
+			if (!ret && key_infos[cpy].magic != 0)
+				valid_flag += cpy + 1;
+			else
+				pr_err("cpy %d is not valid\n", cpy);
+		}
+		cpy--;
+	}
+
+	if (key_infos[0].stamp > key_infos[1].stamp)
+		mmc->key_stamp = key_infos[0].stamp;
+	else
+		mmc->key_stamp = key_infos[1].stamp;
+
+	return valid_flag;
+}
+
+static int _key_init(struct mmc_card *mmc)
+{
+	int ret = 0;
+	void *key;
+	int valid = 0;
+
+	/*malloc 256k byte to key */
+	key = kmalloc(EMMC_KEYAREA_SIZE, GFP_KERNEL);
+	if (!key)
+		return -ENOMEM;
+
+	valid = update_key_info(mmc, key);
+
+	switch (valid) {
+	case 0:
+	break;
+	case 1:
+		write_invalid_key(key, 1);
+	break;
+	case 2:
+		write_invalid_key(key, 2);
+	break;
+	case 3:
+		update_old_key(mmc, key);
+	break;
+	default:
+		pr_err("impossible valid values.\n");
+	break;
+	}
+
+	kfree(key);
+	return ret;
+}
+#endif
+
+#ifdef KEY_BACKUP
+int32_t emmc_key_write(u8 *buffer,
+	u32 length, u32 *actual_length)
+{
+	int ret;
+	int cpy = 1, index;
+	struct mmc_card *card = mmc_card_key;
+
+	do {
+		index = cpy - 1;
+		key_infos[index].stamp = card->key_stamp + 1;
+		key_infos[index].checksum = _calc_key_checksum(buffer, length);
+		key_infos[index].magic = 9;
+		pr_info("new stamp %d, checksum 0x%llx, magic %d\n",
+				key_infos[index].stamp,
+				key_infos[index].checksum,
+				key_infos[index].magic);
+
+		ret = emmc_write_one_key(buffer, cpy);
+		if (ret) {
+			pr_info("write %d failed\n", cpy);
+			return ret;
+		}
+		cpy++;
+	} while (cpy < 3);
+	return ret;
+}
+EXPORT_SYMBOL(emmc_key_write);
+#else
+int32_t emmc_key_write(u8 *buffer,
+		u32 length, u32 *actual_length)
+{
+	int ret;
+	u64  addr = 0;
+	u32  size = 0;
+	int blk, cnt;
+	unsigned char *src = NULL;
+	struct mmc_card *card = mmc_card_key;
+	int bit = card->csd.read_blkbits;
+
+	size = length;
+	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
+	blk = addr >> bit;
+	cnt = size >> bit;
+	src = (unsigned char *)buffer;
+	mmc_claim_host(card->host);
+	do {
+		ret = mmc_write_internal(card, blk, EMMC_BLOCK_SIZE, src);
+		if (ret) {
+			pr_err("%s [%d] mmc_write_internal error\n",
+					__func__, __LINE__);
+			return ret;
+		}
+		blk += EMMC_BLOCK_SIZE;
+		cnt -= EMMC_BLOCK_SIZE;
+		src = (unsigned char *)buffer + MAX_EMMC_BLOCK_SIZE;
+	} while (cnt != 0);
+	pr_info("%s:%d, write %s\n", __func__, __LINE__, (ret) ? "error" : "ok");
+	mmc_release_host(card->host);
+	return ret;
+}
+EXPORT_SYMBOL(emmc_key_write);
+#endif
+
+static int aml_emmc_key_check(void)
+{
+	u8 keypart_cnt;
+	u64 part_size;
+	struct emmckey_valid_node_t *emmckey_valid_node, *temp_valid_node;
+
+	emmckey_info->key_part_count =
+		emmckey_info->keyarea_phy_size / EMMC_KEYAREA_SIZE;
+
+	if (emmckey_info->key_part_count
+			> EMMC_KEYAREA_COUNT) {
+		emmckey_info->key_part_count = EMMC_KEYAREA_COUNT;
+	}
+	keypart_cnt = 0;
+	part_size = EMMC_KEYAREA_SIZE;
+	do {
+		emmckey_valid_node = kmalloc(sizeof(*emmckey_valid_node),
+				GFP_KERNEL);
+
+		if (!emmckey_valid_node) {
+			pr_info("%s:%d,kmalloc memory fail\n",
+				__func__, __LINE__);
+			return -ENOMEM;
+		}
+		emmckey_valid_node->phy_addr = emmckey_info->keyarea_phy_addr
+						+ part_size * keypart_cnt;
+		emmckey_valid_node->phy_size = EMMC_KEYAREA_SIZE;
+		emmckey_valid_node->next = NULL;
+		emmckey_info->key_valid = 0;
+		if (!emmckey_info->key_valid_node) {
+			emmckey_info->key_valid_node = emmckey_valid_node;
+
+		} else {
+			temp_valid_node = emmckey_info->key_valid_node;
+
+			while (temp_valid_node->next)
+				temp_valid_node = temp_valid_node->next;
+
+			temp_valid_node->next = emmckey_valid_node;
+		}
+	} while (++keypart_cnt < emmckey_info->key_part_count);
+
+	emmckey_info->key_valid = 1;
+	return 0;
+}
+
+int32_t emmc_key_read(u8 *buffer,
+	u32 length, u32 *actual_length)
+{
+	int ret;
+	u64  addr = 0;
+	u32  size = 0;
+	int blk, cnt;
+	unsigned char *dst = NULL;
+	struct mmc_card *card = mmc_card_key;
+	int bit = card->csd.read_blkbits;
+
+	size = length;
+	*actual_length = length;
+	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
+	blk = addr >> bit;
+	cnt = size >> bit;
+	dst = (unsigned char *)buffer;
+	mmc_claim_host(card->host);
+	do {
+		ret = mmc_read_internal(card, blk,
+					min(EMMC_BLOCK_SIZE, cnt), dst);
+		if (ret) {
+			pr_err("%s [%d] mmc_write_internal error\n",
+			       __func__, __LINE__);
+			break;
+		}
+		blk += EMMC_BLOCK_SIZE;
+		cnt -= EMMC_BLOCK_SIZE;
+		dst = (unsigned char *)buffer + MAX_EMMC_BLOCK_SIZE;
+	} while (cnt > 0);
+
+	pr_info("%s:%d, read %s\n", __func__, __LINE__, (ret) ? "error" : "ok");
+
+	mmc_release_host(card->host);
+	return ret;
+}
+EXPORT_SYMBOL(emmc_key_read);
+
+int emmc_key_init(struct mmc_card *card)
+{
+	u64  addr = 0;
+	u32  size = 0;
+	u64  lba_start = 0, lba_end = 0;
+	int err = 0;
+	int bit = card->csd.read_blkbits;
+	struct unifykey_type *uk_type = NULL;
+	struct unifykey_storage_ops ops;
+
+	pr_info("card key: card_blk_probe.\n");
+	emmckey_info = kmalloc(sizeof(*emmckey_info), GFP_KERNEL);
+	if (!emmckey_info) {
+		pr_info("%s:%d,kmalloc memory fail\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+	uk_type = kmalloc(sizeof(*uk_type), GFP_KERNEL);
+	if (!uk_type) {
+		err = -ENOMEM;
+		goto exit_err;
+	}
+	memset(emmckey_info, 0, sizeof(*emmckey_info));
+	emmckey_info->key_init = 0;
+#ifdef KEY_BACKUP
+	size = EMMCKEY_AREA_PHY_SIZE + (512 * 2);
+#else
+	size = EMMCKEY_AREA_PHY_SIZE;
+#endif
+	if (get_reserve_partition_off_from_tbl() < 0) {
+		err = -EINVAL;
+		goto exit_err1;
+	}
+	addr = get_reserve_partition_off_from_tbl() + EMMCKEY_RESERVE_OFFSET;
+	lba_start = addr >> bit;
+	lba_end = (addr + size) >> bit;
+	emmckey_info->key_init = 1;
+
+	pr_info("%s:%d emmc key lba_start:0x%llx,lba_end:0x%llx\n",
+		__func__, __LINE__, lba_start, lba_end);
+
+	if (!emmckey_info->key_init) {
+		err = -EINVAL;
+
+		pr_info("%s:%d,emmc key init fail\n", __func__, __LINE__);
+		goto exit_err1;
+	}
+	emmckey_info->keyarea_phy_addr = addr;
+	emmckey_info->keyarea_phy_size = size;
+	emmckey_info->lba_start = lba_start;
+	emmckey_info->lba_end   = lba_end;
+	mmc_card_key = card;
+#ifdef KEY_BACKUP
+	_key_init(card);
+#endif
+	err = aml_emmc_key_check();
+	if (err) {
+		pr_info("%s:%d,emmc key check fail\n", __func__, __LINE__);
+		goto exit_err1;
+	}
+
+	uk_type->storage_type = UNIFYKEY_STORAGE_TYPE_EMMC;
+	uk_type->ops = &ops;
+	uk_type->ops->read = emmc_key_read;
+	uk_type->ops->write = emmc_key_write;
+
+	if (register_unifykey_types(uk_type)) {
+		err = -EINVAL;
+		pr_info("%s:%d,emmc key check fail\n", __func__, __LINE__);
+		goto exit_err1;
+	}
+	pr_info("emmc key: %s:%d ok.\n", __func__, __LINE__);
+exit_err1:
+	kfree(uk_type);
+exit_err:
+	kfree(emmckey_info);
+	return err;
+}
diff -Naur a/vendor/amlogic/mmc/emmc_key.h b/vendor/amlogic/mmc/emmc_key.h
--- a/vendor/amlogic/mmc/emmc_key.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/mmc/emmc_key.h	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __EMMC_KEY_H__
+#define __EMMC_KEY_H__
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/core.h>
+
+#define EMMC_KEY_AREA_SIGNAL		"emmckeys"
+#define EMMC_KEY_AREA_SIGNAL_LEN	16
+
+#define EMMC_KEYAREA_SIZE		(256 * 1024)
+#define EMMC_KEYAREA_COUNT		2
+
+/* we store partition table in the previous 16KB space */
+#define EMMCKEY_RESERVE_OFFSET          0x4000
+#define EMMCKEY_AREA_PHY_SIZE           (EMMC_KEYAREA_COUNT * EMMC_KEYAREA_SIZE)
+
+struct emmckey_valid_node_t {
+	u64 phy_addr;
+	u64 phy_size;
+	struct emmckey_valid_node_t *next;
+};
+
+struct aml_emmckey_info_t {
+	/* struct memory_card *card; */
+	struct	emmckey_valid_node_t *key_valid_node;
+	u64	keyarea_phy_addr;
+	u64	keyarea_phy_size;
+	u64	lba_start;
+	u64	lba_end;
+	u32	blk_size;
+	u32	blk_shift;
+	u8	key_init;
+	u8	key_valid;
+	u8	key_part_count;
+};
+
+struct aml_key_info {
+	u64 checksum;
+	u32 stamp;
+	u32 magic;
+};
+
+#define EMMCKEY_DATA_VALID_LEN		\
+	(EMMC_KEYAREA_SIZE - EMMC_KEY_AREA_SIGNAL_LEN - 4 - 4 - 4)
+struct emmckey_data_t {
+	u8	keyarea_mark[EMMC_KEY_AREA_SIGNAL_LEN];
+	u32	keyarea_mark_checksum;
+	u32	checksum;
+	u32	reserve;
+	u8	data[EMMCKEY_DATA_VALID_LEN];
+};
+
+int emmc_key_init(struct mmc_card *card);
+
+int32_t emmc_key_read(u8 *buffer,
+		      u32 length, u32 *actual_length);
+int32_t emmc_key_write(u8 *buffer,
+		       u32 length, u32 *actual_length);
+
+#endif
+
diff -Naur a/vendor/amlogic/mmc/emmc_partitions.c b/vendor/amlogic/mmc/emmc_partitions.c
--- a/vendor/amlogic/mmc/emmc_partitions.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/mmc/emmc_partitions.c	2022-06-24 14:48:21.048601295 +0800
@@ -0,0 +1,1230 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/genhd.h>
+#include <linux/blkdev.h>
+#include <linux/scatterlist.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/vmalloc.h>
+#include <linux/mmc/emmc_partitions.h>
+#include "emmc_key.h"
+#include <linux/amlogic/aml_sd.h>
+#include "../../../block/blk.h"
+#include "../../drivers/mmc/core/mmc_ops.h"
+#include "../../drivers/mmc/core/core.h"
+
+#define DTB_NAME		"dtb"
+#define	SZ_1M			0x00100000
+#define	MMC_DTB_PART_OFFSET	(40 * SZ_1M)
+#define	EMMC_BLOCK_SIZE		(0x100)
+#define	MAX_EMMC_BLOCK_SIZE	(128 * 1024)
+
+#define DTB_RESERVE_OFFSET	(4 * SZ_1M)
+#define	DTB_BLK_SIZE		(0x200)
+#define	DTB_BLK_CNT		(512)
+#define	DTB_SIZE		(DTB_BLK_CNT * DTB_BLK_SIZE)
+#define DTB_COPIES		(2)
+#define DTB_AREA_BLK_CNT	(DTB_BLK_CNT * DTB_COPIES)
+/* pertransfer for internal opearations. */
+#define MAX_TRANS_BLK		(256)
+#define	MAX_TRANS_SIZE		(MAX_TRANS_BLK * DTB_BLK_SIZE)
+#define stamp_after(a, b)	((int)(b) - (int)(a)  < 0)
+
+#define GPT_HEADER_SIGNATURE	0x5452415020494645ULL
+
+struct aml_dtb_rsv {
+	u8 data[DTB_BLK_SIZE * DTB_BLK_CNT - 4 * sizeof(unsigned int)];
+	unsigned int magic;
+	unsigned int version;
+	unsigned int timestamp;
+	unsigned int checksum;
+};
+
+struct aml_dtb_info {
+	unsigned int stamp[2];
+	u8 valid[2];
+};
+
+struct  efi_guid_t {
+	u8 b[16];
+};
+
+struct gpt_header {
+	__le64 signature;
+	__le32 revision;
+	__le32 header_size;
+	__le32 header_crc32;
+	__le32 reserved1;
+	__le64 my_lba;
+	__le64 alternate_lba;
+	__le64 first_usable_lba;
+	__le64 last_usable_lba;
+	struct efi_guid_t disk_guid;
+	__le64 partition_entry_lba;
+	__le32 num_partition_entries;
+	__le32 sizeof_partition_entry;
+	__le32 partition_entry_array_crc32;
+};
+
+static dev_t amlmmc_dtb_no;
+struct cdev amlmmc_dtb;
+struct device *dtb_dev;
+struct class *amlmmc_dtb_class;
+static char *glb_dtb_buf;
+struct mmc_card *card_dtb;
+static struct aml_dtb_info dtb_infos = {{0, 0}, {0, 0} };
+struct mmc_partitions_fmt *pt_fmt;
+
+/* dtb read&write operation with backup updates */
+static unsigned int _calc_dtb_checksum(struct aml_dtb_rsv *dtb)
+{
+	int i = 0;
+	int size = sizeof(struct aml_dtb_rsv) - sizeof(unsigned int);
+	unsigned int *buffer;
+	unsigned int checksum = 0;
+
+	size = size >> 2;
+	buffer = (unsigned int *)dtb;
+	while (i < size)
+		checksum += buffer[i++];
+
+	return checksum;
+}
+
+static int _verify_dtb_checksum(struct aml_dtb_rsv *dtb)
+{
+	unsigned int checksum;
+
+	checksum = _calc_dtb_checksum(dtb);
+	pr_info("calc %x, store %x\n", checksum, dtb->checksum);
+
+	return !(checksum == dtb->checksum);
+}
+
+static int _dtb_write(struct mmc_card *mmc, int blk, unsigned char *buf)
+{
+	int ret = 0;
+	unsigned char *src = NULL;
+	int bit = mmc->csd.read_blkbits;
+	int cnt = CONFIG_DTB_SIZE >> bit;
+
+	src = (unsigned char *)buf;
+
+	mmc_claim_host(mmc->host);
+	do {
+		ret = mmc_write_internal(mmc, blk, MAX_TRANS_BLK, src);
+		if (ret) {
+			pr_err("%s: save dtb error", __func__);
+			ret = -EFAULT;
+			break;
+		}
+		blk += MAX_TRANS_BLK;
+		cnt -= MAX_TRANS_BLK;
+		src = (unsigned char *)buf + MAX_TRANS_SIZE;
+	} while (cnt != 0);
+	mmc_release_host(mmc->host);
+
+	return ret;
+}
+
+static int _dtb_read(struct mmc_card *mmc, int blk, unsigned char *buf)
+{
+	int ret = 0;
+	unsigned char *dst = NULL;
+	int bit = mmc->csd.read_blkbits;
+	int cnt = CONFIG_DTB_SIZE >> bit;
+
+	dst = (unsigned char *)buf;
+	mmc_claim_host(mmc->host);
+	do {
+		ret = mmc_read_internal(mmc, blk, MAX_TRANS_BLK, dst);
+		if (ret) {
+			pr_err("%s: save dtb error", __func__);
+			ret = -EFAULT;
+			break;
+		}
+		blk += MAX_TRANS_BLK;
+		cnt -= MAX_TRANS_BLK;
+		dst = (unsigned char *)buf + MAX_TRANS_SIZE;
+	} while (cnt != 0);
+	mmc_release_host(mmc->host);
+	return ret;
+}
+
+static int _dtb_init(struct mmc_card *mmc)
+{
+	int ret = 0;
+	struct aml_dtb_rsv *dtb;
+	struct aml_dtb_info *info = &dtb_infos;
+	int cpy = 1, valid = 0;
+	int bit = mmc->csd.read_blkbits;
+	int blk;
+
+	if (!glb_dtb_buf) {
+		glb_dtb_buf = kmalloc(CONFIG_DTB_SIZE, GFP_KERNEL);
+		if (!glb_dtb_buf)
+			return -ENOMEM;
+	}
+	dtb = (struct aml_dtb_rsv *)glb_dtb_buf;
+
+	/* read dtb2 1st, for compatibility without checksum. */
+	while (cpy >= 0) {
+		blk = ((get_reserve_partition_off_from_tbl()
+					+ DTB_RESERVE_OFFSET) >> bit)
+			+ cpy * DTB_BLK_CNT;
+		if (_dtb_read(mmc, blk, (unsigned char *)dtb)) {
+			pr_err("%s: block # %#x ERROR!\n", __func__, blk);
+		} else {
+			ret = _verify_dtb_checksum(dtb);
+			if (!ret) {
+				info->stamp[cpy] = dtb->timestamp;
+				info->valid[cpy] = 1;
+			} else {
+				pr_err("cpy %d is not valid\n", cpy);
+			}
+		}
+		valid += info->valid[cpy];
+		cpy--;
+	}
+	pr_info("total valid %d\n", valid);
+
+	return ret;
+}
+
+int amlmmc_dtb_write(struct mmc_card *mmc, unsigned char *buf, int len)
+{
+	int ret = 0, blk;
+	int bit = mmc->csd.read_blkbits;
+	int cpy, valid;
+	struct aml_dtb_rsv *dtb = (struct aml_dtb_rsv *)buf;
+	struct aml_dtb_info *info = &dtb_infos;
+
+	if (len > CONFIG_DTB_SIZE) {
+		pr_err("%s dtb data len too much", __func__);
+		return -EFAULT;
+	}
+	/* set info */
+	valid = info->valid[0] + info->valid[1];
+	if (valid == 0) {
+		dtb->timestamp = 0;
+	} else if (valid == 1) {
+		dtb->timestamp = 1 + info->stamp[info->valid[0] ? 0 : 1];
+	} else {
+		/* both are valid */
+		if (info->stamp[0] != info->stamp[1]) {
+			pr_info("timestamp are not same %d:%d\n",
+				info->stamp[0], info->stamp[1]);
+			dtb->timestamp = 1 +
+				(stamp_after(info->stamp[1], info->stamp[0]) ?
+				info->stamp[1] : info->stamp[0]);
+		} else {
+			dtb->timestamp = 1 + info->stamp[0];
+		}
+	}
+	/*setting version and magic*/
+	dtb->version = 1; /* base version */
+	dtb->magic = 0x00447e41; /*A~D\0*/
+	dtb->checksum = _calc_dtb_checksum(dtb);
+	pr_info("stamp %d, checksum 0x%x, version %d, magic %s\n",
+		dtb->timestamp, dtb->checksum,
+		dtb->version, (char *)&dtb->magic);
+	/* write down... */
+	for (cpy = 0; cpy < DTB_COPIES; cpy++) {
+		blk = ((get_reserve_partition_off_from_tbl()
+					+ DTB_RESERVE_OFFSET) >> bit)
+			+ cpy * DTB_BLK_CNT;
+		ret |= _dtb_write(mmc, blk, buf);
+	}
+
+	return ret;
+}
+
+int amlmmc_dtb_read(struct mmc_card *card, unsigned char *buf, int len)
+{
+	int ret = 0, start_blk, size, blk_cnt;
+	int bit = card->csd.read_blkbits;
+	unsigned char *dst = NULL;
+	unsigned char *buffer = NULL;
+
+	if (len > CONFIG_DTB_SIZE) {
+		pr_err("%s dtb data len too much", __func__);
+		return -EFAULT;
+	}
+	memset(buf, 0x0, len);
+
+	start_blk = MMC_DTB_PART_OFFSET;
+	buffer = kmalloc(DTB_CELL_SIZE, GFP_KERNEL | __GFP_RECLAIM);
+	if (!buffer)
+		return -ENOMEM;
+
+	start_blk >>= bit;
+	size = CONFIG_DTB_SIZE;
+	blk_cnt = size >> bit;
+	dst = (unsigned char *)buffer;
+	while (blk_cnt != 0) {
+		memset(buffer, 0x0, DTB_CELL_SIZE);
+		ret = mmc_read_internal(card, start_blk,
+					(DTB_CELL_SIZE >> bit), dst);
+		if (ret) {
+			pr_err("%s read dtb error", __func__);
+			ret = -EFAULT;
+			kfree(buffer);
+			return ret;
+		}
+		start_blk += (DTB_CELL_SIZE >> bit);
+		blk_cnt -= (DTB_CELL_SIZE >> bit);
+		memcpy(buf, dst, DTB_CELL_SIZE);
+		buf += DTB_CELL_SIZE;
+	}
+	kfree(buffer);
+	return ret;
+}
+static CLASS_ATTR_STRING(emmcdtb, 0644, NULL);
+
+int mmc_dtb_open(struct inode *node, struct file *file)
+{
+	return 0;
+}
+
+ssize_t mmc_dtb_read(struct file *file, char __user *buf,
+		     size_t count, loff_t *ppos)
+{
+	unsigned char *dtb_ptr = NULL;
+	ssize_t read_size = 0;
+	int ret = 0;
+
+	if (*ppos == CONFIG_DTB_SIZE)
+		return 0;
+
+	if (*ppos >= CONFIG_DTB_SIZE) {
+		pr_err("%s: out of space!", __func__);
+		return -EFAULT;
+	}
+
+	dtb_ptr = glb_dtb_buf;
+	if (!dtb_ptr)
+		return -ENOMEM;
+
+	mmc_claim_host(card_dtb->host);
+	ret = amlmmc_dtb_read(card_dtb, (unsigned char *)dtb_ptr,
+			      CONFIG_DTB_SIZE);
+	if (ret) {
+		pr_err("%s: read failed:%d", __func__, ret);
+		ret = -EFAULT;
+		goto exit;
+	}
+	if ((*ppos + count) > CONFIG_DTB_SIZE)
+		read_size = CONFIG_DTB_SIZE - *ppos;
+	else
+		read_size = count;
+	ret = copy_to_user(buf, (dtb_ptr + *ppos), read_size);
+	*ppos += read_size;
+
+exit:
+	mmc_release_host(card_dtb->host);
+	return read_size;
+}
+
+ssize_t mmc_dtb_write(struct file *file,
+		      const char __user *buf, size_t count, loff_t *ppos)
+{
+	unsigned char *dtb_ptr = NULL;
+	ssize_t write_size = 0;
+	int ret = 0;
+
+	if (*ppos == CONFIG_DTB_SIZE)
+		return 0;
+	if (*ppos >= CONFIG_DTB_SIZE) {
+		pr_err("%s: out of space!", __func__);
+		return -EFAULT;
+	}
+
+	dtb_ptr = glb_dtb_buf;
+	if (!dtb_ptr)
+		return -ENOMEM;
+
+	mmc_claim_host(card_dtb->host);
+
+	if ((*ppos + count) > CONFIG_DTB_SIZE)
+		write_size = CONFIG_DTB_SIZE - *ppos;
+	else
+		write_size = count;
+
+	ret = copy_from_user((dtb_ptr + *ppos), buf, write_size);
+
+	ret = amlmmc_dtb_write(card_dtb,
+			       dtb_ptr, CONFIG_DTB_SIZE);
+	if (ret) {
+		pr_err("%s: write dtb failed", __func__);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	*ppos += write_size;
+exit:
+	mmc_release_host(card_dtb->host);
+	return write_size;
+}
+
+long mmc_dtb_ioctl(struct file *file, unsigned int cmd, unsigned long args)
+{
+	return 0;
+}
+
+static const struct file_operations dtb_ops = {
+	.open = mmc_dtb_open,
+	.read = mmc_dtb_read,
+	.write = mmc_dtb_write,
+	.unlocked_ioctl = mmc_dtb_ioctl,
+};
+
+int amlmmc_dtb_init(struct mmc_card *card)
+{
+	int ret = 0;
+
+	card_dtb = card;
+	pr_info("%s: register dtb chardev", __func__);
+
+	_dtb_init(card);
+
+	ret = alloc_chrdev_region(&amlmmc_dtb_no, 0, 1, DTB_NAME);
+	if (ret < 0) {
+		pr_err("alloc dtb dev_t no failed");
+		ret = -1;
+		goto exit_err;
+	}
+
+	cdev_init(&amlmmc_dtb, &dtb_ops);
+	amlmmc_dtb.owner = THIS_MODULE;
+	ret = cdev_add(&amlmmc_dtb, amlmmc_dtb_no, 1);
+	if (ret) {
+		pr_err("dtb dev add failed");
+		ret = -1;
+		goto exit_err1;
+	}
+
+	amlmmc_dtb_class = class_create(THIS_MODULE, DTB_NAME);
+	if (IS_ERR(amlmmc_dtb_class)) {
+		pr_err("dtb dev add failed");
+		ret = -1;
+		goto exit_err2;
+	}
+
+	ret = class_create_file(amlmmc_dtb_class, &class_attr_emmcdtb.attr);
+	if (ret) {
+		pr_err("dtb dev add failed");
+		ret = -1;
+		goto exit_err2;
+	}
+
+	dtb_dev = device_create(amlmmc_dtb_class, NULL,
+				amlmmc_dtb_no, NULL, DTB_NAME);
+	if (IS_ERR(dtb_dev)) {
+		pr_err("dtb dev add failed");
+		ret = -1;
+		goto exit_err3;
+	}
+
+	pr_info("%s: register dtb chardev OK", __func__);
+
+	return ret;
+
+exit_err3:
+	class_remove_file(amlmmc_dtb_class, &class_attr_emmcdtb.attr);
+	class_destroy(amlmmc_dtb_class);
+exit_err2:
+	cdev_del(&amlmmc_dtb);
+exit_err1:
+	unregister_chrdev_region(amlmmc_dtb_no, 1);
+exit_err:
+	return ret;
+}
+
+/*
+ * Checks that a normal transfer didn't have any errors
+ */
+static int mmc_check_result(struct mmc_request *mrq)
+{
+	int ret;
+
+	WARN_ON(!mrq || !mrq->cmd || !mrq->data);
+
+	ret = 0;
+
+	if (!ret && mrq->cmd->error)
+		ret = mrq->cmd->error;
+	if (!ret && mrq->data->error)
+		ret = mrq->data->error;
+	if (!ret && mrq->stop && mrq->stop->error)
+		ret = mrq->stop->error;
+	if (!ret && mrq->data->bytes_xfered !=
+			mrq->data->blocks * mrq->data->blksz)
+		ret = RESULT_FAIL;
+
+	if (ret == -EINVAL)
+		ret = RESULT_UNSUP_HOST;
+
+	return ret;
+}
+
+static void mmc_prepare_mrq(struct mmc_card *card,
+			    struct mmc_request *mrq, struct scatterlist *sg,
+			    unsigned int sg_len, unsigned int dev_addr,
+			    unsigned int blocks,
+			    unsigned int blksz, int write)
+{
+	WARN_ON(!mrq || !mrq->cmd || !mrq->data || !mrq->stop);
+
+	if (blocks > 1) {
+		mrq->cmd->opcode = write ?
+			MMC_WRITE_MULTIPLE_BLOCK : MMC_READ_MULTIPLE_BLOCK;
+	} else {
+		mrq->cmd->opcode = write ?
+			MMC_WRITE_BLOCK : MMC_READ_SINGLE_BLOCK;
+	}
+
+	mrq->cmd->arg = dev_addr;
+	if (!mmc_card_is_blockaddr(card))
+		mrq->cmd->arg <<= 9;
+
+	mrq->cmd->flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+
+	if (blocks == 1) {
+		mrq->stop = NULL;
+	} else {
+		mrq->stop->opcode = MMC_STOP_TRANSMISSION;
+		mrq->stop->arg = 0;
+		mrq->stop->flags = MMC_RSP_R1B | MMC_CMD_AC;
+	}
+
+	mrq->data->blksz = blksz;
+	mrq->data->blocks = blocks;
+	mrq->data->flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;
+	mrq->data->sg = sg;
+	mrq->data->sg_len = sg_len;
+
+	mmc_set_data_timeout(mrq->data, card);
+}
+
+unsigned int mmc_capacity(struct mmc_card *card)
+{
+	if (!mmc_card_sd(card) && mmc_card_is_blockaddr(card))
+		return card->ext_csd.sectors;
+	else
+		return card->csd.capacity << (card->csd.read_blkbits - 9);
+}
+
+static int mmc_transfer(struct mmc_card *card, unsigned int dev_addr,
+			unsigned int blocks, void *buf, int write)
+{
+	u8 original_part_config;
+	u8 user_part_number = 0;
+	u8 cur_part_number;
+	bool switch_partition = false;
+	unsigned int size;
+	struct scatterlist sg;
+	struct mmc_request mrq = {0};
+	struct mmc_command cmd = {0};
+	struct mmc_command stop = {0};
+	struct mmc_data data = {0};
+	int ret;
+
+	cur_part_number = card->ext_csd.part_config
+		& EXT_CSD_PART_CONFIG_ACC_MASK;
+	if (cur_part_number != user_part_number) {
+		switch_partition = true;
+		original_part_config = card->ext_csd.part_config;
+		cur_part_number = original_part_config
+			& (~EXT_CSD_PART_CONFIG_ACC_MASK);
+		ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_PART_CONFIG, cur_part_number,
+				 card->ext_csd.part_time);
+		if (ret)
+			return ret;
+
+		card->ext_csd.part_config = cur_part_number;
+	}
+	if ((dev_addr + blocks) >= mmc_capacity(card)) {
+		pr_info("[%s] %s range exceeds device capacity!\n",
+			__func__, write ? "write" : "read");
+		ret = -1;
+		return ret;
+	}
+
+	size = blocks << card->csd.read_blkbits;
+	sg_init_one(&sg, buf, size);
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+	mrq.stop = &stop;
+
+	mmc_prepare_mrq(card, &mrq, &sg, 1, dev_addr,
+			blocks, 1 << card->csd.read_blkbits, write);
+
+	mmc_wait_for_req(card->host, &mrq);
+
+	ret = mmc_check_result(&mrq);
+	if (switch_partition) {
+		ret = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+				 EXT_CSD_PART_CONFIG, original_part_config,
+				 card->ext_csd.part_time);
+		if (ret)
+			return ret;
+		card->ext_csd.part_config = original_part_config;
+	}
+
+	return ret;
+}
+
+/*write tuning para on emmc, the offset is 0x14400*/
+static int amlmmc_write_tuning_para(struct mmc_card *card,
+				    unsigned int dev_addr)
+{
+	unsigned int size;
+	struct mmc_host *mmc = card->host;
+	struct meson_host *host = mmc_priv(mmc);
+	struct aml_tuning_para *parameter = &host->para;
+	unsigned int *buf;
+	int para_size;
+	int blocks;
+
+	if (host->save_para == 0)
+		return 0;
+
+	if (parameter->update == 0)
+		return 0;
+	parameter->update = 0;
+
+	para_size = sizeof(struct aml_tuning_para);
+	blocks = (para_size - 1)  / 512 + 1;
+	size = blocks << card->csd.read_blkbits;
+
+	buf = kmalloc(size, GFP_KERNEL);
+	memset(buf, 0, size);
+
+	memcpy(buf, parameter, sizeof(struct aml_tuning_para));
+
+	mmc_claim_host(card->host);
+	mmc_transfer(card, dev_addr, blocks, buf, 1);
+	mmc_release_host(card->host);
+
+	kfree(buf);
+	return 0;
+}
+
+int mmc_read_internal(struct mmc_card *card, unsigned int dev_addr,
+		      unsigned int blocks, void *buf)
+{
+	return mmc_transfer(card, dev_addr, blocks, buf, 0);
+}
+
+int mmc_write_internal(struct mmc_card *card, unsigned int dev_addr,
+		       unsigned int blocks, void *buf)
+{
+	return mmc_transfer(card, dev_addr, blocks, buf, 1);
+}
+
+static int mmc_partition_tbl_checksum_calc(struct partitions *part,
+					   int part_num)
+{
+	int i, j;
+	u32 checksum = 0, *p;
+
+	for (i = 0; i < part_num; i++) {
+		p = (u32 *)part;
+
+		for (j = sizeof(struct partitions) / sizeof(checksum);
+				j > 0; j--) {
+			checksum += *p;
+			p++;
+		}
+	}
+
+	return checksum;
+}
+
+static int get_reserve_partition_off(struct mmc_card *card) /* byte unit */
+{
+	int off = -1;
+
+	off = MMC_BOOT_PARTITION_SIZE + MMC_BOOT_PARTITION_RESERVED;
+
+	return off;
+}
+
+int get_reserve_partition_off_from_tbl(void)
+{
+	int i;
+
+	for (i = 0; i < pt_fmt->part_num; i++) {
+		if (!strcmp(pt_fmt->partitions[i].name, MMC_RESERVED_NAME))
+			return pt_fmt->partitions[i].offset;
+	}
+	return -1;
+}
+
+static int mmc_read_partition_tbl(struct mmc_card *card,
+				  struct mmc_partitions_fmt *pt_fmt)
+{
+	int ret = 0, start_blk, size, blk_cnt;
+	int bit = card->csd.read_blkbits;
+	int blk_size = 1 << bit; /* size of a block */
+	char *buf, *dst;
+
+	buf = kmalloc(blk_size, GFP_KERNEL);
+	if (!buf) {
+		/*	pr_info("malloc failed for buffer!\n");*/
+		ret = -ENOMEM;
+		goto exit_err;
+	}
+	memset(pt_fmt, 0, sizeof(struct mmc_partitions_fmt));
+	memset(buf, 0, blk_size);
+	start_blk = get_reserve_partition_off(card);
+	if (start_blk < 0) {
+		ret = -EINVAL;
+		goto exit_err;
+	}
+	start_blk >>= bit;
+	size = sizeof(struct mmc_partitions_fmt);
+	dst = (char *)pt_fmt;
+	if (size >= blk_size) {
+		blk_cnt = size >> bit;
+		ret = mmc_read_internal(card, start_blk, blk_cnt, dst);
+		if (ret) { /* error */
+			goto exit_err;
+		}
+		start_blk += blk_cnt;
+		dst += blk_cnt << bit;
+		size -= blk_cnt << bit;
+	}
+	if (size > 0) { /* the last block */
+		ret = mmc_read_internal(card, start_blk, 1, buf);
+		if (ret)
+			goto exit_err;
+		memcpy(dst, buf, size);
+	}
+	/* pr_info("Partition table stored in eMMC/TSD:\n"); */
+	/* pr_info("magic: %s, version: %s, checksum=%#x\n", */
+	/* pt_fmt->magic, pt_fmt->version, pt_fmt->checksum); */
+	/* show_mmc_patition(pt_fmt->partitions, pt_fmt->part_num); */
+
+	if ((strncmp(pt_fmt->magic, MMC_PARTITIONS_MAGIC,
+		     sizeof(pt_fmt->magic)) == 0) && pt_fmt->part_num > 0 &&
+			pt_fmt->part_num <= MAX_MMC_PART_NUM &&
+			pt_fmt->checksum == mmc_partition_tbl_checksum_calc
+			(pt_fmt->partitions, pt_fmt->part_num)) {
+		ret = 0; /* everything is OK now */
+
+	} else {
+		if (strncmp(pt_fmt->magic, MMC_PARTITIONS_MAGIC,
+			    sizeof(pt_fmt->magic)) != 0) {
+			pr_info("magic error: %s\n", pt_fmt->magic);
+		} else if ((pt_fmt->part_num < 0) ||
+			    (pt_fmt->part_num > MAX_MMC_PART_NUM)) {
+			pr_info("partition number error: %d\n",
+				pt_fmt->part_num);
+		} else {
+			pr_info("checksum error: pt_fmt->checksum=%d,calc_result=%d\n",
+				pt_fmt->checksum,
+				mmc_partition_tbl_checksum_calc
+				(pt_fmt->partitions, pt_fmt->part_num));
+		}
+
+		pr_info("[%s]: partition verified error\n", __func__);
+		ret = -1; /* the partition information is invalid */
+	}
+
+exit_err:
+	kfree(buf);
+
+	pr_info("[%s] mmc read partition %s!\n",
+		__func__, (ret == 0) ? "OK" : "ERROR");
+
+	return ret;
+}
+
+/* This function is copy and modified from kernel function add_partition() */
+static struct hd_struct *add_emmc_each_part(struct gendisk *disk, int partno,
+					    sector_t start, sector_t len,
+					    int flags, char *pname)
+{
+	struct hd_struct *p;
+	dev_t devt = MKDEV(0, 0);
+	struct device *ddev = disk_to_dev(disk);
+	struct device *pdev;
+	struct disk_part_tbl *ptbl;
+	const char *dname;
+	int err;
+	struct partition_meta_info *pinfo;
+
+	/*
+	 * Partitions are not supported on zoned block devices that are used as
+	 * such.
+	 */
+	switch (disk->queue->limits.zoned) {
+	case BLK_ZONED_HM:
+		pr_warn("%s: partitions not supported on host managed zoned block device\n",
+			disk->disk_name);
+		return ERR_PTR(-ENXIO);
+	case BLK_ZONED_HA:
+		pr_info("%s: disabling host aware zoned block device support due to partitions\n",
+			disk->disk_name);
+		disk->queue->limits.zoned = BLK_ZONED_NONE;
+		break;
+	case BLK_ZONED_NONE:
+		break;
+	}
+
+	err = disk_expand_part_tbl(disk, partno);
+	if (err)
+		return ERR_PTR(err);
+	ptbl = rcu_dereference_protected(disk->part_tbl, 1);
+
+	if (ptbl->part[partno])
+		return ERR_PTR(-EBUSY);
+
+	p = kzalloc(sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return ERR_PTR(-EBUSY);
+
+	p->dkstats = alloc_percpu(struct disk_stats);
+	if (!p->dkstats) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+	hd_sects_seq_init(p);
+	pdev = part_to_dev(p);
+
+	p->start_sect = start;
+	p->nr_sects = len;
+	p->partno = partno;
+	p->policy = get_disk_ro(disk);
+
+	pinfo = kzalloc_node(sizeof(*pinfo), GFP_KERNEL, disk->node_id);
+	p->info = pinfo;
+	sprintf(p->info->volname, "%s", pname);
+
+	dname = dev_name(ddev);
+	dev_set_name(pdev, "%s", pname);
+
+	device_initialize(pdev);
+	pdev->class = &block_class;
+	pdev->type = &part_type;
+	pdev->parent = ddev;
+
+	err = blk_alloc_devt(p, &devt);
+	if (err)
+		goto out_free_info;
+	pdev->devt = devt;
+
+	/* delay uevent until 'holders' subdir is created */
+	dev_set_uevent_suppress(pdev, 1);
+	err = device_add(pdev);
+	if (err)
+		goto out_put;
+
+	err = -ENOMEM;
+	p->holder_dir = kobject_create_and_add("holders", &pdev->kobj);
+	if (!p->holder_dir)
+		goto out_del;
+
+	dev_set_uevent_suppress(pdev, 0);
+
+	/* everything is up and running, commence */
+	rcu_assign_pointer(ptbl->part[partno], p);
+
+	/* suppress uevent if the disk suppresses it */
+	if (!dev_get_uevent_suppress(ddev))
+		kobject_uevent(&pdev->kobj, KOBJ_ADD);
+
+	hd_ref_init(p);
+	return p;
+
+out_free_info:
+	kfree(p->info);
+out_free:
+	kfree(p);
+	return ERR_PTR(err);
+out_del:
+	kobject_put(p->holder_dir);
+	device_del(pdev);
+out_put:
+	put_device(pdev);
+	blk_free_devt(devt);
+	return ERR_PTR(err);
+}
+
+static inline int card_proc_info(struct seq_file *m, char *dev_name, int i)
+{
+	struct partitions *this = &(pt_fmt->partitions[i]);
+
+	if (i >= pt_fmt->part_num)
+		return 0;
+
+	seq_printf(m, "%s%02d: %9llx %9x \"%s\"\n", dev_name,
+		   i + 1, (unsigned long long)this->size,
+		   512 * 1024, this->name);
+	return 0;
+}
+
+static int card_proc_show(struct seq_file *m, void *v)
+{
+	int i;
+
+	seq_puts(m, "dev:	size   erasesize  name\n");
+	for (i = 0; i < 16; i++)
+		card_proc_info(m, "inand", i);
+
+	return 0;
+}
+
+static int card_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, card_proc_show, NULL);
+}
+
+static const struct proc_ops card_proc_fops = {
+	.proc_open = card_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+
+static int add_emmc_partition(struct gendisk *disk,
+			      struct mmc_partitions_fmt *pt_fmt)
+{
+	unsigned int i;
+	struct hd_struct *ret = NULL;
+	uint64_t offset, size, cap;
+	struct partitions *pp;
+	struct proc_dir_entry *proc_card;
+
+	pr_info("%s\n", __func__);
+
+	cap = get_capacity(disk); /* unit:512 bytes */
+	for (i = 0; i < pt_fmt->part_num; i++) {
+		pp = &(pt_fmt->partitions[i]);
+		offset = pp->offset >> 9; /* unit:512 bytes */
+		size = pp->size >> 9; /* unit:512 bytes */
+		if ((offset + size) <= cap) {
+			ret = add_emmc_each_part(disk, 1 + i, offset,
+						 size, 0, pp->name);
+
+			pr_info("[%sp%02d] %20s  offset 0x%012llx, size 0x%012llx %s\n",
+				disk->disk_name, 1 + i,
+				pp->name, offset << 9,
+				size << 9, IS_ERR(ret) ? "add fail" : "");
+		} else {
+			pr_info("[%s] %s: partition exceeds device capacity:\n",
+				__func__, disk->disk_name);
+
+			pr_info("%20s	offset 0x%012llx, size 0x%012llx\n",
+				pp->name, offset << 9, size << 9);
+
+			break;
+		}
+	}
+	/* create /proc/inand */
+
+	proc_card = proc_create("inand", 0444, NULL, &card_proc_fops);
+	if (!proc_card)
+		pr_info("[%s] create /proc/inand fail.\n", __func__);
+
+	/* create /proc/ntd */
+	if (!proc_create("ntd", 0444, NULL, &card_proc_fops))
+		pr_info("[%s] create /proc/ntd fail.\n", __func__);
+
+	return 0;
+}
+
+static int is_card_emmc(struct mmc_card *card)
+{
+	struct mmc_host *mmc = card->host;
+	struct meson_host *host = mmc_priv(mmc);
+
+	/* emmc port, so it must be an eMMC or TSD */
+	if (aml_card_type_mmc(host))
+		return 0;
+	else
+		return 1;
+	/*return mmc->is_emmc_port;*/
+}
+
+static ssize_t emmc_version_get(struct class *class,
+				struct class_attribute *attr, char *buf)
+{
+	int num = 0;
+
+	return sprintf(buf, "%d", num);
+}
+
+static void show_partition_table(struct partitions *table)
+{
+	int i = 0;
+	struct partitions *par_table = NULL;
+
+	pr_info("show partition table:\n");
+	for (i = 0; i < MAX_MMC_PART_NUM; i++) {
+		par_table = &table[i];
+		if (par_table->size == -1)
+			pr_info("part: %d, name : %10s, size : %-4s mask_flag %d\n",
+				i, par_table->name, "end",
+				par_table->mask_flags);
+		else
+			pr_info("part: %d, name : %10s, size : %-4llx  mask_flag %d\n",
+				i, par_table->name, par_table->size,
+				par_table->mask_flags);
+	}
+}
+
+static ssize_t emmc_part_table_get(struct class *class,
+				   struct class_attribute *attr, char *buf)
+{
+	struct partitions *part_table = NULL;
+	struct partitions *tmp_table = NULL;
+	int i = 0, part_num = 0;
+
+	tmp_table = pt_fmt->partitions;
+	part_table = kmalloc_array(MAX_MMC_PART_NUM,
+				   sizeof(struct partitions), GFP_KERNEL);
+
+	if (!part_table) {
+		pr_info("[%s] malloc failed for  part_table!\n", __func__);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < MAX_MMC_PART_NUM; i++) {
+		if (tmp_table[i].mask_flags == STORE_CODE) {
+			strncpy(part_table[part_num].name,
+				tmp_table[i].name,
+				MAX_MMC_PART_NAME_LEN);
+
+			part_table[part_num].size = tmp_table[i].size;
+			part_table[part_num].offset = tmp_table[i].offset;
+
+			part_table[part_num].mask_flags =
+				tmp_table[i].mask_flags;
+			part_num++;
+		}
+	}
+	for (i = 0; i < MAX_MMC_PART_NUM; i++) {
+		if (tmp_table[i].mask_flags == STORE_CACHE) {
+			strncpy(part_table[part_num].name,
+				tmp_table[i].name,
+				MAX_MMC_PART_NAME_LEN);
+
+			part_table[part_num].size = tmp_table[i].size;
+			part_table[part_num].offset = tmp_table[i].offset;
+
+			part_table[part_num].mask_flags =
+				tmp_table[i].mask_flags;
+
+			part_num++;
+		}
+	}
+	for (i = 0; i < MAX_MMC_PART_NUM; i++) {
+		if (tmp_table[i].mask_flags == STORE_DATA) {
+			strncpy(part_table[part_num].name,
+				tmp_table[i].name,
+				MAX_MMC_PART_NAME_LEN);
+
+			part_table[part_num].size = tmp_table[i].size;
+			part_table[part_num].offset = tmp_table[i].offset;
+			part_table[part_num].mask_flags =
+				tmp_table[i].mask_flags;
+
+			if (!strncmp(part_table[part_num].name, "data",
+				     MAX_MMC_PART_NAME_LEN))
+				/* last part size is FULL */
+				part_table[part_num].size = -1;
+			part_num++;
+		}
+	}
+
+	show_partition_table(part_table);
+	memcpy(buf, part_table, MAX_MMC_PART_NUM * sizeof(struct partitions));
+
+	kfree(part_table);
+	part_table = NULL;
+
+	return MAX_MMC_PART_NUM * sizeof(struct partitions);
+}
+
+static int store_device = -1;
+static ssize_t store_device_flag_get(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+	if (store_device == -1) {
+		pr_info("[%s]  get store device flag something wrong !\n",
+			__func__);
+	}
+
+	return sprintf(buf, "%d", store_device);
+}
+
+static ssize_t get_bootloader_offset(struct class *class,
+				     struct class_attribute *attr, char *buf)
+{
+	int offset = 0;
+
+	offset = 512;
+	return sprintf(buf, "%d", offset);
+}
+
+/*
+ * extern u32 cd_irq_cnt[2];
+ *
+ *static ssize_t get_cdirq_cnt(struct class *class,
+ *	struct class_attribute *attr, char *buf)
+ *{
+ *	return sprintf(buf, "in:%d, out:%d\n", cd_irq_cnt[1], cd_irq_cnt[0]);
+ *}
+ */
+
+static struct class_attribute aml_version =
+__ATTR(version, 0444, emmc_version_get, NULL);
+static struct class_attribute aml_part_table =
+__ATTR(part_table, 0444, emmc_part_table_get, NULL);
+static struct class_attribute aml_store_device =
+__ATTR(store_device, 0444, store_device_flag_get, NULL);
+static struct class_attribute bootloader_offset =
+__ATTR(bl_off_bytes, 0444, get_bootloader_offset, NULL);
+
+int add_fake_boot_partition(struct gendisk *disk, char *name, int idx)
+{
+	u64 boot_size = (u64)get_capacity(disk) - 1;
+	char fake_name[80];
+	int offset = 1;
+	struct hd_struct *ret = NULL;
+
+	idx ^= 1;
+	sprintf(fake_name, name, idx);
+	ret = add_emmc_each_part(disk, 1, offset, boot_size, 0, fake_name);
+	if (IS_ERR(ret))
+		pr_info("%s added failed\n", fake_name);
+
+	return 0;
+}
+
+int aml_emmc_partition_ops(struct mmc_card *card, struct gendisk *disk)
+{
+	int ret = 0;
+	struct disk_part_iter piter;
+	struct hd_struct *part;
+	struct class *aml_store_class = NULL;
+	struct gpt_header *gpt_h = NULL;
+	unsigned char *buffer = NULL;
+
+	pr_info("Enter %s\n", __func__);
+	if (!is_card_emmc(card)) /* not emmc, nothing to do */
+		return 0;
+
+	buffer = kmalloc(512, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
+	mmc_claim_host(card->host);
+
+	/*self adapting*/
+	ret = mmc_read_internal(card, 1, 1, buffer);
+	if (ret) {
+		pr_err("%s: save dtb error", __func__);
+		kfree(buffer);
+		goto out;
+	}
+
+	gpt_h = (struct gpt_header *)buffer;
+
+	if (le64_to_cpu(gpt_h->signature) == GPT_HEADER_SIGNATURE) {
+		kfree(buffer);
+		mmc_release_host(card->host);
+		return 0;
+	}
+
+	kfree(buffer);
+
+	pt_fmt = kmalloc(sizeof(*pt_fmt), GFP_KERNEL);
+	if (!pt_fmt) {
+		/*	pr_info(
+		 *	"[%s] malloc failed for struct mmc_partitions_fmt!\n",
+		 *	__func__);
+		 */
+		mmc_release_host(card->host);
+		return -ENOMEM;
+	}
+
+	disk_part_iter_init(&piter, disk, DISK_PITER_INCL_EMPTY);
+
+	while ((part = disk_part_iter_next(&piter))) {
+		pr_info("Delete invalid mbr partition part %p, part->partno %d\n",
+				part, part->partno);
+		delete_partition(part);
+	}
+	disk_part_iter_exit(&piter);
+
+	ret = mmc_read_partition_tbl(card, pt_fmt);
+	if (ret == 0) { /* ok */
+		ret = add_emmc_partition(disk, pt_fmt);
+	}
+	mmc_release_host(card->host);
+
+	if (ret == 0) /* ok */
+		ret = emmc_key_init(card);
+	if (ret)
+		goto out;
+
+	amlmmc_dtb_init(card);
+	amlmmc_write_tuning_para(card, MMC_TUNING_OFFSET);
+
+	aml_store_class = class_create(THIS_MODULE, "aml_store");
+	if (IS_ERR(aml_store_class)) {
+		pr_info("[%s] create aml_store_class class fail.\n", __func__);
+		ret = -1;
+		goto out;
+	}
+
+	ret = class_create_file(aml_store_class, &aml_version);
+	if (ret) {
+		pr_info("[%s] can't create aml_store_class file .\n", __func__);
+		goto out_class1;
+	}
+	ret = class_create_file(aml_store_class, &aml_part_table);
+	if (ret) {
+		pr_info("[%s] can't create aml_store_class file .\n", __func__);
+		goto out_class2;
+	}
+	ret = class_create_file(aml_store_class, &aml_store_device);
+	if (ret) {
+		pr_info("[%s] can't create aml_store_class file .\n", __func__);
+		goto out_class3;
+	}
+
+	ret = class_create_file(aml_store_class, &bootloader_offset);
+	if (ret) {
+		pr_info("[%s] can't create aml_store_class file .\n", __func__);
+		goto out_class3;
+	}
+
+	pr_info("Exit %s %s.\n", __func__, (ret == 0) ? "OK" : "ERROR");
+	return ret;
+
+out_class3:
+	class_remove_file(aml_store_class, &aml_part_table);
+out_class2:
+	class_remove_file(aml_store_class, &aml_version);
+out_class1:
+	class_destroy(aml_store_class);
+out:
+	kfree(pt_fmt);
+	return ret;
+}
diff -Naur a/vendor/amlogic/mmc/Makefile b/vendor/amlogic/mmc/Makefile
--- a/vendor/amlogic/mmc/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/mmc/Makefile	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+# Makefile for the kernel amlogic mmc.
+
+obj-$(CONFIG_MMC_MESON_GX)     += emmc_partitions.o \
+				emmc_key.o
diff -Naur a/vendor/amlogic/pm/Kconfig b/vendor/amlogic/pm/Kconfig
--- a/vendor/amlogic/pm/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/pm/Kconfig	2022-06-30 16:21:34.294964448 +0800
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Amlogic Power Management
+#
+
+config MESON_GX_PM
+	bool
+	default ARCH_MESON if ARM64
+	help
+	  Say y here to enable the Amlogic GX SoC Power Management
diff -Naur a/vendor/amlogic/pm/Makefile b/vendor/amlogic/pm/Makefile
--- a/vendor/amlogic/pm/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/pm/Makefile	2022-06-30 16:21:12.984323728 +0800
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-$(CONFIG_MESON_GX_PM) +=	meson_gx_pm.o
diff -Naur a/vendor/amlogic/pm/meson_gx_pm.c b/vendor/amlogic/pm/meson_gx_pm.c
--- a/vendor/amlogic/pm/meson_gx_pm.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/pm/meson_gx_pm.c	2022-05-31 11:56:47.725259396 +0800
@@ -0,0 +1,86 @@
+/*
+ * Amlogic Meson GX Power Management
+ *
+ * Copyright (c) 2016 Baylibre, SAS.
+ * Author: Neil Armstrong <narmstrong@baylibre.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/suspend.h>
+#include <linux/arm-smccc.h>
+
+#include <uapi/linux/psci.h>
+
+#include <asm/suspend.h>
+
+/*
+ * The Amlogic GX SoCs uses a special argument value to the
+ * PSCI CPU_SUSPEND method to enter SUSPEND_MEM.
+ */
+
+#define MESON_SUSPEND_PARAM	0x0010000
+#define PSCI_FN_NATIVE(version, name)	PSCI_##version##_FN64_##name
+
+static int meson_gx_suspend_finish(unsigned long arg)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(PSCI_FN_NATIVE(0_2, CPU_SUSPEND), arg,
+		      virt_to_phys(cpu_resume), 0, 0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static int meson_gx_suspend_enter(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		return cpu_suspend(MESON_SUSPEND_PARAM,
+				   meson_gx_suspend_finish);
+	}
+
+	return -EINVAL;
+}
+
+static const struct platform_suspend_ops meson_gx_pm_ops = {
+		.enter = meson_gx_suspend_enter,
+		.valid = suspend_valid_only_mem,
+};
+
+static const struct of_device_id meson_gx_pm_match[] = {
+	{ .compatible = "amlogic,meson-gx-pm", },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, meson_gx_pm_match);
+
+static int meson_gx_pm_probe(struct platform_device *pdev)
+{
+	suspend_set_ops(&meson_gx_pm_ops);
+
+	return 0;
+}
+
+static struct platform_driver meson_gx_pm_driver = {
+	.probe = meson_gx_pm_probe,
+	.driver = {
+		.name = "meson-gx-pm",
+		.of_match_table = meson_gx_pm_match,
+	},
+};
+
+module_platform_driver(meson_gx_pm_driver);
+
+MODULE_AUTHOR("Neil Armstrong <narmstrong@baylibre.com>");
+MODULE_DESCRIPTION("Amlogic Meson GX PM driver");
+MODULE_LICENSE("GPL v2");
diff -Naur a/vendor/amlogic/reboot/Kconfig b/vendor/amlogic/reboot/Kconfig
--- a/vendor/amlogic/reboot/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/reboot/Kconfig	2022-07-04 10:14:26.238273685 +0800
@@ -0,0 +1,16 @@
+# Amlogic POWER OFF
+config AMLOGIC_REBOOT
+	bool "Amlogic Board level reboot or power off"
+	default n
+    help
+		This is the Amlogic
+		Board reboot
+		or poweroff
+		driver.
+
+config AMLOGIC_GX_REBOOT
+	bool "Amlogic reboot gx"
+	depends on AMLOGIC_REBOOT
+	default n
+    help
+		This is the Amlogic GX reboot driver.
diff -Naur a/vendor/amlogic/reboot/Makefile b/vendor/amlogic/reboot/Makefile
--- a/vendor/amlogic/reboot/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/reboot/Makefile	2022-07-04 10:14:40.820257260 +0800
@@ -0,0 +1,4 @@
+#
+#Makefile for the RESET dirver
+#
+obj-$(CONFIG_AMLOGIC_GX_REBOOT)	+= reboot.o
diff -Naur a/vendor/amlogic/reboot/reboot.c b/vendor/amlogic/reboot/reboot.c
--- a/vendor/amlogic/reboot/reboot.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/reboot/reboot.c	2022-07-04 13:59:02.866804967 +0800
@@ -0,0 +1,205 @@
+/*
+ * Reboot driver for Amlogic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/reboot.h>
+
+#include <asm/system_misc.h>
+
+#include <linux/amlogic/iomap.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/reboot.h>
+#include <asm/compiler.h>
+#include <linux/kdebug.h>
+#include <linux/arm-smccc.h>
+
+static void __iomem *reboot_reason_vaddr;
+static u32 psci_function_id_restart;
+static u32 psci_function_id_poweroff;
+static char *kernel_panic;
+
+static u32 parse_reason(const char *cmd)
+{
+	u32 reboot_reason = MESON_NORMAL_BOOT;
+
+	if (cmd) {
+		if (strcmp(cmd, "recovery") == 0 ||
+				strcmp(cmd, "factory_reset") == 0)
+			reboot_reason = MESON_FACTORY_RESET_REBOOT;
+		else if (strcmp(cmd, "cold_boot") == 0)
+			reboot_reason = MESON_COLD_REBOOT;
+		else if (strcmp(cmd, "update") == 0)
+			reboot_reason = MESON_UPDATE_REBOOT;
+		else if (strcmp(cmd, "fastboot") == 0)
+			reboot_reason = MESON_FASTBOOT_REBOOT;
+		else if (strcmp(cmd, "bootloader") == 0)
+			reboot_reason = MESON_BOOTLOADER_REBOOT;
+		else if (strcmp(cmd, "rpmbp") == 0)
+			reboot_reason = MESON_RPMBP_REBOOT;
+		else if (strcmp(cmd, "report_crash") == 0)
+			reboot_reason = MESON_CRASH_REBOOT;
+		else if (strcmp(cmd, "uboot_suspend") == 0)
+			reboot_reason = MESON_UBOOT_SUSPEND;
+		else if (strcmp(cmd, "quiescent") == 0 ||
+				strcmp(cmd, ",quiescent") == 0)
+			reboot_reason = MESON_QUIESCENT_REBOOT;
+		else if (strcmp(cmd, "recovery,quiescent") == 0 ||
+				strcmp(cmd, "factory_reset,quiescent") == 0 ||
+				strcmp(cmd, "quiescent,recovery") == 0 ||
+				strcmp(cmd, "quiescent,factory_reset") == 0)
+			reboot_reason = MESON_RECOVERY_QUIESCENT_REBOOT;
+		else if (strcmp(cmd, "ffv_reboot") == 0)
+			reboot_reason = MESON_FFV_REBOOT;
+	} else {
+		if (kernel_panic) {
+			if (strcmp(kernel_panic, "kernel_panic") == 0) {
+				reboot_reason = MESON_KERNEL_PANIC;
+			}
+		}
+	}
+
+	pr_info("reboot reason %d\n", reboot_reason);
+	return reboot_reason;
+}
+static noinline int __invoke_psci_fn_smc(u64 function_id, u64 arg0, u64 arg1,
+					 u64 arg2)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc((unsigned long)function_id,
+			(unsigned long)arg0,
+			(unsigned long)arg1,
+			(unsigned long)arg2,
+			0, 0, 0, 0, &res);
+	return res.a0;
+}
+
+void meson_smc_restart(u64 function_id, u64 reboot_reason)
+{
+	__invoke_psci_fn_smc(function_id,
+				reboot_reason, 0, 0);
+}
+
+void meson_common_restart(char mode, const char *cmd)
+{
+	u32 reboot_reason = parse_reason(cmd);
+
+	if (psci_function_id_restart)
+		meson_smc_restart((u64)psci_function_id_restart,
+						(u64)reboot_reason);
+}
+
+static void do_aml_restart(enum reboot_mode reboot_mode, const char *cmd)
+{
+	meson_common_restart(reboot_mode, cmd);
+}
+
+static void do_aml_poweroff(void)
+{
+	/* TODO: Add poweroff capability */
+	__invoke_psci_fn_smc(0x82000042, 1, 0, 0);
+	__invoke_psci_fn_smc(psci_function_id_poweroff,
+				0, 0, 0);
+}
+static int panic_notify(struct notifier_block *self,
+			unsigned long cmd, void *ptr)
+{
+	kernel_panic = "kernel_panic";
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_notifier = {
+	.notifier_call	= panic_notify,
+};
+
+ssize_t reboot_reason_show(struct device *dev,
+			   struct device_attribute *attr, char *buf)
+{
+	unsigned int value, len;
+
+	if (!reboot_reason_vaddr)
+		return 0;
+	value = readl(reboot_reason_vaddr);
+	value = (value >> 12) & 0xf;
+	len = sprintf(buf, "%d\n", value);
+
+	return len;
+}
+
+DEVICE_ATTR(reboot_reason, 0444, reboot_reason_show, NULL);
+
+static int aml_restart_probe(struct platform_device *pdev)
+{
+	u32 id;
+	int ret;
+	u32 paddr = 0;
+
+	if (!of_property_read_u32(pdev->dev.of_node, "sys_reset", &id)) {
+		psci_function_id_restart = id;
+		arm_pm_restart = do_aml_restart;
+	}
+
+	if (!of_property_read_u32(pdev->dev.of_node, "sys_poweroff", &id)) {
+		psci_function_id_poweroff = id;
+		pm_power_off = do_aml_poweroff;
+	}
+
+	ret = of_property_read_u32(pdev->dev.of_node,
+				   "reboot_reason_addr", &paddr);
+	if (!ret) {
+		pr_debug("reboot_reason paddr: 0x%x\n", paddr);
+		reboot_reason_vaddr = ioremap(paddr, 0x4);
+		device_create_file(&pdev->dev, &dev_attr_reboot_reason);
+	}
+
+	ret = register_die_notifier(&panic_notifier);
+	if (ret != 0) {
+		pr_err("%s,register die notifier failed,ret =%d!\n",
+			__func__, ret);
+		return ret;
+	}
+
+	/* Register a call for panic conditions. */
+	ret = atomic_notifier_chain_register(&panic_notifier_list,
+			&panic_notifier);
+	if (ret != 0) {
+		pr_err("%s,register panic notifier failed,ret =%d!\n",
+			__func__, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static const struct of_device_id of_aml_restart_match[] = {
+	{ .compatible = "aml, reboot", },
+	{ .compatible = "amlogic, reboot", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_aml_restart_match);
+
+static struct platform_driver aml_restart_driver = {
+	.probe = aml_restart_probe,
+	.driver = {
+		.name = "aml-restart",
+		.of_match_table = of_match_ptr(of_aml_restart_match),
+	},
+};
+
+static int __init aml_restart_init(void)
+{
+	return platform_driver_register(&aml_restart_driver);
+}
+device_initcall(aml_restart_init);
diff -Naur a/vendor/amlogic/secmon/Kconfig b/vendor/amlogic/secmon/Kconfig
--- a/vendor/amlogic/secmon/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/secmon/Kconfig	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,10 @@
+# Amlogic secure monitor driver
+
+config AMLOGIC_SEC
+	bool "Amlogic secure monitor driver support"
+	default n
+	help
+		This is the Amlogic secure monitor driver
+		this config only ctrl in makefile
+		prepare share memory
+		etc
diff -Naur a/vendor/amlogic/secmon/Makefile b/vendor/amlogic/secmon/Makefile
--- a/vendor/amlogic/secmon/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/secmon/Makefile	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1 @@
+obj-$(CONFIG_AMLOGIC_SEC)	+= secmon.o
diff -Naur a/vendor/amlogic/secmon/secmon.c b/vendor/amlogic/secmon/secmon.c
--- a/vendor/amlogic/secmon/secmon.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/secmon/secmon.c	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,238 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/of_fdt.h>
+#include <linux/libfdt_env.h>
+#include <linux/of_reserved_mem.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/dma-map-ops.h>
+#include <linux/cma.h>
+#include <linux/arm-smccc.h>
+#undef pr_fmt
+#define pr_fmt(fmt) "secmon: " fmt
+
+static void __iomem *sharemem_in_base;
+static void __iomem *sharemem_out_base;
+static long phy_in_base;
+static long phy_out_base;
+static unsigned long secmon_start_virt;
+static unsigned int secmon_size;
+
+#ifdef CONFIG_ARM64
+#define IN_SIZE	0x6000
+#else
+ #define IN_SIZE	0x6000
+#endif
+ #define OUT_SIZE 0x1000
+static DEFINE_MUTEX(sharemem_mutex);
+#define DEV_REGISTERED 1
+#define DEV_UNREGISTED 0
+
+unsigned int sharemem_in_size = IN_SIZE;
+unsigned int sharemem_out_size = OUT_SIZE;
+
+static int secmon_dev_registered = DEV_UNREGISTED;
+static long get_sharemem_info(unsigned int function_id)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(function_id, 0, 0, 0, 0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static void get_sharemem_size(unsigned int function_id)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc(function_id, 1, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0 != -1)
+		sharemem_in_size =  res.a0;
+
+	arm_smccc_smc(function_id, 2, 0, 0, 0, 0, 0, 0, &res);
+	if (res.a0 != -1)
+		sharemem_out_size =  res.a0;
+}
+
+#define RESERVE_MEM_SIZE	0x300000
+
+int within_secmon_region(unsigned long addr)
+{
+	if (!secmon_start_virt)
+		return 0;
+
+	if (addr >= secmon_start_virt &&
+	    addr <= (secmon_start_virt + secmon_size))
+		return 1;
+
+	return 0;
+}
+
+static int secmon_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	unsigned int id;
+	int ret;
+	struct page *page;
+
+	if (!of_property_read_u32(np, "in_base_func", &id))
+		phy_in_base = get_sharemem_info(id);
+
+	if (!of_property_read_u32(np, "out_base_func", &id))
+		phy_out_base = get_sharemem_info(id);
+
+	if (!of_property_read_u32(np, "inout_size_func", &id))
+		get_sharemem_size(id);
+
+	if (of_property_read_u32(np, "reserve_mem_size", &secmon_size)) {
+		pr_err("can't get reserve_mem_size, use default value\n");
+		secmon_size = RESERVE_MEM_SIZE;
+	} else {
+		pr_info("reserve_mem_size:0x%x\n", secmon_size);
+	}
+
+	ret = of_reserved_mem_device_init(&pdev->dev);
+	if (ret) {
+		pr_info("reserve memory init fail:%d\n", ret);
+		return ret;
+	}
+
+	page = dma_alloc_from_contiguous(&pdev->dev, secmon_size >> PAGE_SHIFT, 0, 0);
+	if (!page) {
+		pr_err("alloc page failed, ret:%p\n", page);
+		return -ENOMEM;
+	}
+
+	secmon_start_virt = (unsigned long)page_to_virt(page);
+
+	if (pfn_valid(__phys_to_pfn(phy_in_base)))
+		sharemem_in_base = (void __iomem *)__phys_to_virt(phy_in_base);
+	else
+		sharemem_in_base = ioremap_cache(phy_in_base, sharemem_in_size);
+
+	if (!sharemem_in_base) {
+		pr_info("secmon share mem in buffer remap fail!\n");
+		return -ENOMEM;
+	}
+
+	if (pfn_valid(__phys_to_pfn(phy_out_base)))
+		sharemem_out_base = (void __iomem *)
+				__phys_to_virt(phy_out_base);
+	else
+		sharemem_out_base = ioremap_cache(phy_out_base,
+				sharemem_out_size);
+
+	if (!sharemem_out_base) {
+		pr_info("secmon share mem out buffer remap fail!\n");
+		return -ENOMEM;
+	}
+	secmon_dev_registered = DEV_REGISTERED;
+	pr_info("share in base: 0x%lx, share out base: 0x%lx\n",
+		(long)sharemem_in_base, (long)sharemem_out_base);
+	pr_info("phy_in_base: 0x%lx, phy_out_base: 0x%lx\n",
+		phy_in_base, phy_out_base);
+
+	return ret;
+}
+
+void __init secmon_clear_cma_mmu(void)
+{
+	struct device_node *np;
+	unsigned int clear[2] = {};
+
+	np = of_find_node_by_name(NULL, "secmon");
+	if (!np)
+		return;
+
+	if (of_property_read_u32_array(np, "clear_range", clear, 2))
+		pr_info("can't fine clear_range\n");
+	else
+		pr_info("clear_range:%x %x\n", clear[0], clear[1]);
+
+#ifdef CONFIG_AMLOGIC_CMA
+	if (clear[0]) {
+		struct page *page = phys_to_page(clear[0]);
+		int cnt = clear[1] / PAGE_SIZE;
+
+		cma_mmu_op(page, cnt, 0);
+	}
+#endif
+}
+
+static const struct of_device_id secmon_dt_match[] = {
+	{ .compatible = "amlogic, secmon" },
+	{ /* sentinel */ },
+};
+
+static  struct platform_driver secmon_platform_driver = {
+	.probe		= secmon_probe,
+	.driver		= {
+		.owner		= THIS_MODULE,
+		.name		= "secmon",
+		.of_match_table	= secmon_dt_match,
+	},
+};
+
+int __init meson_secmon_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&secmon_platform_driver);
+	WARN((secmon_dev_registered != DEV_REGISTERED),
+			"ERROR: secmon device must be enable!!!\n");
+	return ret;
+}
+subsys_initcall(meson_secmon_init);
+
+void meson_sm_mutex_lock(void)
+{
+	mutex_lock(&sharemem_mutex);
+}
+EXPORT_SYMBOL(meson_sm_mutex_lock);
+
+void meson_sm_mutex_unlock(void)
+{
+	mutex_unlock(&sharemem_mutex);
+}
+EXPORT_SYMBOL(meson_sm_mutex_unlock);
+
+void __iomem *get_meson_sm_input_base(void)
+{
+	return sharemem_in_base;
+}
+EXPORT_SYMBOL(get_meson_sm_input_base);
+void __iomem *get_meson_sm_output_base(void)
+{
+	return sharemem_out_base;
+}
+EXPORT_SYMBOL(get_meson_sm_output_base);
+
+long get_secmon_phy_input_base(void)
+{
+	return phy_in_base;
+}
+EXPORT_SYMBOL(get_secmon_phy_input_base);
+
+long get_secmon_phy_output_base(void)
+{
+	return phy_out_base;
+}
+
+unsigned int get_secmon_sharemem_in_size(void)
+{
+	return sharemem_in_size;
+}
+EXPORT_SYMBOL(get_secmon_sharemem_in_size);
+unsigned int get_secmon_sharemem_out_size(void)
+{
+	return sharemem_out_size;
+}
+EXPORT_SYMBOL(get_secmon_sharemem_out_size);
+
diff -Naur a/vendor/amlogic/unifykey/amlkey_if.h b/vendor/amlogic/unifykey/amlkey_if.h
--- a/vendor/amlogic/unifykey/amlkey_if.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/amlkey_if.h	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __AMLKEY_IF_H__
+#define __AMLKEY_IF_H__
+
+struct amlkey_if {
+	s32 (*init)(u8 *seed, u32 len, int encrypt_type);
+	u32 (*exsit)(const u8 *name);
+	unsigned int (*size)(const u8 *name);
+	u32 (*get_attr)(const u8 *name);
+	unsigned int (*read)(const u8 *name, u8 *buffer, u32 len);
+	ssize_t (*write)(const u8 *name, u8 *buffer, u32 len, u32 attr);
+	s32 (*hash)(const u8 *name, u8 *hash);
+};
+
+extern struct amlkey_if *amlkey_if;
+
+static inline s32 amlkey_init(u8 *seed, u32 len, int encrypt_type)
+{
+	return amlkey_if->init(seed, len, encrypt_type);
+}
+
+static inline u32 amlkey_exsit(const u8 *name)
+{
+	return amlkey_if->exsit(name);
+}
+
+static inline unsigned int amlkey_size(const u8 *name)
+{
+	return amlkey_if->size(name);
+}
+
+static inline u32 amlkey_get_attr(const u8 *name)
+{
+	return amlkey_if->get_attr(name);
+}
+
+static inline unsigned int amlkey_read(const u8 *name, u8 *buffer, u32 len)
+{
+	return amlkey_if->read(name, buffer, len);
+}
+
+static inline ssize_t amlkey_write(const u8 *name, u8 *buffer, u32 len,
+				   u32 attr)
+{
+	return amlkey_if->write(name, buffer, len, attr);
+}
+
+static inline s32 amlkey_hash(const u8 *name, u8 *hash)
+{
+	return amlkey_if->hash(name, hash);
+}
+
+int amlkey_if_init(struct platform_device *pdev);
+void amlkey_if_deinit(void);
+#endif
+
diff -Naur a/vendor/amlogic/unifykey/efuse_api.c b/vendor/amlogic/unifykey/efuse_api.c
--- a/vendor/amlogic/unifykey/efuse_api.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/efuse_api.c	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,337 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/arm-smccc.h>
+#include <linux/highmem.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/amlogic/efuse.h>
+#include <linux/kallsyms.h>
+#include "efuse.h"
+
+static DEFINE_MUTEX(efuse_lock);
+
+static unsigned long get_sharemem_info(unsigned long function_id)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc((unsigned long)function_id, 0, 0, 0, 0, 0, 0, 0, &res);
+
+	return res.a0;
+}
+
+static ssize_t meson_efuse_fn_smc(struct efuse_hal_api_arg *arg)
+{
+	long ret;
+	unsigned int cmd, offset, size;
+	unsigned long *retcnt = (unsigned long *)(arg->retcnt);
+	struct arm_smccc_res res;
+	void *sharemem_in_base = NULL;
+	void *sharemem_out_base;
+	long phy_in_base = 0;
+	long phy_out_base = 0;
+
+	if (arg->cmd == EFUSE_HAL_API_READ)
+		cmd = efuse_cmd.read_cmd;
+	else if (arg->cmd == EFUSE_HAL_API_WRITE)
+		cmd = efuse_cmd.write_cmd;
+	else
+		return -1;
+
+	offset = arg->offset;
+	size = arg->size;
+
+	mutex_lock(&efuse_lock);
+
+	if (arg->cmd == EFUSE_HAL_API_WRITE) {
+		phy_in_base = get_sharemem_info(efuse_cmd.mem_in_base_cmd);
+
+		if (!pfn_valid(__phys_to_pfn(phy_in_base)))
+			sharemem_in_base = ioremap_nocache(phy_in_base, size);
+		else
+			sharemem_in_base = phys_to_virt(phy_in_base);
+
+		memcpy((void *)sharemem_in_base,
+		       (const void *)arg->buffer, size);
+	}
+
+	asm __volatile__("" : : : "memory");
+
+	arm_smccc_smc(cmd, offset, size, 0, 0, 0, 0, 0, &res);
+	ret = res.a0;
+	*retcnt = res.a0;
+
+	if (arg->cmd == EFUSE_HAL_API_WRITE) {
+		if (!pfn_valid(__phys_to_pfn(phy_in_base)))
+			iounmap(sharemem_in_base);
+	} else if ((arg->cmd == EFUSE_HAL_API_READ) && (ret != 0)) {
+		phy_out_base = get_sharemem_info(efuse_cmd.mem_out_base_cmd);
+
+		if (!pfn_valid(__phys_to_pfn(phy_out_base)))
+			sharemem_out_base = ioremap_nocache(phy_out_base, ret);
+		else
+			sharemem_out_base = phys_to_virt(phy_out_base);
+
+		memcpy((void *)arg->buffer,
+		       (const void *)sharemem_out_base, ret);
+
+		if (!pfn_valid(__phys_to_pfn(phy_out_base)))
+			iounmap(sharemem_out_base);
+	}
+
+	mutex_unlock(&efuse_lock);
+
+	if (!ret)
+		return -1;
+
+	return 0;
+}
+
+static ssize_t meson_trustzone_efuse(struct efuse_hal_api_arg *arg)
+{
+	ssize_t ret;
+	struct cpumask task_cpumask;
+
+	if (!arg)
+		return -1;
+
+	cpumask_copy(&task_cpumask, current->cpus_ptr);
+	set_cpus_allowed_ptr(current, cpumask_of(0));
+
+	ret = meson_efuse_fn_smc(arg);
+	set_cpus_allowed_ptr(current, &task_cpumask);
+
+	return ret;
+}
+
+static unsigned long efuse_data_process(unsigned long type,
+					unsigned long buffer,
+					unsigned long length,
+					unsigned long option)
+{
+	struct arm_smccc_res res;
+	void *sharemem_in_base;
+	long phy_in_base;
+	struct page *page;
+
+	mutex_lock(&efuse_lock);
+
+	phy_in_base = get_sharemem_info(efuse_cmd.mem_in_base_cmd);
+	page = pfn_to_page(phy_in_base >> PAGE_SHIFT);
+
+	if (!pfn_valid(__phys_to_pfn(phy_in_base)))
+		sharemem_in_base = ioremap_nocache(phy_in_base, length);
+	else
+		sharemem_in_base = phys_to_virt(phy_in_base);
+
+	memcpy((void *)sharemem_in_base,
+	       (const void *)buffer, length);
+
+	asm __volatile__("" : : : "memory");
+
+	do {
+		arm_smccc_smc((unsigned long)AML_DATA_PROCESS,
+			      (unsigned long)type,
+			      (unsigned long)phy_in_base,
+			      (unsigned long)length,
+			      (unsigned long)option,
+			      0, 0, 0, &res);
+	} while (0);
+
+	if (!pfn_valid(__phys_to_pfn(phy_in_base)))
+		iounmap(sharemem_in_base);
+
+	mutex_unlock(&efuse_lock);
+
+	return res.a0;
+}
+
+int efuse_amlogic_cali_item_read(unsigned int item)
+{
+	struct arm_smccc_res res;
+
+	/* range check */
+	if (item < EFUSE_CALI_SUBITEM_WHOBURN ||
+		item > EFUSE_CALI_SUBITEM_BC)
+		return -EINVAL;
+
+	mutex_lock(&efuse_lock);
+
+	do {
+		arm_smccc_smc((unsigned long)EFUSE_READ_CALI_ITEM,
+			(unsigned long)item,
+			0, 0, 0, 0, 0, 0, &res);
+	} while (0);
+
+	mutex_unlock(&efuse_lock);
+	return res.a0;
+}
+EXPORT_SYMBOL_GPL(efuse_amlogic_cali_item_read);
+
+/*
+ *retrun: 1: wrote, 0: not write, -1: fail or not support
+ */
+int efuse_amlogic_check_lockable_item(unsigned int item)
+{
+	struct arm_smccc_res res;
+
+	/* range check */
+	if (item < EFUSE_LOCK_SUBITEM_BASE ||
+		item > EFUSE_LOCK_SUBITEM_MAX)
+		return -EINVAL;
+
+	mutex_lock(&efuse_lock);
+
+	do {
+		arm_smccc_smc((unsigned long)EFUSE_READ_CALI_ITEM,
+			(unsigned long)item,
+			0, 0, 0, 0, 0, 0, &res);
+	} while (0);
+
+	mutex_unlock(&efuse_lock);
+	return res.a0;
+}
+EXPORT_SYMBOL_GPL(efuse_amlogic_check_lockable_item);
+
+unsigned long efuse_amlogic_set(char *buf, size_t count)
+{
+	unsigned long ret;
+	struct cpumask task_cpumask;
+
+	cpumask_copy(&task_cpumask, current->cpus_ptr);
+	set_cpus_allowed_ptr(current, cpumask_of(0));
+
+	ret = efuse_data_process(AML_D_P_W_EFUSE_AMLOGIC,
+				 (unsigned long)buf, (unsigned long)count, 0);
+	set_cpus_allowed_ptr(current, &task_cpumask);
+
+	return ret;
+}
+
+static ssize_t meson_trustzone_efuse_get_max(struct efuse_hal_api_arg *arg)
+{
+	ssize_t ret;
+	unsigned int cmd;
+	struct arm_smccc_res res;
+
+	if (arg->cmd != EFUSE_HAL_API_USER_MAX)
+		return -1;
+
+	cmd = efuse_cmd.get_max_cmd;
+
+	asm __volatile__("" : : : "memory");
+	arm_smccc_smc(cmd, 0, 0, 0, 0, 0, 0, 0, &res);
+	ret = res.a0;
+
+	if (!ret)
+		return -1;
+
+	return ret;
+}
+
+ssize_t efuse_get_max(void)
+{
+	struct efuse_hal_api_arg arg;
+	ssize_t ret;
+	struct cpumask task_cpumask;
+
+	arg.cmd = EFUSE_HAL_API_USER_MAX;
+
+	cpumask_copy(&task_cpumask, current->cpus_ptr);
+	set_cpus_allowed_ptr(current, cpumask_of(0));
+
+	ret = meson_trustzone_efuse_get_max(&arg);
+	set_cpus_allowed_ptr(current, &task_cpumask);
+
+	return ret;
+}
+
+static ssize_t _efuse_read(char *buf, size_t count, loff_t *ppos)
+{
+	unsigned int pos = *ppos;
+
+	struct efuse_hal_api_arg arg;
+	unsigned int retcnt;
+	ssize_t ret;
+
+	arg.cmd = EFUSE_HAL_API_READ;
+	arg.offset = pos;
+	arg.size = count;
+	arg.buffer = (unsigned long)buf;
+	arg.retcnt = (unsigned long)&retcnt;
+	ret = meson_trustzone_efuse(&arg);
+	if (ret == 0) {
+		*ppos += retcnt;
+		return retcnt;
+	}
+
+	return ret;
+}
+
+static ssize_t _efuse_write(const char *buf, size_t count, loff_t *ppos)
+{
+	unsigned int pos = *ppos;
+
+	struct efuse_hal_api_arg arg;
+	unsigned int retcnt;
+	ssize_t ret;
+
+	arg.cmd = EFUSE_HAL_API_WRITE;
+	arg.offset = pos;
+	arg.size = count;
+	arg.buffer = (unsigned long)buf;
+	arg.retcnt = (unsigned long)&retcnt;
+
+	ret = meson_trustzone_efuse(&arg);
+	if (ret == 0) {
+		*ppos = retcnt;
+		return retcnt;
+	}
+
+	return ret;
+}
+
+ssize_t efuse_read_usr(char *buf, size_t count, loff_t *ppos)
+{
+	char *pdata = NULL;
+	ssize_t ret;
+	loff_t pos;
+
+	pdata = kmalloc(count, GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	pos = *ppos;
+
+	ret = _efuse_read(pdata, count, (loff_t *)&pos);
+
+	memcpy(buf, pdata, count);
+	kfree(pdata);
+
+	return ret;
+}
+
+ssize_t efuse_write_usr(char *buf, size_t count, loff_t *ppos)
+{
+	char *pdata = NULL;
+	ssize_t ret;
+	loff_t pos;
+
+	pdata = kmalloc(count, GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	memcpy(pdata, buf, count);
+	pos = *ppos;
+
+	ret = _efuse_write(pdata, count, (loff_t *)&pos);
+	kfree(pdata);
+
+	return ret;
+}
diff -Naur a/vendor/amlogic/unifykey/efuse_burn.c b/vendor/amlogic/unifykey/efuse_burn.c
--- a/vendor/amlogic/unifykey/efuse_burn.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/efuse_burn.c	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,303 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include "efuse.h"
+#include <linux/amlogic/efuse.h>
+#include <linux/io.h>
+#include "efuse_burn.h"
+
+#define EFUSE_BURN_DEVICE_NAME   "efuse_burn"
+#define EFUSE_BURN_CLASS_NAME    "efuse_burn"
+
+static struct aml_efuse_burn_dev *pefuse_burn_dev;
+
+static int efuse_burn_open(struct inode *inode, struct file *file)
+{
+	struct aml_efuse_burn_dev *devp;
+
+	devp = container_of(inode->i_cdev, struct aml_efuse_burn_dev, cdev);
+	file->private_data = devp;
+
+	//printk(KERN_NOTICE "%s:%d\n", __func__, __LINE__);
+	pr_notice("%s:%d\n", __func__, __LINE__);
+
+	return 0;
+}
+
+static int efuse_burn_release(struct inode *inode, struct file *file)
+{
+	file->private_data = NULL;
+	return 0;
+}
+
+static loff_t efuse_burn_llseek(struct file *filp, loff_t off, int whence)
+{
+	return 0;
+}
+
+static long efuse_burn_unlocked_ioctl(struct file *file,
+				 unsigned int cmd, unsigned long arg)
+{
+	long ret = -ENOTTY;
+	void __user *argp = (void __user *)arg;
+	struct efuse_burn_info info;
+
+	pr_notice("%s:%d\n", __func__, __LINE__);
+	switch (cmd) {
+	case EFUSE_BURN_CHECK_KEY:
+		if (copy_from_user((void *)&info, argp, sizeof(info))) {
+			pr_err("%s: copy_from_user fail\n", __func__);
+			return -EFAULT;
+		}
+		if (efuse_burn_lockable_is_cfg(info.itemname) == 0) {
+			info.status = efuse_burn_check_burned(info.itemname);
+		} else {
+			pr_err("%s: efuse_burn check item not cfg\n", __func__);
+			return -EFAULT;
+		}
+		if (copy_to_user(argp, &info, sizeof(info))) {
+			pr_err("%s: copy_to_user fail\n", __func__);
+			return -EFAULT;
+		}
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+static long efuse_burn_compat_ioctl(struct file *filp,
+			       unsigned int cmd, unsigned long args)
+{
+	long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = efuse_burn_unlocked_ioctl(filp, cmd, args);
+
+	return ret;
+}
+#endif
+
+static ssize_t efuse_burn_read(struct file *file, char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	pr_notice("%s:%d\n", __func__, __LINE__);
+	return 0;
+}
+
+static ssize_t efuse_burn_write(struct file *file,
+			   const char __user *buf, size_t count, loff_t *ppos)
+{
+	struct aml_efuse_burn_dev *devp;
+	ssize_t ret;
+	char *op = NULL;
+
+	devp = file->private_data;
+	//pr_notice("%s:%d, sizeof(loff_t):%d\n",
+	//	__func__, __LINE__, sizeof(loff_t));
+	//pr_notice("pos=%lld,count=%d\n", *ppos, count);
+	if (count != devp->efuse_pattern_size) {
+		ret = -EINVAL;
+		pr_err("efuse burn: bad pattern size, only support size %d!\n",
+		       devp->efuse_pattern_size);
+		goto exit;
+	}
+	op = kzalloc(sizeof(char) * count, GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse burn: failed to allocate memory!\n");
+		goto exit;
+	}
+
+	memset(op, 0, count);
+	if (copy_from_user(op, buf, count)) {
+		pr_err("%s: copy_from_user fail\n", __func__);
+		kfree(op);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	ret = efuse_amlogic_set(op, count);
+	kfree(op);
+
+	if (ret) {
+		pr_err("efuse burn: pattern programming fail! ret: %d\n",
+		       (unsigned int)ret);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	pr_info("efuse burn: pattern programming success!\n");
+
+	ret = count;
+
+exit:
+	return ret;
+}
+
+static const struct file_operations efuse_burn_fops = {
+	.owner      = THIS_MODULE,
+	.llseek     = efuse_burn_llseek,
+	.open       = efuse_burn_open,
+	.release    = efuse_burn_release,
+	.read       = efuse_burn_read,
+	.write      = efuse_burn_write,
+	.unlocked_ioctl      = efuse_burn_unlocked_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = efuse_burn_compat_ioctl,
+#endif
+};
+
+static ssize_t version_show(struct class *cla,
+			     struct class_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+
+	n = sprintf(buf, "ver1.0");
+	return n;
+}
+
+static ssize_t version_store(struct class *cla,
+			      struct class_attribute *attr,
+			      const char *buf, size_t count)
+{
+	pr_notice("%s:%d,buf=0x%lx,count=%lu\n",
+		__func__, __LINE__, (long)buf, count);
+	return count;
+}
+
+static EFUSE_CLASS_ATTR(version);
+
+static struct attribute *efuse_burn_class_attrs[] = {
+	&class_attr_version.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(efuse_burn_class);
+
+static int efuse_burn_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device *devp;
+	struct aml_efuse_burn_dev *efuse_burn_dev;
+	struct device_node *np = pdev->dev.of_node;
+
+	efuse_burn_dev = devm_kzalloc(&pdev->dev, sizeof(*efuse_burn_dev),
+						GFP_KERNEL);
+	if (!efuse_burn_dev) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "failed to alloc enough mem for efuse_dev\n");
+		goto out;
+	}
+
+	efuse_burn_dev->pdev = pdev;
+	platform_set_drvdata(pdev, efuse_burn_dev);
+
+	of_node_get(np);
+
+	ret = of_property_read_u32(np, "efuse_pattern_size",
+				   &efuse_burn_dev->efuse_pattern_size);
+	if (ret) {
+		pr_err("can't get efuse_pattern_size, please configurate size\n");
+		goto error1;
+	}
+
+	ret = alloc_chrdev_region(&efuse_burn_dev->devno, 0, 1,
+			EFUSE_BURN_DEVICE_NAME);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "fail to allocate major number\n ");
+		goto error1;
+	}
+
+	efuse_burn_dev->cls.name = EFUSE_BURN_CLASS_NAME;
+	efuse_burn_dev->cls.owner = THIS_MODULE;
+	efuse_burn_dev->cls.class_groups = efuse_burn_class_groups;
+	ret = class_register(&efuse_burn_dev->cls);
+	if (ret)
+		goto error2;
+
+	cdev_init(&efuse_burn_dev->cdev, &efuse_burn_fops);
+	efuse_burn_dev->cdev.owner = THIS_MODULE;
+
+	ret = cdev_add(&efuse_burn_dev->cdev, efuse_burn_dev->devno, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add device\n");
+		goto error3;
+	}
+
+	devp = device_create(&efuse_burn_dev->cls, NULL,
+			 efuse_burn_dev->devno, efuse_burn_dev, "efuse_burn");
+	if (IS_ERR(devp)) {
+		dev_err(&pdev->dev, "failed to create device node\n");
+		ret = PTR_ERR(devp);
+		goto error4;
+	}
+	pefuse_burn_dev = efuse_burn_dev;
+
+	dev_info(&pdev->dev, "device %s created OK\n", EFUSE_BURN_DEVICE_NAME);
+
+	return 0;
+
+error4:
+	cdev_del(&efuse_burn_dev->cdev);
+error3:
+	class_unregister(&efuse_burn_dev->cls);
+error2:
+	unregister_chrdev_region(efuse_burn_dev->devno, 1);
+error1:
+	devm_kfree(&pdev->dev, efuse_burn_dev);
+out:
+	return ret;
+}
+
+static int efuse_burn_remove(struct platform_device *pdev)
+{
+	struct aml_efuse_burn_dev *efuse_burn_dev;
+
+	efuse_burn_dev = platform_get_drvdata(pdev);
+	unregister_chrdev_region(efuse_burn_dev->devno, 1);
+	device_destroy(&efuse_burn_dev->cls, efuse_burn_dev->devno);
+	cdev_del(&efuse_burn_dev->cdev);
+	class_unregister(&efuse_burn_dev->cls);
+	platform_set_drvdata(pdev, NULL);
+	devm_kfree(&pdev->dev, efuse_burn_dev);
+	return 0;
+}
+
+static const struct of_device_id efuse_burn_dt_match[] = {
+	{	.compatible = "amlogic, efuseburn",
+	},
+	{},
+};
+
+static struct platform_driver efuse_burn_driver = {
+	.probe = efuse_burn_probe,
+	.remove = efuse_burn_remove,
+	.driver = {
+		.name = EFUSE_BURN_DEVICE_NAME,
+		.of_match_table = efuse_burn_dt_match,
+	.owner = THIS_MODULE,
+	},
+};
+
+int __init aml_efuse_burn_init(void)
+{
+	return platform_driver_register(&efuse_burn_driver);
+}
+
+void aml_efuse_burn_exit(void)
+{
+	platform_driver_unregister(&efuse_burn_driver);
+}
+
diff -Naur a/vendor/amlogic/unifykey/efuse_burn.h b/vendor/amlogic/unifykey/efuse_burn.h
--- a/vendor/amlogic/unifykey/efuse_burn.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/efuse_burn.h	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __EFUSE_BURN_H
+#define __EFUSE_BURN_H
+
+#define EFUSE_BURN_BURN_KEY		    _IO('f', 0x60)
+#define EFUSE_BURN_CHECK_KEY		_IO('f', 0x62)
+
+#define IOCTL_TYPE_UNKNOWN       0
+#define IOCTL_TYPE_BURN          1
+#define IOCTL_TYPE_CHECK         2
+
+struct efuse_burn_info {
+	char itemname[32];
+	int  status;  //1:wrote, 0:not write, -1:fail.
+};
+
+struct aml_efuse_burn_dev {
+	struct platform_device *pdev;
+	struct class           cls;
+	struct cdev            cdev;
+	dev_t                  devno;
+	int efuse_pattern_size;
+};
+
+#ifdef CONFIG_AMLOGIC_EFUSE_BURN
+int __init aml_efuse_burn_init(void);
+void aml_efuse_burn_exit(void);
+#else
+int __init aml_efuse_burn_init(void)
+{
+	return 0;
+}
+
+void aml_efuse_burn_exit(void)
+{
+}
+#endif
+#endif
diff -Naur a/vendor/amlogic/unifykey/efuse.c b/vendor/amlogic/unifykey/efuse.c
--- a/vendor/amlogic/unifykey/efuse.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/efuse.c	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,1182 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include "efuse.h"
+#include <linux/amlogic/efuse.h>
+#include <linux/io.h>
+
+#define EFUSE_DEVICE_NAME   "efuse"
+#define EFUSE_CLASS_NAME    "efuse"
+
+static struct aml_efuse_key efuse_key = {
+	.num      = 0,
+	.infos    = NULL,
+};
+
+static struct aml_efuse_lockable_check efusecheck = {
+	.main_cmd = 0,
+	.item_num = 0,
+	.infos = NULL,
+};
+
+struct aml_efuse_cmd efuse_cmd;
+unsigned int efuse_pattern_size;
+
+#define  DEFINE_EFUEKEY_SHOW_ATTR(keyname)	\
+	static ssize_t  keyname##_show(struct class *cla, \
+					  struct class_attribute *attr,	\
+						char *buf)	\
+	{	\
+		ssize_t ret;	\
+		\
+		ret = efuse_user_attr_show(#keyname, buf); \
+		return ret; \
+	}
+DEFINE_EFUEKEY_SHOW_ATTR(mac)
+DEFINE_EFUEKEY_SHOW_ATTR(mac_bt)
+DEFINE_EFUEKEY_SHOW_ATTR(mac_wifi)
+DEFINE_EFUEKEY_SHOW_ATTR(usid)
+
+#ifndef EFUSE_READ_ONLY
+#define  DEFINE_EFUEKEY_STORE_ATTR(keyname)	\
+	static ssize_t  keyname##_store(struct class *cla, \
+					  struct class_attribute *attr,	\
+						const char *buf,	\
+						size_t count)	\
+	{	\
+		ssize_t ret;	\
+		\
+		ret = efuse_user_attr_store(#keyname, buf, count); \
+		return ret; \
+	}
+DEFINE_EFUEKEY_STORE_ATTR(mac)
+DEFINE_EFUEKEY_STORE_ATTR(mac_bt)
+DEFINE_EFUEKEY_STORE_ATTR(mac_wifi)
+DEFINE_EFUEKEY_STORE_ATTR(usid)
+#endif
+
+int efuse_getinfo(char *item, struct efusekey_info *info)
+{
+	int i;
+	int ret = -EINVAL;
+
+	for (i = 0; i < efuse_key.num; i++) {
+		if (strcmp(efuse_key.infos[i].keyname, item) == 0) {
+			strcpy(info->keyname, efuse_key.infos[i].keyname);
+			info->offset = efuse_key.infos[i].offset;
+			info->size = efuse_key.infos[i].size;
+			ret = 0;
+			break;
+		}
+	}
+	if (ret < 0)
+		pr_err("%s item not found.\n", item);
+	return ret;
+}
+
+/*return: 0:is configurated, -1: don't cfg*/
+int efuse_burn_lockable_is_cfg(char *itemname)
+{
+	int ret = -1;
+	int i;
+
+	for (i = 0; i < efusecheck.item_num; i++) {
+		if (strcmp(itemname, efusecheck.infos[i].itemname) == 0) {
+			ret = 0;
+			break;
+		}
+	}
+	return ret;
+}
+
+/*
+ * retrun: 1:burned(wrote), 0: not write, -1: fail
+ */
+int efuse_burn_check_burned(char *itemname)
+{
+	int i;
+	int ret = -1;
+	int subcmd;
+
+	for (i = 0; i < efusecheck.item_num; i++) {
+		if (strcmp(itemname, efusecheck.infos[i].itemname) == 0) {
+			subcmd = efusecheck.infos[i].subcmd;
+			ret = efuse_amlogic_check_lockable_item(subcmd);
+			break;
+		}
+	}
+	return ret;
+}
+
+static int efuse_open(struct inode *inode, struct file *file)
+{
+	struct aml_efuse_dev *devp;
+
+	devp = container_of(inode->i_cdev, struct aml_efuse_dev, cdev);
+	file->private_data = devp;
+
+	return 0;
+}
+
+static int efuse_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static loff_t efuse_llseek(struct file *filp, loff_t off, int whence)
+{
+	loff_t newpos;
+	ssize_t max_size;
+
+	max_size = efuse_get_max();
+	if (max_size <= 0)
+		return -EINVAL;
+
+	switch (whence) {
+	case 0: /* SEEK_SET */
+		newpos = off;
+		break;
+
+	case 1: /* SEEK_CUR */
+		newpos = filp->f_pos + off;
+		break;
+
+	case 2: /* SEEK_END */
+		newpos = max_size + off;
+		break;
+
+	default: /* can't happen */
+		return -EINVAL;
+	}
+
+	if (newpos < 0 || newpos >= max_size)
+		return -EINVAL;
+
+	filp->f_pos = newpos;
+	return newpos;
+}
+
+static long efuse_unlocked_ioctl(struct file *file,
+				 unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct efusekey_info info;
+
+	switch (cmd) {
+	case EFUSE_INFO_GET:
+		if (copy_from_user((void *)&info, argp, sizeof(info))) {
+			pr_err("%s: copy_from_user fail\n", __func__);
+			return -EFAULT;
+		}
+
+		if (efuse_getinfo(info.keyname, &info) < 0) {
+			pr_err("efuse: %s is not found\n", info.keyname);
+			return -EFAULT;
+		}
+
+		if (copy_to_user(argp, &info, sizeof(info))) {
+			pr_err("%s: copy_to_user fail\n", __func__);
+			return -EFAULT;
+		}
+		break;
+
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long efuse_compat_ioctl(struct file *filp,
+			       unsigned int cmd, unsigned long args)
+{
+	long ret;
+
+	args = (unsigned long)compat_ptr(args);
+	ret = efuse_unlocked_ioctl(filp, cmd, args);
+
+	return ret;
+}
+#endif
+
+static ssize_t efuse_read(struct file *file, char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	ssize_t ret;
+	unsigned int  pos = (unsigned int)*ppos;
+	unsigned char *op = NULL;
+	unsigned int max_size;
+
+	ret = efuse_get_max();
+	if (ret < 0) {
+		pr_err("efuse: failed to get userdata max size\n");
+		goto exit;
+	}
+	max_size = (unsigned int)ret;
+
+	if (pos >= max_size || count > max_size || count > max_size - pos) {
+		ret = -EINVAL;
+		pr_err("efuse: data range over userdata range\n");
+		goto exit;
+	}
+	op = kzalloc((sizeof(char) * count), GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse: failed to allocate memory\n");
+		goto exit;
+	}
+
+	memset(op, 0, count);
+
+	ret = efuse_read_usr(op, count, ppos);
+	if (ret < 0) {
+		kfree(op);
+		pr_err("efuse: read user data fail!\n");
+		goto exit;
+	}
+
+	ret = copy_to_user((void *)buf, (void *)op, count);
+	kfree(op);
+
+	if (ret) {
+		ret = -EFAULT;
+		pr_err("%s: copy_to_user fail!!\n", __func__);
+		goto exit;
+	}
+
+	ret = count;
+
+exit:
+	return ret;
+}
+
+static ssize_t efuse_write(struct file *file,
+			   const char __user *buf, size_t count, loff_t *ppos)
+{
+#ifndef EFUSE_READ_ONLY
+	ssize_t ret;
+	unsigned int  pos = (unsigned int)*ppos;
+	unsigned char *op = NULL;
+	unsigned int max_size;
+
+	ret = efuse_get_max();
+	if (ret < 0) {
+		pr_err("efuse: failed to get userdata max size\n");
+		goto exit;
+	}
+	max_size = (unsigned int)ret;
+
+	if (pos >= max_size || count > max_size || count > max_size - pos) {
+		ret = -EINVAL;
+		pr_err("efuse: data range over userdata range\n");
+		goto exit;
+	}
+
+	op = kzalloc((sizeof(char) * count), GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse: failed to allocate memory\n");
+		goto exit;
+	}
+
+	memset(op, 0, count);
+
+	if (copy_from_user((void *)op, (void *)buf, count)) {
+		kfree(op);
+		ret = -EFAULT;
+		pr_err("%s: copy_from_user fail!!\n", __func__);
+		goto exit;
+	}
+
+	ret = efuse_write_usr(op, count, ppos);
+	kfree(op);
+
+	if (ret < 0) {
+		pr_err("efuse: write user area %d bytes data fail\n",
+		       (unsigned int)count);
+		goto exit;
+	}
+
+	pr_info("efuse: write user area %d bytes data OK\n", (unsigned int)ret);
+
+	ret = count;
+
+exit:
+	return ret;
+#else
+	pr_err("no permission to write!!\n");
+	return -EPERM;
+#endif
+}
+
+static const struct file_operations efuse_fops = {
+	.owner      = THIS_MODULE,
+	.llseek     = efuse_llseek,
+	.open       = efuse_open,
+	.release    = efuse_release,
+	.read       = efuse_read,
+	.write      = efuse_write,
+	.unlocked_ioctl      = efuse_unlocked_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = efuse_compat_ioctl,
+#endif
+};
+
+ssize_t efuse_user_attr_store(char *name, const char *buf, size_t count)
+{
+#ifndef EFUSE_READ_ONLY
+	char *op = NULL;
+	ssize_t ret;
+	int i;
+	const char *c, *s;
+	struct efusekey_info info;
+	unsigned int uint_val;
+	loff_t pos;
+
+	if (efuse_getinfo(name, &info) < 0) {
+		ret = -EINVAL;
+		pr_err("efuse: %s is not found\n", name);
+		goto exit;
+	}
+
+	op = kzalloc(sizeof(char) * count, GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse: failed to allocate memory\n");
+		goto exit;
+	}
+
+	memset(op, 0, count);
+	memcpy(op, buf, count);
+
+	c = ":";
+	s = op;
+	if (strstr(s, c)) {
+		for (i = 0; i < info.size; i++) {
+			uint_val = 0;
+			if (i != info.size - 1) {
+				ret = sscanf(s, "%x:", &uint_val);
+				if (ret != 1  || uint_val > 0xff)
+					ret = -EINVAL;
+			} else {
+				ret = kstrtou8(s, 16,
+					       (unsigned char *)&uint_val);
+			}
+
+			if (ret < 0) {
+				kfree(op);
+				pr_err("efuse: get key input data fail\n");
+				goto exit;
+			}
+
+			op[i] = uint_val;
+
+			s += 2;
+			if (!strncmp(s, c, 1))
+				s++;
+		}
+	} else if ((op[count - 1] != 0x0A && count != info.size) ||
+		   count - 1 > info.size || count < info.size) {
+		kfree(op);
+		ret = -EINVAL;
+		pr_err("efuse: key data length not match\n");
+		goto exit;
+	}
+
+	pos = ((loff_t)(info.offset)) & 0xffffffff;
+	ret = efuse_write_usr(op, info.size, &pos);
+	kfree(op);
+
+	if (ret < 0) {
+		pr_err("efuse: write user area %d bytes data fail\n",
+		       (unsigned int)info.size);
+		goto exit;
+	}
+
+	pr_info("efuse: write user area %d bytes data OK\n",
+		(unsigned int)ret);
+
+	ret = count;
+
+exit:
+	return ret;
+#else
+	pr_err("no permission to write!!\n");
+	return -EPERM;
+#endif
+}
+EXPORT_SYMBOL(efuse_user_attr_store);
+
+ssize_t efuse_user_attr_show(char *name, char *buf)
+{
+	char *op = NULL;
+	ssize_t ret;
+	ssize_t len = 0;
+	struct efusekey_info info;
+	int i;
+	loff_t pos;
+
+	if (efuse_getinfo(name, &info) < 0) {
+		ret = -EINVAL;
+		pr_err("efuse: %s is not found\n", name);
+		goto exit;
+	}
+
+	op = kzalloc(sizeof(char) * info.size, GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse: failed to allocate memory\n");
+		goto exit;
+	}
+
+	memset(op, 0, info.size);
+
+	pos = ((loff_t)(info.offset)) & 0xffffffff;
+	ret = efuse_read_usr(op, info.size, &pos);
+	if (ret < 0) {
+		kfree(op);
+		pr_err("efuse: read user data fail!\n");
+		goto exit;
+	}
+
+	for (i = 0; i < info.size; i++) {
+		if (i != 0 && (i % 16 == 0))
+			len += sprintf(buf + len, "\n");
+		if (i % 16 == 0)
+			len += sprintf(buf + len, "0x%02x: ", i);
+
+		len += sprintf(buf + len, "%02x ", op[i]);
+	}
+	len += sprintf(buf + len, "\n");
+	kfree(op);
+
+	ret = len;
+
+exit:
+	return ret;
+}
+
+ssize_t efuse_user_attr_read(char *name, char *buf)
+{
+	char *op = NULL;
+	ssize_t ret;
+	struct efusekey_info info;
+	loff_t pos;
+
+	if (efuse_getinfo(name, &info) < 0) {
+		ret = -EINVAL;
+		pr_err("efuse: %s is not found\n", name);
+		goto exit;
+	}
+
+	op = kzalloc(sizeof(char) * info.size, GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse: failed to allocate memory\n");
+		goto exit;
+	}
+
+	memset(op, 0, info.size);
+
+	pos = ((loff_t)(info.offset)) & 0xffffffff;
+	ret = efuse_read_usr(op, info.size, &pos);
+	if (ret < 0) {
+		kfree(op);
+		pr_err("efuse: read user data fail!\n");
+		goto exit;
+	}
+
+	memcpy(buf, op, info.size);
+	kfree(op);
+
+	ret = (ssize_t)info.size;
+
+exit:
+	return ret;
+}
+
+static ssize_t userdata_show(struct class *cla,
+			     struct class_attribute *attr, char *buf)
+{
+	char *op = NULL;
+	ssize_t ret;
+	ssize_t len = 0;
+	int i;
+	loff_t offset = 0;
+	unsigned int max_size;
+
+	ret = efuse_get_max();
+	if (ret < 0) {
+		pr_err("efuse: failed to get userdata max size\n");
+		goto exit;
+	}
+	max_size = (unsigned int)ret;
+
+	op = kcalloc(max_size, sizeof(char), GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse: failed to allocate memory\n");
+		goto exit;
+	}
+
+	memset(op, 0, max_size);
+
+	ret = efuse_read_usr(op, max_size, &offset);
+	if (ret < 0) {
+		kfree(op);
+		pr_err("efuse: read user data error!!\n");
+		goto exit;
+	}
+
+	for (i = 0; i < ret; i++) {
+		if (i != 0 && (i % 16 == 0))
+			len += sprintf(buf + len, "\n");
+		if (i % 16 == 0)
+			len += sprintf(buf + len, "0x%02x: ", i);
+
+		len += sprintf(buf + len, "%02x ", op[i]);
+	}
+	len += sprintf(buf + len, "\n");
+	kfree(op);
+
+	ret = len;
+
+exit:
+	return ret;
+}
+
+#ifndef EFUSE_READ_ONLY
+static ssize_t userdata_store(struct class *cla,
+			      struct class_attribute *attr,
+			      const char *buf, size_t count)
+{
+	ssize_t ret;
+	loff_t offset = 0;
+	char *op = NULL;
+	unsigned int max_size;
+
+	ret = efuse_get_max();
+	if (ret < 0) {
+		pr_err("efuse: failed to get userdata max size\n");
+		goto exit;
+	}
+	max_size = (unsigned int)ret;
+
+	if (count > max_size) {
+		ret = -EINVAL;
+		pr_err("efuse: data length over userdata max size\n");
+		goto exit;
+	}
+
+	op = kzalloc(sizeof(char) * count, GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse: failed to allocate memory\n");
+		goto exit;
+	}
+
+	memset(op, 0, count);
+	memcpy(op, buf, count);
+
+	ret = efuse_write_usr(op, count, &offset);
+	kfree(op);
+
+	if (ret < 0) {
+		pr_err("efuse: write user area %d bytes data fail\n",
+		       (unsigned int)count);
+		goto exit;
+	}
+
+	pr_info("efuse: write user area %d bytes data OK\n",
+		(unsigned int)ret);
+
+	ret = count;
+
+exit:
+	return ret;
+}
+#endif
+
+static ssize_t amlogic_set_store(struct class *cla,
+				 struct class_attribute *attr,
+				 const char *buf, size_t count)
+{
+	ssize_t ret;
+	char *op = NULL;
+
+	if (count != efuse_pattern_size) {
+		ret = -EINVAL;
+		pr_err("efuse: bad pattern size, only support size %d!\n",
+		       efuse_pattern_size);
+		goto exit;
+	}
+
+	op = kzalloc(sizeof(char) * count, GFP_KERNEL);
+	if (!op) {
+		ret = -ENOMEM;
+		pr_err("efuse: failed to allocate memory!\n");
+		goto exit;
+	}
+
+	memset(op, 0, count);
+	memcpy(op, buf, count);
+
+	ret = efuse_amlogic_set(op, count);
+	kfree(op);
+
+	if (ret) {
+		pr_err("efuse: pattern programming fail! ret: %d\n",
+		       (unsigned int)ret);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	pr_info("efuse: pattern programming success!\n");
+
+	ret = count;
+
+exit:
+	return ret;
+}
+
+static ssize_t secureboot_check_show(struct class *cla,
+				 struct class_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+	int ret;
+
+	struct aml_efuse_dev *efuse_dev;
+
+	efuse_dev = container_of(cla, struct aml_efuse_dev, cls);
+	if (!efuse_dev->reg_base)
+		ret = -EINVAL;
+	else
+		ret = readl(efuse_dev->reg_base) & efuse_dev->secureboot_mask;
+	if (ret < 0)
+		n = sprintf(buf, "fail");
+	else if (ret == 0)
+		n = sprintf(buf, "raw");
+	else
+		n = sprintf(buf, "encrypt");
+
+	return n;
+}
+
+static ssize_t checkburn_show(struct class *cla,
+			     struct class_attribute *attr, char *buf)
+{
+	ssize_t n = 0;
+	struct aml_efuse_dev *efuse_dev;
+
+	efuse_dev = container_of(cla, struct aml_efuse_dev, cls);
+	if (efuse_dev->name[0]) {
+		if (efuse_burn_lockable_is_cfg(efuse_dev->name) == 0) {
+			n = efuse_burn_check_burned(efuse_dev->name);
+			if (n == 1)
+				n = sprintf(buf, "wrote");
+			else if (n == 0)
+				n = sprintf(buf, "notwrite");
+			else
+				n = sprintf(buf, "error");
+		} else {
+			n = sprintf(buf, "nocfg");
+		}
+	} else {
+		n = sprintf(buf, "unknown");
+	}
+	return n;
+}
+
+static ssize_t checkburn_store(struct class *cla,
+			      struct class_attribute *attr,
+			      const char *buf, size_t count)
+{
+	ssize_t n = 0;
+	struct aml_efuse_dev *efuse_dev;
+
+	efuse_dev = container_of(cla, struct aml_efuse_dev, cls);
+
+	n = strlen(buf);
+	pr_notice("%s:%d %s,n=%ld\n", __func__, __LINE__, buf, n);
+
+	n--; //discard '\n'
+	if (n >= EFUSE_CHECK_NAME_LEN)
+		n = EFUSE_CHECK_NAME_LEN - 1;
+
+	memset(efuse_dev->name, 0, sizeof(efuse_dev->name));
+	memcpy(efuse_dev->name, buf, n);
+
+	return count;
+}
+
+static ssize_t checklist_show(struct class *cla,
+			     struct class_attribute *attr, char *buf)
+{
+	int i;
+	ssize_t n = 0;
+
+	for (i = 0; i < efusecheck.item_num; i++) {
+		n += sprintf(&buf[n], efusecheck.infos[i].itemname);
+		n += sprintf(&buf[n], "\n");
+	}
+	return n;
+}
+
+static int key_item_parse_dt(const struct device_node *np_efusekey,
+			     int index, struct efusekey_info *infos)
+{
+	const phandle *phandle;
+	struct device_node *np_key;
+	char *propname;
+	const char *keyname;
+	int ret;
+	int name_size;
+
+	propname = kasprintf(GFP_KERNEL, "key%d", index);
+
+	phandle = of_get_property(np_efusekey, propname, NULL);
+	if (!phandle) {
+		ret = -EINVAL;
+		pr_err("failed to find match %s\n", propname);
+		goto exit;
+	}
+	np_key = of_find_node_by_phandle(be32_to_cpup(phandle));
+	if (!np_key) {
+		ret = -EINVAL;
+		pr_err("failed to find device node %s\n", propname);
+		goto exit;
+	}
+
+	ret = of_property_read_string(np_key, "keyname", &keyname);
+	if (ret < 0) {
+		pr_err("failed to get keyname item\n");
+		goto exit;
+	}
+
+	name_size = EFUSE_KEY_NAME_LEN - 1;
+	memcpy(infos[index].keyname, keyname,
+	       strlen(keyname) > name_size ? name_size : strlen(keyname));
+
+	ret = of_property_read_u32(np_key, "offset",
+				   &infos[index].offset);
+	if (ret < 0) {
+		pr_err("failed to get key offset item\n");
+		goto exit;
+	}
+
+	ret = of_property_read_u32(np_key, "size",
+				   &infos[index].size);
+	if (ret < 0) {
+		pr_err("failed to get key size item\n");
+		goto exit;
+	}
+
+	pr_info("efusekey name: %15s\toffset: %5d\tsize: %5d\n",
+		infos[index].keyname,
+		infos[index].offset,
+		infos[index].size);
+
+	ret = 0;
+
+exit:
+	kfree(propname);
+	return ret;
+}
+
+static int get_efusekey_info(struct device_node *np)
+{
+	const phandle *phandle;
+	struct device_node *np_efusekey = NULL;
+	int index;
+	int ret;
+
+	phandle = of_get_property(np, "key", NULL);
+	if (!phandle) {
+		ret = -EINVAL;
+		pr_err("failed to find match efuse key\n");
+		goto exit;
+	}
+	np_efusekey = of_find_node_by_phandle(be32_to_cpup(phandle));
+	if (!np_efusekey) {
+		ret = -EINVAL;
+		pr_err("failed to find device node efusekey\n");
+		goto exit;
+	}
+
+	ret = of_property_read_u32(np_efusekey, "keynum", &efuse_key.num);
+	if (ret < 0) {
+		pr_err("failed to get efusekey num item\n");
+		goto exit;
+	}
+
+	if (efuse_key.num <= 0) {
+		ret = -EINVAL;
+		pr_err("efusekey num config error\n");
+		goto exit;
+	}
+	pr_info("efusekey num: %d\n", efuse_key.num);
+
+	efuse_key.infos = kzalloc((sizeof(struct efusekey_info))
+		* efuse_key.num, GFP_KERNEL);
+	if (!efuse_key.infos) {
+		ret = -ENOMEM;
+		pr_err("fail to alloc enough mem for efusekey_infos\n");
+		goto exit;
+	}
+
+	for (index = 0; index < efuse_key.num; index++) {
+		ret = key_item_parse_dt(np_efusekey, index, efuse_key.infos);
+		if (ret < 0) {
+			kfree(efuse_key.infos);
+			goto exit;
+		}
+	}
+
+	return 0;
+
+exit:
+	return ret;
+}
+
+static int check_item_parse_dt(const struct device_node *np_efusecheck,
+			     int index, struct lockable_info *infos)
+{
+	const phandle *phandle;
+	struct device_node *np_check;
+	char *propname;
+	const char *checkname;
+	int ret;
+	int name_size;
+
+	propname = kasprintf(GFP_KERNEL, "check%d", index);
+
+	phandle = of_get_property(np_efusecheck, propname, NULL);
+	if (!phandle) {
+		ret = -EINVAL;
+		pr_err("failed to find match %s\n", propname);
+		goto exit;
+	}
+	np_check = of_find_node_by_phandle(be32_to_cpup(phandle));
+	if (!np_check) {
+		ret = -EINVAL;
+		pr_err("failed to find device node %s\n", propname);
+		goto exit;
+	}
+
+	ret = of_property_read_string(np_check, "checkname", &checkname);
+	if (ret < 0) {
+		pr_err("failed to get checkname item\n");
+		goto exit;
+	}
+
+	name_size = EFUSE_CHECK_NAME_LEN - 1;
+	memcpy(infos[index].itemname, checkname,
+	       strlen(checkname) > name_size ? name_size : strlen(checkname));
+
+	ret = of_property_read_u32(np_check, "subcmd",
+				   &infos[index].subcmd);
+	if (ret < 0) {
+		pr_err("failed to get subcmd item\n");
+		goto exit;
+	}
+
+	pr_info("efusecheck name: %15s subcmd: 0x%16x\n",
+		infos[index].itemname,
+		infos[index].subcmd);
+
+	ret = 0;
+
+exit:
+	kfree(propname);
+	return ret;
+}
+
+static int get_efusecheck_info(struct device_node *np)
+{
+	const phandle *phandle;
+	struct device_node *np_ec = NULL;
+	int index;
+	int ret;
+
+	phandle = of_get_property(np, "check", NULL);
+	if (!phandle) {
+		ret = -EINVAL;
+		pr_err("failed to find match efuse key\n");
+		goto exit;
+	}
+	np_ec = of_find_node_by_phandle(be32_to_cpup(phandle));
+	if (!np_ec) {
+		ret = -EINVAL;
+		pr_err("failed to find device node efusekey\n");
+		goto exit;
+	}
+
+	ret = of_property_read_u32(np_ec, "maincmd",
+			&efusecheck.main_cmd);
+	if (ret < 0) {
+		efusecheck.main_cmd = EFUSE_READ_CALI_ITEM;
+		pr_err("don't cfg efusecheck maincmd, used default:0x%x\n",
+				efusecheck.main_cmd);
+		pr_notice("don't cfg efusecheck maincmd, used default:0x%x\n",
+				efusecheck.main_cmd);
+	} else {
+		pr_info("efuse check maincmd:0x%x\n",
+			efusecheck.main_cmd);
+	}
+
+	ret = of_property_read_u32(np_ec, "checknum", &efusecheck.item_num);
+	if (ret < 0) {
+		pr_err("failed to get efusecheck num item\n");
+		goto exit;
+	}
+
+	if (efusecheck.item_num <= 0) {
+		ret = -EINVAL;
+		pr_err("efusecheck num config error\n");
+		goto exit;
+	}
+	pr_info("efusecheck num: %d\n", efusecheck.item_num);
+
+	efusecheck.infos = kzalloc((sizeof(struct lockable_info))
+		* efusecheck.item_num, GFP_KERNEL);
+	if (!efusecheck.infos) {
+		ret = -ENOMEM;
+		pr_err("fail to alloc enough mem for efusecheck_item\n");
+		goto exit;
+	}
+
+	for (index = 0; index < efusecheck.item_num; index++) {
+		ret = check_item_parse_dt(np_ec, index, efusecheck.infos);
+		if (ret < 0) {
+			kfree(efusecheck.infos);
+			goto exit;
+		}
+	}
+
+	return 0;
+
+exit:
+	return ret;
+}
+
+static EFUSE_CLASS_ATTR(userdata);
+static EFUSE_CLASS_ATTR(mac);
+static EFUSE_CLASS_ATTR(mac_bt);
+static EFUSE_CLASS_ATTR(mac_wifi);
+static EFUSE_CLASS_ATTR(usid);
+static CLASS_ATTR_WO(amlogic_set);
+static CLASS_ATTR_RO(secureboot_check);
+static EFUSE_CLASS_ATTR(checkburn);
+static CLASS_ATTR_RO(checklist);
+
+static struct attribute *efuse_calss_attrs[] = {
+	&class_attr_userdata.attr,
+	&class_attr_mac.attr,
+	&class_attr_mac_bt.attr,
+	&class_attr_mac_wifi.attr,
+	&class_attr_usid.attr,
+	&class_attr_amlogic_set.attr,
+	&class_attr_secureboot_check.attr,
+	&class_attr_checkburn.attr,
+	&class_attr_checklist.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(efuse_calss);
+
+static int efuse_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device *devp;
+	struct device_node *np = pdev->dev.of_node;
+	struct clk *efuse_clk;
+	struct aml_efuse_dev *efuse_dev;
+	struct resource *reg_mem = NULL;
+	void __iomem *reg_base = NULL;
+	unsigned int  secureboot_mask;
+
+	efuse_dev = devm_kzalloc(&pdev->dev, sizeof(*efuse_dev), GFP_KERNEL);
+	if (!efuse_dev) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "failed to alloc enough mem for efuse_dev\n");
+		goto out;
+	}
+
+	efuse_dev->pdev = pdev;
+	platform_set_drvdata(pdev, efuse_dev);
+
+	efuse_clk = devm_clk_get(&pdev->dev, "efuse_clk");
+	if (IS_ERR(efuse_clk)) {
+		dev_err(&pdev->dev, "can't get efuse clk gate, use default clk\n");
+	} else {
+		ret = clk_prepare_enable(efuse_clk);
+		if (ret) {
+			dev_err(&pdev->dev, "failed to enable efuse clk gate\n");
+			goto error1;
+		}
+	}
+
+	of_node_get(np);
+
+	ret = of_property_read_u32(np, "read_cmd", &efuse_cmd.read_cmd);
+	if (ret) {
+		dev_err(&pdev->dev, "please config read_cmd\n");
+		goto error1;
+	}
+
+	ret = of_property_read_u32(np, "write_cmd", &efuse_cmd.write_cmd);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to write_cmd\n");
+		goto error1;
+	}
+
+	ret = of_property_read_u32(np, "get_max_cmd", &efuse_cmd.get_max_cmd);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get_max_cmd\n");
+		goto error1;
+	}
+
+	ret = of_property_read_u32(np, "mem_in_base_cmd",
+				   &efuse_cmd.mem_in_base_cmd);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to mem_in_base_cmd\n");
+		goto error1;
+	}
+
+	ret = of_property_read_u32(np, "mem_out_base_cmd",
+				   &efuse_cmd.mem_out_base_cmd);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to mem_out_base_cmd\n");
+		goto error1;
+	}
+
+	ret = of_property_read_u32(np, "efuse_pattern_size",
+				   &efuse_pattern_size);
+	if (ret) {
+		efuse_pattern_size = EFUSE_PATTERN_SIZE;
+		pr_err("can't get efuse_pattern_size, use default size0x%x\n",
+			efuse_pattern_size);
+	} else {
+		pr_info("efuse_pattern_size:0x%x\n",
+			efuse_pattern_size);
+	}
+
+	reg_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!IS_ERR_OR_NULL(reg_mem)) {
+		reg_base = devm_ioremap_resource(&pdev->dev, reg_mem);
+		if (IS_ERR(reg_base)) {
+			dev_err(&pdev->dev, "reg0: cannot obtain I/O memory region.\n");
+			ret = PTR_ERR(reg_base);
+			goto error1;
+		} else {
+			ret = of_property_read_u32(np, "secureboot_mask",
+				   &secureboot_mask);
+			if (ret) {
+				dev_err(&pdev->dev, "can't get reg secureboot_mask\n");
+				goto error1;
+			}
+		}
+	} else {
+		dev_err(&pdev->dev, "can't get reg resource\n");
+	}
+
+	get_efusekey_info(np);
+	get_efusecheck_info(np);
+
+	ret = alloc_chrdev_region(&efuse_dev->devno, 0, 1, EFUSE_DEVICE_NAME);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "fail to allocate major number\n ");
+		goto error1;
+	}
+
+	efuse_dev->reg_base = reg_base;
+	efuse_dev->secureboot_mask = secureboot_mask;
+	efuse_dev->cls.name = EFUSE_CLASS_NAME;
+	efuse_dev->cls.owner = THIS_MODULE;
+	efuse_dev->cls.class_groups = efuse_calss_groups;
+	ret = class_register(&efuse_dev->cls);
+	if (ret)
+		goto error2;
+
+	cdev_init(&efuse_dev->cdev, &efuse_fops);
+	efuse_dev->cdev.owner = THIS_MODULE;
+
+	ret = cdev_add(&efuse_dev->cdev, efuse_dev->devno, 1);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add device\n");
+		goto error3;
+	}
+
+	devp = device_create(&efuse_dev->cls, NULL,
+			     efuse_dev->devno, NULL, "efuse");
+	if (IS_ERR(devp)) {
+		dev_err(&pdev->dev, "failed to create device node\n");
+		ret = PTR_ERR(devp);
+		goto error4;
+	}
+
+	dev_info(&pdev->dev, "device %s created OK\n", EFUSE_DEVICE_NAME);
+	return 0;
+
+error4:
+	cdev_del(&efuse_dev->cdev);
+error3:
+	class_unregister(&efuse_dev->cls);
+error2:
+	unregister_chrdev_region(efuse_dev->devno, 1);
+error1:
+	devm_kfree(&pdev->dev, efuse_dev);
+out:
+	return ret;
+}
+
+static int efuse_remove(struct platform_device *pdev)
+{
+	struct aml_efuse_dev *efuse_dev = platform_get_drvdata(pdev);
+
+	unregister_chrdev_region(efuse_dev->devno, 1);
+	device_destroy(&efuse_dev->cls, efuse_dev->devno);
+	cdev_del(&efuse_dev->cdev);
+	class_unregister(&efuse_dev->cls);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id efuse_dt_match[] = {
+	{	.compatible = "amlogic, efuse",
+	},
+	{},
+};
+
+static struct platform_driver efuse_driver = {
+	.probe = efuse_probe,
+	.remove = efuse_remove,
+	.driver = {
+		.name = EFUSE_DEVICE_NAME,
+		.of_match_table = efuse_dt_match,
+	.owner = THIS_MODULE,
+	},
+};
+
+int __init aml_efuse_init(void)
+{
+	return platform_driver_register(&efuse_driver);
+}
+
+void aml_efuse_exit(void)
+{
+	platform_driver_unregister(&efuse_driver);
+}
diff -Naur a/vendor/amlogic/unifykey/efuse.h b/vendor/amlogic/unifykey/efuse.h
--- a/vendor/amlogic/unifykey/efuse.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/efuse.h	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,99 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __EFUSE_H
+#define __EFUSE_H
+
+/* #define EFUSE_READ_ONLY */
+
+#ifndef EFUSE_READ_ONLY
+#define EFUSE_CLASS_ATTR CLASS_ATTR_RW
+#else
+#define EFUSE_CLASS_ATTR CLASS_ATTR_RO
+#endif
+
+#define EFUSE_CHECK_NAME_LEN   32
+
+struct aml_efuse_dev {
+	struct platform_device *pdev;
+	struct class           cls;
+	struct cdev            cdev;
+	dev_t                  devno;
+	void __iomem	       *reg_base;
+	unsigned int           secureboot_mask;
+	char name[EFUSE_CHECK_NAME_LEN];
+};
+
+struct aml_efuse_key {
+	int                   num;
+	struct efusekey_info *infos;
+};
+
+#define EFUSE_INFO_GET		_IO('f', 0x40)
+
+#define EFUSE_HAL_API_READ	0
+#define EFUSE_HAL_API_WRITE 1
+#define EFUSE_HAL_API_USER_MAX 3
+
+#define AML_DATA_PROCESS            (0x820000FF)
+#define AML_D_P_W_EFUSE_AMLOGIC     (0x20)
+#define EFUSE_PATTERN_SIZE      (0x400)
+
+/* efuse HAL_API arg */
+struct efuse_hal_api_arg {
+	unsigned int cmd;
+	unsigned int offset;
+	unsigned int size;
+	unsigned long buffer;
+	unsigned long retcnt;
+};
+
+struct aml_efuse_cmd {
+	unsigned int read_cmd;
+	unsigned int write_cmd;
+	unsigned int get_max_cmd;
+	unsigned int mem_in_base_cmd;
+	unsigned int mem_out_base_cmd;
+};
+
+struct lockable_info {
+	char itemname[EFUSE_CHECK_NAME_LEN];
+	unsigned int subcmd;
+};
+
+struct aml_efuse_lockable_check {
+	unsigned int main_cmd;
+	unsigned int item_num;
+	struct lockable_info *infos;
+};
+
+extern struct aml_efuse_cmd efuse_cmd;
+
+ssize_t efuse_get_max(void);
+ssize_t efuse_read_usr(char *buf, size_t count, loff_t *ppos);
+ssize_t efuse_write_usr(char *buf, size_t count, loff_t *ppos);
+unsigned long efuse_amlogic_set(char *buf, size_t count);
+
+/*return: 0:is configurated, -1: don't cfg*/
+int efuse_burn_lockable_is_cfg(char *itemname);
+/*
+ * retrun: 1:burned(wrote), 0: not write, -1: fail
+ */
+int efuse_burn_check_burned(char *itemname);
+
+#ifdef CONFIG_AMLOGIC_EFUSE
+int __init aml_efuse_init(void);
+void aml_efuse_exit(void);
+#else
+static int __init aml_efuse_init(void)
+{
+	return 0;
+}
+
+static void aml_efuse_exit(void)
+{
+}
+#endif
+#endif
diff -Naur a/vendor/amlogic/unifykey/efuse_unifykey.c b/vendor/amlogic/unifykey/efuse_unifykey.c
--- a/vendor/amlogic/unifykey/efuse_unifykey.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/efuse_unifykey.c	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/ctype.h>
+#include <linux/kallsyms.h>
+#include "efuse.h"
+#include "unifykey.h"
+#include "efuse_burn.h"
+
+static int __init efuse_unifykey_init(void)
+{
+	int ret;
+
+	ret = aml_efuse_init();
+	if (ret)
+		return ret;
+
+	ret = aml_unifykeys_init();
+	if (ret) {
+		aml_efuse_exit();
+		return ret;
+	}
+
+	ret = aml_efuse_burn_init();
+	if (ret) {
+		aml_efuse_burn_exit();
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit efuse_unifykey_exit(void)
+{
+	aml_efuse_exit();
+	aml_unifykeys_exit();
+	aml_efuse_burn_exit();
+}
+
+module_init(efuse_unifykey_init);
+module_exit(efuse_unifykey_exit);
+
+MODULE_DESCRIPTION("Amlogic efuse/unifykey management driver");
+MODULE_LICENSE("GPL v2");
+
diff -Naur a/vendor/amlogic/unifykey/Kconfig b/vendor/amlogic/unifykey/Kconfig
--- a/vendor/amlogic/unifykey/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/Kconfig	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,33 @@
+#
+# Amlogic efuse&unifykey device configuration
+#
+config AMLOGIC_EFUSE_UNIFYKEY
+	tristate "Amlogic EUSE and UNIFYKEY support"
+	default n
+	help
+	    amlogic EFUSE and UNIFYKEY glue driver
+	    choose by default
+
+config AMLOGIC_EFUSE
+	bool "Amlogic EFUSE driver support"
+	default n
+	help
+	    amlogic EFUSE device driver
+	    not choose by default
+
+config AMLOGIC_UNIFYKEY
+	bool "Amlogic unifykey driver support"
+	default n
+	help
+	    platform independent part of unifykey driver
+	    not choose by default
+
+config AMLOGIC_EFUSE_BURN
+	bool "Amlogic efuse pattern burn suppot"
+	default n
+	help
+	    if project need burn efuse pattern file, then
+	    it can enable this. if efuse pattern size exceed
+	    4KB, it must enable this. it write efuse pattern
+	    file through /dev/efuse_burn.
+
diff -Naur a/vendor/amlogic/unifykey/Makefile b/vendor/amlogic/unifykey/Makefile
--- a/vendor/amlogic/unifykey/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/Makefile	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,11 @@
+#
+# Makefile for eFuse and unifykey
+#
+MODULE_NAME = aml_efuse_unifykey
+
+obj-$(CONFIG_AMLOGIC_EFUSE_UNIFYKEY) = $(MODULE_NAME).o
+
+$(MODULE_NAME)-y += efuse_unifykey.o
+$(MODULE_NAME)-$(CONFIG_AMLOGIC_EFUSE) += efuse.o efuse_api.o
+$(MODULE_NAME)-$(CONFIG_AMLOGIC_EFUSE_BURN) +=  efuse_burn.o
+$(MODULE_NAME)-$(CONFIG_AMLOGIC_UNIFYKEY) += security_key.o unifykey.o unifykey_dts.o storage_key.o normal_key.o
diff -Naur a/vendor/amlogic/unifykey/normal_key.c b/vendor/amlogic/unifykey/normal_key.c
--- a/vendor/amlogic/unifykey/normal_key.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/normal_key.c	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,683 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/arm-smccc.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <crypto/hash.h>
+#include <crypto/sha.h>
+#include "normal_key.h"
+
+#undef pr_fmt
+#define pr_fmt(fmt) "unifykey: " fmt
+#define DBG 0
+
+/* Storage BLOCK RAW HEAD: fixed 512B*/
+#define ENC_TYPE_DEFAULT 0
+#define ENC_TYPE_EFUSE	1
+#define ENC_TYPE_FIXED	2
+
+#define STORAGE_BLOCK_RAW_HEAD_SIZE 512
+
+#define BLOCK_VERSION_0		0
+
+#define ERR_HEADER	0x1
+#define ERR_KEYMEMFAIL	0x2
+#define ERR_KEYRDFAIL	0x4
+#define ERR_KEYCHKFAIL	0x8
+#define ERR_ENCHDFAIL	0x10
+#define ERR_DATASZ	0x20
+struct storage_block_raw_head {
+	u8 mark[16]; /* AMLNORMAL*/
+	u32 version;
+	u32 enctype; /*from EFUSE, from default, from fixed*/
+	u32 keycnt;
+	u32 initcnt;
+	u32 wrtcnt;
+	u32 errcnt;
+	u32 flags;
+	u8  headhash[32];
+	u8  hash[32];
+};
+
+/* Storage BLOCK ENC HEAD: fixed 512B*/
+#define STORAGE_BLOCK_ENC_HEAD_SIZE 512
+struct storage_block_enc_head {
+	u32 blocksize;
+	u32 flashsize;
+};
+
+/* Storage Format: TLV*/
+enum emTLVTag {
+	EMTLVNONE,
+
+	EMTLVHEAD,
+	EMTLVHEADSIZE,
+
+	EMTLVOBJECT,
+	EMTLVOBJNAMESIZE,
+	EMTLVOBJNAME,
+	EMTLVOBJDATASIZE,
+	EMTLVOBJDATABUF,
+	EMTLVOBJTYPE,
+	EMTLVOBJATTR,
+	EMTLVOBJHASHBUF,
+
+	EMTLVHEADFLASHSIZE,
+};
+
+struct storage_node {
+	struct list_head node;
+	struct storage_object object;
+};
+
+static LIST_HEAD(keys);
+static int blockinited;
+static struct storage_block_raw_head rawhead;
+static struct storage_block_enc_head enchead;
+static char *blockmark = "AMLNORMAL";
+
+#if DBG
+static void dump_raw_head(struct storage_block_raw_head *prawhead)
+{
+	pr_info("rawhead:\n");
+	pr_info("mark: %s\n", prawhead->mark);
+	pr_info("keycnt: %u\n", prawhead->keycnt);
+	pr_info("initcnt: %u\n", prawhead->initcnt);
+	pr_info("wrtcnt: %u\n", prawhead->wrtcnt);
+	pr_info("errcnt: %u\n", prawhead->errcnt);
+	pr_info("flags: 0x%x\n", prawhead->flags);
+}
+
+static void dump_enc_head(struct storage_block_enc_head *penchead)
+{
+	pr_info("enchead:\n");
+	pr_info("blocksize: %u\n", penchead->blocksize);
+	pr_info("flashsize: %u\n", penchead->flashsize);
+}
+
+static void dump_mem(const u8 *p, int len)
+{
+	int idx = 0, j, tmp;
+	char buf[64];
+	int total;
+
+	while (idx < len) {
+		total = 0;
+		tmp = min(((int)len - idx), 16);
+		for (j = 0; j < tmp; j++)
+			total += snprintf(buf + total, 64 - total, "%02x ", p[idx + j]);
+		buf[total] = 0;
+		pr_info("%s\n", buf);
+		idx += tmp;
+	}
+}
+
+static void dump_object(struct storage_object *obj)
+{
+	pr_info("key: [%u, %.*s, %x, %x, %u]\n",
+		obj->namesize, obj->namesize, obj->name,
+		obj->type, obj->attribute, obj->datasize);
+	if (obj->dataptr) {
+		pr_info("data:\n");
+		dump_mem(obj->dataptr, obj->datasize);
+	}
+}
+#endif
+
+static u32 Tlv_WriteUint32(u8 *output, s32 len,
+			   u32 tag, u32 value)
+{
+	u32 *out = (u32 *)output;
+
+	if (len < 12)
+		return 0;
+
+	out[0] = tag;
+	out[1] = 4;
+	out[2] = value;
+	return 12;
+}
+
+static u32 Tlv_WriteBuf(u8 *output, s32 len,
+			u32 tag,
+			u32 length, u8 *input)
+{
+	u8 *out = output;
+	u32 tmplen = (((length + 3) / 4) * 4);
+
+	if (len < (s32)(8 + tmplen))
+		return 0;
+
+	*((u32 *)out) = tag;
+	*((u32 *)(out + 4)) = tmplen;
+	memset(out + 8, 0, tmplen);
+	memcpy(out + 8, input, length);
+
+	return tmplen + 8;
+}
+
+static u32 Tlv_ReadTl(u8 *input, int32_t len,
+		      u32 *tag, u32 *length,
+		      u32 *idx)
+{
+	if (len < 8)
+		return 0;
+
+	*tag = *((u32 *)input);
+	*length =  *((u32 *)(input + 4));
+
+	if ((8 + *length) > len)
+		return 0;
+	*idx += 8;
+
+	return 8;
+}
+
+static u32 Tlv_ReadHead(u8 *input, int32_t len,
+			struct storage_block_enc_head *pblockhead)
+{
+	u32 tag;
+	u32 sum;
+	u32 length;
+	u32 idx = 0;
+	u32 ret;
+
+	ret = Tlv_ReadTl(input, len,
+			 &tag, &sum, &idx);
+	if (!ret)
+		return 0;
+
+	if (tag != EMTLVHEAD)
+		return 0;
+
+	sum += ret;
+	while (idx < sum) {
+		ret = Tlv_ReadTl(input + idx, len - idx,
+				 &tag, &length, &idx);
+		if (!ret)
+			return 0;
+
+		switch (tag) {
+		case EMTLVHEADSIZE:
+			pblockhead->blocksize = *((u32 *)(input + idx));
+			break;
+		case EMTLVHEADFLASHSIZE:
+			pblockhead->flashsize = *((u32 *)(input + idx));
+			break;
+		default:
+			break;
+		}
+		idx += length;
+	}
+	return sum;
+}
+
+static u32 Tlv_ReadObject(u8 *input, int32_t len,
+			  struct storage_object *pcontent)
+{
+	u32 tag;
+	u32 length;
+	u32 sum;
+	u32 idx = 0;
+	u32 ret;
+
+	memset(pcontent, 0, sizeof(*pcontent));
+	ret = Tlv_ReadTl(input, len,
+			 &tag, &sum, &idx);
+	if (!ret)
+		return 0;
+
+	if (tag != EMTLVOBJECT)
+		return 0;
+
+	sum += ret;
+	while (idx < sum) {
+		ret = Tlv_ReadTl(input + idx, len - idx,
+				 &tag, &length, &idx);
+		if (!ret)
+			goto tlv_readkeycontent_err;
+
+		switch (tag) {
+		case EMTLVOBJNAMESIZE:
+			pcontent->namesize = *((u32 *)(input + idx));
+			break;
+		case EMTLVOBJNAME:
+			memset(pcontent->name, 0, MAX_OBJ_NAME_LEN);
+			memcpy(pcontent->name, input + idx, pcontent->namesize);
+			break;
+		case EMTLVOBJTYPE:
+			pcontent->type = *((u32 *)(input + idx));
+			break;
+		case EMTLVOBJATTR:
+			pcontent->attribute = *((u32 *)(input + idx));
+			break;
+		case EMTLVOBJDATASIZE:
+			pcontent->datasize = *((u32 *)(input + idx));
+			break;
+		case EMTLVOBJHASHBUF:
+			if (length != 32)
+				goto tlv_readkeycontent_err;
+			memcpy(pcontent->hashptr, input + idx, length);
+			break;
+		case EMTLVOBJDATABUF:
+			pcontent->dataptr = kmalloc(pcontent->datasize,
+						    GFP_KERNEL);
+			if (!pcontent->dataptr)
+				goto tlv_readkeycontent_err;
+			memcpy(pcontent->dataptr,
+			       input + idx, pcontent->datasize);
+			break;
+		default:
+			break;
+		}
+		idx += length;
+	}
+	return sum;
+
+tlv_readkeycontent_err:
+	kfree(pcontent->dataptr);
+	return 0;
+}
+
+#define WRT_UINT32(tag, field) \
+	({ \
+		u32 __tmp; \
+		__tmp = Tlv_WriteUint32(output + idx, len - idx, \
+					tag, field); \
+		if (__tmp) \
+			idx += __tmp; \
+		__tmp; \
+	})
+
+#define WRT_BUF(tag, buflen, buf) \
+	({ \
+		u32 __tmp; \
+		__tmp = Tlv_WriteBuf(output + idx, len - idx, \
+				     tag, buflen, buf); \
+		if (__tmp) \
+			idx += __tmp; \
+		__tmp; \
+	})
+
+u32 Tlv_WriteHead(struct storage_block_enc_head *enchead,
+		  u8 *output, int32_t len)
+{
+	u32 *sum;
+	u32 idx = 0;
+
+	if (len < 8)
+		return 0;
+
+	*(u32 *)output = EMTLVHEAD;
+	sum = (u32 *)(output + 4);
+	idx += 8;
+
+	if (!WRT_UINT32(EMTLVHEADSIZE, enchead->blocksize))
+		return 0;
+	if (!WRT_UINT32(EMTLVHEADFLASHSIZE, enchead->flashsize))
+		return 0;
+
+	*sum = idx - 8;
+	return idx;
+}
+
+u32 Tlv_WriteObject(struct storage_object *object,
+		    u8 *output, int32_t len)
+{
+	u32 *sum;
+	u32 idx = 0;
+
+	if (len < 8)
+		return 0;
+
+	*(u32 *)output = EMTLVOBJECT;
+	sum = (u32 *)(output + 4);
+	idx += 8;
+
+	if (object->namesize != 0) {
+		if (!WRT_UINT32(EMTLVOBJNAMESIZE, object->namesize))
+			return 0;
+		if (!WRT_BUF(EMTLVOBJNAME, object->namesize,
+			     (u8 *)object->name))
+			return 0;
+	}
+
+	if (object->dataptr && object->datasize != 0) {
+		if (!WRT_UINT32(EMTLVOBJDATASIZE, object->datasize))
+			return 0;
+		if (!WRT_BUF(EMTLVOBJDATABUF, object->datasize,
+			     object->dataptr))
+			return 0;
+	}
+
+	if (!WRT_BUF(EMTLVOBJHASHBUF, 32, object->hashptr))
+		return 0;
+	if (!WRT_UINT32(EMTLVOBJTYPE, object->type))
+		return 0;
+	if (!WRT_UINT32(EMTLVOBJATTR, object->attribute))
+		return 0;
+
+	*sum = idx - 8;
+	return idx;
+}
+
+static int normalkey_hash(u8 *data, u32 len, u8 *hash)
+{
+	struct crypto_shash *tfm;
+	struct shash_desc *desc;
+	int ret = -1;
+
+	memset(hash, 0, SHA256_DIGEST_SIZE);
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm)) {
+		pr_err("Failed to allocate hash\n");
+		ret = -EINVAL;
+		goto finish;
+	}
+
+	desc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);
+	if (!desc) {
+		ret = -ENOMEM;
+		goto out_free_shash;
+	}
+	desc->tfm = tfm;
+
+	ret = crypto_shash_digest(desc, data, len, hash);
+	if (ret) {
+		pr_err("Failed to digest, err = %d\n", ret);
+		goto out_free_desc;
+	}
+
+out_free_desc:
+	kfree(desc);
+out_free_shash:
+	crypto_free_shash(tfm);
+finish:
+	return ret;
+}
+
+int normalkey_init(void)
+{
+	if (blockinited)
+		return -1;
+
+	blockinited = 1;
+	return 0;
+}
+
+void normalkey_deinit(void)
+{
+	struct storage_node *pos, *n;
+
+	if (!blockinited)
+		return;
+
+	blockinited = 0;
+
+	list_for_each_entry_safe(pos, n, &keys, node) {
+		list_del(&pos->node);
+		kfree(pos->object.dataptr);
+		kfree(pos);
+	}
+}
+
+struct storage_object *normalkey_get(const u8 *name)
+{
+	struct storage_node *pos;
+	struct storage_object *obj;
+	u32 len;
+
+	if (!name)
+		return NULL;
+
+	len = strlen(name);
+	list_for_each_entry(pos, &keys, node) {
+		obj = &pos->object;
+		if (len == obj->namesize &&
+		    !memcmp(name, obj->name, len))
+			return obj;
+	}
+
+	return NULL;
+}
+
+int normalkey_add(const u8 *name, u8 *buffer, u32 len, u32 attr)
+{
+	struct storage_object *obj;
+	struct storage_node *node;
+	u32 namelen;
+	u8 *data;
+
+	if (blockinited != 2)
+		return -1;
+
+	if (!name || !buffer || !len || (attr & OBJ_ATTR_SECURE))
+		return -1;
+
+	namelen = strlen(name);
+	if (namelen > MAX_OBJ_NAME_LEN)
+		return -1;
+
+	obj = normalkey_get(name);
+	if (obj) {
+		if (attr != obj->attribute)
+			return -1;
+		if (len > obj->datasize) {
+			data = kmalloc(len, GFP_KERNEL);
+			if (!data)
+				return -1;
+			kfree(obj->dataptr);
+			obj->dataptr = data;
+		}
+	} else {
+		node = kmalloc(sizeof(*node), GFP_KERNEL);
+		if (!node)
+			return -1;
+		data = kmalloc(len, GFP_KERNEL);
+		if (!data) {
+			kfree(node);
+			return -1;
+		}
+		obj = &node->object;
+		memcpy(obj->name, name, namelen);
+		obj->namesize = namelen;
+		obj->attribute = attr;
+		obj->type = OBJ_TYPE_GENERIC;
+		obj->dataptr = data;
+		list_add(&node->node, &keys);
+	}
+	obj->datasize = len;
+	memcpy(obj->dataptr, buffer, len);
+	normalkey_hash(buffer, len, obj->hashptr);
+	return 0;
+}
+
+int normalkey_del(const u8 *name)
+{
+	struct storage_object *obj;
+	struct storage_node *node;
+
+	if (blockinited != 2)
+		return -1;
+
+	obj = normalkey_get(name);
+	if (!obj)
+		return -1;
+
+	node = container_of(obj, struct storage_node, object);
+	list_del(&node->node);
+	kfree(obj->dataptr);
+	kfree(node);
+
+	return 0;
+}
+
+int normalkey_readfromblock(void *block, unsigned long size)
+{
+	struct storage_block_raw_head *prawhead;
+	u8 *penchead, *pdata;
+	struct storage_node *node = NULL;
+	u8 hash[32];
+	u32 idx;
+	u32 ret;
+
+	if (blockinited != 1)
+		return -1;
+
+	prawhead = (struct storage_block_raw_head *)block;
+	penchead = (u8 *)block + STORAGE_BLOCK_RAW_HEAD_SIZE;
+	pdata = penchead + STORAGE_BLOCK_ENC_HEAD_SIZE;
+
+	if (!block || size <=
+	    (STORAGE_BLOCK_ENC_HEAD_SIZE + STORAGE_BLOCK_RAW_HEAD_SIZE))
+		return -1;
+
+	blockinited = 2;
+
+	memset(&rawhead, 0, sizeof(rawhead));
+	strncpy(rawhead.mark, blockmark, 15);
+	rawhead.version = BLOCK_VERSION_0;
+
+	enchead.flashsize = size;
+	if (strcmp((const char *)prawhead->mark, blockmark) != 0) {
+		pr_info("mark is not found\n");
+		return 0;
+	}
+
+	normalkey_hash((u8 *)prawhead, sizeof(*prawhead) - 64,
+		       rawhead.headhash);
+	if (memcmp(rawhead.headhash, prawhead->headhash, 32)) {
+		pr_info("rawhead hash check fail\n");
+		rawhead.flags |= ERR_HEADER;
+	} else {
+		pr_info("rawhead hash check successful\n");
+		rawhead.keycnt = prawhead->keycnt;
+		rawhead.initcnt = prawhead->initcnt;
+		rawhead.wrtcnt = prawhead->wrtcnt;
+		rawhead.errcnt = prawhead->errcnt;
+		rawhead.flags = prawhead->flags;
+	}
+
+	rawhead.initcnt++;
+
+#if DBG
+	dump_raw_head(&rawhead);
+#endif
+
+	normalkey_hash(penchead, size - STORAGE_BLOCK_RAW_HEAD_SIZE,
+		       rawhead.hash);
+	if (memcmp(rawhead.hash, prawhead->hash, 32)) {
+		pr_info("data hash check fail\n");
+		rawhead.errcnt++;
+		return 0;
+	}
+
+	ret = Tlv_ReadHead(penchead, STORAGE_BLOCK_ENC_HEAD_SIZE,
+			   &enchead);
+	if (!ret) {
+		pr_info("read head fail\n");
+		rawhead.flags |= ERR_ENCHDFAIL;
+		return 0;
+	}
+
+#if DBG
+	dump_enc_head(&enchead);
+#endif
+
+	if (size < (enchead.blocksize + STORAGE_BLOCK_ENC_HEAD_SIZE +
+	    STORAGE_BLOCK_RAW_HEAD_SIZE)) {
+		rawhead.flags |= ERR_DATASZ;
+		return 0;
+	}
+
+	idx = 0;
+	while (idx < enchead.blocksize) {
+		struct storage_object *obj = NULL;
+
+		if (!node) {
+			node = kmalloc(sizeof(*node), GFP_KERNEL);
+			if (!node) {
+				rawhead.flags |= ERR_KEYMEMFAIL;
+				break;
+			}
+		}
+		obj = &node->object;
+		ret = Tlv_ReadObject(pdata + idx,
+				     enchead.blocksize - idx, obj);
+		if (!ret) {
+			rawhead.flags |= ERR_KEYRDFAIL;
+			break;
+		}
+		idx += ret;
+
+		normalkey_hash(obj->dataptr, obj->datasize, hash);
+		if (memcmp(hash, obj->hashptr, 32)) {
+			kfree(obj->dataptr);
+			rawhead.flags |= ERR_KEYCHKFAIL;
+			continue;
+		}
+#if DBG
+		dump_object(obj);
+#endif
+		list_add(&node->node, &keys);
+		node = NULL;
+	}
+
+	kfree(node);
+	return 0;
+}
+
+int normalkey_writetoblock(void *block, unsigned long size)
+{
+	u8 *prawhead;
+	u8 *penchead, *pdata;
+	struct storage_object *obj = NULL;
+	struct storage_node *node = NULL;
+	u32 idx;
+	u32 ret;
+
+	if (blockinited != 2)
+		return -1;
+
+	prawhead = (u8 *)block;
+	penchead = prawhead + STORAGE_BLOCK_RAW_HEAD_SIZE;
+	pdata = penchead + STORAGE_BLOCK_ENC_HEAD_SIZE;
+
+	if (!block || size <=
+	    (STORAGE_BLOCK_ENC_HEAD_SIZE + STORAGE_BLOCK_RAW_HEAD_SIZE))
+		return -1;
+
+	enchead.flashsize = size;
+	size -= (STORAGE_BLOCK_ENC_HEAD_SIZE + STORAGE_BLOCK_RAW_HEAD_SIZE);
+	idx = 0;
+	rawhead.keycnt = 0;
+	list_for_each_entry(node, &keys, node) {
+		obj = &node->object;
+		ret = Tlv_WriteObject(obj, pdata + idx, size - idx);
+		if (!ret)
+			return -1;
+		idx += ret;
+		rawhead.keycnt++;
+	}
+	enchead.blocksize = idx;
+
+	ret = Tlv_WriteHead(&enchead, penchead, STORAGE_BLOCK_ENC_HEAD_SIZE);
+	if (!ret)
+		return -1;
+
+	rawhead.wrtcnt++;
+	normalkey_hash((u8 *)&rawhead, sizeof(rawhead) - 64,
+		       rawhead.headhash);
+	normalkey_hash(penchead, enchead.flashsize - STORAGE_BLOCK_RAW_HEAD_SIZE,
+		       rawhead.hash);
+	memcpy(prawhead, &rawhead, sizeof(rawhead));
+
+	return 0;
+}
diff -Naur a/vendor/amlogic/unifykey/normal_key.h b/vendor/amlogic/unifykey/normal_key.h
--- a/vendor/amlogic/unifykey/normal_key.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/normal_key.h	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _AML_NORMAL_KEY_H_
+#define _AML_NORMAL_KEY_H_
+
+#define MAX_OBJ_NAME_LEN	80
+
+/*Attribute*/
+#define OBJ_ATTR_SECURE	BIT(0)
+#define OBJ_ATTR_OTP	BIT(1)
+#define OBJ_ATTR_ENC	BIT(8)
+
+/* Type */
+#define OBJ_TYPE_GENERIC	0xA00000BF
+
+struct storage_object {
+	char name[MAX_OBJ_NAME_LEN];
+	u32 namesize;
+	u32 attribute; /*secure, OTP*/
+	u32 type; /*AES, RSA, GENERIC, ...*/
+	u32 datasize;
+	u8 *dataptr;
+	u8 hashptr[32];
+};
+
+int normalkey_init(void);
+void normalkey_deinit(void);
+struct storage_object *normalkey_get(const u8 *name);
+int normalkey_add(const u8 *name, u8 *buffer, u32 len, u32 attr);
+int normalkey_del(const u8 *name);
+int normalkey_readfromblock(void *block, unsigned long size);
+int normalkey_writetoblock(void *block, unsigned long size);
+
+#endif
diff -Naur a/vendor/amlogic/unifykey/security_key.c b/vendor/amlogic/unifykey/security_key.c
--- a/vendor/amlogic/unifykey/security_key.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/security_key.c	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,286 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/arm-smccc.h>
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/kallsyms.h>
+#include "security_key.h"
+
+#undef pr_fmt
+#define pr_fmt(fmt) "unifykey: " fmt
+
+static DEFINE_SPINLOCK(storage_lock);
+static int storage_init_status;
+static struct bl31_storage_share_mem *share_mem;
+
+static unsigned long storage_smc_ops(u64 func)
+{
+	struct arm_smccc_res res;
+
+	arm_smccc_smc((unsigned long)func, 0, 0, 0, 0, 0, 0, 0, &res);
+	return res.a0;
+}
+
+void *secure_storage_getbuf(u32 *size)
+{
+	if (storage_init_status == 1) {
+		*size = share_mem->size;
+		return (void *)(share_mem->block);
+	}
+
+	*size = 0;
+	return NULL;
+}
+
+unsigned long secure_storage_write(u8 *keyname, u8 *keybuf,
+				   u32 keylen, u32 keyattr)
+{
+	u32	      *input;
+	u32	      namelen;
+	u8	      *keydata;
+	u8	      *name;
+	unsigned long ret;
+	unsigned long lockflags;
+
+	if (storage_init_status != 1)
+		return RET_EUND;
+
+	namelen = strlen(keyname);
+	if (namelen + keylen + 12 > share_mem->size)
+		return RET_EMEM;
+
+	spin_lock_irqsave(&storage_lock, lockflags);
+	input = (u32 *)(share_mem->in);
+	*input++ = namelen;
+	*input++ = keylen;
+	*input++ = keyattr;
+	name = (u8 *)input;
+	memcpy(name, keyname, namelen);
+	keydata = name + namelen;
+	memcpy(keydata, keybuf, keylen);
+	ret = storage_smc_ops(BL31_STORAGE_WRITE);
+	spin_unlock_irqrestore(&storage_lock, lockflags);
+
+	return ret;
+}
+
+unsigned long secure_storage_read(u8 *keyname, u8 *keybuf,
+				  u32 keylen, u32 *readlen)
+{
+	u32	      *input;
+	u32	      *output;
+	u32	      namelen;
+	u8	      *name;
+	u8	      *buf;
+	unsigned long ret;
+	unsigned long lockflags;
+
+	if (storage_init_status != 1)
+		return RET_EUND;
+
+	namelen = strlen(keyname);
+	if (namelen + 8 > share_mem->size)
+		return RET_EMEM;
+
+	spin_lock_irqsave(&storage_lock, lockflags);
+	input = (u32 *)(share_mem->in);
+	output = (u32 *)(share_mem->out);
+	*input++ = namelen;
+	*input++ = keylen;
+	name = (u8 *)input;
+	memcpy(name, keyname, namelen);
+	ret = storage_smc_ops(BL31_STORAGE_READ);
+	if (ret == RET_OK) {
+		*readlen = *output;
+		if (*readlen > keylen)
+			*readlen = keylen;
+		buf = (u8 *)(output + 1);
+		memcpy(keybuf, buf, *readlen);
+	}
+	spin_unlock_irqrestore(&storage_lock, lockflags);
+
+	return ret;
+}
+
+unsigned long secure_storage_verify(u8 *keyname, u8 *hashbuf)
+{
+	u32	      *input;
+	u32	      *output;
+	u32	      namelen;
+	u8	      *name;
+	unsigned long ret;
+	unsigned long lockflags;
+
+	if (storage_init_status != 1)
+		return RET_EUND;
+
+	namelen = strlen(keyname);
+	if (namelen + 4 > share_mem->size)
+		return RET_EMEM;
+
+	spin_lock_irqsave(&storage_lock, lockflags);
+	input = (u32 *)(share_mem->in);
+	output = (u32 *)(share_mem->out);
+	*input++ = namelen;
+	name = (u8 *)input;
+	memcpy(name, keyname, namelen);
+	ret = storage_smc_ops(BL31_STORAGE_VERIFY);
+	if (ret == RET_OK)
+		memcpy(hashbuf, (u8 *)output, 32);
+	spin_unlock_irqrestore(&storage_lock, lockflags);
+
+	return ret;
+}
+
+unsigned long secure_storage_query(u8 *key_name, u32 *retval)
+{
+	u32	      *input;
+	u32	      *output;
+	u32	      namelen;
+	u8	      *name;
+	unsigned long ret;
+	unsigned long lockflags;
+
+	if (storage_init_status != 1)
+		return RET_EUND;
+
+	namelen = strlen(key_name);
+	if (namelen + 4 > share_mem->size)
+		return RET_EMEM;
+
+	spin_lock_irqsave(&storage_lock, lockflags);
+	input = (u32 *)(share_mem->in);
+	output = (u32 *)(share_mem->out);
+	*input++ = namelen;
+	name = (u8 *)input;
+	memcpy(name, key_name, namelen);
+	ret = storage_smc_ops(BL31_STORAGE_QUERY);
+	if (ret == RET_OK)
+		*retval = *output;
+	spin_unlock_irqrestore(&storage_lock, lockflags);
+
+	return ret;
+}
+
+unsigned long secure_storage_tell(u8 *keyname, u32 *retval)
+{
+	u32	      *input;
+	u32	      *output;
+	u32	      namelen;
+	u8	      *name;
+	unsigned long ret;
+	unsigned long lockflags;
+
+	if (storage_init_status != 1)
+		return RET_EUND;
+
+	namelen = strlen(keyname);
+	if (namelen + 4 > share_mem->size)
+		return RET_EMEM;
+
+	spin_lock_irqsave(&storage_lock, lockflags);
+	input = (u32 *)(share_mem->in);
+	output = (u32 *)(share_mem->out);
+	*input++ = namelen;
+	name = (u8 *)input;
+	memcpy(name, keyname, namelen);
+	ret = storage_smc_ops(BL31_STORAGE_TELL);
+	if (ret == RET_OK)
+		*retval = *output;
+	spin_unlock_irqrestore(&storage_lock, lockflags);
+
+	return ret;
+}
+
+unsigned long secure_storage_status(u8 *keyname, u32 *retval)
+{
+	u32	      *input;
+	u32	      *output;
+	u32	      namelen;
+	u8	      *name;
+	u64	      ret;
+	unsigned long lockflags;
+
+	if (storage_init_status != 1)
+		return RET_EUND;
+
+	namelen = strlen(keyname);
+	if (namelen + 4 > share_mem->size)
+		return RET_EMEM;
+
+	spin_lock_irqsave(&storage_lock, lockflags);
+	input = (u32 *)(share_mem->in);
+	output = (u32 *)(share_mem->out);
+	*input++ = namelen;
+	name = (u8 *)input;
+	memcpy(name, keyname, namelen);
+	ret = storage_smc_ops(BL31_STORAGE_STATUS);
+	if (ret == RET_OK)
+		*retval = *output;
+	spin_unlock_irqrestore(&storage_lock, lockflags);
+
+	return ret;
+}
+
+int __init security_key_init(struct platform_device *pdev)
+{
+	unsigned long phy_in;
+	unsigned long phy_out;
+	unsigned long phy_block;
+
+	storage_init_status = -1;
+
+	share_mem = devm_kzalloc(&pdev->dev, sizeof(*share_mem), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(share_mem)) {
+		pr_err("fail to alloc mem for struct share_mem\n");
+		return -ENOMEM;
+	}
+
+	phy_in = storage_smc_ops(BL31_STORAGE_IN);
+	phy_out = storage_smc_ops(BL31_STORAGE_OUT);
+	phy_block = storage_smc_ops(BL31_STORAGE_BLOCK);
+	share_mem->size = storage_smc_ops(BL31_STORAGE_SIZE);
+
+	if (!phy_in || phy_in == SMC_UNK ||
+	    !phy_out || phy_out == SMC_UNK ||
+	    !phy_block || phy_block == SMC_UNK ||
+	    !(share_mem->size) || share_mem->size == SMC_UNK) {
+		pr_err("fail to obtain phy addr of shared mem\n");
+		return -EOPNOTSUPP;
+	}
+
+	/*
+	 * The BL31 shared mem for key storage is
+	 * part of secure monitor, and all of the
+	 * mem locates at lowmem region, so its
+	 * okay to call phys_to_virt directly
+	 */
+	if (pfn_valid(__phys_to_pfn(phy_in))) {
+		share_mem->in = (void __iomem *)phys_to_virt(phy_in);
+		share_mem->out = (void __iomem *)phys_to_virt(phy_out);
+		share_mem->block = (void __iomem *)phys_to_virt(phy_block);
+	}	else {
+		share_mem->in = ioremap_cache(phy_in, share_mem->size);
+		share_mem->out = ioremap_cache(phy_out, share_mem->size);
+		share_mem->block = ioremap_cache(phy_block, share_mem->size);
+	}
+
+	pr_info("storage in: 0x%lx, out: 0x%lx, block: 0x%lx\n",
+		(long)(share_mem->in), (long)(share_mem->out),
+		(long)(share_mem->block));
+
+	if (!(share_mem->in) || !(share_mem->out) || !(share_mem->block)) {
+		pr_err("fail to obtain virtual addr of shared mem\n");
+		return -EINVAL;
+	}
+
+	storage_init_status = 1;
+	pr_info("security_key init done!\n");
+	return 0;
+}
diff -Naur a/vendor/amlogic/unifykey/security_key.h b/vendor/amlogic/unifykey/security_key.h
--- a/vendor/amlogic/unifykey/security_key.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/security_key.h	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef _AML_SECURITY_KEY_H_
+#define _AML_SECURITY_KEY_H_
+
+/* internal return value*/
+#define RET_OK		0
+#define RET_EFAIL	1	/*not found*/
+#define RET_EINVAL	2	/*name length*/
+#define RET_EMEM	3	/*no enough memory*/
+#define RET_EUND	0xff
+
+#define SMC_UNK		0xffffffff
+
+#define	BL31_STORAGE_QUERY		0x82000060
+#define	BL31_STORAGE_READ		0x82000061
+#define	BL31_STORAGE_WRITE		0x82000062
+#define	BL31_STORAGE_TELL		0x82000063
+#define	BL31_STORAGE_VERIFY		0x82000064
+#define	BL31_STORAGE_STATUS		0x82000065
+#define	BL31_STORAGE_LIST		0x82000067
+#define	BL31_STORAGE_REMOVE		0x82000068
+#define	BL31_STORAGE_IN			0x82000023
+#define	BL31_STORAGE_OUT		0x82000024
+#define	BL31_STORAGE_BLOCK		0x82000025
+#define	BL31_STORAGE_SIZE		0x82000027
+#define	BL31_STORAGE_SET_ENCTYPE	0x8200006A
+#define	BL31_STORAGE_GET_ENCTYPE	0x8200006B
+#define	BL31_STORAGE_VER		0x8200006C
+
+struct bl31_storage_share_mem {
+	void __iomem  *in;
+	void __iomem  *out;
+	void __iomem  *block;
+	unsigned long size;
+};
+
+/* keyattr: 0: normal, 1: secure*/
+unsigned long secure_storage_write(u8 *name, u8 *buf, u32 len, u32 attr);
+unsigned long secure_storage_read(u8 *name, u8 *buf, u32 len, u32 *readlen);
+unsigned long secure_storage_verify(u8 *name, u8 *hashbuf);
+unsigned long secure_storage_query(u8 *name, u32 *retval);
+unsigned long secure_storage_tell(u8 *name, u32 *retval);
+unsigned long secure_storage_status(u8 *name, u32 *retval);
+void *secure_storage_getbuf(u32 *size);
+int __init security_key_init(struct platform_device *pdev);
+#endif
diff -Naur a/vendor/amlogic/unifykey/storage_key.c b/vendor/amlogic/unifykey/storage_key.c
--- a/vendor/amlogic/unifykey/storage_key.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/storage_key.c	2022-05-31 11:56:47.717259467 +0800
@@ -0,0 +1,542 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/property.h>
+#include <linux/mm.h>
+#include <linux/platform_device.h>
+#ifdef CONFIG_AMLOGIC_EFUSE
+#include <linux/amlogic/efuse.h>
+#endif
+#include <linux/amlogic/key_manage.h>
+#include "unifykey.h"
+#include "amlkey_if.h"
+#include "security_key.h"
+#include "normal_key.h"
+
+#define SECUESTORAGE_HEAD_SIZE		(256)
+#define SECUESTORAGE_WHOLE_SIZE		(0x40000)
+
+#undef pr_fmt
+#define pr_fmt(fmt) "unifykey: " fmt
+
+#define SECUREKEY_SIZE		SECUESTORAGE_WHOLE_SIZE
+
+static DEFINE_MUTEX(securekey_lock);
+u8 *securekey_prebuf;
+
+struct storagekey_info_t {
+	u8  *buffer;
+	u32 size;
+};
+
+static struct storagekey_info_t storagekey_info = {
+	.buffer = NULL,
+	/* default size */
+	.size = SECUESTORAGE_WHOLE_SIZE,
+};
+
+static struct unifykey_storage_ops ops;
+static struct unifykey_type unifykey_types = {
+	.ops = &ops,
+};
+
+static inline
+int is_valid_unifykey_storage_type(u32 storage_type)
+{
+	if (storage_type == UNIFYKEY_STORAGE_TYPE_INVALID ||
+	    storage_type >= UNIFYKEY_STORAGE_TYPE_MAX) {
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+int register_unifykey_types(struct unifykey_type *uk_type)
+{
+	u32 type;
+
+	if (!uk_type) {
+		pr_err("the uk_type is NULL\n");
+		return -EINVAL;
+	}
+	type = uk_type->storage_type;
+
+	if (!is_valid_unifykey_storage_type(type)) {
+		pr_err("not a supported unifykey storage type\n");
+		return -EINVAL;
+	}
+
+	if (is_valid_unifykey_storage_type(unifykey_types.storage_type)) {
+		pr_err("alreay registered\n");
+		return -EBUSY;
+	}
+
+	unifykey_types.storage_type = uk_type->storage_type;
+	unifykey_types.ops->read = uk_type->ops->read;
+	unifykey_types.ops->write = uk_type->ops->write;
+
+	return 0;
+}
+EXPORT_SYMBOL(register_unifykey_types);
+
+/**
+ *1.init
+ * return ok 0, fail 1
+ */
+static s32 _amlkey_init(u8 *seed, u32 len, int encrypt_type)
+{
+	s32	ret = 0;
+	u32	actual_size = 0;
+	struct unifykey_type *uk_type;
+
+	if (storagekey_info.buffer) {
+		pr_info("already init!\n");
+		goto _out;
+	}
+
+	/* get buffer from bl31 */
+	storagekey_info.buffer = secure_storage_getbuf(&storagekey_info.size);
+	if (!storagekey_info.buffer) {
+		pr_err("can't get buffer from bl31!\n");
+		ret = -EINVAL;
+		goto _out;
+	}
+
+	/* fullfill key infos from storage. */
+	if (!is_valid_unifykey_storage_type(unifykey_types.storage_type)) {
+		pr_err("check whether emmc_key/nand_key driver is enabled\n");
+		ret = -EINVAL;
+		goto _out;
+	}
+
+	uk_type = &unifykey_types;
+	if (unlikely(!uk_type->ops->read)) {
+		pr_err("the read fun for current unifykey type is NULL\n");
+		ret = -EINVAL;
+		goto _out;
+	}
+
+	ret = uk_type->ops->read(storagekey_info.buffer,
+				 storagekey_info.size,
+				 &actual_size);
+	if (ret) {
+		pr_err("fail to read key data\n");
+		memset(storagekey_info.buffer, 0, SECUESTORAGE_HEAD_SIZE);
+		goto _out;
+	}
+
+	if (actual_size >= (1U << 20)) {
+		pr_err("really need more than 1M mem? please check\n");
+		memset(storagekey_info.buffer, 0, SECUESTORAGE_HEAD_SIZE);
+		ret = -EINVAL;
+		goto _out;
+	}
+
+	storagekey_info.size = min_t(int, actual_size, storagekey_info.size);
+	pr_info("buffer=%p, size = %0x!\n", storagekey_info.buffer,
+		storagekey_info.size);
+
+_out:
+	return ret;
+}
+
+int securekey_prebuf_init(void)
+{
+	securekey_prebuf = kmalloc(SECUREKEY_SIZE, GFP_KERNEL);
+	if (!securekey_prebuf)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void securekey_prebuf_deinit(void)
+{
+	kfree(securekey_prebuf);
+}
+
+static u32 _amlkey_exsit(const u8 *name)
+{
+	unsigned long ret = 0;
+	u32	retval;
+
+	if (!name) {
+		pr_err("key name is NULL\n");
+		return 0;
+	}
+
+	ret = secure_storage_query((u8 *)name, &retval);
+	if (ret) {
+		pr_err("fail to query key %s\n", name);
+		retval = 0;
+	}
+
+	return retval;
+}
+
+static u32 _amlkey_get_attr(const u8 *name)
+{
+	unsigned long ret = 0;
+	u32	retval;
+
+	if (!name) {
+		pr_err("key name is NULL\n");
+		return 0;
+	}
+
+	ret = secure_storage_status((u8 *)name, &retval);
+	if (ret) {
+		pr_err("fail to obtain status for key %s\n", name);
+		retval = 0;
+	}
+
+	return retval;
+}
+
+static unsigned int _amlkey_size(const u8 *name)
+{
+	unsigned int	retval;
+
+	if (!name) {
+		pr_err("key name is NULL\n");
+		retval = 0;
+		goto _out;
+	}
+
+	if (secure_storage_tell((u8 *)name, &retval)) {
+		pr_err("fail to obtain size of key %s\n", name);
+		retval = 0;
+	}
+_out:
+	return retval;
+}
+
+static unsigned int _amlkey_read(const u8 *name, u8 *buffer, u32 len)
+{
+	unsigned int retval = 0;
+
+	if (!name) {
+		pr_err("key name is NULL\n");
+		retval = 0;
+		goto _out;
+	}
+	if (secure_storage_read((u8 *)name, buffer, len, &retval)) {
+		pr_err("fail to read key %s\n", name);
+		retval = 0;
+	}
+_out:
+	return retval;
+}
+
+static ssize_t _amlkey_write(const u8 *name, u8 *buffer,
+			     u32 len, u32 attr)
+{
+	ssize_t retval = 0;
+	u32	actual_length;
+	u8	*buf = NULL;
+	struct unifykey_type *uk_type;
+
+	if (!name) {
+		pr_err("key name is NULL\n");
+		return retval;
+	}
+
+	if (secure_storage_write((u8 *)name, buffer, len, attr)) {
+		pr_err("fail to write key %s\n", name);
+		retval = 0;
+		goto _out;
+	}
+
+	retval = (ssize_t)len;
+
+	if (!is_valid_unifykey_storage_type(unifykey_types.storage_type)) {
+		pr_err("error: no storage type set\n");
+		return 0;
+	}
+	uk_type = &unifykey_types;
+
+	if (!storagekey_info.buffer) {
+		retval = 0;
+		goto _out;
+	}
+
+	if (!securekey_prebuf)
+		return 0;
+
+	if (storagekey_info.size > SECUREKEY_SIZE) {
+		pr_err("%s() %d: pre alloc buffer[0x%x] is too small, need size[0x%x].\n",
+			__func__, __LINE__, SECUREKEY_SIZE, storagekey_info.size);
+		return 0;
+	}
+
+	mutex_lock(&securekey_lock);
+	memset(securekey_prebuf, 0, SECUREKEY_SIZE);
+	buf = securekey_prebuf;
+
+	memcpy(buf, storagekey_info.buffer, storagekey_info.size);
+	if (!uk_type->ops->write) {
+		pr_err("the write fun for current unifykey type is NULL\n");
+		retval = 0;
+		mutex_unlock(&securekey_lock);
+		goto _out;
+	}
+	if (uk_type->ops->write(buf, storagekey_info.size, &actual_length)) {
+		pr_err("fail to write key data to storage\n");
+		retval = 0;
+	}
+
+	mutex_unlock(&securekey_lock);
+
+_out:
+	return retval;
+}
+
+static s32 _amlkey_hash(const u8 *name, u8 *hash)
+{
+	return secure_storage_verify((u8 *)name, hash);
+}
+
+#define DEF_NORMAL_BLOCK_SIZE	(256 * 1024)
+static DEFINE_MUTEX(normalkey_lock);
+static u32 normal_blksz = DEF_NORMAL_BLOCK_SIZE;
+static u32 normal_flashsize = DEF_NORMAL_BLOCK_SIZE;
+static u8 *normal_block;
+
+static s32 _amlkey_init_normal(u8 *seed, u32 len, int encrypt_type)
+{
+	int ret;
+
+	if (!normal_block)
+		return -1;
+
+	if (!unifykey_types.ops->read) {
+		pr_err("no storage found\n");
+		return -1;
+	}
+
+	if (normalkey_init())
+		return -1;
+
+	mutex_lock(&normalkey_lock);
+	ret = unifykey_types.ops->read(normal_block,
+				       normal_blksz,
+				       &normal_flashsize);
+	if (ret) {
+		pr_err("read storage fail\n");
+		goto finish;
+	}
+
+	ret = normalkey_readfromblock(normal_block, normal_flashsize);
+	if (ret) {
+		pr_err("init block key fail\n");
+		goto finish;
+	}
+
+	ret = 0;
+finish:
+	if (ret)
+		normalkey_deinit();
+	mutex_unlock(&normalkey_lock);
+
+	return ret;
+}
+
+static u32 _amlkey_exist_normal(const u8 *name)
+{
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	mutex_unlock(&normalkey_lock);
+
+	return !!obj;
+}
+
+static u32 _amlkey_get_attr_normal(const u8 *name)
+{
+	u32 attr = 0;
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	if (obj)
+		attr = obj->attribute;
+	mutex_unlock(&normalkey_lock);
+
+	return attr;
+}
+
+static unsigned int _amlkey_size_normal(const u8 *name)
+{
+	unsigned int size = 0;
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	if (obj)
+		size = obj->datasize;
+	mutex_unlock(&normalkey_lock);
+
+	return size;
+}
+
+static unsigned int _amlkey_read_normal(const u8 *name, u8 *buffer, u32 len)
+{
+	unsigned int size = 0;
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	if (obj && len >= obj->datasize) {
+		size = obj->datasize;
+		memcpy(buffer, obj->dataptr, size);
+	}
+	mutex_unlock(&normalkey_lock);
+
+	return size;
+}
+
+static ssize_t _amlkey_write_normal(const u8 *name, u8 *buffer,
+				    u32 len, u32 attr)
+{
+	int ret;
+	u32 wrtsz = 0;
+
+	if (attr & OBJ_ATTR_SECURE) {
+		pr_err("can't write secure key\n");
+		return 0;
+	}
+
+	if (!unifykey_types.ops->write) {
+		pr_err("no storage found\n");
+		return 0;
+	}
+
+	mutex_lock(&normalkey_lock);
+	ret = normalkey_add(name, buffer, len, attr);
+	if (ret) {
+		pr_err("write key fail\n");
+		ret = 0;
+		goto unlock;
+	}
+
+	ret = normalkey_writetoblock(normal_block, normal_flashsize);
+	if (ret) {
+		pr_err("write block fail\n");
+		ret = 0;
+		goto unlock;
+	}
+
+	ret = unifykey_types.ops->write(normal_block,
+					normal_flashsize,
+					&wrtsz);
+	if (ret) {
+		pr_err("write storage fail\n");
+		ret = 0;
+		goto unlock;
+	}
+	ret = len;
+unlock:
+	mutex_unlock(&normalkey_lock);
+	return ret;
+}
+
+static s32 _amlkey_hash_normal(const u8 *name, u8 *hash)
+{
+	int ret = -1;
+	struct storage_object *obj;
+
+	mutex_lock(&normalkey_lock);
+	obj = normalkey_get(name);
+	if (obj) {
+		ret = 0;
+		memcpy(hash, obj->hashptr, 32);
+	}
+	mutex_unlock(&normalkey_lock);
+
+	return ret;
+}
+
+int normal_key_init(struct platform_device *pdev)
+{
+	u32 blksz;
+	int ret;
+
+	ret = device_property_read_u32(&pdev->dev, "blocksize", &blksz);
+	if (!ret && blksz && PAGE_ALIGNED(blksz)) {
+		normal_blksz = blksz;
+		pr_info("block size from config: %x\n", blksz);
+	}
+
+	normal_block = kmalloc(normal_blksz, GFP_KERNEL);
+	if (!normal_block)
+		return -1;
+
+	return 0;
+}
+
+void normal_key_deinit(void)
+{
+	kfree(normal_block);
+}
+
+enum amlkey_if_type {
+	IFTYPE_SECURE_STORAGE,
+	IFTYPE_NORMAL_STORAGE,
+	IFTYPE_MAX
+};
+
+struct amlkey_if amlkey_ifs[] = {
+	[IFTYPE_SECURE_STORAGE] = {
+		.init = _amlkey_init,
+		.exsit = _amlkey_exsit,
+		.get_attr = _amlkey_get_attr,
+		.size = _amlkey_size,
+		.read = _amlkey_read,
+		.write = _amlkey_write,
+		.hash = _amlkey_hash,
+	},
+	[IFTYPE_NORMAL_STORAGE] = {
+		.init = _amlkey_init_normal,
+		.exsit = _amlkey_exist_normal,
+		.get_attr = _amlkey_get_attr_normal,
+		.size = _amlkey_size_normal,
+		.read = _amlkey_read_normal,
+		.write = _amlkey_write_normal,
+		.hash = _amlkey_hash_normal,
+	}
+};
+
+struct amlkey_if *amlkey_if;
+
+int __init amlkey_if_init(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = security_key_init(pdev);
+	if (ret != -EOPNOTSUPP) {
+		amlkey_if = &amlkey_ifs[IFTYPE_SECURE_STORAGE];
+		ret = securekey_prebuf_init();
+		return ret;
+	}
+
+	pr_info("normal key used!\n");
+	ret = normal_key_init(pdev);
+	amlkey_if = &amlkey_ifs[IFTYPE_NORMAL_STORAGE];
+
+	return ret;
+}
+
+void amlkey_if_deinit(void)
+{
+	securekey_prebuf_deinit();
+
+	normal_key_deinit();
+}
diff -Naur a/vendor/amlogic/unifykey/unifykey.c b/vendor/amlogic/unifykey/unifykey.c
--- a/vendor/amlogic/unifykey/unifykey.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/unifykey.c	2022-05-31 11:56:47.721259431 +0800
@@ -0,0 +1,1368 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/cdev.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/ctype.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+#if defined(CONFIG_AMLOGIC_EFUSE)
+#include <linux/amlogic/efuse.h>
+#endif
+#include "unifykey.h"
+#include "amlkey_if.h"
+
+#undef pr_fmt
+#define pr_fmt(fmt) "unifykey: " fmt
+
+#define UNIFYKEYS_DEVICE_NAME    "unifykeys"
+#define UNIFYKEYS_CLASS_NAME     "unifykeys"
+
+#define KEY_EMPTY	0
+#define KEY_BURNED	1
+
+#define SHA256_SUM_LEN	32
+#define DBG_DUMP_DATA	(0)
+
+typedef int (*key_unify_dev_init)(struct key_info_t *uk_info,
+				  char *buf, unsigned int len);
+
+static struct aml_uk_dev *ukdev_global;
+
+/*
+ * This strange API is for LCD driver to call my internal APIs,
+ * And I donnot understand why they need to do this
+ */
+void  *get_ukdev(void)
+{
+	return ukdev_global;
+}
+EXPORT_SYMBOL(get_ukdev);
+
+static struct key_item_t *uk_find_item_by_name(struct list_head *list,
+					       char *name)
+{
+	struct key_item_t *item;
+
+	list_for_each_entry(item, list, node)
+		if (!strncmp(item->name, name,
+			     ((strlen(item->name) > strlen(name)) ?
+			     strlen(item->name) : strlen(name))))
+			return item;
+
+	return NULL;
+}
+
+static struct key_item_t *uk_find_item_by_id(struct list_head *list, int id)
+{
+	struct key_item_t *item;
+
+	list_for_each_entry(item, list, node)
+		if (item->id == id)
+			return item;
+
+	return NULL;
+}
+
+static int uk_count_key(struct list_head *list)
+{
+	int		 count = 0;
+	struct list_head *node;
+
+	list_for_each(node, list)
+		count++;
+
+	return count;
+}
+
+static int key_storage_read(char *name, unsigned char *data,
+			    unsigned int len, unsigned int *real,
+			    int flag)
+{
+	int	ret = 0;
+	unsigned int read_len = 0;
+	u32	encrypt;
+	u32	encrypt_dts;
+
+	if (amlkey_get_attr((u8 *)name) & KEY_ATTR_SECURE) {
+		pr_err("key[%s] can't read, is configured secured?\n", name);
+		return -EINVAL;
+	}
+
+	/* make sure attr in storage & dts are the same! */
+	encrypt = amlkey_get_attr((u8 *)name) & KEY_ATTR_ENCRYPT;
+
+	encrypt_dts = (u32)(flag & KEY_ATTR_ENCRYPT) ? 1 : 0;
+	if (encrypt != encrypt_dts) {
+		pr_err("key[%s] can't read, encrypt?\n", name);
+		return -EINVAL;
+	}
+
+	read_len = amlkey_read((u8 *)name, (u8 *)data, len);
+	if (read_len != len) {
+		pr_err("key[%s], want read %u Bytes, but %u bytes\n",
+		       name, len, read_len);
+		return -EINVAL;
+	}
+	*real = read_len;
+	return ret;
+}
+
+static int key_efuse_write(char *name, unsigned char *data, unsigned int len)
+{
+#if defined(CONFIG_AMLOGIC_EFUSE)
+	struct efusekey_info info;
+
+	if (efuse_getinfo(name, &info) < 0)
+		return -EINVAL;
+
+	if (efuse_user_attr_store(name, (const char *)data, (size_t)len) < 0) {
+		pr_err("efuse write fail.\n");
+		return -1;
+	}
+
+	pr_info("%s written done.\n", info.keyname);
+	return 0;
+#else
+	pr_err("efusekey not supported!\n");
+	return -EINVAL;
+#endif
+}
+
+static int key_efuse_read(char *name, unsigned char *data,
+			  unsigned int len, unsigned int *real)
+{
+#if defined(CONFIG_AMLOGIC_EFUSE)
+	struct efusekey_info info;
+	int		     err = 0;
+	char		     *buf;
+
+	if (efuse_getinfo(name, &info) < 0)
+		return -EINVAL;
+
+	buf = kzalloc(info.size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	err = efuse_user_attr_read(name, buf);
+	if (err >= 0) {
+		*real = info.size;
+		if (len > info.size)
+			len = info.size;
+		memcpy(data, buf, len);
+	}
+	kfree(buf);
+	return err;
+#else
+	pr_err("efusekey not supported!\n");
+	return -EINVAL;
+#endif
+}
+
+static int key_efuse_query(char *name, unsigned int *state)
+{
+#if defined(CONFIG_AMLOGIC_EFUSE)
+	int		     i;
+	int		     err = 0;
+	struct efusekey_info info;
+	char		     *buf;
+
+	if (efuse_getinfo(name, &info) < 0)
+		return -EINVAL;
+	buf = kzalloc(info.size, GFP_KERNEL);
+	if (!buf) {
+		pr_err("%s:%d,kzalloc mem fail\n", __func__, __LINE__);
+		return -ENOMEM;
+	}
+	err = efuse_user_attr_read(name, buf);
+	*state = KEY_EMPTY;
+	if (err > 0) {
+		for (i = 0; i < info.size; i++) {
+			if (buf[i] != 0) {
+				*state = KEY_BURNED;
+				break;
+			}
+		}
+	}
+	kfree(buf);
+	return err;
+#else
+	pr_err("efusekey not supported!\n");
+	return -EINVAL;
+#endif
+}
+
+static int key_unify_init(struct aml_uk_dev *ukdev, char *buf,
+			  unsigned int len)
+{
+	int ret;
+	int enc_type;
+
+	if (unlikely(!ukdev))
+		return -EINVAL;
+
+	if (ukdev->init_flag == 1) {
+		pr_info("already inited!\n");
+		return 0;
+	}
+
+	enc_type = ukdev->uk_info.encrypt_type;
+	ret = amlkey_init((u8 *)buf, len, enc_type);
+	if (ret < 0) {
+		pr_err("device init fail\n");
+		return ret;
+	}
+
+	ukdev->init_flag = 1;
+	return 0;
+}
+
+int key_unify_write(struct aml_uk_dev *ukdev, char *name,
+		    unsigned char *data, unsigned int len)
+{
+	int		  ret = 0;
+	int		  attr;
+	struct key_item_t *key;
+	ssize_t write_len = 0;
+
+	key = uk_find_item_by_name(&ukdev->uk_hdr, name);
+	if (!key) {
+		pr_err("can not find key %s\n", name);
+		return -EINVAL;
+	}
+
+	if ((key->perm & KEY_PERM_WRITE) != KEY_PERM_WRITE) {
+		pr_err("no write permission for key %s\n", name);
+		return -EPERM;
+	}
+
+	switch (key->dev) {
+	case KEY_EFUSE:
+		ret = key_efuse_write(name, data, len);
+		break;
+	case KEY_SECURE:
+	case KEY_NORMAL:
+		attr = ((key->dev == KEY_SECURE) ? KEY_ATTR_SECURE : 0);
+		attr |= (key->attr & KEY_ATTR_ENCRYPT) ? KEY_ATTR_ENCRYPT : 0;
+		write_len = amlkey_write((u8 *)name, (u8 *)data, len, attr);
+		if (write_len != len) {
+			pr_err("%u != %zd bytes\n", len, write_len);
+			ret = -EINVAL;
+		}
+		break;
+	case KEY_UNKNOWN_DEV:
+	default:
+		pr_err("unknown device for key %s\n", name);
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(key_unify_write);
+
+int key_unify_read(struct aml_uk_dev *ukdev, char *name,
+		   unsigned char *data, unsigned int len,
+		   unsigned int *real)
+{
+	int ret = 0;
+	struct key_item_t *key;
+
+	if (!data) {
+		pr_err("key data is NULL\n");
+		return -EINVAL;
+	}
+
+	key = uk_find_item_by_name(&ukdev->uk_hdr, name);
+	if (!key) {
+		pr_err("key %s does not exist\n", name);
+		return -EINVAL;
+	}
+
+	if ((key->perm & KEY_PERM_READ) != KEY_PERM_READ) {
+		pr_err("no read permission for key %s\n", name);
+		return -EPERM;
+	}
+
+	switch (key->dev) {
+	case KEY_EFUSE:
+		ret = key_efuse_read(name, data, len, real);
+			break;
+	case KEY_SECURE:
+		ret = amlkey_hash((u8 *)name, data);
+		if (ret)
+			pr_err("fail to obtain hash for key %s\n", name);
+		*real = SHA256_SUM_LEN;
+		break;
+	case KEY_NORMAL:
+		ret = key_storage_read(name, data, len, real, key->attr);
+		break;
+	case KEY_UNKNOWN_DEV:
+	default:
+		pr_err("unknown device for key %s\n", name);
+		break;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(key_unify_read);
+
+int key_unify_size(struct aml_uk_dev *ukdev, char *name, unsigned int *real)
+{
+	int		  ret = 0;
+	struct key_item_t *key;
+
+	key = uk_find_item_by_name(&ukdev->uk_hdr, name);
+	if (!key) {
+		pr_err("key %s does not exist\n", name);
+		return -EINVAL;
+	}
+
+	if ((key->perm & KEY_PERM_READ) != KEY_PERM_READ) {
+		pr_err("no read permission for key %s\n", name);
+		return -EPERM;
+	}
+
+	switch (key->dev) {
+	case KEY_EFUSE:
+#if defined(CONFIG_AMLOGIC_EFUSE)
+	{
+		struct efusekey_info info;
+
+		ret = efuse_getinfo(name, &info);
+		if (ret == 0)
+			*real = info.size;
+	}
+#else
+		pr_err("does not support efusekey\n");
+#endif
+		break;
+	case KEY_SECURE:
+	case KEY_NORMAL:
+		*real = amlkey_size((u8 *)name);
+		break;
+	case KEY_UNKNOWN_DEV:
+	default:
+		pr_err("unknown device for key %s\n", name);
+		break;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(key_unify_size);
+
+int key_unify_query(struct aml_uk_dev *ukdev, char *name,
+		    unsigned int *state, unsigned int *perm)
+{
+	int		  ret = 0;
+	struct key_item_t *key;
+
+	key = uk_find_item_by_name(&ukdev->uk_hdr, name);
+	if (!key) {
+		pr_err("can not find key %s\n", name);
+		return -EINVAL;
+	}
+
+	if ((key->perm & KEY_PERM_READ) != KEY_PERM_READ) {
+		pr_err("no read permission for key %s\n", name);
+		return -EINVAL;
+	}
+
+	switch (key->dev) {
+	case KEY_EFUSE:
+		ret = key_efuse_query(name, state);
+		*perm = key->perm;
+		break;
+	case KEY_SECURE:
+	case KEY_NORMAL:
+		if (state)
+			*state = amlkey_exsit((u8 *)name) ?
+					KEY_BURNED : KEY_EMPTY;
+		if (perm)
+			*perm = key->perm;
+		break;
+	case KEY_UNKNOWN_DEV:
+	default:
+		pr_err("unknown device for key %s\n", name);
+		break;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(key_unify_query);
+
+int key_unify_secure(struct aml_uk_dev *ukdev, char *name,
+		     unsigned int *secure)
+{
+	int		  ret = 0;
+	struct key_item_t *key;
+	unsigned int	  state;
+
+	key = uk_find_item_by_name(&ukdev->uk_hdr, name);
+	if (!key) {
+		pr_err("can not find key %s\n", name);
+		return -EINVAL;
+	}
+
+	/* check key burned or not */
+	ret = key_unify_query(ukdev, key->name, &state, NULL);
+	if (ret != 0)
+		return ret;
+
+	*secure = 0;
+	if (state == KEY_BURNED) {
+		*secure = amlkey_get_attr((u8 *)(key->name)) & KEY_ATTR_SECURE;
+	} else {
+		if (key->dev == KEY_SECURE)
+			*secure = 1;
+		else
+			*secure = 0;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(key_unify_secure);
+
+int key_unify_encrypt(struct aml_uk_dev *ukdev, char *name, unsigned int *enc)
+{
+	int		  ret = 0;
+	struct key_item_t *key;
+	unsigned int	  state;
+
+	key = uk_find_item_by_name(&ukdev->uk_hdr, name);
+	if (!key) {
+		pr_err("can not find key %s\n", name);
+		return -EINVAL;
+	}
+
+	/* check key burned or not */
+	ret = key_unify_query(ukdev, key->name, &state, NULL);
+	if (ret != 0)
+		return ret;
+
+	*enc = 0;
+
+	if (state == KEY_BURNED)
+		*enc = amlkey_get_attr((u8 *)(key->name)) & KEY_ATTR_ENCRYPT;
+	else
+		if (key->attr & KEY_ATTR_ENCRYPT)
+			*enc = 1;
+
+	return ret;
+}
+EXPORT_SYMBOL(key_unify_encrypt);
+
+int key_unify_get_init_flag(void)
+{
+	if (ukdev_global)
+		return ukdev_global->init_flag;
+	pr_info("%s: ukdev_global is null\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL(key_unify_get_init_flag);
+
+static int unifykey_open(struct inode *inode, struct file *file)
+{
+	struct aml_uk_dev *ukdev;
+
+	ukdev = container_of(inode->i_cdev, struct aml_uk_dev, cdev);
+	file->private_data = ukdev;
+
+	return 0;
+}
+
+static int unifykey_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static loff_t unifykey_llseek(struct file *filp, loff_t off, int whence)
+{
+	struct aml_uk_dev *ukdev;
+	loff_t			newpos;
+
+	ukdev = filp->private_data;
+
+	switch (whence) {
+	case 0: /* SEEK_SET (start postion)*/
+		newpos = off;
+		break;
+
+	case 1: /* SEEK_CUR */
+		newpos = filp->f_pos + off;
+		break;
+
+	case 2: /* SEEK_END */
+		newpos = (loff_t)uk_count_key(&ukdev->uk_hdr) - 1;
+		newpos = newpos - off;
+		break;
+
+	default: /* can't happen */
+		return -EINVAL;
+	}
+
+	if (newpos < 0)
+		return -EINVAL;
+	if (newpos >= (loff_t)uk_count_key(&ukdev->uk_hdr))
+		return -EINVAL;
+	filp->f_pos = newpos;
+
+	return newpos;
+}
+
+static long unifykey_unlocked_ioctl(struct file *file,
+				    unsigned int cmd,
+				    unsigned long arg)
+{
+	struct aml_uk_dev *ukdev;
+	void __user		*argp = (void __user *)arg;
+	struct key_item_t *key;
+	struct key_item_info_t *item;
+	unsigned int perm, state;
+	int ret;
+
+	ukdev = file->private_data;
+
+	switch (cmd) {
+	case KEYUNIFY_ATTACH:
+		key = kmalloc(sizeof(*key), GFP_KERNEL);
+		if (!key)
+			return -ENOMEM;
+		ret = copy_from_user(key, argp, sizeof(*key));
+		if (ret != 0) {
+			pr_err("copy_from_user fail\n");
+			kfree(key);
+			return ret;
+		}
+		ret = key_unify_init(ukdev, key->name, KEY_UNIFY_NAME_LEN);
+		kfree(key);
+		if (ret != 0)
+			return ret;
+		break;
+	case KEYUNIFY_GET_INFO:
+		item = kmalloc(sizeof(*item), GFP_KERNEL);
+		if (!item)
+			return -ENOMEM;
+		ret = copy_from_user(item, argp, sizeof(*item));
+		if (ret != 0) {
+			pr_err("copy_from_user fail\n");
+			kfree(item);
+			return ret;
+		}
+
+		item->name[KEY_UNIFY_NAME_LEN - 1] = '\0';
+		if (strlen(item->name))
+			key = uk_find_item_by_name(&ukdev->uk_hdr, item->name);
+		else
+			key = uk_find_item_by_id(&ukdev->uk_hdr, item->id);
+		if (!key) {
+			pr_err("can not find key\n");
+			kfree(item);
+			return -EINVAL;
+		}
+		pr_err("%d, %s\n", key->id, key->name);
+
+		ret = key_unify_query(ukdev, key->name, &state, &perm);
+		if (ret != 0) {
+			pr_err("fail to query key: %s\n", key->name);
+			kfree(item);
+			return ret;
+		}
+		item->perm = perm;
+		item->flag = state;
+		item->id = key->id;
+		strncpy(item->name, key->name, (KEY_UNIFY_NAME_LEN - 1));
+		item->name[KEY_UNIFY_NAME_LEN - 1] = '\0';
+		ret = key_unify_size(ukdev, key->name, &item->size);
+		if (ret != 0) {
+			pr_err("fail to obtain key size of %s\n", key->name);
+			kfree(item);
+			return -EFAULT;
+		}
+
+		ret = copy_to_user(argp, item, sizeof(*item));
+		if (ret != 0) {
+			pr_err("copy_to_user fail\n");
+			kfree(item);
+			return ret;
+		}
+
+		kfree(item);
+		return 0;
+	default:
+		pr_err("unsupported ioctrl cmd\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+static long unifykey_compat_ioctl(struct file *file,
+				  unsigned int cmd,
+				  unsigned long arg)
+{
+	return unifykey_unlocked_ioctl(file, cmd,
+				(unsigned long)compat_ptr(arg));
+}
+#endif
+
+static ssize_t unifykey_read(struct file *file,
+			     char __user *buf,
+			     size_t count,
+			     loff_t *ppos)
+{
+	struct aml_uk_dev *ukdev;
+	int			ret;
+	int			id;
+	unsigned int		reallen;
+	struct key_item_t	*item;
+	char			*local_buf = NULL;
+
+	ukdev = file->private_data;
+
+	id = (int)(*ppos);
+	item = uk_find_item_by_id(&ukdev->uk_hdr, id);
+	if (!item) {
+		ret =  -EINVAL;
+		goto exit;
+	}
+
+	if (item->dev == KEY_SECURE)
+		count = SHA256_SUM_LEN;
+	local_buf = kzalloc(count, GFP_KERNEL);
+	if (!local_buf) {
+		pr_err("memory not enough,%s:%d\n",
+		       __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	ret = key_unify_read(ukdev, item->name, local_buf, count, &reallen);
+	if (ret < 0)
+		goto exit;
+	if (count > reallen)
+		count = reallen;
+	if (copy_to_user((void *)buf, (void *)local_buf, count)) {
+		ret =  -EFAULT;
+		goto exit;
+	}
+	ret = count;
+exit:
+	kfree(local_buf);
+	return ret;
+}
+
+static ssize_t unifykey_write(struct file *file,
+			      const char __user *buf,
+			      size_t count, loff_t *ppos)
+{
+	struct aml_uk_dev *ukdev;
+	int			ret;
+	int			id;
+	struct key_item_t	*item;
+	char			*local_buf;
+
+	ukdev = file->private_data;
+
+	local_buf = kzalloc(count, GFP_KERNEL);
+	if (!local_buf)
+		return -ENOMEM;
+
+	id = (int)(*ppos);
+	item = uk_find_item_by_id(&ukdev->uk_hdr, id);
+	if (!item) {
+		ret =  -EINVAL;
+		goto exit;
+	}
+	if (copy_from_user(local_buf, buf, count)) {
+		ret =  -EFAULT;
+		goto exit;
+	}
+
+	ret = key_unify_write(ukdev, item->name, local_buf, count);
+	if (ret < 0)
+		goto exit;
+	ret = count;
+exit:
+	kfree(local_buf);
+	return ret;
+}
+
+static ssize_t version_show(struct class *cla,
+			    struct class_attribute *attr,
+			    char *buf)
+{
+	ssize_t n = 0;
+
+	n = sprintf(buf, "version:1.0\n");
+	buf[n] = 0;
+
+	return n;
+}
+
+static ssize_t list_show(struct class *cla,
+			 struct class_attribute *attr,
+			 char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	ssize_t			n = 0;
+	int			index;
+	int			key_cnt;
+	struct key_item_t	*unifykey;
+	const char *const keydev[] = {
+		"unknown", "efuse", "normal", "secure"};
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+
+	key_cnt = uk_count_key(&ukdev->uk_hdr);
+	n = sprintf(&buf[0], "%d keys installed\n", key_cnt);
+
+	for (index = 0; index < key_cnt; index++) {
+		unifykey = uk_find_item_by_id(&ukdev->uk_hdr, index);
+		if (unifykey)
+			n += sprintf(&buf[n], "%02d: %s, %s, %x\n",
+				index, unifykey->name,
+				keydev[unifykey->dev], unifykey->perm);
+	}
+	buf[n] = 0;
+
+	return n;
+}
+
+static ssize_t exist_show(struct class *cla,
+			  struct class_attribute *attr,
+			  char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	struct key_item_t	*curkey;
+	ssize_t			n = 0;
+	int			ret;
+	unsigned int		keystate;
+	unsigned int		keypermit;
+	static const char *const state[] = {"none", "exist", "unknown"};
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	curkey = ukdev->curkey;
+
+	if (!curkey) {
+		pr_err("please set key name first, %s:%d\n",
+		       __func__, __LINE__);
+		return -EINVAL;
+	}
+	/* using current key*/
+	ret = key_unify_query(ukdev, curkey->name, &keystate, &keypermit);
+	if (ret < 0) {
+		pr_err("%s:%d, key_unify_query failed!\n",
+		       __func__, __LINE__);
+		return 0;
+	}
+
+	if (keystate > 2)
+		keystate = 2;
+
+	n = sprintf(buf, "%s\n", state[keystate]);
+	buf[n] = 0;
+
+	return n;
+}
+
+static ssize_t secure_show(struct class *cla,
+			   struct class_attribute *attr,
+			   char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	struct key_item_t	*curkey;
+	ssize_t			n = 0;
+	int			ret;
+	unsigned int		secure = 0;
+	static const char * const state[] = {"false", "true", "error"};
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	curkey = ukdev->curkey;
+	if (!curkey) {
+		pr_err("please set key name first, %s:%d\n",
+		       __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	/* using current key*/
+	ret = key_unify_secure(ukdev, curkey->name, &secure);
+	if (ret < 0) {
+		pr_err("%s:%d, key_unify_secure failed!\n",
+		       __func__, __LINE__);
+		secure = 2;
+		goto _out;
+	}
+
+	if (secure > 1)
+		secure = 1;
+_out:
+	n = sprintf(buf, "%s\n", state[secure]);
+	buf[n] = 0;
+
+	return n;
+}
+
+static ssize_t encrypt_show(struct class *cla,
+			    struct class_attribute *attr,
+			    char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	struct key_item_t	*curkey;
+	ssize_t			n = 0;
+	int			ret;
+	unsigned int		encrypt;
+	static const char * const state[] = {"false", "true", "error"};
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	curkey = ukdev->curkey;
+	if (!curkey) {
+		pr_err("please set key name first, %s:%d\n",
+		       __func__, __LINE__);
+		return -EINVAL;
+	}
+
+	/* using current key*/
+	ret = key_unify_encrypt(ukdev, curkey->name, &encrypt);
+	if (ret < 0) {
+		pr_err("%s:%d, key_unify_query failed!\n",
+		       __func__, __LINE__);
+		encrypt = 2;
+		goto _out;
+	}
+
+	if (encrypt > 1)
+		encrypt = 1;
+_out:
+	n = sprintf(buf, "%s\n", state[encrypt]);
+	buf[n] = 0;
+
+	return n;
+}
+
+static ssize_t size_show(struct class *cla,
+			 struct class_attribute *attr,
+			 char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	struct key_item_t	*curkey;
+	ssize_t			n = 0;
+	int			ret;
+	unsigned int		reallen;
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	curkey = ukdev->curkey;
+	if (!curkey) {
+		pr_err("please set key name first, %s:%d\n",
+		       __func__, __LINE__);
+		return -EINVAL;
+	}
+	/* using current key*/
+	ret = key_unify_size(ukdev, curkey->name, &reallen);
+	if (ret < 0) {
+		pr_err("%s:%d, key_unify_query failed!\n",
+		       __func__, __LINE__);
+		return 0;
+	}
+
+	n = sprintf(buf, "%d\n", reallen);
+	buf[n] = 0;
+
+	return n;
+}
+
+static ssize_t name_show(struct class *cla,
+			 struct class_attribute *attr,
+			 char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	struct key_item_t	*curkey;
+	ssize_t			n = 0;
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	curkey = ukdev->curkey;
+	if (!curkey) {
+		pr_err("please set cur key name,%s:%d\n", __func__, __LINE__);
+		return 0;
+	}
+
+	n = sprintf(buf, "%s\n", curkey->name);
+	buf[n] = 0;
+
+	return n;
+}
+
+static ssize_t name_store(struct class *cla,
+			  struct class_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct aml_uk_dev *ukdev;
+	struct key_item_t	*curkey;
+	char			*name;
+	int			index;
+	int			key_cnt;
+	struct key_item_t	*unifykey = NULL;
+	size_t			query_name_len;
+	size_t			reval;
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	curkey = ukdev->curkey;
+
+	if (count >= KEY_UNIFY_NAME_LEN)
+		count = KEY_UNIFY_NAME_LEN - 1;
+
+	if (count <= 0) {
+		pr_err(" count=%zd is invalid in %s\n", count, __func__);
+		return -EINVAL;
+	}
+
+	key_cnt = uk_count_key(&ukdev->uk_hdr);
+	name = kzalloc(count + 1, GFP_KERNEL);
+	if (!name) {
+		pr_err("can't kzalloc mem,%s:%d\n",
+		       __func__, __LINE__);
+		return -EINVAL;
+	}
+	/* check '\n' and del */
+	if (buf[count - 1] == '\n')
+		memcpy(name, buf, count - 1);
+	else
+		memcpy(name, buf, count);
+
+	query_name_len = strlen(name);
+	pr_info("%s() %d, name %s, %d\n", __func__, __LINE__,
+		name, (int)query_name_len);
+
+	curkey = NULL;
+	for (index = 0; index < key_cnt; index++) {
+		unifykey = uk_find_item_by_id(&ukdev->uk_hdr, index);
+		if (unifykey) {
+			if (!strncmp(name, unifykey->name,
+				     ((strlen(unifykey->name) > query_name_len)
+				     ? strlen(unifykey->name) : query_name_len))
+			) {
+				pr_info("%s() %d\n", __func__, __LINE__);
+				curkey = unifykey;
+				break;
+			}
+		}
+	}
+	reval = count;
+	if (!curkey) {
+		pr_err("could not found key %s\n", name);
+		kfree(name);
+		return -EINVAL;
+	}
+	ukdev->curkey = curkey;
+
+	kfree(name);
+	return reval;
+}
+
+static ssize_t read_show(struct class *cla,
+			 struct class_attribute *attr,
+			 char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	struct key_item_t	*curkey;
+	ssize_t			n = 0;
+	unsigned int		keysize;
+	unsigned int		reallen;
+	int			ret;
+	unsigned char		*keydata = NULL;
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	curkey = ukdev->curkey;
+	if (curkey) {
+		/* get key value */
+		ret = key_unify_size(ukdev, curkey->name, &keysize);
+		if (ret < 0) {
+			pr_err("%s() %d: get key size fail\n",
+			       __func__, __LINE__);
+			goto _out;
+		}
+		if (keysize == 0) {
+			pr_err("%s() %d: key %s may not burned yet!\n",
+			       __func__, __LINE__, curkey->name);
+			goto _out;
+		}
+		if (curkey->dev == KEY_SECURE)
+			keysize = SHA256_SUM_LEN;
+		pr_err("name: %s, size %d\n", curkey->name, keysize);
+		keydata = kzalloc(keysize, GFP_KERNEL);
+		if (!keydata) {
+			pr_err("%s() %d: no enough memory\n",
+			       __func__, __LINE__);
+			goto _out;
+		}
+		ret = key_unify_read(ukdev, curkey->name,
+				     keydata, keysize, &reallen);
+		if (ret < 0) {
+			pr_err("%s() %d: get key size fail\n",
+			       __func__, __LINE__);
+			goto _out;
+		}
+
+		memcpy(buf, keydata, keysize);
+		n = keysize;
+		buf[n] = 0;
+	}
+_out:
+	if (!IS_ERR_OR_NULL(keydata))
+		kfree(keydata);
+
+	return n;
+}
+
+static ssize_t write_store(struct class *cla,
+			   struct class_attribute *attr,
+			   const char *buf, size_t count)
+{
+	struct aml_uk_dev *ukdev;
+	struct key_item_t	*curkey;
+	int			ret;
+	unsigned char		*keydata = NULL;
+	size_t			key_len = 0;
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	curkey = ukdev->curkey;
+
+	if (count <= 0) {
+		pr_err(" count=%zd is invalid in %s\n", count, __func__);
+		return -EINVAL;
+	}
+
+	if (curkey) {
+		keydata = kzalloc(count, GFP_KERNEL);
+
+		if (!keydata)
+			goto _out;
+
+		/* check string */
+		for (key_len = 0; key_len < count; key_len++)
+			if (!isascii(buf[key_len]))
+				break;
+		/* check '\n' and del while string */
+		if (key_len == count && (buf[count - 1] == '\n')) {
+			pr_err("%s()  is a string\n", __func__);
+			memcpy(keydata, buf, count - 1);
+			key_len = count - 1;
+		} else {
+			memcpy(keydata, buf, count);
+			key_len = count;
+		}
+
+		ret = key_unify_write(ukdev, curkey->name, keydata, key_len);
+		if (ret < 0) {
+			pr_err("%s() %d: key write fail\n",
+			       __func__, __LINE__);
+			goto _out;
+		}
+	}
+_out:
+	kfree(keydata);
+	keydata = NULL;
+
+	return count;
+}
+
+static ssize_t attach_show(struct class *cla,
+			   struct class_attribute *attr,
+			   char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	ssize_t n = 0;
+
+	/* show attach status. */
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	n = sprintf(buf, "%s\n", (ukdev->init_flag == 0 ? "no" : "yes"));
+	buf[n] = 0;
+
+	return n;
+}
+
+static ssize_t attach_store(struct class *cla,
+			    struct class_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct aml_uk_dev *ukdev;
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	key_unify_init(ukdev, NULL, KEY_UNIFY_NAME_LEN);
+
+	return count;
+}
+
+static ssize_t lock_show(struct class *cla,
+			 struct class_attribute *attr,
+			 char *buf)
+{
+	struct aml_uk_dev *ukdev;
+	ssize_t n = 0;
+
+	/* show lock state. */
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+	n = sprintf(buf, "%d\n", ukdev->lock_flag);
+	buf[n] = 0;
+	pr_info("%s\n", (ukdev->lock_flag == 1 ? "locked" : "unlocked"));
+
+	return n;
+}
+
+static ssize_t lock_store(struct class *cla,
+			  struct class_attribute *attr,
+			  const char *buf, size_t count)
+{
+	struct aml_uk_dev *ukdev;
+	unsigned int state, len;
+
+	ukdev = container_of(cla, struct aml_uk_dev, cls);
+
+	if (count <= 0) {
+		pr_err("count=%zd is invalid in %s\n", count, __func__);
+		return -EINVAL;
+	}
+
+	/* check '\n' and del */
+	if (buf[count - 1] == '\n')
+		len = count - 1;
+	else
+		len = count;
+
+	if (!strncmp(buf, "1", len)) {
+		state = 1;
+	} else if (!strncmp(buf, "0", len)) {
+		state = 0;
+	} else {
+		pr_info("unifykey lock set fail\n");
+		return -EINVAL;
+	}
+
+	ukdev->lock_flag = state;
+	pr_info("unifykey is %s\n",
+		(ukdev->lock_flag == 1 ? "locked" : "unlocked"));
+	return count;
+}
+
+static const char *unifykeys_help_str = {
+"Usage:\n"
+"echo 1 > attach //initialise unifykeys\n"
+"cat lock //get lock status\n"
+"//if lock=1,you must wait, lock=0, you can go on\n"
+"//so you must set unifykey lock first, then do other operations\n"
+"echo 1 > lock //1:locked, 0:unlocked\n"
+"echo \"key name\" > name //set current key name->\"key name\"\n"
+"cat name //get current key name\n"
+"echo \"key value\" > write //set current key value->\"key value\"\n"
+"cat read //get current key value\n"
+"cat size //get current key value\n"
+"cat exist //get whether current key is exist or not\n"
+"cat list //get all unifykeys\n"
+"cat version //get unifykeys versions\n"
+"//at last, you must set lock=0 when you has done all operations\n"
+"echo 0 > lock //set unlock\n"
+};
+
+static ssize_t help_show(struct class *cla,
+			 struct class_attribute *attr,
+			 char *buf)
+{
+	ssize_t n = 0;
+
+	n = sprintf(buf, "%s", unifykeys_help_str);
+	buf[n] = 0;
+
+	return n;
+}
+
+static const struct of_device_id unifykeys_dt_match[];
+
+static char *get_unifykeys_drv_data(struct platform_device *pdev)
+{
+	char *key_dev = NULL;
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+
+		match = of_match_node(unifykeys_dt_match,
+				      pdev->dev.of_node);
+		if (match)
+			key_dev = (char *)match->data;
+	}
+
+	return key_dev;
+}
+
+static const struct file_operations unifykey_fops = {
+	.owner      = THIS_MODULE,
+	.llseek     = unifykey_llseek,
+	.open       = unifykey_open,
+	.release    = unifykey_release,
+	.read       = unifykey_read,
+	.write      = unifykey_write,
+	.unlocked_ioctl  = unifykey_unlocked_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= unifykey_compat_ioctl,
+#endif
+};
+
+static CLASS_ATTR_RO(version);
+static CLASS_ATTR_RO(list);
+static CLASS_ATTR_RO(exist);
+static CLASS_ATTR_RO(encrypt);
+static CLASS_ATTR_RO(secure);
+static CLASS_ATTR_RO(size);
+static CLASS_ATTR_RO(help);
+static CLASS_ATTR_RW(name);
+static CLASS_ATTR_WO(write);
+static CLASS_ATTR_RO(read);
+static CLASS_ATTR_RW(attach);
+static CLASS_ATTR_RW(lock);
+
+static struct attribute *unifykey_class_attrs[] = {
+	&class_attr_version.attr,
+	&class_attr_list.attr,
+	&class_attr_exist.attr,
+	&class_attr_encrypt.attr,
+	&class_attr_secure.attr,
+	&class_attr_size.attr,
+	&class_attr_help.attr,
+	&class_attr_name.attr,
+	&class_attr_write.attr,
+	&class_attr_read.attr,
+	&class_attr_attach.attr,
+	&class_attr_lock.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(unifykey_class);
+
+static int __init aml_unifykeys_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device *devp;
+	struct aml_uk_dev *ukdev;
+
+	if (amlkey_if_init(pdev) != 0) {
+		pr_err("fail to initialize aml key\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ukdev = devm_kzalloc(&pdev->dev, sizeof(*ukdev), GFP_KERNEL);
+	if (unlikely(!ukdev)) {
+		pr_err("fail to alloc enough mem for ukdev\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	ukdev_global = ukdev;
+	ukdev->pdev = pdev;
+	platform_set_drvdata(pdev, ukdev);
+
+	INIT_LIST_HEAD(&ukdev->uk_hdr);
+
+	ret = uk_dt_create(pdev);
+	if (ret != 0) {
+		pr_err("fail to obtain necessary info from dts\n");
+		goto error1;
+	}
+
+	ret = alloc_chrdev_region(&ukdev->uk_devno, 0, 1,
+				  UNIFYKEYS_DEVICE_NAME);
+	if (ret != 0) {
+		pr_err("fail to allocate major number\n ");
+		goto error1;
+	}
+	pr_info("unifykey_devno: %x\n", ukdev->uk_devno);
+
+	ukdev->cls.name = UNIFYKEYS_CLASS_NAME;
+	ukdev->cls.owner = THIS_MODULE;
+	ukdev->cls.class_groups = unifykey_class_groups;
+	ret = class_register(&ukdev->cls);
+	if (ret != 0)
+		goto error2;
+
+	/* connect the file operations with cdev */
+	cdev_init(&ukdev->cdev, &unifykey_fops);
+	ukdev->cdev.owner = THIS_MODULE;
+	/* connect the major/minor number to the cdev */
+	ret = cdev_add(&ukdev->cdev, ukdev->uk_devno, 1);
+	if (ret != 0) {
+		pr_err("fail to add device\n");
+		goto error3;
+	}
+
+	devp = device_create(&ukdev->cls, NULL,
+			     ukdev->uk_devno, NULL, UNIFYKEYS_DEVICE_NAME);
+	if (IS_ERR(devp)) {
+		pr_err("failed to create device node\n");
+		ret = PTR_ERR(devp);
+		goto error4;
+	}
+
+	devp->platform_data = get_unifykeys_drv_data(pdev);
+
+	pr_info("device %s created ok\n", UNIFYKEYS_DEVICE_NAME);
+	return 0;
+
+error4:
+	cdev_del(&ukdev->cdev);
+error3:
+	class_unregister(&ukdev->cls);
+error2:
+	unregister_chrdev_region(ukdev->uk_devno, 1);
+error1:
+	devm_kfree(&pdev->dev, ukdev);
+out:
+	amlkey_if_deinit();
+	return ret;
+}
+
+static int aml_unifykeys_remove(struct platform_device *pdev)
+{
+	struct aml_uk_dev *ukdev = platform_get_drvdata(pdev);
+
+	if (pdev->dev.of_node)
+		uk_dt_release(pdev);
+
+	unregister_chrdev_region(ukdev->uk_devno, 1);
+	device_destroy(&ukdev->cls, ukdev->uk_devno);
+	cdev_del(&ukdev->cdev);
+	class_unregister(&ukdev->cls);
+	platform_set_drvdata(pdev, NULL);
+	amlkey_if_deinit();
+
+	return 0;
+}
+
+static const struct of_device_id unifykeys_dt_match[] = {
+	{	.compatible = "amlogic,unifykey",
+	},
+	{},
+};
+
+static struct platform_driver unifykey_platform_driver = {
+	.remove = aml_unifykeys_remove,
+	.driver = {
+		.name = UNIFYKEYS_DEVICE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = unifykeys_dt_match,
+	},
+};
+
+int __init aml_unifykeys_init(void)
+{
+	return platform_driver_probe(&unifykey_platform_driver,
+				    aml_unifykeys_probe);
+}
+
+void aml_unifykeys_exit(void)
+{
+	platform_driver_unregister(&unifykey_platform_driver);
+}
diff -Naur a/vendor/amlogic/unifykey/unifykey_dts.c b/vendor/amlogic/unifykey/unifykey_dts.c
--- a/vendor/amlogic/unifykey/unifykey_dts.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/unifykey_dts.c	2022-05-31 11:56:47.721259431 +0800
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/of.h>
+#include "unifykey.h"
+
+#undef pr_fmt
+#define pr_fmt(fmt) "unifykey: " fmt
+
+static int uk_item_parse_dt(struct aml_uk_dev *ukdev, struct device_node *node,
+			    int id)
+{
+	int		  count;
+	int		  ret;
+	const char	  *propname;
+	struct key_item_t *tmp_item = NULL;
+
+	tmp_item = kzalloc(sizeof(*tmp_item), GFP_KERNEL);
+	if (!tmp_item)
+		return -ENOMEM;
+
+	propname = NULL;
+	ret = of_property_read_string(node, "key-name", &propname);
+	if (ret < 0) {
+		pr_err("%s:%d,get key-name fail\n", __func__, __LINE__);
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (propname) {
+		count = strlen(propname);
+		if (count >= KEY_UNIFY_NAME_LEN)
+			count = KEY_UNIFY_NAME_LEN - 1;
+		memcpy(tmp_item->name, propname, count);
+	}
+
+	propname = NULL;
+	ret = of_property_read_string(node, "key-device", &propname);
+	if (ret < 0) {
+		pr_err("%s:%d,get key-device fail\n", __func__, __LINE__);
+		ret = -EINVAL;
+		goto exit;
+	}
+	if (propname) {
+		if (strcmp(propname, "efuse") == 0)
+			tmp_item->dev = KEY_EFUSE;
+		else if (strcmp(propname, "normal") == 0)
+			tmp_item->dev = KEY_NORMAL;
+		else if (strcmp(propname, "secure") == 0)
+			tmp_item->dev = KEY_SECURE;
+		else
+			tmp_item->dev = KEY_UNKNOWN_DEV;
+	}
+
+	tmp_item->perm = 0;
+	if (of_property_match_string(node, "key-permit", "read") >= 0)
+		tmp_item->perm |= KEY_PERM_READ;
+	if (of_property_match_string(node, "key-permit", "write") >= 0)
+		tmp_item->perm |= KEY_PERM_WRITE;
+	tmp_item->id = id;
+
+	tmp_item->attr = 0;
+	if (of_property_read_bool(node, "key-encrypt"))
+		tmp_item->attr = KEY_ATTR_ENCRYPT;
+
+	list_add(&tmp_item->node, &ukdev->uk_hdr);
+	return 0;
+exit:
+	kfree(tmp_item);
+	return ret;
+}
+
+static int uk_item_create(struct platform_device *pdev, int *num)
+{
+	int			ret =  -1;
+	int			index;
+	struct device_node	*child;
+	struct device_node	*np = pdev->dev.of_node;
+	struct aml_uk_dev *ukdev = platform_get_drvdata(pdev);
+
+	of_node_get(np);
+	index = 0;
+	for_each_child_of_node(np, child) {
+		ret = uk_item_parse_dt(ukdev, child, index);
+		if (!ret)
+			index++;
+	}
+	*num = index;
+	pr_info("unifykey num is %d\n", *num);
+
+	return 0;
+}
+
+int uk_dt_create(struct platform_device *pdev)
+{
+	int			key_num, ret;
+	struct aml_uk_dev *ukdev = platform_get_drvdata(pdev);
+
+	ukdev->uk_info.encrypt_type = -1;
+	/* do not care whether unifykey-encrypt really exists*/
+	ret = of_property_read_u32(pdev->dev.of_node, "unifykey-encrypt",
+				   &ukdev->uk_info.encrypt_type);
+	if (ret < 0)
+		pr_info("no unifykey-encrypt property\n");
+
+	if (!(ukdev->uk_info.key_flag)) {
+		uk_item_create(pdev, &key_num);
+		ukdev->uk_info.key_num = key_num;
+		ukdev->uk_info.key_flag = 1;
+	}
+
+	return 0;
+}
+
+int uk_dt_release(struct platform_device *pdev)
+{
+	struct aml_uk_dev *ukdev = platform_get_drvdata(pdev);
+	struct key_item_t *item;
+	struct key_item_t *tmp;
+
+	if (pdev->dev.of_node)
+		of_node_put(pdev->dev.of_node);
+
+	list_for_each_entry_safe(item, tmp, &ukdev->uk_hdr, node) {
+		list_del(&item->node);
+		kfree(item);
+	}
+	ukdev->uk_info.key_flag = 0;
+	return 0;
+}
diff -Naur a/vendor/amlogic/unifykey/unifykey.h b/vendor/amlogic/unifykey/unifykey.h
--- a/vendor/amlogic/unifykey/unifykey.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/unifykey/unifykey.h	2022-05-31 11:56:47.721259431 +0800
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2019 Amlogic, Inc. All rights reserved.
+ */
+
+#ifndef __UNIFYKEY_MANAGE_H__
+#define __UNIFYKEY_MANAGE_H__
+
+#include <linux/cdev.h>
+#include <linux/list.h>
+
+#define KEYUNIFY_ATTACH		_IO('f', 0x60)
+#define KEYUNIFY_GET_INFO	_IO('f', 0x62)
+
+#define KEY_UNIFY_NAME_LEN	48
+
+enum key_manager_dev_e {
+	KEY_UNKNOWN_DEV = 0,
+	KEY_EFUSE,
+	KEY_NORMAL,/*nand/emmc key*/
+	KEY_SECURE,
+	KEY_MAX_DEV,
+};
+
+enum key_manager_permit_e {
+	KEY_PERM_READ = BIT(0),
+	KEY_PERM_WRITE = BIT(1),
+};
+
+/* for ioctrl transfer parameters. */
+struct key_item_info_t {
+	unsigned int id;
+	char	     name[KEY_UNIFY_NAME_LEN];
+	unsigned int size;
+	unsigned int perm;
+	unsigned int flag;	/*bit 0: 1 exsit, 0-none;*/
+	unsigned int reserve;
+};
+
+#define KEY_ATTR_ENCRYPT		BIT(8)
+#define KEY_ATTR_SECURE		BIT(0)
+
+struct key_item_t {
+	struct list_head node;
+	char name[KEY_UNIFY_NAME_LEN];
+	int id;
+	unsigned int dev;
+	unsigned int perm;
+	int attr;
+	int reserve;
+};
+
+struct key_info_t {
+	int key_num;
+	int key_flag;
+	int encrypt_type;
+};
+
+struct aml_uk_dev {
+	struct platform_device *pdev;
+	struct class           cls;
+	struct cdev            cdev;
+	dev_t                  uk_devno;
+	int		       init_flag;
+	int                    lock_flag;
+	struct key_item_t      *curkey;
+	struct list_head       uk_hdr;
+	struct key_info_t      uk_info;
+};
+
+int uk_dt_create(struct platform_device *pdev);
+int uk_dt_release(struct platform_device *pdev);
+
+#ifdef CONFIG_AMLOGIC_UNIFYKEY
+int __init aml_unifykeys_init(void);
+void __exit aml_unifykeys_exit(void);
+#else
+static int __init aml_unifykeys_init(void)
+{
+	return 0;
+}
+
+static void aml_unifykeys_exit(void)
+{
+}
+#endif
+#endif
diff -Naur a/vendor/amlogic/wifi/dhd_static_buf.c b/vendor/amlogic/wifi/dhd_static_buf.c
--- a/vendor/amlogic/wifi/dhd_static_buf.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/wifi/dhd_static_buf.c	2022-06-30 14:53:29.553189617 +0800
@@ -0,0 +1,463 @@
+/*
+ * vendor/amlogic/wifi/dhd_static_buf.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#define pr_fmt(fmt)	"Wifi: %s: " fmt, __func__
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/skbuff.h>
+#include "dhd_static_buf.h"
+
+#define	DHD_STATIC_VERSION_STR		"100.10.545.3"
+
+#define BCMDHD_SDIO
+#define BCMDHD_PCIE
+
+enum dhd_prealloc_index {
+	DHD_PREALLOC_PROT = 0,
+#if defined(BCMDHD_SDIO)
+	DHD_PREALLOC_RXBUF = 1,
+	DHD_PREALLOC_DATABUF = 2,
+#endif
+	DHD_PREALLOC_OSL_BUF = 3,
+	DHD_PREALLOC_SKB_BUF = 4,
+	DHD_PREALLOC_WIPHY_ESCAN0 = 5,
+	DHD_PREALLOC_WIPHY_ESCAN1 = 6,
+	DHD_PREALLOC_DHD_INFO = 7,
+	DHD_PREALLOC_DHD_WLFC_INFO = 8,
+#ifdef BCMDHD_PCIE
+	DHD_PREALLOC_IF_FLOW_LKUP = 9,
+#endif
+	DHD_PREALLOC_MEMDUMP_BUF = 10,
+	DHD_PREALLOC_MEMDUMP_RAM = 11,
+	DHD_PREALLOC_DHD_WLFC_HANGER = 12,
+	DHD_PREALLOC_PKTID_MAP = 13,
+	DHD_PREALLOC_PKTID_MAP_IOCTL = 14,
+	DHD_PREALLOC_DHD_LOG_DUMP_BUF = 15,
+	DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX = 16,
+	DHD_PREALLOC_DHD_PKTLOG_DUMP_BUF = 17,
+	DHD_PREALLOC_STAT_REPORT_BUF = 18,
+	DHD_PREALLOC_WL_WEXT_INFO = 19,
+	DHD_PREALLOC_FW_VERBOSE_RING = 20,
+	DHD_PREALLOC_FW_EVENT_RING = 21,
+	DHD_PREALLOC_DHD_EVENT_RING = 22,
+	DHD_PREALLOC_NAN_EVENT_RING = 23,
+	DHD_PREALLOC_MAX
+};
+
+#define STATIC_BUF_MAX_NUM	20
+#define STATIC_BUF_SIZE	(PAGE_SIZE*2)
+#define CUSTOM_LOG_DUMP_BUFSIZE_MB    4
+#define DHD_PREALLOC_PROT_SIZE	(16 * 1024)
+#define DHD_PREALLOC_RXBUF_SIZE	(24 * 1024)
+#define DHD_PREALLOC_DATABUF_SIZE	(64 * 1024)
+#define DHD_PREALLOC_OSL_BUF_SIZE	(STATIC_BUF_MAX_NUM * STATIC_BUF_SIZE)
+#define DHD_PREALLOC_WIPHY_ESCAN0_SIZE	(64 * 1024)
+#define DHD_PREALLOC_DHD_INFO_SIZE	(32 * 1024)
+#define DHD_PREALLOC_MEMDUMP_RAM_SIZE	(1290 * 1024)
+#define DHD_PREALLOC_DHD_WLFC_HANGER_SIZE	(73 * 1024)
+#define DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE (1024 * 1024 * CUSTOM_LOG_DUMP_BUFSIZE_MB)
+#define DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE (8 * 1024)
+#define DHD_PREALLOC_WL_WEXT_INFO_SIZE	(70 * 1024)
+#ifdef CONFIG_64BIT
+#define DHD_PREALLOC_IF_FLOW_LKUP_SIZE	(20 * 1024 * 2)
+#else
+#define DHD_PREALLOC_IF_FLOW_LKUP_SIZE	(20 * 1024)
+#endif
+#define FW_VERBOSE_RING_SIZE		(256 * 1024)
+#define FW_EVENT_RING_SIZE		(64 * 1024)
+#define DHD_EVENT_RING_SIZE		(64 * 1024)
+#define NAN_EVENT_RING_SIZE		(64 * 1024)
+
+#if defined(CONFIG_64BIT)
+#define WLAN_DHD_INFO_BUF_SIZE	(24 * 1024)
+#define WLAN_DHD_WLFC_BUF_SIZE	(64 * 1024)
+#define WLAN_DHD_IF_FLOW_LKUP_SIZE	(64 * 1024)
+#else
+#define WLAN_DHD_INFO_BUF_SIZE	(16 * 1024)
+#define WLAN_DHD_WLFC_BUF_SIZE	(64 * 1024)
+#define WLAN_DHD_IF_FLOW_LKUP_SIZE	(20 * 1024)
+#endif /* CONFIG_64BIT */
+#define WLAN_DHD_MEMDUMP_SIZE	(800 * 1024)
+
+#define DHD_SKB_1PAGE_BUFSIZE	(PAGE_SIZE*1)
+#define DHD_SKB_2PAGE_BUFSIZE	(PAGE_SIZE*2)
+#define DHD_SKB_4PAGE_BUFSIZE	(PAGE_SIZE*4)
+
+#define DHD_SKB_1PAGE_BUF_NUM	8
+#define DHD_SKB_2PAGE_BUF_NUM	64
+#define DHD_SKB_4PAGE_BUF_NUM	1
+
+/* The number is defined in linux_osl.c
+ * WLAN_SKB_1_2PAGE_BUF_NUM => STATIC_PKT_1_2PAGE_NUM
+ * WLAN_SKB_BUF_NUM => STATIC_PKT_MAX_NUM
+ */
+#define WLAN_SKB_1_2PAGE_BUF_NUM ((DHD_SKB_1PAGE_BUF_NUM) + \
+		(DHD_SKB_2PAGE_BUF_NUM))
+#define WLAN_SKB_BUF_NUM ((WLAN_SKB_1_2PAGE_BUF_NUM) + (DHD_SKB_4PAGE_BUF_NUM))
+
+void *wlan_static_prot;
+void *wlan_static_rxbuf;
+void *wlan_static_databuf;
+void *wlan_static_osl_buf;
+void *wlan_static_scan_buf0;
+void *wlan_static_scan_buf1;
+void *wlan_static_dhd_info_buf;
+void *wlan_static_dhd_wlfc_info_buf;
+void *wlan_static_if_flow_lkup;
+void *wlan_static_dhd_memdump_ram_buf;
+void *wlan_static_dhd_wlfc_hanger_buf;
+void *wlan_static_dhd_log_dump_buf;
+void *wlan_static_dhd_log_dump_buf_ex;
+void *wlan_static_wl_escan_info_buf;
+void *wlan_static_fw_verbose_ring_buf;
+void *wlan_static_fw_event_ring_buf;
+void *wlan_static_dhd_event_ring_buf;
+void *wlan_static_nan_event_ring_buf;
+
+static struct sk_buff *wlan_static_skb[WLAN_SKB_BUF_NUM];
+
+void *bcmdhd_mem_prealloc(int section, unsigned long size)
+{
+	pr_info("sectoin %d, size %ld\n", section, size);
+	if (section == DHD_PREALLOC_PROT)
+		return wlan_static_prot;
+
+#if defined(BCMDHD_SDIO)
+	if (section == DHD_PREALLOC_RXBUF)
+		return wlan_static_rxbuf;
+
+	if (section == DHD_PREALLOC_DATABUF)
+		return wlan_static_databuf;
+#endif /* BCMDHD_SDIO */
+
+	if (section == DHD_PREALLOC_SKB_BUF)
+		return wlan_static_skb;
+
+	if (section == DHD_PREALLOC_WIPHY_ESCAN0)
+		return wlan_static_scan_buf0;
+
+	if (section == DHD_PREALLOC_WIPHY_ESCAN1)
+		return wlan_static_scan_buf1;
+
+	if (section == DHD_PREALLOC_OSL_BUF) {
+		if (size > DHD_PREALLOC_OSL_BUF_SIZE) {
+			pr_err("request OSL_BUF(%lu) > %ld\n",
+				size, DHD_PREALLOC_OSL_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_osl_buf;
+	}
+
+	if (section == DHD_PREALLOC_DHD_INFO) {
+		if (size > DHD_PREALLOC_DHD_INFO_SIZE) {
+			pr_err("request DHD_INFO size(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_INFO_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_info_buf;
+	}
+	if (section == DHD_PREALLOC_DHD_WLFC_INFO) {
+		if (size > WLAN_DHD_WLFC_BUF_SIZE) {
+			pr_err("request DHD_WLFC_INFO size(%lu) > %d\n",
+				size, WLAN_DHD_WLFC_BUF_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_wlfc_info_buf;
+	}
+#ifdef BCMDHD_PCIE
+	if (section == DHD_PREALLOC_IF_FLOW_LKUP)  {
+		if (size > DHD_PREALLOC_IF_FLOW_LKUP_SIZE) {
+			pr_err("request DHD_IF_FLOW_LKUP size(%lu) > %d\n",
+				size, DHD_PREALLOC_IF_FLOW_LKUP_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_if_flow_lkup;
+	}
+#endif /* BCMDHD_PCIE */
+	if (section == DHD_PREALLOC_MEMDUMP_RAM) {
+		if (size > DHD_PREALLOC_MEMDUMP_RAM_SIZE) {
+			pr_err("request DHD_PREALLOC_MEMDUMP_RAM_SIZE(%lu) > %d\n",
+				size, DHD_PREALLOC_MEMDUMP_RAM_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_dhd_memdump_ram_buf;
+	}
+	if (section == DHD_PREALLOC_DHD_WLFC_HANGER) {
+		if (size > DHD_PREALLOC_DHD_WLFC_HANGER_SIZE) {
+			pr_err("request DHD_WLFC_HANGER size(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_WLFC_HANGER_SIZE);
+			return NULL;
+		}
+		return wlan_static_dhd_wlfc_hanger_buf;
+	}
+	if (section == DHD_PREALLOC_DHD_LOG_DUMP_BUF) {
+		if (size > DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE) {
+			pr_err("request DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_dhd_log_dump_buf;
+	}
+	if (section == DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX) {
+		if (size > DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE) {
+			pr_err("request DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE(%lu) > %d\n",
+				size, DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_dhd_log_dump_buf_ex;
+	}
+	if (section == DHD_PREALLOC_WL_WEXT_INFO) {
+		if (size > DHD_PREALLOC_WL_WEXT_INFO_SIZE) {
+			pr_err("request DHD_PREALLOC_WL_WEXT_INFO_SIZE(%lu) > %d\n",
+				size, DHD_PREALLOC_WL_WEXT_INFO_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_wl_escan_info_buf;
+	}
+	if (section == DHD_PREALLOC_FW_VERBOSE_RING) {
+		if (size > FW_VERBOSE_RING_SIZE) {
+			pr_err("request DHD_PREALLOC_FW_VERBOSE_RING(%lu) > %d\n",
+				size, FW_VERBOSE_RING_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_fw_verbose_ring_buf;
+	}
+	if (section == DHD_PREALLOC_FW_EVENT_RING) {
+		if (size > FW_EVENT_RING_SIZE) {
+			pr_err("request DHD_PREALLOC_FW_EVENT_RING(%lu) > %d\n",
+				size, FW_EVENT_RING_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_fw_event_ring_buf;
+	}
+	if (section == DHD_PREALLOC_DHD_EVENT_RING) {
+		if (size > DHD_EVENT_RING_SIZE) {
+			pr_err("request DHD_PREALLOC_DHD_EVENT_RING(%lu) > %d\n",
+				size, DHD_EVENT_RING_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_dhd_event_ring_buf;
+	}
+	if (section == DHD_PREALLOC_NAN_EVENT_RING) {
+		if (size > NAN_EVENT_RING_SIZE) {
+			pr_err("request DHD_PREALLOC_NAN_EVENT_RING(%lu) > %d\n",
+				size, NAN_EVENT_RING_SIZE);
+			return NULL;
+		}
+
+		return wlan_static_nan_event_ring_buf;
+	}
+	if ((section < 0) || (section > DHD_PREALLOC_MAX))
+		pr_err("request section id(%d) is out of max index %d\n",
+				section, DHD_PREALLOC_MAX);
+
+	pr_err("%s: failed to alloc section %d, size=%ld\n",
+		__func__, section, size);
+
+	return NULL;
+}
+EXPORT_SYMBOL(bcmdhd_mem_prealloc);
+
+int bcmdhd_init_wlan_mem(void)
+{
+	int i;
+	int j;
+	pr_info("%s(): %s\n", __func__, DHD_STATIC_VERSION_STR);
+
+	for (i = 0; i < DHD_SKB_1PAGE_BUF_NUM; i++) {
+		wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_1PAGE_BUFSIZE);
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+	}
+
+	for (i = DHD_SKB_1PAGE_BUF_NUM; i < WLAN_SKB_1_2PAGE_BUF_NUM; i++) {
+		wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_2PAGE_BUFSIZE);
+		if (!wlan_static_skb[i])
+			goto err_skb_alloc;
+	}
+
+#if defined(BCMDHD_SDIO)
+	wlan_static_skb[i] = dev_alloc_skb(DHD_SKB_4PAGE_BUFSIZE);
+	if (!wlan_static_skb[i])
+		goto err_skb_alloc;
+#endif /* BCMDHD_SDIO */
+
+	wlan_static_prot = kmalloc(DHD_PREALLOC_PROT_SIZE, GFP_KERNEL);
+	if (!wlan_static_prot)
+		goto err_mem_alloc;
+
+#if defined(BCMDHD_SDIO)
+	wlan_static_rxbuf = kmalloc(DHD_PREALLOC_RXBUF_SIZE, GFP_KERNEL);
+	if (!wlan_static_rxbuf)
+		goto err_mem_alloc;
+
+	wlan_static_databuf = kmalloc(DHD_PREALLOC_DATABUF_SIZE, GFP_KERNEL);
+	if (!wlan_static_databuf)
+		goto err_mem_alloc;
+#endif /* BCMDHD_SDIO */
+
+	wlan_static_osl_buf = kmalloc(DHD_PREALLOC_OSL_BUF_SIZE, GFP_KERNEL);
+	if (!wlan_static_osl_buf)
+		goto err_mem_alloc;
+
+	wlan_static_scan_buf0 = kmalloc(DHD_PREALLOC_WIPHY_ESCAN0_SIZE, GFP_KERNEL);
+	if (!wlan_static_scan_buf0)
+		goto err_mem_alloc;
+
+	wlan_static_dhd_info_buf = kmalloc(DHD_PREALLOC_DHD_INFO_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_info_buf)
+		goto err_mem_alloc;
+
+	wlan_static_dhd_wlfc_info_buf = kmalloc(WLAN_DHD_WLFC_BUF_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_wlfc_info_buf)
+		goto err_mem_alloc;
+
+#ifdef BCMDHD_PCIE
+	wlan_static_if_flow_lkup = kmalloc(DHD_PREALLOC_IF_FLOW_LKUP_SIZE, GFP_KERNEL);
+	if (!wlan_static_if_flow_lkup)
+		goto err_mem_alloc;
+#endif /* BCMDHD_PCIE */
+
+	wlan_static_dhd_memdump_ram_buf = kmalloc(DHD_PREALLOC_MEMDUMP_RAM_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_memdump_ram_buf)
+		goto err_mem_alloc;
+
+	wlan_static_dhd_wlfc_hanger_buf = kmalloc(DHD_PREALLOC_DHD_WLFC_HANGER_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_wlfc_hanger_buf)
+		goto err_mem_alloc;
+
+	wlan_static_dhd_log_dump_buf = kmalloc(DHD_PREALLOC_DHD_LOG_DUMP_BUF_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_log_dump_buf)
+		goto err_mem_alloc;
+
+	wlan_static_dhd_log_dump_buf_ex = kmalloc(DHD_PREALLOC_DHD_LOG_DUMP_BUF_EX_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_log_dump_buf_ex)
+		goto err_mem_alloc;
+
+	wlan_static_wl_escan_info_buf = kmalloc(DHD_PREALLOC_WL_WEXT_INFO_SIZE, GFP_KERNEL);
+	if (!wlan_static_wl_escan_info_buf)
+		goto err_mem_alloc;
+
+	wlan_static_fw_verbose_ring_buf = kmalloc(FW_VERBOSE_RING_SIZE, GFP_KERNEL);
+	if (!wlan_static_fw_verbose_ring_buf)
+		goto err_mem_alloc;
+
+	wlan_static_fw_event_ring_buf = kmalloc(FW_EVENT_RING_SIZE, GFP_KERNEL);
+	if (!wlan_static_fw_event_ring_buf)
+		goto err_mem_alloc;
+
+	wlan_static_dhd_event_ring_buf = kmalloc(DHD_EVENT_RING_SIZE, GFP_KERNEL);
+	if (!wlan_static_dhd_event_ring_buf)
+		goto err_mem_alloc;
+
+	wlan_static_nan_event_ring_buf = kmalloc(NAN_EVENT_RING_SIZE, GFP_KERNEL);
+	if (!wlan_static_nan_event_ring_buf)
+		goto err_mem_alloc;
+
+	pr_info("bcmdhd_init_wlan_mem prealloc ok\n");
+	return 0;
+
+err_mem_alloc:
+
+	if (wlan_static_prot)
+		kfree(wlan_static_prot);
+
+#if defined(BCMDHD_SDIO)
+	if (wlan_static_rxbuf)
+		kfree(wlan_static_rxbuf);
+
+	if (wlan_static_databuf)
+		kfree(wlan_static_databuf);
+#endif /* BCMDHD_SDIO */
+
+	if (wlan_static_osl_buf)
+		kfree(wlan_static_osl_buf);
+
+	if (wlan_static_scan_buf0)
+		kfree(wlan_static_scan_buf0);
+
+	if (wlan_static_scan_buf1)
+		kfree(wlan_static_scan_buf1);
+
+	if (wlan_static_dhd_info_buf)
+		kfree(wlan_static_dhd_info_buf);
+
+	if (wlan_static_dhd_wlfc_info_buf)
+		kfree(wlan_static_dhd_wlfc_info_buf);
+
+#ifdef BCMDHD_PCIE
+	if (wlan_static_if_flow_lkup)
+		kfree(wlan_static_if_flow_lkup);
+#endif /* BCMDHD_PCIE */
+
+	if (wlan_static_dhd_memdump_ram_buf)
+		kfree(wlan_static_dhd_memdump_ram_buf);
+
+	if (wlan_static_dhd_wlfc_hanger_buf)
+		kfree(wlan_static_dhd_wlfc_hanger_buf);
+
+	if (wlan_static_dhd_log_dump_buf)
+		kfree(wlan_static_dhd_log_dump_buf);
+
+	if (wlan_static_dhd_log_dump_buf_ex)
+		kfree(wlan_static_dhd_log_dump_buf_ex);
+
+	if (wlan_static_wl_escan_info_buf)
+		kfree(wlan_static_wl_escan_info_buf);
+
+#ifdef BCMDHD_PCIE
+	if (wlan_static_fw_verbose_ring_buf)
+		kfree(wlan_static_fw_verbose_ring_buf);
+
+	if (wlan_static_fw_event_ring_buf)
+		kfree(wlan_static_fw_event_ring_buf);
+
+	if (wlan_static_dhd_event_ring_buf)
+		kfree(wlan_static_dhd_event_ring_buf);
+
+	if (wlan_static_nan_event_ring_buf)
+		kfree(wlan_static_nan_event_ring_buf);
+#endif /* BCMDHD_PCIE */
+
+	pr_err("%s: Failed to mem_alloc for WLAN\n", __func__);
+
+	i = WLAN_SKB_BUF_NUM;
+
+err_skb_alloc:
+	pr_err("%s: Failed to skb_alloc for WLAN\n", __func__);
+	for (j = 0; j < i; j++)
+		dev_kfree_skb(wlan_static_skb[j]);
+
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(bcmdhd_init_wlan_mem);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("wifi device tree driver");
diff -Naur a/vendor/amlogic/wifi/dhd_static_buf.h b/vendor/amlogic/wifi/dhd_static_buf.h
--- a/vendor/amlogic/wifi/dhd_static_buf.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/wifi/dhd_static_buf.h	2022-05-31 11:56:48.093256151 +0800
@@ -0,0 +1,21 @@
+/*
+ * include/linux/amlogic/dhd_buf.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _BCMDHD_BUF_H
+#define _BCMDHD_BUF_H
+int bcmdhd_init_wlan_mem(void);
+#endif
diff -Naur a/vendor/amlogic/wifi/Kconfig b/vendor/amlogic/wifi/Kconfig
--- a/vendor/amlogic/wifi/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/wifi/Kconfig	2022-05-31 11:56:47.721259431 +0800
@@ -0,0 +1,7 @@
+config AMLOGIC_WIFI
+	bool "WiFi support"
+	select WIRELESS_EXT
+	select WEXT_PRIV
+	default n
+	help
+		select y to support wifi
diff -Naur a/vendor/amlogic/wifi/Makefile b/vendor/amlogic/wifi/Makefile
--- a/vendor/amlogic/wifi/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/wifi/Makefile	2022-05-31 11:56:47.721259431 +0800
@@ -0,0 +1 @@
+obj-y += wifi_dt.o dhd_static_buf.o
\ No newline at end of file
diff -Naur a/vendor/amlogic/wifi/wifi_dt.c b/vendor/amlogic/wifi/wifi_dt.c
--- a/vendor/amlogic/wifi/wifi_dt.c	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/wifi/wifi_dt.c	2022-06-30 15:33:21.221209131 +0800
@@ -0,0 +1,578 @@
+/*
+ * Wifi device tree driver for Amlogic
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+#include <linux/delay.h>
+#include <linux/cdev.h>
+#include <linux/proc_fs.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/rfkill.h>
+#include <linux/of.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
+#include <linux/amlogic/cpu_version.h>
+#include <linux/amlogic/iomap.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/pwm.h>
+#include <linux/pci.h>
+#include <linux/gpio/consumer.h>
+#include "dhd_static_buf.h"
+#include "wifi_dt.h"
+
+#define OWNER_NAME "sdio_wifi"
+
+struct wifi_plat_info {
+	int interrupt_pin;
+	int irq_num;
+	int irq_trigger_type;
+
+	int power_on_pin;
+	int power_on_pin_level;
+	int power_on_pin_OD;
+	int power_on_pin2;
+
+	struct gpio_desc *interrupt_desc;
+	struct gpio_desc *power_desc;
+
+	int plat_info_valid;
+	struct pinctrl *p;
+	struct device *dev;
+};
+
+#define WIFI_POWER_DRIVER_NAME	"wifi_power"
+#define WIFI_POWER_DEVICE_NAME	"wifi_power"
+#define WIFI_POWER_CLASS_NAME	"wifi_power"
+
+#define WIFI_POWER_UP		_IO('m', 1)
+#define WIFI_POWER_DOWN	_IO('m', 2)
+#define USB_POWER_UP		_IO('m', 3)
+#define USB_POWER_DOWN		_IO('m', 4)
+#define SDIO_GET_DEV_TYPE	_IO('m', 5)
+
+#define BT_BIT	0
+#define WIFI_BIT	1
+
+static struct wifi_plat_info wifi_info;
+static dev_t wifi_power_devno;
+static struct cdev *wifi_power_cdev;
+static struct device *devp;
+struct wifi_power_platform_data *pdata;
+static int power_flag;
+
+static DEFINE_MUTEX(wifi_bt_mutex);
+
+#define WIFI_INFO(fmt, args...)	\
+	dev_info(wifi_info.dev, "[%s] " fmt, __func__, ##args)
+
+#ifdef CONFIG_OF
+static const struct of_device_id wifi_match[] = {
+	{
+		.compatible = "amlogic, wifi-dev",
+		.data = (void *)&wifi_info
+	},
+	{},
+};
+
+static struct wifi_plat_info *wifi_get_driver_data(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+
+	match = of_match_node(wifi_match, pdev->dev.of_node);
+	if (!match)
+		return NULL;
+	return (struct wifi_plat_info *)match->data;
+}
+#else
+#define wifi_match NULL
+#endif
+
+
+#define SHOW_PIN_OWN(pin_str, pin_num)	\
+	WIFI_INFO("%s(%d)\n", pin_str, pin_num)
+
+static int set_power(int value)
+{
+	if (!wifi_info.power_on_pin_OD) {
+		if (wifi_info.power_on_pin_level)
+			return gpio_direction_output(wifi_info.power_on_pin,
+					!value);
+		else
+			return gpio_direction_output(wifi_info.power_on_pin,
+					value);
+	} else {
+		if (wifi_info.power_on_pin_level) {
+			if (value)
+				gpio_direction_input(wifi_info.power_on_pin);
+			else
+				gpio_direction_output(wifi_info.power_on_pin,
+					0);
+		} else {
+			if (value)
+				gpio_direction_output(wifi_info.power_on_pin,
+					0);
+			else
+				gpio_direction_input(wifi_info.power_on_pin);
+		}
+	}
+	return 0;
+}
+
+static int set_power2(int value)
+{
+	if (wifi_info.power_on_pin_level)
+		return gpio_direction_output(wifi_info.power_on_pin2,
+				!value);
+	else
+		return gpio_direction_output(wifi_info.power_on_pin2,
+				value);
+}
+
+static int set_wifi_power(int is_power)
+{
+	int ret = 0;
+
+	if (is_power) {
+		if (wifi_info.power_on_pin) {
+			ret = set_power(1);
+			if (ret)
+				WIFI_INFO("power up failed(%d)\n", ret);
+		}
+		if (wifi_info.power_on_pin2) {
+			ret = set_power2(1);
+			if (ret)
+				WIFI_INFO("power2 up failed(%d)\n", ret);
+		}
+	} else {
+		if (wifi_info.power_on_pin) {
+			ret = set_power(0);
+			if (ret)
+				WIFI_INFO("power down failed(%d)\n", ret);
+		}
+		if (wifi_info.power_on_pin2) {
+			ret = set_power2(0);
+			if (ret)
+				WIFI_INFO("power2 down failed(%d)\n", ret);
+		}
+	}
+	return ret;
+}
+
+static void wifi_power_control(int is_power, int shift)
+{
+	mutex_lock(&wifi_bt_mutex);
+	if (is_power) {
+		if (!power_flag) {
+			set_wifi_power(is_power);
+			WIFI_INFO("Set %s power on !\n", (shift ? "WiFi":"BT"));
+			msleep(200);
+			sdio_reinit();
+		}
+		power_flag |= (1 << shift);
+		WIFI_INFO("Set %s power on !\n", (shift ? "WiFi":"BT"));
+	} else {
+		power_flag &= ~(1 << shift);
+		if (!power_flag) {
+			set_wifi_power(is_power);
+			WIFI_INFO("Set %s power down\n", (shift ? "WiFi":"BT"));
+		}
+	}
+	mutex_unlock(&wifi_bt_mutex);
+}
+
+void aml_set_bt_power(int is_power)
+{
+	wifi_power_control(is_power, BT_BIT);
+}
+EXPORT_SYMBOL(aml_set_bt_power);
+
+void aml_set_wifi_power(int is_power)
+{
+	wifi_power_control(is_power, WIFI_BIT);
+}
+EXPORT_SYMBOL(aml_set_wifi_power);
+
+static int wifi_power_open(struct inode *inode, struct file *file)
+{
+	struct cdev *cdevp = inode->i_cdev;
+	file->private_data = cdevp;
+	return 0;
+}
+
+static int wifi_power_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long wifi_power_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	char dev_type[10] = {'\0'};
+
+	switch (cmd) {
+		case WIFI_POWER_UP:
+			aml_set_wifi_power(0);
+			mdelay(200);
+			aml_set_wifi_power(1);
+			mdelay(200);
+			WIFI_INFO("ioctl wifi power up!\n");
+			break;
+		case WIFI_POWER_DOWN:
+			aml_set_wifi_power(0);
+			WIFI_INFO("ioctl wifi power down!\n");
+			break;
+		case USB_POWER_UP:
+			WIFI_INFO(KERN_INFO "ioctl usb wifi power up!\n");
+			break;
+		case USB_POWER_DOWN:
+			WIFI_INFO(KERN_INFO "ioctl usb wifi power down!\n");
+			break;
+		case SDIO_GET_DEV_TYPE: /* Now only support sdio */
+			if (strlen("sdio") >= sizeof(dev_type))
+				memcpy(dev_type, "sdio", (sizeof(dev_type) - 1));
+			else
+				memcpy(dev_type, "sdio", strlen("sdio"));
+			WIFI_INFO("wifi interface dev type: %s, length = %d\n",
+					dev_type, (int)strlen(dev_type));
+			if (copy_to_user((char __user *)arg,
+					dev_type, strlen(dev_type)))
+				return -ENOTTY;
+			break;
+		default:
+			WIFI_INFO("usb wifi_power_ioctl: default !!!\n");
+			return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct file_operations wifi_power_fops = {
+	.unlocked_ioctl = wifi_power_ioctl,
+	.compat_ioctl = wifi_power_ioctl,
+	.open	= wifi_power_open,
+	.release	= wifi_power_release,
+};
+
+static struct class wifi_power_class = {
+	.name = WIFI_POWER_CLASS_NAME,
+	.owner = THIS_MODULE,
+};
+
+int wifi_setup_dt(void)
+{
+	int ret;
+
+	WIFI_INFO("wifi_setup_dt\n");
+	if (!wifi_info.plat_info_valid) {
+		WIFI_INFO("wifi_setup_dt : invalid device tree setting\n");
+		return -1;
+	}
+
+	/* setup irq */
+	if (wifi_info.interrupt_pin) {
+		ret = gpio_request(wifi_info.interrupt_pin,
+			OWNER_NAME);
+		if (ret)
+			WIFI_INFO("interrupt_pin request failed(%d)\n", ret);
+
+		ret = gpio_direction_input(wifi_info.interrupt_pin);
+		if (ret)
+			WIFI_INFO("set interrupt_pin input failed(%d)\n", ret);
+
+		wifi_info.irq_num = gpio_to_irq(wifi_info.interrupt_pin);
+		if (wifi_info.irq_num)
+			WIFI_INFO("irq num is:(%d)\n", wifi_info.irq_num);
+
+		SHOW_PIN_OWN("interrupt_pin", wifi_info.interrupt_pin);
+	}
+
+	/* setup power */
+	if (wifi_info.power_on_pin) {
+		ret = gpio_request(wifi_info.power_on_pin, OWNER_NAME);
+		if (ret)
+			WIFI_INFO("power_on_pin request failed(%d)\n", ret);
+		if (wifi_info.power_on_pin_level)
+			ret = set_power(1);
+		else
+			ret = set_power(0);
+		if (ret)
+			WIFI_INFO("power_on_pin output failed(%d)\n", ret);
+		SHOW_PIN_OWN("WIFI: power_on_pin ", wifi_info.power_on_pin);
+	}
+
+	if (wifi_info.power_on_pin2) {
+		ret = gpio_request(wifi_info.power_on_pin2,
+			OWNER_NAME);
+		if (ret)
+			WIFI_INFO("power_on_pin2 request failed(%d)\n", ret);
+		if (wifi_info.power_on_pin_level)
+			ret = set_power2(1);
+		else
+			ret = set_power2(0);
+		if (ret)
+			WIFI_INFO("power_on_pin2 output failed(%d)\n", ret);
+		SHOW_PIN_OWN("WIFI: power_on_pin2 ", wifi_info.power_on_pin2);
+	}
+
+	return 0;
+}
+
+void wifi_teardown_dt(void)
+{
+	WIFI_INFO("wifi_teardown_dt\n");
+
+	if (!wifi_info.plat_info_valid) {
+		WIFI_INFO("wifi_teardown_dt : invalid device tree setting\n");
+		return;
+	}
+
+	if (wifi_info.power_on_pin)
+		gpio_free(wifi_info.power_on_pin);
+
+	if (wifi_info.power_on_pin2)
+		gpio_free(wifi_info.power_on_pin2);
+
+	if (wifi_info.interrupt_pin)
+		gpio_free(wifi_info.interrupt_pin);
+}
+
+static int wifi_dev_probe(struct platform_device *pdev)
+{
+	int ret;
+#ifdef CONFIG_OF
+	struct wifi_plat_info *plat;
+	const char *value;
+	int desc;
+#else
+	struct wifi_plat_info *plat = (struct wifi_plat_info *)(pdev->dev.platform_data);
+#endif
+
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node) {
+		plat = wifi_get_driver_data(pdev);
+		plat->plat_info_valid = 0;
+		plat->dev = &pdev->dev;
+
+		ret = of_property_read_string(pdev->dev.of_node, "interrupt_pin", &value);
+		if (ret) {
+			plat->interrupt_pin = 0;
+		} else {
+			desc = of_get_named_gpio_flags(pdev->dev.of_node, "interrupt_pin", 0, NULL);
+			plat->interrupt_desc = gpio_to_desc(desc);
+			plat->interrupt_pin = desc;
+
+			ret = of_property_read_string(pdev->dev.of_node, "irq_trigger_type", &value);
+			if (ret) {
+				WIFI_INFO("no irq_trigger_type");
+				plat->irq_trigger_type = 0;
+				return -1;
+			}
+
+			if (strcmp(value, "GPIO_IRQ_HIGH") == 0)
+				plat->irq_trigger_type = GPIO_IRQ_HIGH;
+			else if (strcmp(value, "GPIO_IRQ_LOW") == 0)
+				plat->irq_trigger_type = GPIO_IRQ_LOW;
+			else if (strcmp(value, "GPIO_IRQ_RISING") == 0)
+				plat->irq_trigger_type = GPIO_IRQ_RISING;
+			else if (strcmp(value, "GPIO_IRQ_FALLING") == 0)
+				plat->irq_trigger_type = GPIO_IRQ_FALLING;
+			else {
+				WIFI_INFO("unknown irq trigger type-%s\n",
+				 value);
+				return -1;
+			}
+
+			WIFI_INFO("interrupt_pin=%d\n", plat->interrupt_pin);
+			WIFI_INFO("irq_num=%d, irq_trigger_type=%d\n",
+				plat->irq_num, plat->irq_trigger_type);
+		}
+
+		ret = of_property_read_string(pdev->dev.of_node, "power_on_pin", &value);
+		if (ret) {
+			WIFI_INFO("no power_on_pin");
+			plat->power_on_pin = 0;
+			plat->power_on_pin_OD = 0;
+		} else {
+			desc = of_get_named_gpio_flags(pdev->dev.of_node, "power_on_pin", 0, NULL);
+			plat->power_desc = gpio_to_desc(desc);
+			plat->power_on_pin = desc;
+		}
+
+		ret = of_property_read_u32(pdev->dev.of_node, "power_on_pin_level", &plat->power_on_pin_level);
+		if (ret)
+			plat->power_on_pin_level = 0;
+
+		ret = of_property_read_u32(pdev->dev.of_node, "power_on_pin_OD", &plat->power_on_pin_OD);
+		if (ret)
+			plat->power_on_pin_OD = 0;
+
+		ret = of_property_read_string(pdev->dev.of_node, "power_on_pin2", &value);
+		if (ret) {
+			plat->power_on_pin2 = 0;
+		} else {
+			desc = of_get_named_gpio_flags(pdev->dev.of_node, "power_on_pin2", 0, NULL);
+			plat->power_on_pin2 = desc;
+		}
+
+		if (of_get_property(pdev->dev.of_node, "dhd_static_buf", NULL)) {
+			WIFI_INFO("dhd_static_buf setup\n");
+		}
+
+		plat->plat_info_valid = 1;
+	}
+#endif
+
+	ret = alloc_chrdev_region(&wifi_power_devno,
+			0, 1, WIFI_POWER_DRIVER_NAME);
+	if (ret < 0) {
+		ret = -ENODEV;
+		goto out;
+	}
+	
+	ret = class_register(&wifi_power_class);
+	if (ret < 0)
+		goto error1;
+
+	wifi_power_cdev = cdev_alloc();
+	if (!wifi_power_cdev)
+		goto error2;
+	cdev_init(wifi_power_cdev, &wifi_power_fops);
+	wifi_power_cdev->owner = THIS_MODULE;
+	ret = cdev_add(wifi_power_cdev, wifi_power_devno, 1);
+	if (ret)
+		goto error3;
+
+	devp = device_create(&wifi_power_class, NULL,
+			wifi_power_devno, NULL, WIFI_POWER_DEVICE_NAME);
+	if (IS_ERR(devp)) {
+		ret = PTR_ERR(devp);
+		goto error3;
+	}
+	devp->platform_data = pdata;
+
+	wifi_setup_dt();
+
+	return 0;
+error3:
+	cdev_del(wifi_power_cdev);
+error2:
+	class_unregister(&wifi_power_class);
+error1:
+	unregister_chrdev_region(wifi_power_devno, 1);
+out:
+	return ret;
+}
+
+static int wifi_dev_remove(struct platform_device *pdev)
+{
+	WIFI_INFO("wifi_dev_remove\n");
+	wifi_teardown_dt();
+	return 0;
+}
+
+static struct platform_driver wifi_plat_driver = {
+	.probe = wifi_dev_probe,
+	.remove = wifi_dev_remove,
+	.driver = {
+	.name = "wifi",
+	.owner = THIS_MODULE,
+	.of_match_table = wifi_match
+	},
+};
+
+static int __init wifi_dt_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&wifi_plat_driver);
+	return ret;
+}
+
+device_initcall_sync(wifi_dt_init);
+
+static void __exit wifi_dt_exit(void)
+{
+	platform_driver_unregister(&wifi_plat_driver);
+}
+module_exit(wifi_dt_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("AlgoIdeas <yu19881234@163.com>");
+MODULE_DESCRIPTION("Wifi device tree driver for Amlogic");
+
+/**************** wifi mac *****************/
+u8 WIFI_MAC[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+static unsigned char chartonum(char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'A' && c <= 'F')
+		return (c - 'A') + 10;
+	if (c >= 'a' && c <= 'f')
+		return (c - 'a') + 10;
+	return 0;
+}
+
+static int __init mac_addr_set(char *line)
+{
+	unsigned char mac[6];
+	int i = 0;
+
+	WIFI_INFO("try to wifi mac from emmc key!\n");
+	for (i = 0; i < 6 && line[0] != '\0' && line[1] != '\0'; i++) {
+		mac[i] = chartonum(line[0]) << 4 | chartonum(line[1]);
+		line += 3;
+	}
+	memcpy(WIFI_MAC, mac, 6);
+	WIFI_INFO("uboot setup mac-addr: %x:%x:%x:%x:%x:%x\n",
+	WIFI_MAC[0], WIFI_MAC[1], WIFI_MAC[2], WIFI_MAC[3], WIFI_MAC[4],
+	WIFI_MAC[5]);
+
+	return 1;
+}
+
+__setup("mac_wifi=", mac_addr_set);
+
+u8 *wifi_get_mac(void)
+{
+	return WIFI_MAC;
+}
+EXPORT_SYMBOL(wifi_get_mac);
+
+void extern_wifi_set_enable(int is_on)
+{
+	if (is_on) {
+		set_wifi_power(1);
+		WIFI_INFO("WIFI  Enable! %d\n", wifi_info.power_on_pin);
+	} else {
+		set_wifi_power(0);
+		WIFI_INFO("WIFI  Disable! %d\n", wifi_info.power_on_pin);
+
+	}
+}
+EXPORT_SYMBOL(extern_wifi_set_enable);
+
+int wifi_irq_num(void)
+{
+	return wifi_info.irq_num;
+}
+EXPORT_SYMBOL(wifi_irq_num);
+
+int wifi_irq_trigger_level(void)
+{
+	return wifi_info.irq_trigger_type;
+}
+EXPORT_SYMBOL(wifi_irq_trigger_level);
+MODULE_DESCRIPTION("Amlogic S912/wifi driver");
+MODULE_AUTHOR("Kevin Hilman <khilman@baylibre.com>");
+MODULE_LICENSE("GPL");
diff -Naur a/vendor/amlogic/wifi/wifi_dt.h b/vendor/amlogic/wifi/wifi_dt.h
--- a/vendor/amlogic/wifi/wifi_dt.h	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/amlogic/wifi/wifi_dt.h	2022-06-30 15:28:16.867026208 +0800
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2022 Unionman Technology Co., Ltd. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _WIFI_DT_H
+#define _WIFI_DT_H
+int sdio_reinit(void);
+#endif
diff -Naur a/vendor/Kconfig b/vendor/Kconfig
--- a/vendor/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/Kconfig	2022-06-25 19:52:18.146274718 +0800
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+menu "Vendor Drivers"
+
+source "vendor/amlogic/Kconfig"
+
+source "vendor/drivers/Kconfig"
+
+endmenu
diff -Naur a/vendor/Makefile b/vendor/Makefile
--- a/vendor/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/Makefile	2022-06-25 19:55:57.496041292 +0800
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the Linux kernel drivers.
+#
+#
+
+# vendor drivers
+VENDOR_DRIVERS_PREFIX := ../../../../..
+obj-y		+= $(VENDOR_DRIVERS_PREFIX)/device/board/$(PRODUCT_COMPANY)/$(DEVICE_NAME)/kernel/drivers/
+
+obj-$(CONFIG_ARCH_MESON)	+= amlogic/
